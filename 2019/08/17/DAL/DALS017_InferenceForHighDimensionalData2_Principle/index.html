<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="高维数据," />










<meta name="description" content="前言 这一部分是《Data Analysis for the life sciences》的第6章线性模型的第2小节，这一部分的主要内容涉及高维数据统计的一些原理，相应的R markdown文档可以参考作者的Github。 高维数据的p值 在前面我们了解了，当我们在分析高维数据时，p值就不再是一个很好的统计指标了。这是因为，我们同一次检测了许多特征值(feature)。这种检测手段被称为多重">
<meta name="keywords" content="高维数据">
<meta property="og:type" content="article">
<meta property="og:title" content="DALS017-高维数据推断2-统计原理">
<meta property="og:url" content="http://rvdsd.top/2019/08/17/DAL/DALS017_InferenceForHighDimensionalData2_Principle/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:description" content="前言 这一部分是《Data Analysis for the life sciences》的第6章线性模型的第2小节，这一部分的主要内容涉及高维数据统计的一些原理，相应的R markdown文档可以参考作者的Github。 高维数据的p值 在前面我们了解了，当我们在分析高维数据时，p值就不再是一个很好的统计指标了。这是因为，我们同一次检测了许多特征值(feature)。这种检测手段被称为多重">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831135218.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831140759.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831142643.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831145524.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831151618.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831180342.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190901144305.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902153110.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902194350.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902194645.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902195138.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202117.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202322.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202859.jpeg">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902215832.jpeg">
<meta property="og:updated_time" content="2019-09-12T05:12:38.367Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DALS017-高维数据推断2-统计原理">
<meta name="twitter:description" content="前言 这一部分是《Data Analysis for the life sciences》的第6章线性模型的第2小节，这一部分的主要内容涉及高维数据统计的一些原理，相应的R markdown文档可以参考作者的Github。 高维数据的p值 在前面我们了解了，当我们在分析高维数据时，p值就不再是一个很好的统计指标了。这是因为，我们同一次检测了许多特征值(feature)。这种检测手段被称为多重">
<meta name="twitter:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831135218.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/2019/08/17/DAL/DALS017_InferenceForHighDimensionalData2_Principle/"/>





  <title>DALS017-高维数据推断2-统计原理 | RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/17/DAL/DALS017_InferenceForHighDimensionalData2_Principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">DALS017-高维数据推断2-统计原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T12:00:00+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,658
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第6章线性模型的第2小节，这一部分的主要内容涉及高维数据统计的一些原理，相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/advinference/multiple_testing.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="高维数据的p值">高维数据的p值</h2>
<p>在前面我们了解了，当我们在分析高维数据时，p值就不再是一个很好的统计指标了。这是因为，我们同一次检测了许多特征值(feature)。这种检测手段被称为多重比较( multiple comparison)，或多重检测(multiple testing)，或多重性问题(multiplicity)。在此情况下，p值就不再适用。另外，当我们同时检测多个假设问题时，仅仅基于一个小p值的阈值，例如0.01，这就很容易导假阳性。针对这种情况，我们需要定义一个新的术语来研究高通量数据。</p>
<p>为了处理多重比较的问题，我们广泛使用的方法就是定义一个程序(procedure，也可以说是一种算法，也可以翻译为<code>校正</code>等等，总之，表达的是一个意思)，然后用它来估计或控制(control)计算过程中的错误率(rate error)。我们这里所说的<code>控制(control)</code>的意思是说，我们会采用这个程序来保证错误率(error rate)低于某个提前设定的值。通过参数或截止值(cutoff)来进行设定的这个程序通常比较灵活，它会让我们能够控制特异性(specificity)和灵敏度(sensitivity)，这种程序的一个典型功能如下所示：</p>
<ul>
<li>计算每个基因的p值；</li>
<li>计算出p值小于<span class="math inline">\(\alpha\)</span>的所有显著性基因。</li>
</ul>
<p>这里需要注意的是，当我们改变<span class="math inline">\(\alpha\)</span>值时，会调整相应的特异性(specificity)和灵敏度(sensitivity)。</p>
<p>接着我们来定义错误率(error rate)，它会让我们对统计过程进行估计和控制。</p>
<h2 id="错误率">错误率</h2>
<p>在这一部分中，我们会了解到I类错误与II类错误，这两类错误分别代表假阳性(false positives)与假阴性(false negatives)。通常，特异性(specificity)与I类错误有关，灵敏性(sensitivity)与II类错误有关。</p>
<p>在一次高通量实验里，我们会犯第I类错误和第II类错误。我们参考了Benjamini-Hochberg的论文，做了以下表格，总结了这些错误，如下所示：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Called significant（真）</th>
<th>Not called significant（假）</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Null True</td>
<td><span class="math inline">\(V\)</span></td>
<td><span class="math inline">\(m_0-V\)</span></td>
<td><span class="math inline">\(m_0\)</span></td>
</tr>
<tr class="even">
<td>Alternative True</td>
<td><span class="math inline">\(S\)</span></td>
<td><span class="math inline">\(m_1-S\)</span></td>
<td><span class="math inline">\(m_1\)</span></td>
</tr>
<tr class="odd">
<td>True</td>
<td><span class="math inline">\(R\)</span></td>
<td><span class="math inline">\(m-R\)</span></td>
<td><span class="math inline">\(m\)</span></td>
</tr>
</tbody>
</table>
<p>为了说明这个表格中的内容，我们来打个比方，假设我们检测了10000个基因，这就意味着我们需要做检测的次数为<span class="math inline">\(m=10000\)</span>。</p>
<p>那些零假设是真的基因数目（多数是我们不感兴趣的基因，零假设为真，也就是说这些基因在对照和实验组中都没有显著性差异）为<span class="math inline">\(m_{0}\)</span>，那些零假设为假的基因数目为<span class="math inline">\(m_{1}\)</span>，零假设为假，也就是说，替代假设(alternative hypothesis)为真（不一定严谨，反正就是说零假设为假）。通常来说，我们感兴趣的是尽可能地检测到那些替代假设为真的基因（真阳性），避免检测到那些零假设为真的基因（假阳性）。对于多数高通量实验来说，我们会假设<span class="math inline">\(m_{0}\)</span>远大于<span class="math inline">\(m_{1}\)</span>（这句话我的理解就是，在一次高通量实验中，没差异基因的数目<span class="math inline">\(m_{0}\)</span>要大于有差异基因的数目<span class="math inline">\(m_{1}\)</span>）。</p>
<p>例如我们检测了10000个基因，对其中约有100个基因感兴趣。这也就是说，<span class="math inline">\(m_1 \leq 100\)</span> 并且 <span class="math inline">\(m_0 \geq 19,900\)</span>。</p>
<p>在这一章中，我们指的特征值(feature)就是我们的检测值。在遗传学中，这些特征值可以是基因(genes)，转录本(transcripts)，结合位点(binding sites)，CpG岛和SNPs。</p>
<p>在上面的那个表格中，<span class="math inline">\(R\)</span>表示的是经过检测后，有显著性差异的特征值的数目总和，而<span class="math inline">\(m-R\)</span>则表示不显著的基因数目。表格中剩下的部分表示的是一些实际上未知的重要的量。</p>
<ul>
<li><span class="math inline">\(V\)</span>表示I类错误或假阳性。更具体地来说就是，<span class="math inline">\(V\)</span>表示了那些零假设为真的特征值的数目。</li>
<li><span class="math inline">\(S\)</span>表示的是真阳性的数目。具体地来说就是，<span class="math inline">\(S\)</span>表示替代假设为真的特征值的数目。</li>
</ul>
<p><span class="math inline">\(m_{1}-S\)</span>表示了II类错误或假阴性，<span class="math inline">\(m_{0}-V\)</span>表示真阴性。</p>
<p>这里需要牢记的是，当我们只做一次检测时，p就仅仅是当<span class="math inline">\(V=1\)</span>，<span class="math inline">\(m=m_{0}=1\)</span>时的概率。功效(power)就是当<span class="math inline">\(S=1\)</span>，<span class="math inline">\(m=m_{1}=1\)</span>时的概率。在这种非常简单的案例里，我们并不制作上面类似的表格，但是我们会说明一下，如何定义表格中的术语，从而帮助我们处理高维数据。</p>
<h2 id="数据案例">数据案例</h2>
<p>现在看一个案例。在这个案例中我们会使用小鼠数据进行Monte Carlo模拟，从而模拟一种情况，在这种情况里，我们会检测10000种对小鼠体重无影响的减肥饲料(fad diets)。这就是说，在零假设下，这些饲料对小鼠体重没影响为真，也就是说<span class="math inline">\(m=m_{0}=10000\)</span>，并且<span class="math inline">\(m_{1}=0\)</span>，现在我们先进行一个样本数目为12的计算，并且我们认为p值小于<span class="math inline">\(\alpha=0.05\)</span>显著，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">population = unlist( read.csv(<span class="string">"femaleControlsPopulation.csv"</span>) )</div><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">N &lt;- <span class="number">12</span></div><div class="line">m &lt;- <span class="number">10000</span></div><div class="line">pvals &lt;- replicate(m,&#123;</div><div class="line">  control = sample(population,N)</div><div class="line">  treatment = sample(population,N)</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div><div class="line">sum(pvals &lt; <span class="number">0.05</span>) <span class="comment">##This is R</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>) <span class="comment">##This is R</span></div><div class="line">[<span class="number">1</span>] <span class="number">462</span></div></pre></td></tr></table></figure>
<p>从结果我们可以看出，这个假阳性（462个）还是比较高的，这是要在多数分析中是要避免的。</p>
<p>下面我们来看一个更加复杂的代码，这段代码会进行人为设定10%的饮食有效，平均效应(average effect size)为<span class="math inline">\(\Delta=3\)</span>盎司（约85克）。仔细研究这段代码可以帮助我们理解上面的那个表格，现在我们先来定义这样的数据，其中10%有效：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">N &lt;- <span class="number">12</span></div><div class="line">m &lt;- <span class="number">10000</span></div><div class="line">p0 &lt;- <span class="number">0.90</span> <span class="comment">##10% of diets work, 90% don't</span></div><div class="line">m0 &lt;- m*p0</div><div class="line">m1 &lt;- m-m0</div><div class="line">nullHypothesis &lt;- c( rep(<span class="literal">TRUE</span>,m0), rep(<span class="literal">FALSE</span>,m1))</div><div class="line">delta &lt;- <span class="number">3</span></div></pre></td></tr></table></figure>
<p>现在我们做10000次模拟统计，每次都采用t检验，并记录下来：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">calls &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,N)</div><div class="line">  treatment &lt;- sample(population,N)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  ifelse( t.test(treatment,control)$p.value &lt; alpha,</div><div class="line">          <span class="string">"Called Significant"</span>,</div><div class="line">          <span class="string">"Not Called Significant"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>由于我们知道哪些是数据是有差异的（毕竟是自己人为生成的，保存在了<code>nullHypothesis</code>中)，我们现在计算一下上面的表格，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">null_hypothesis &lt;- factor( nullHypothesis, levels=c(<span class="string">"TRUE"</span>,<span class="string">"FALSE"</span>))</div><div class="line">table(null_hypothesis,calls)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; null_hypothesis &lt;- factor( nullHypothesis, levels=c(<span class="string">"TRUE"</span>,<span class="string">"FALSE"</span>))</div><div class="line">&gt; table(null_hypothesis,calls)</div><div class="line">               calls</div><div class="line">null_hypothesis Called Significant Not Called Significant</div><div class="line">          <span class="literal">TRUE</span>                 <span class="number">421</span>                   <span class="number">8579</span></div><div class="line">          <span class="literal">FALSE</span>                <span class="number">520</span>                    <span class="number">480</span></div></pre></td></tr></table></figure>
<p>结果中的第1列就是<span class="math inline">\(V\)</span>与<span class="math inline">\(S\)</span>，需要注意的是，<span class="math inline">\(V\)</span>与<span class="math inline">\(S\)</span>是随机变量，如果我们再次运行这段代码以，这些值就会改变，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">B &lt;- <span class="number">10</span> <span class="comment">##number of simulations</span></div><div class="line">VandS &lt;- replicate(B,&#123;</div><div class="line">  calls &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">    control &lt;- sample(population,N)</div><div class="line">    treatment &lt;- sample(population,N)</div><div class="line">    <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">    t.test(treatment,control)$p.val &lt; alpha</div><div class="line">  &#125;)</div><div class="line">  cat(<span class="string">"V ="</span>,sum(nullHypothesis &amp; calls), <span class="string">"S ="</span>,sum(!nullHypothesis &amp; calls),<span class="string">"\n"</span>)</div><div class="line">  c(sum(nullHypothesis &amp; calls),sum(!nullHypothesis &amp; calls))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">V = <span class="number">410</span> S = <span class="number">564</span> </div><div class="line">V = <span class="number">400</span> S = <span class="number">552</span> </div><div class="line">V = <span class="number">366</span> S = <span class="number">546</span> </div><div class="line">V = <span class="number">382</span> S = <span class="number">553</span> </div><div class="line">V = <span class="number">372</span> S = <span class="number">505</span> </div><div class="line">V = <span class="number">382</span> S = <span class="number">530</span> </div><div class="line">V = <span class="number">381</span> S = <span class="number">539</span> </div><div class="line">V = <span class="number">396</span> S = <span class="number">554</span> </div><div class="line">V = <span class="number">380</span> S = <span class="number">550</span> </div><div class="line">V = <span class="number">405</span> S = <span class="number">569</span></div></pre></td></tr></table></figure>
<p>针对这种情况，我们就定义了错误率(error rate)。例如，我们可以估计<span class="math inline">\(V\)</span>大于0的概率。它可以解释为，在10000次检验中，我们出现I类错误的概率。在上述模拟数据中，<span class="math inline">\(V\)</span>在每次模拟中都大于1，因此我们怀疑这个概率实际上就是1（这里的1就是“V大于0”这个事件的概率，换句话讲，就是，在这个检验中，必然会出现假阳性）。</p>
<p>当<span class="math inline">\(m=1\)</span>时，这个概率就等于p值。当我们进行多重检验模拟时，我们称之为多重比较谬误(Family Wide Error Rate,FWER)，它与我们广泛使用的一个检验方法有关，即Bonferroni校正( Bonferroni Correction)。</p>
<h2 id="bonferroni校正">Bonferroni校正</h2>
<p>现在我们了解一下FWER是如何运用的，在实际的分析中，我们会选择一个程序(procedure)来保证FWER小于某个提前设定好的阈值，例如0.05，通常情况下，就使用<span class="math inline">\(\alpha\)</span>来表示。</p>
<p>现在我们来描述一个这样的程序：拒绝所有p值小于0.01的假设。</p>
<p>为了说明这个目的，我们假设所有的检验都是独立的（在10000个饲料检验的实验里，这个假设是成立的；但是在一些遗传学实验里，这个假设有可能不成立，因为某些基因会共同发挥作用）。每次检验得到的p值我们用<span class="math inline">\(p_1,\dots,p_{10000}\)</span>表示。这些独立的随机变量如下所示： <span class="math display">\[
\begin{align*}
\mbox{Pr}(\mbox{at least one rejection}) &amp;= 1 -\mbox{Pr}(\mbox{no rejections}) \\
&amp;= 1 - \prod_{i=1}^{10000} \mbox{Pr}(p_i&gt;0.01) \\
&amp;= 1-0.99^{10000} \approx 1
\end{align*}
\]</span> 如果我们要模拟这个过程，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">B&lt;-<span class="number">10000</span></div><div class="line">minpval &lt;- replicate(B, min(runif(<span class="number">10000</span>,<span class="number">0</span>,<span class="number">1</span>))&lt;<span class="number">0.01</span>)</div><div class="line">mean(minpval&gt;=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(minpval&gt;=<span class="number">1</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div></pre></td></tr></table></figure>
<p>因此，我们计算出来的FWER是1，这并非我们想要的结果。如果我们想要它低于<span class="math inline">\(\alpha=0.05\)</span>，那么我们的统计就是失败的。</p>
<p>我们如何做才能使得一个错误出现的概率低于<span class="math inline">\(\alpha\)</span>呢，我们可以使用上面的公式推导一下，通过选择更严格的截止值(cutoff），之前的是0.01，从而将我们的错误降低至至少5%的水平，如下所示： <span class="math display">\[
\mbox{Pr}(\mbox{at least one rejection}) =  1-(1-k)^{10000}
\]</span> 解这个方程，我们就得到了 <span class="math inline">\(1-(1-k)^{10000}=0.01 \implies k = 1-0.99^{1/10000} \approx 1e-6\)</span></p>
<p>这就是我们给出的一个程序案例。这实际上就是Sikdak过程。尤其是，当我们定义一个说明，例如<code>拒绝所有p值小于 0.000005的零假设</code>。然后，我们知道了p值是一个随机变量，我们会使用统计理论来计算，如果我们遵循这个程序，平均会犯多少错误。更确切地讲就是，我们可以计算出这些错误的边界，也就是说，这些错误小于某些预定值的比例。</p>
<p>Sidak校正的一个问题是，这个校正假设所有的检验都是独立的。因此当这个假设时成立的，它只能控制FWER。百Bonferroini校正则更为通用，因为即使每个检测不独立，它也能控制FWER。。与Sidak校正一样，我们首先来看一下： <span class="math display">\[
FWER = \mbox{Pr}(V&gt;0) \leq \mbox{Pr}(V&gt;0 \mid \mbox{all nulls are true})
\]</span></p>
<p>现在使用前面表格的那种表示方法为： <span class="math display">\[
\mbox{Pr}(V&gt;0) \leq \mbox{Pr}(V&gt;0 \mid m_1=0)
\]</span> Bonferoni校正会设定<span class="math inline">\(k=\alpha/m\)</span>，因此可以写为如下形式： <span class="math display">\[
\begin{align*}
\mbox{Pr}(V&gt;0 \,\mid \, m_1=0) &amp;= \mbox{Pr}\left( \min_i \{p_i\} \leq \frac{\alpha}{m} \mid m_1=0 \right)\\
 &amp;\leq \sum_{i=1}^m \mbox{Pr}\left(p_i \leq \frac{\alpha}{m} \right)\\
 &amp;= m \frac{\alpha}{m}=\alpha
\end{align*}
\]</span> 将FWER控制在0.05水平是一种非常保守的方法，现在我们使用前面计算的p值来计算一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">pvals &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,N)</div><div class="line">  treatment &lt;- sample(population,N)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>只需要关于p值是否小于0.05/10000即可，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">2</span></div></pre></td></tr></table></figure>
<p>当使用了Bonferroni校正后，即使我们进行了10000次饮食实验，却只有发现2个假阳性的结果，Bonferroni是一种非常严格的校正。</p>
<h2 id="错误发现率fdr">错误发现率(FDR)</h2>
<p>在许多情况下，要求FWER是0.05没多大意义，因为它太严格了。例如，我们常见的做法就是先进行初步的小型实验来确定小数候选基因。这种做法被称为之发现驱动的实验或项目。我们也许会寻找一个未知的致病基因，而不仅仅是对候选基因进行采用更多的样本进行后续研究。如果我们开发一个程序，例如一个10个基因列表，从中发现1到2个为重要的基因，这个实验就算非常成功。小样本实验，实现<span class="math inline">\(FWER\leq0.05\)</span>的唯一途径就是使用一个空的基因列表。在前面我们已经看到，虽然只有1000种包含有效，但是最终我们只得到2个饮食有效这样一个结果，如果把样本数目降低到6，这个结果有可能就是0，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">pvals &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,<span class="number">6</span>)</div><div class="line">  treatment &lt;- sample(population,<span class="number">6</span>)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div><div class="line">sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>由于我们要求<span class="math inline">\(FWER\leq 0.05\)</span>，因此我们实际上就是0功效（灵敏度）。在许多方法中，这种情况称为特异性(specificity)过强(over-kill)。替代FWER的另外一种方法就是FDR，即错误发现率(false discover rate)。FDR背后的思想就是集中关注Q值，即 <span class="math inline">\(Q \equiv V/R\)</span>，当<span class="math inline">\(R=0,V=0\)</span>时，<span class="math inline">\(Q=0\)</span>。其中，当<span class="math inline">\(R=0\)</span>（没有显著性）就表明，<span class="math inline">\(V=0\)</span>（没有假阳性）。因此<span class="math inline">\(Q\)</span>是一个随机变量，它的范围是0到1，通过计算Q的平均值，我们可以定义一个比值(rate)，它所表示的是意思是，在显著的基因里，假阳性的基因占的比例。为了更好地理解这个概含，我们计算Q的程序要求调用所有的p值都小于0.05。</p>
<h2 id="向量化代码">向量化代码</h2>
<p>在R中可以使用<code>sapply()</code>系列函数来加快运行速度，前面已经看到了这个函数的使用方法，现在使用传统的代码来看一下Q值的计算方法，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(genefilter) <span class="comment">##rowttests is here</span></div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line"><span class="comment">##Define groups to be used with rowttests</span></div><div class="line">g &lt;- factor( c(rep(<span class="number">0</span>,N),rep(<span class="number">1</span>,N)) )</div><div class="line">B &lt;- <span class="number">1000</span> <span class="comment">##number of simulations</span></div><div class="line">Qs &lt;- replicate(B,&#123;</div><div class="line">  <span class="comment">##matrix with control data (rows are tests, columns are mice)</span></div><div class="line">  controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  <span class="comment">##matrix with control data (rows are tests, columns are mice)</span></div><div class="line">  treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  <span class="comment">##add effect to 10% of them</span></div><div class="line">  treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">  <span class="comment">##combine to form one matrix</span></div><div class="line">  dat &lt;- cbind(controls,treatments)</div><div class="line">  calls &lt;- rowttests(dat,g)$p.value &lt; alpha</div><div class="line">  R=sum(calls)</div><div class="line">  Q=ifelse(R&gt;<span class="number">0</span>,sum(nullHypothesis &amp; calls)/R,<span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span>(Q)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; head(Qs)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4513274</span> <span class="number">0.4063786</span> <span class="number">0.4568627</span> <span class="number">0.4490414</span> <span class="number">0.4468314</span> <span class="number">0.4315569</span></div><div class="line">&gt; tail(Qs)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4390756</span> <span class="number">0.4718657</span> <span class="number">0.4395373</span> <span class="number">0.4425711</span> <span class="number">0.4536391</span> <span class="number">0.4284284</span></div></pre></td></tr></table></figure>
<h2 id="控制fdr">控制FDR</h2>
<p>上述代码使用Monte Carlo模拟计算了1000次10000个样本的实验，并保存了Q值，现在看一下Q值的直方图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(Qs) <span class="comment">##Q is a random variable, this is its distribution</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831135218.jpeg">

</div>
<p>FDR就是Q值的平均值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FDR=mean(Qs)</div><div class="line">print(FDR)</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(FDR)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4463354</span></div></pre></td></tr></table></figure>
<p>这里的计算结果表明，FDR值比较高。这是因为对于90%的统计检验而言，零假设是真。这就暗示了，由于p值是cutoff值为0.05，100个检验中，大概有4到5个是假阳性。再加上我们没有考虑到替代所设为真时的所有情况，因此FDR值就比较高。那么我们如何控制它呢，如果我们想要更低的FDR值，比如5%怎么办？</p>
<p>为了用图形说明FDR为什么这么高，我们来绘制p值的直方图。我们使用一个较大的<code>m</code>值从直方图中获取更多的数据。再绘制一条水平线，表示当NULL为真时，从<span class="math inline">\(m_{0}\)</span>个案例（指的基因或其它检测值，<span class="math inline">\(m_{0}\)</span>就是没有统计学差异的基因）中到的阳性结果的均匀分布，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">dat &lt;- cbind(controls,treatments)</div><div class="line">pvals &lt;- rowttests(dat,g)$p.value</div><div class="line">h &lt;- hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.05</span>))</div><div class="line">polygon(c(<span class="number">0</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,h$counts[<span class="number">1</span>],h$counts[<span class="number">1</span>]),col=<span class="string">"grey"</span>)</div><div class="line">abline(h=m0/<span class="number">20</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831140759.jpeg">

</div>
<p>第1个柱子（灰色）表示提p值小于0.05的基因的数目，从水平线可知，大概有一半p值小于0.05的基因是假阳性，这与前面提到的FDR=0.5是一致的。我们来看一下当柱子的宽度为0.01时FDR的值会更低，但同时我们的显著性差异数目也会降低。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">h &lt;- hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.01</span>))</div><div class="line">polygon(c(<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0.01</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,h$counts[<span class="number">1</span>],h$counts[<span class="number">1</span>]),col=<span class="string">"grey"</span>)</div><div class="line">abline(h=m0/<span class="number">100</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831142643.jpeg">

</div>
<p>当柱子的宽度变为0.01时，我们可以看到一个更小的p值cutoff，并且检测到到特征值的数目也会下降（降低了灵敏性sensitivity)，但是，FDR也会降低（提高了特异性specificity）。我们如何设定这个cutoff呢？其中一个方法就是设定一个FDR水平<span class="math inline">\(\alpha\)</span>，然后设置控制错误率的程序即可：<span class="math inline">\(FDR \leq \alpha\)</span>。</p>
<h2 id="benjamini-hochberg">Benjamini-Hochberg</h2>
<p>对于任意给定的<span class="math inline">\(\alpha\)</span>，Benjamini-Hochberg方法都非常适用，这种方法可以让使用者地每个检验的p值进行校正，也能很好地定义一个程序。</p>
<p>Benjamini-Hochberg方法的原理是，先按照升序对p值进行排列，即<span class="math inline">\(p_{(1)},\dots,p_{(m)}\)</span>，然后定义一个<span class="math inline">\(k\)</span>用来表示最大的秩<span class="math inline">\(i\)</span>，它所对应的p值为： <span class="math display">\[
p_{(i)} \leq \frac{i}{m}\alpha
\]</span> 这个程序会拒绝那些p值小于或等于<span class="math inline">\(p_{(k)}\)</span>的检验。现在看一个案例，如何选择<span class="math inline">\(k\)</span>来计算p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">i = seq(along=pvals)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(i,sort(pvals))</div><div class="line">abline(<span class="number">0</span>,i/m*alpha)</div><div class="line"><span class="comment">##close-up</span></div><div class="line">plot(i[<span class="number">1</span>:<span class="number">15</span>],sort(pvals)[<span class="number">1</span>:<span class="number">15</span>],main=<span class="string">"Close-up"</span>)</div><div class="line">abline(<span class="number">0</span>,i/m*alpha)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831145524.jpeg">

</div>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">k &lt;- max( which( sort(pvals) &lt; i/m*alpha) )</div><div class="line">cutoff &lt;- sort(pvals)[k]</div><div class="line">cat(<span class="string">"k ="</span>,k,<span class="string">"p-value cutoff="</span>,cutoff)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"k ="</span>,k,<span class="string">"p-value cutoff="</span>,cutoff)</div><div class="line">k = <span class="number">11</span> p-value cutoff= <span class="number">3.763357e-05</span></div></pre></td></tr></table></figure>
<p>我们可以从数学上证明到这个程序可以将FDR控制在5%以下，具体的算法可以参考Benjamini-Hochberg在1995年的论文。这种新的程序计算的结果就是将原来得到的2个有统计学差异的数值提高到了11个。如果我们将FDR的值设为50%，那么这个数字会提高到1063。FWER无法提供这种灵活性，因为只要检测值的数量增加，都会造成FWER的值为1。</p>
<p>这里我们需要注意的是，在R中，已经有了计算FDR的函数，前面的那些复杂代码只是为了说明这种算法，在R中我们可以使用下面的代码进行计算，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fdr &lt;- p.adjust(pvals, method=<span class="string">"fdr"</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(pvals,fdr,log=<span class="string">"xy"</span>)</div><div class="line">abline(h=alpha,v=cutoff) <span class="comment">##cutoff was computed above</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831151618.jpeg">

</div>
<p>我们也可以使用Monte Carlo模拟来确认一下FDR的值实际上小于0.05，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">B &lt;- <span class="number">1000</span> <span class="comment">##number of simulations. We should increase for more precision</span></div><div class="line">res &lt;- replicate(B,&#123;</div><div class="line">  controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">  dat &lt;- cbind(controls,treatments)</div><div class="line">  pvals &lt;- rowttests(dat,g)$p.value</div><div class="line">  <span class="comment">##then the FDR</span></div><div class="line">  calls &lt;- p.adjust(pvals,method=<span class="string">"fdr"</span>) &lt; alpha</div><div class="line">  R=sum(calls)</div><div class="line">  Q=ifelse(R&gt;<span class="number">0</span>,sum(nullHypothesis &amp; calls)/R,<span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span>(c(R,Q))</div><div class="line">&#125;)</div><div class="line">Qs &lt;- res[<span class="number">2</span>,]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(Qs) <span class="comment">##Q is a random variable, this is its distribution</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831180342.jpeg">

</div>
<p>上述是Q值的直方图（假阳性除以显著性特征值的数目），现在看一下FDR值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FDR=mean(Qs)</div><div class="line">print(FDR)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; FDR=mean(Qs)</div><div class="line">&gt; print(FDR)</div><div class="line">[<span class="number">1</span>] <span class="number">0.03813818</span></div></pre></td></tr></table></figure>
<p>这个FDR的值小于0.05，这个结果是符合预期的，因为我们需要保守一点，从而确保任何值的<span class="math inline">\(m_{0}\)</span>的FDR都小于0.05，例如当每个假设检验都是零的极端情况，例如<span class="math inline">\(m=m_{0}\)</span>。如果你重新模拟上述情况，你会发现FDR会增加。</p>
<p>我们需要注意下面的值：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Rs &lt;- res[<span class="number">1</span>,]</div><div class="line">&gt; mean(Rs==<span class="number">0</span>)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">0.7</span></div></pre></td></tr></table></figure>
<p>在模拟中，这个比例是0.7%，我们没有调用任何有显著性差异的基因。</p>
<p>在R中，<code>p.adjust()</code>函数可以选择一些算法来控制FDR，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; p.adjust.methods</div><div class="line">[<span class="number">1</span>] <span class="string">"holm"</span>       <span class="string">"hochberg"</span>   <span class="string">"hommel"</span>     <span class="string">"bonferroni"</span> <span class="string">"BH"</span>         <span class="string">"BY"</span>         <span class="string">"fdr"</span>        <span class="string">"none"</span></div></pre></td></tr></table></figure>
<p>上面的这些方法不仅仅是估计错误率的不同方法，并且它们的估计值也不同，也就是说FWER与FDR不同。</p>
<h2 id="直接fdr与q值">直接FDR与q值</h2>
<p>这里我们先回顾一下由John D.Storey在J. R. Statist. Soc. B(2002)中提到的结果。Storey与Benjamini-Hochberg方法的不同之处在于，前者不再提前设定<span class="math inline">\(\alpha\)</span>水平。因为在一些高通量实验中，我们感兴趣的仅仅是找到一个基因列表用于验证这些基因，我们会事先考虑将那些p值小于0.01的基因都进行验证。我们人随后会考虑估计的错误率。通常使用这些方法，我们会确保我们的<span class="math inline">\(R&gt;0\)</span>。在上述定义的FDR里，当<span class="math inline">\(R=V=0\)</span>时，我们指定<span class="math inline">\(Q=0\)</span>，因此我们可以计算FDR如下所示： <span class="math display">\[
\mbox{FDR} = E\left( \frac{V}{R} \mid R&gt;0\right) \mbox{Pr}(R&gt;0)
\]</span> 在Storey提出的方法里，我们需要构建一个非空列表，也就是说<span class="math inline">\(R&gt;0\)</span>，那么我们计算阳性FDR(positive FDR)的公式如下所示： <span class="math display">\[
\mbox{pFDR} = E\left( \frac{V}{R} \mid R&gt;0\right)
\]</span> 第二点不同之处在于，Benjamini和Hochberg的程度是在最差的情况下进行控制，最差的情况是指零假设都为真（<span class="math inline">\(m=m_{0}\)</span>的情况），Storey的方法则是让我们从数据中估计<span class="math inline">\(m_{0}\)</span>。因为在高通量实验中，我们已经获得了如此多的数据，使Storey的算法成为了可能。这种算法的大致思路就是，挑选一个相对高值的p值cut-off，将它称为<span class="math inline">\(\lambda\)</span>，并且假设那些p值大于<span class="math inline">\(\Lambda\)</span>的检验在多数情况下其零假设是成立的，因此我们可以计算出估计值<span class="math inline">\(\pi_0 = m_0/m\)</span>为： <span class="math display">\[
\hat{\pi}_0 = \frac{\#\left\{p_i &gt; \lambda \right\} }{ (1-\lambda) m }
\]</span> 还有其它比这种算法更复杂的算法，但是它们的思路都是一样的，例如当我们设定<span class="math inline">\(\lambda=0.1\)</span>时，我们计算一下p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.05</span>),freq=<span class="literal">FALSE</span>)</div><div class="line">lambda = <span class="number">0.1</span></div><div class="line">pi0=sum(pvals&gt; lambda) /((<span class="number">1</span>-lambda)*m)</div><div class="line">abline(h= pi0)</div><div class="line">print(pi0) <span class="comment">##this is close to the trye pi0=0.9</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190901144305.jpeg">

</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(pi0) ##this is close to the trye pi0=0.9</div><div class="line">[1] 0.9311111</div></pre></td></tr></table></figure>
<p>根据这个估计，我们可以改变一下Benjamini-Hochberg程序，例如选择一个<span class="math inline">\(k\)</span>作为最大值（<span class="math inline">\(k\)</span>这里是最大的<span class="math inline">\(i\)</span>），因此就有如下公式： <span class="math display">\[
\hat{\pi}_0 p_{(i)} \leq \frac{i}{m}\alpha
\]</span> 我们还有一种方法可以计算校正后的p值，即对每个检验计算q值(q-value)，如果一个特征计算的p值为<span class="math inline">\(p\)</span>，那么q值就是一系列含有最小p值为<span class="math inline">\(p\)</span>的特征值的估计pFDR。</p>
<p>除此之外，我们还有一种方法可以计算校正后的p值，即对每个检验计算q值(<code>q-value</code>)，如果一个特征最终计算的p值为<span class="math inline">\(p\)</span>，那么q值就是一系列含有尽可能最小与<span class="math inline">\(p\)</span>相等的p值的特征值的估计pFDR（原文是：However, instead of doing this, we compute a q-value for each test. If a feature resulted in a p-value of <span class="math inline">\(p\)</span>, the q-value is the estimated pFDR for a list of all the features with a p-value at least as small as <span class="math inline">\(p\)</span>.）。</p>
<p>上面这段我也不理解，后来查中文资料，根据Benjamini-Hochberg的算法，q值的定义如下所示：</p>
<p>对于m个独立的假设检验，它们对就的p值为：<span class="math inline">\(p_{i},i=1,2,\cdots,m\)</span></p>
<ol style="list-style-type: decimal">
<li>按照升序的方法对这些p值进行排序，得到：</li>
</ol>
<p><span class="math display">\[
p_{(1)} \leq p_{(1)} \cdots \leq p_{(m)}
\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>对于给定的统计学检验水平<span class="math inline">\(\alpha in(0,1]\)</span>，找到最大的<span class="math inline">\(k\)</span>，使得：</li>
</ol>
<p><span class="math display">\[
p_{(k)} \leq \frac{a*k}{m}
\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>对于排序靠前的<span class="math inline">\(k\)</span>个假设检验，认为它们是真阳性，看下面的案例：</li>
</ol>
<p>现在我们做了6个基因的检验，它们的p值如下所示：</p>
<table>
<thead>
<tr class="header">
<th>Gene</th>
<th>p-value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>G1</td>
<td>p1=0.053</td>
</tr>
<tr class="even">
<td>G2</td>
<td>p2=0.001</td>
</tr>
<tr class="odd">
<td>G3</td>
<td>p3=0.045</td>
</tr>
<tr class="even">
<td>G4</td>
<td>p4=0.03</td>
</tr>
<tr class="odd">
<td>G5</td>
<td>p5=0.02</td>
</tr>
<tr class="even">
<td>G6</td>
<td>p6=0.01</td>
</tr>
</tbody>
</table>
<p>现在取检测水平<span class="math inline">\(\alpha=0.05\)</span>，先把p值按从小到大的升序排列：</p>
<table>
<thead>
<tr class="header">
<th>Gene</th>
<th>p-value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>G2</td>
<td>p2=0.001</td>
</tr>
<tr class="even">
<td>G6</td>
<td>p6=0.01</td>
</tr>
<tr class="odd">
<td>G5</td>
<td>p5=0.02</td>
</tr>
<tr class="even">
<td>G4</td>
<td>p4=0.03</td>
</tr>
<tr class="odd">
<td>G3</td>
<td>p3=0.045</td>
</tr>
<tr class="even">
<td>G1</td>
<td>p1=0.053</td>
</tr>
</tbody>
</table>
<p>取检测水平<span class="math inline">\(\alpha=0.05\)</span>，现在我们找到一个值<span class="math inline">\(k\)</span>，这个<span class="math inline">\(k\)</span>满足以下公式： <span class="math display">\[
p_{(k)} \leq \frac{a*k}{m}
\]</span> 当<span class="math inline">\(k=1\)</span>时，<span class="math inline">\(p_{(1)}=0.001 &lt; 0.05*1/6=0.008333333\)</span></p>
<p>当<span class="math inline">\(k=2\)</span>时，<span class="math inline">\(p_{(2)}=0.01&lt;0.05*2/6=0.01666667\)</span></p>
<p>当<span class="math inline">\(k=3\)</span>时，<span class="math inline">\(p_{(3)}=0.02&lt;0.05*3/6=0.025\)</span></p>
<p>当<span class="math inline">\(k=4\)</span>时，<span class="math inline">\(p_{(4)}=0.03&lt;0.05*4/6=0.03333333\)</span></p>
<p>当<span class="math inline">\(k=5\)</span>时，<span class="math inline">\(p_{(5)}=0.045&gt;0.05*5/6=0.04166667\)</span></p>
<p>当<span class="math inline">\(k=6\)</span>时，<span class="math inline">\(p_{(6)}=0.053&gt;0.05*6/6=0.05\)</span></p>
<p>从上面的计算过程可以知道，这个<span class="math inline">\(k\)</span>等于4，也就是说，在FDR&lt;0.05的情况下，G2，G6，G5，G4有差异。</p>
<p>到这里，只是说明了，G2，G6，G5，G4是有差异的，但是q值还没有算出来，继续计算：</p>
<p>前面我们已经把原始的p值按照从小到大的顺序排列好了，也就是<code>[1] 0.001 0.010 0.020 0.030 0.045 0.053</code>，其中最大的p值是<code>0.053</code>，它校正后还是这个值，也就是说这个值是校正后的最大p值，次大的p值是<code>0.045</code>，这个值需要校正，它排序是第5，那么校正的公式就是所有p值的数目（一共是6个p值）除以秩（这里是5），再乘以p值大小，也就是<code>0.045*6/5=0.054</code>，但是，这个值已经大于原来最大的p值（0.053）了，因此这个把它校正后的值也作为0.053，再看倒数第3个值，即0.03的校正p值，即<code>0.03*6/4=0.045</code>，它小于0.053，因此它校正后可以是0.045，现在依次校正剩下的值：</p>
<p><code>0.02*6/3=0.04</code>，<code>0.01*6/2=0.03</code>，<code>0.001*6/1=0.006</code>，也就是说校正后的p值（就是q值），按从小到大的顺序排列就是：<code>0.006，0.03，0.04，0.045，0.053，0.053</code>，从结果中我们可以发现，前4个是有差异的，它们都小于0.05，也就是说G2，G6，G5，G4有差异。</p>
<p>其实公式就是： <span class="math display">\[
q^{(i)}=p_{(k)}^{(i)} * \frac{\text {Total Gene } N u m b e r}{\operatorname{rank}\left(p^{(i)}\right)}=p_{(k)}^{(i)} * \frac{m}{k}
\]</span> 以上是BH法进行q值计算的过程，R中可以使用<code>p.adjust()</code>函数计算q值，所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">p1 &lt;- <span class="number">0.053</span></div><div class="line">p2 &lt;- <span class="number">0.001</span></div><div class="line">p3 &lt;- <span class="number">0.045</span></div><div class="line">p4 &lt;- <span class="number">0.03</span></div><div class="line">p5 &lt;- <span class="number">0.02</span></div><div class="line">p6 &lt;- <span class="number">0.01</span></div><div class="line"></div><div class="line">p0 &lt;- c(p1,p2,p3,p4,p5,p6)</div><div class="line">p.adjust(p0,method = <span class="string">"BH"</span>)</div><div class="line">p.adjust(sort(p0),method = <span class="string">"BH"</span>)</div><div class="line">p.adjust(sort(p0),method = <span class="string">"fdr"</span>)</div><div class="line">sort(p.adjust(p0,method = <span class="string">"BH"</span>))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; p.adjust(p0,method = <span class="string">"BH"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.053</span> <span class="number">0.006</span> <span class="number">0.053</span> <span class="number">0.045</span> <span class="number">0.040</span> <span class="number">0.030</span></div><div class="line">&gt; p.adjust(sort(p0),method = <span class="string">"BH"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div><div class="line">&gt; p.adjust(sort(p0),method = <span class="string">"fdr"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div><div class="line">&gt; sort(p.adjust(p0,method = <span class="string">"BH"</span>))</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div></pre></td></tr></table></figure>
<p>从上面的计算结果看来：</p>
<ol style="list-style-type: decimal">
<li><code>method=&quot;BH&quot;</code>等于<code>method=&quot;fdr&quot;</code>，结果没有区别；</li>
<li>在使用<code>p.adjust()</code>函数计算q值时，不用对原始数据进行排序，如果想要结果按从小到大的序列排列，那么就排序原始值，或计算后的值均可。</li>
</ol>
<p>回到原文。</p>
<p>在R中，<code>qvalue</code>包中的<code>qvalue()</code>函数可以用来计算q值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(qvalue)</div><div class="line">res &lt;- qvalue(pvals)</div><div class="line">qvals &lt;- res$qvalues</div><div class="line">plot(pvals,qvals)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902153110.jpeg">

</div>
<p>估计一下<span class="math inline">\(\hat{\pi_{0}}\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; res$pi0</div><div class="line">[<span class="number">1</span>] <span class="number">0.8813727</span></div></pre></td></tr></table></figure>
<h2 id="练习">练习</h2>
<p>P274</p>
<h2 id="基础探索数据分析">基础探索数据分析</h2>
<p>与低通量数据相比，高通量数据的一个被低估的优点就是它很容易展现数据。例如当我们有了海量的高通量数据后，我们很容易发现那些在少量数据时并不明显的问题。研究这些数据的一个强有力工具就是探索性数据分析(EDA,exploratory data analysis)。这一部分我们就来了解这方面的内容，可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/advinference/eda_for_highthroughput.Rmd" target="_blank" rel="external">Github上的原文</a>。</p>
<h3 id="火山图">火山图</h3>
<p>我们使用前面数据做的t检验结果来看一下火山图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line"><span class="keyword">library</span>(GSE5859Subset)</div><div class="line">data(GSE5859Subset)</div><div class="line">g &lt;- factor(sampleInfo$group)</div><div class="line">results &lt;- rowttests(geneExpression,g)</div><div class="line">pvals &lt;- results$p.value</div></pre></td></tr></table></figure>
<p>我们还可以从一个数据集中生成一些p值，这些数据集中的零假设为真，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m &lt;- nrow(geneExpression)</div><div class="line">n &lt;- ncol(geneExpression)</div><div class="line">randomData &lt;- matrix(rnorm(n*m),m,n)</div><div class="line">nullpvals &lt;- rowttests(randomData,g)$p.value</div></pre></td></tr></table></figure>
<p>我们前面提到过，当我们报告效应大小(effect size)时，如果仅仅计算p值则会造成一些错误。我们可以通过画一个火山图来展示高通量数据的统计结果。火山图背后的思想是，它能展示出所有的特征值（这里指的是基因表达谱）。火山图的y轴是<code>-log(base 10) p-value</code>，x轴是效应大小(effect size)。当我们经过<code>-log(base 10)</code>转换后，那些有着极显著差异的特征值就会出现在火山图的上方。这里使用log转换是因为，我们可用log转换可以更好地区分一些非常小的数据，例如区分<code>0.01</code>和<span class="math inline">\(10^6\)</span>，此时我们来绘制一个火山图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plot(results$dm,-log10(results$p.value),</div><div class="line">xlab=<span class="string">"Effect size"</span>,ylab=<span class="string">"- log (base 10) p-values"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902194350.jpeg">

</div>
<h3 id="p值直方图">p值直方图</h3>
<p>另外一种看整体数据的思路就是绘制p值的直方图。当我们的数据完全无效时，那么p值的直方图是服从均匀分布的，而我们的数据有效时，我们可以发现较小的p值频率较高，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">hist(nullpvals,ylim=c(<span class="number">0</span>,<span class="number">1400</span>))</div><div class="line">hist(pvals,ylim=c(<span class="number">0</span>,<span class="number">1400</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902194645.jpeg">

</div>
<p>左侧的p值是无效数据产生的p值，它服从均匀分布，右侧的p值则是则是我们基因表达谱的数据。</p>
<p>当我们预期大多数假设都是无效时，我们就不会看到服从均匀分布的p值，它也许是一些异常属性的指标，例如相关的样本。如果我们对结果时行置换检验，并计算出p值后，如果样本是独立的，那么我们应该会看到均匀分布，但是，我们的数据却看不到这个结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">permg &lt;- sample(g)</div><div class="line">permresults &lt;- rowttests(geneExpression,permg)</div><div class="line">hist(permresults$p.value)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902195138.jpeg">

</div>
<p>在后面部分中，我们会了解到这个数据集中的每个检验并不是独立的，因此这里用于检验的假设（我们使用的是t检验，而t检验的前提就是样本独立）是不正确的。</p>
<h3 id="箱线图与直方图">箱线图与直方图</h3>
<p>高通量数据实验中，我们会检测每个实验单元的数千个特征值，我们前面也提到了，使用箱线图可以辅助我们来判断这些数据的质量。例如，如果一个样本的分布完全不同于剩余的样本，那么我们就可以认为，这个样本存在着一定问题。虽然一个完全的完全的变化可能是由于真正的生物学差异引起的，但是多数情况下，这就是技术因素造成的。这里我们使用Bioconductor中的基因表达数据，为了模拟出一组异常的数据，我们会对其中的一个样本进行log2转换，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#BiocManager::install("Biobase")</span></div><div class="line"><span class="comment">#devtools::install_github("genomicsclass/GSE5859")</span></div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">load(<span class="string">"GSE5859.rda"</span>)</div><div class="line">data(GSE5859)</div><div class="line">ge &lt;- exprs(e) <span class="comment">##ge for gene expression</span></div><div class="line">ge[,<span class="number">49</span>] &lt;- ge[,<span class="number">49</span>]/log2(exp(<span class="number">1</span>)) <span class="comment">##immitate error</span></div><div class="line"></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">boxplot(ge,range=<span class="number">0</span>,names=<span class="number">1</span>:ncol(e),col=ifelse(<span class="number">1</span>:ncol(ge)==<span class="number">49</span>,<span class="number">1</span>,<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>运行过重中发现，<code>GSE5859</code>这个包无法安装，因此可以去官网下载原始文件，直接加载到RStudio中，另外在加载<code>data(GSE5859)</code>时会出错，不用管，运行就行，图形如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202117.jpeg">

</div>
<p>从上图我们可以看到，样本数据大，很难看清楚中间的箱子形状，但是我们很容易发现有一个样本异常，除此之外，我们可以用另外一种方式来展示一下数据，这个数据不画箱子，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qs &lt;- t(apply(ge,<span class="number">2</span>,quantile,prob=c(<span class="number">0.05</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.75</span>,<span class="number">0.95</span>)))</div><div class="line">matplot(qs,type=<span class="string">"l"</span>,lty=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202322.jpeg">

</div>
<p>这种图形可以称为<code>kaboxplot</code>，因为这是由Karl Broman首次使用的，它绘制的是0.05，0.25，0.5，0.75和0.95分位数的图形。</p>
<p>我们也可以绘制直方图。因为我们的数据很多，因此可以使用很窄的间隔(bin)与柱子，然后将这些柱子进行平滑处理，最终绘制成平滑直方图(smooth histogram)。我们重新再校正这些平滑曲线的高度，那么在<span class="math inline">\(x_{0}\)</span>处的高度与基本单元构成的面积内，它们的点的数目就都比较接近，如下所示：</p>
<p>元区域内的点的数目就与这个基本单元的面积接近积，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">shist(ge,unit=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202859.jpeg">

</div>
<h3 id="ma图">MA图</h3>
<p>散点图(scatterplot)与相关性(correlation)不是检测重复性问题的最佳工具。检测重复性更好的工作就是检测两次之间的差值，如果重复性好，那么这些差值应该是一样的。因此，一种更好的绘图工具就是将散点图旋转一下，这个散点图的y轴上差值，x轴是平均值。这种图最初被叫做Bland-Altman图，但在遗传学中它经常被称为MA图。MA的名称来源于图形的内容，M表示减(minus)，表示两值之差（有的时候是log值之差），A表示平均(Average)，现在绘制一下MA图</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x &lt;- ge[,<span class="number">1</span>]</div><div class="line">y &lt;- ge[,<span class="number">2</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y)</div><div class="line">plot((x+y)/<span class="number">2</span>,x-y)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902215832.jpeg">

</div>
<p>左图是常规的相关图，右图是MA图，需要注意的是，当我们把左图进行旋转后，这些数据的差异的SD就非常直观了：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sd(y-x)</div><div class="line">[<span class="number">1</span>] <span class="number">0.2025465</span></div></pre></td></tr></table></figure>
<p>左图的散点图显示这两个样本的相关性很强，但是显示的信息有限。</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://www.jianshu.com/p/d86823ecd3ac" target="_blank" rel="external">如何理解与计算FDR？（第二版）</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/高维数据/" <i class="fa fa-tag"></i> 高维数据</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/16/DAL/DALS016_InferenceForHighDimensionalData1_Basic/" rel="next" title="DALS016-高维数据推断1-背景介绍">
                <i class="fa fa-chevron-left"></i> DALS016-高维数据推断1-背景介绍
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/18/DAL/DALS018_StatisticalModels1_binomal_Possion_MLE/" rel="prev" title="DALS018-统计模型1-二项分布与泊松分布，MLE">
                DALS018-统计模型1-二项分布与泊松分布，MLE <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="vcomments"></div>
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">219</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">110</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高维数据的p值"><span class="nav-number">2.</span> <span class="nav-text">高维数据的p值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误率"><span class="nav-number">3.</span> <span class="nav-text">错误率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据案例"><span class="nav-number">4.</span> <span class="nav-text">数据案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bonferroni校正"><span class="nav-number">5.</span> <span class="nav-text">Bonferroni校正</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误发现率fdr"><span class="nav-number">6.</span> <span class="nav-text">错误发现率(FDR)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向量化代码"><span class="nav-number">7.</span> <span class="nav-text">向量化代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制fdr"><span class="nav-number">8.</span> <span class="nav-text">控制FDR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#benjamini-hochberg"><span class="nav-number">9.</span> <span class="nav-text">Benjamini-Hochberg</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接fdr与q值"><span class="nav-number">10.</span> <span class="nav-text">直接FDR与q值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习"><span class="nav-number">11.</span> <span class="nav-text">练习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础探索数据分析"><span class="nav-number">12.</span> <span class="nav-text">基础探索数据分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#火山图"><span class="nav-number">12.1.</span> <span class="nav-text">火山图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#p值直方图"><span class="nav-number">12.2.</span> <span class="nav-text">p值直方图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#箱线图与直方图"><span class="nav-number">12.3.</span> <span class="nav-text">箱线图与直方图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ma图"><span class="nav-number">12.4.</span> <span class="nav-text">MA图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">13.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共869.7k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
