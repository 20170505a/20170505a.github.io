<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/05/Literature/文献笔记-RNA sequencing the teenage years/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/Literature/文献笔记-RNA sequencing the teenage years/" itemprop="url">文献笔记-RNA sequencing the teenage years</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T12:00:00+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/文献笔记/" itemprop="url" rel="index">
                    <span itemprop="name">文献笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  29,502
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  105
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文献信息">文献信息</h2>
<p>本文是2019年7月份发表在《Nature Reviews Genetics》上的有关RNA-seq的综述文章。</p>
<p>文献信息如下所示：</p>
<p>Stark, R., et al. (2019). “RNA sequencing: the teenage years.” Nature Reviews Genetics.</p>
<p>## 摘要</p>
<p>在过去的十年中，RNA测序(RNA-seq)已经成为在全转录组范围内分析差异基因表达和mRNAs差异剪接的重要工具。然而，随着下一代测序技术的发展，RNA-seq技术也在不断发展。现在，RNA-seq用于研究RNA生物学的许多方面，其中包括单细胞基因表达、翻译（翻译组,translatome）和RNA结构（结构组，structurome）。RNA-seq的其它应用也在开发中，例如空间转录学(spatialomics)。加上新的长读长 （long-read，**注：在本文中，RNA-seq测序生成的read统一译为“读长“**）和直接RNA-seq(direct RNA-seq)技术以及用于数据分析的更好的计算工具的整合，RNA-seq技术的创新有助于人们更全面地理解RNA生物学，例如从何时何地转录发生到控制RNA功能的折叠和分子间相互作用等问题。</p>
<p>## 前言</p>
<p>RNA-seq技术出现于十年之前，自其诞生之日起，RNA-seq就成了研究分子生物学的普遍工具，这项技术几乎构成了我们对基因组功能的认知基础 。RNA-seq中最常用的分析方法就是找出<strong>差异基因表达(Differential gene expression, DGE)</strong>。从最早的出版期刊开始，DGE分析的基本阶段就未发生实质性的改变。在实验室中，其标准流程就分为三步：</p>
<p>第一步是构建测序文库，这一步骤包括提取RNA，富集mRNA或清除核糖体RNA，合成 cDNA，加上接头。</p>
<p>第二步，在高通量平台（通常是Illumina平台）上对文库进行测序，每个样本的测序深度为10-30M读长数（读长这里就是前面说的reads）。</p>
<p>第三步是数据分析，具体的工作是：对测序得到的读长进行<strong>比对(aligning)</strong>和/或组装到转录组上，对这些覆盖了转录组的读长进行过滤，归一化(Normalization)，根据统计模型找出那些在不同样本之间有差异的转录本。早期的RNA-seq从大量的实验样本中产生了DGE数据，这充分说明了RNA-seq在广泛的生物体以及系统中的使用，这些生物体包括玉米(Zea mays), 拟南芥(Arabiodopsis thaliana), 酿酒酵母（Saccharomyces cerevisae），小鼠(Mus musculus)以及人类。虽然RNA-seq这个术语经常被用于那些完全不同的方法学方法和/或生物学，但是DGE分析仍然是RNA-seq（补充材料中的表1）的主要应用，并被视为常规研究工具。</p>
<p>RNA-seq的更广泛应用已经促进了我们对生物学多方面的理解 ，例如通过提示mRNA剪接和非编码RNAs和增强子RNAs对基因表达的调控。RNA-seq的应用和进步是由技术发展（湿实验室和计算生物学）驱动的，相对于以前的基因芯片，RNA-seq这种方法对RNA生物学和转录组产生更丰富并且偏见更小的信息。到目前为止，从标准的RNA-seq方法衍生而来的各种RNA-seq方法几乎有100种。Illumina的短读长(short-read)测序平台能对这些由大部分不同方法的RNA-seq构建的文库进行测序，但是最近长读长(long-read)RNA-seq的与直接RNA-seq测序(direct RNA sequencing, dRNA-seq)的进步已经能够解决以前研究人员使用短序列手段无法解决的一些问题。</p>
<p>在这篇综述中，我们首先会介绍一些最基本的短读长RNA-seq中的DGE方法，再将这种基础方法与最近新兴的长读长RNA-seq和dRNA-seq进行比较。我们会介绍短读长测序方法在文库制备方面的进展，以及实验设计和DGE的数据分析方法。随后我们会拓展这些常规的RNA-seq方法，介绍一些单细胞测序和空间转录组学的分析。我们会提供一些案例，介绍RNA-seq在RNA生物学方面的关键应用，包括转录组分析，翻译动力学，RNA结构，RNA-RNA之间相互作用和RNA-蛋白质的相互作用。最后，我们会简单描述一下RNA-seq的未来，以及单细胞和空间RNA-seq方法是否会像DGE分析一样成为常规工具，长读长测序方法是否会取代短读长测序方法。由于篇幅限制，我们无法介绍所有的RNA-seq方法，在这些方法中，值得注意的是非编码转录组学，原核转录组学(prokaryotic transcriptomes)和表观转录组学(epitranscriptome)。</p>
<h2 id="rna-seq技术的发展历史">RNA-seq技术的发展历史</h2>
<p>Illumina的短序列读长测序技术生成了<strong>SRA(Short Read Archive)</strong>中95%已表达的数据（附件表2）。由于cDNA的短序列读长测序方法几乎是一种常规的方法，因此 我们认为这是一种最基础的 RNA-seq技术，我们先来讨论这种测序主要流程与局限。不过，长读长cDNA测序与dRNA-seq已经兴起，随着研究人员对能提供更丰富转录本水平方面(isoform-level)数据需求增大，这两种新的测序方法有望对常规的短读长测序方法提出挑战(FIG1, TABLE1)。</p>
<h3 id="table1-短读长与长读长rna-seq平台">Table1-短读长与长读长RNA-seq平台</h3>
<table style="width:100%;">
<colgroup>
<col width="4%">
<col width="12%">
<col width="27%">
<col width="27%">
<col width="27%">
</colgroup>
<thead>
<tr class="header">
<th>测序技术</th>
<th>平台</th>
<th>优势</th>
<th>劣势</th>
<th>重要应用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>短读长cDNA</td>
<td>Illumina， Ion Torrent</td>
<td>①高通量，一次运行产生的读长是长读长平台的100倍到1000倍。②偏倚与错误明确（对Ion Torrent平台来说，聚合物(homopolymers)仍是一个问题）。③ 现在有大量可兼容的方法和计算流程； 4． 可对降解的RNA进行分析。</td>
<td>①样本制备包括逆转录，PCR与片段大小选择，所有的这些操作增加了测序偏倚。②针对异构体检测与定量的能力有限。③转录本发现分析需要从头对转录本进行比对和/或组装步骤。</td>
<td>几乎所有的RNA-seq方法都已经是针对短读长cDNA测序而开发的：DGE，WETA，smallRNA， 半日细胞，空间转录组，nascent RNA，翻译组，结构和RNA-蛋白质相互作用分析等等。</td>
</tr>
<tr class="even">
<td>长读长cDNA</td>
<td>PacBio， ONT</td>
<td>①可捕获1-50kb的长读长； ②从头转录组分析方法简单。</td>
<td>①中低通量：目前一次运行只能生成0.5M到10M的读长；②样本制备包括逆转录，PCR和片段选择，增加了偏倚；③针对降解的RNA分析能力有限。</td>
<td>用于研究新异构体，从头转录组分析，融合转录本发现，MHC，HAL或其它复杂的转录本分析。</td>
</tr>
<tr class="odd">
<td>长读长RNA</td>
<td>ONT</td>
<td>①可捕获许多1-50kb的全长转录组；②从头转录组分析方法简单； ③样本制备并不需要进行逆转录或PCR，从而降低了PCR导致的偏倚；④ 可检测RNA的修饰；⑤ 直接在单细胞水平上对poly(A)进行估计。 ①</td>
<td>低通量，目前一次运行只能生成0.5M到1M的读长；②样本制备与测序偏倚不明；③无法对降解的RNA进行分析。</td>
<td>①用于研究新异构体，从头转录本分析，融合转录本，MHC，HLA或其它的复杂转录本分析。②检测核糖核酸修饰。</td>
</tr>
</tbody>
</table>
<p>### Figure 1-短读长，长读长和直接RNA-seq技术与工作流程</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805185923.png">

</div>
<p><strong>Figure 1-短读长，长读长和直接RNA-seq技术与工作流程。</strong></p>
<p><strong>(a)不同RNA-se方法的文库制备，这些方法可以分为3种，分别是短读长测序（黑色），长读长测序（绿色），或长读长直接RNA-seq（蓝色）。根据使用的文库制备方法不同，文库制备会表现出相应的复杂性和偏倚。短读长与长读长cDNA文库在制备时有一些步骤是相同的，不过所有的方法都需要一个接头连接步骤，并且它们都受到样本质量和文库上下游计算问题的影响。</strong></p>
<p><strong>(b)三种主流的RNA-seq测序方法。</strong></p>
<p><strong>Illumina的工作流程（左边）：文库制备好后，每个cDNA就会在一个泳道(flowcell)上通过合成来聚集成簇，其中合成的过程使用3’阻断的荧光标记的核苷酸。在每一轮测序的过程中，新合成的DNA链就会被成像，从而检测出参与合成的是哪种核苷酸，这种测序方法产生的读长是50-500bp。</strong></p>
<p><strong>Pacific Biosciences工作流程（中间）：文库制备好后，每个分子被加载到一个测序芯片上，在芯片上这些分子与固定到纳米孔(nanowell)底部的聚合酶进行结合。随着每一个荧光标记的核苷酸被整合到新合成的链上，这些核苷酸发出的荧光就会被检测到，这种方法产生的读长为50kb。</strong></p>
<p><strong>Oxford纳米孔工作流程（右边）：文库制备好后，每个分子被加载到流动室(flowccell)中，流式室中含有马达蛋白，马达蛋白固定在流动室中，它可以与文库的接头结合。马达蛋白控制RNA链通过纳米孔，从而造成纳米孔中电流的改变，这种技术产生的读长为1-10kb。</strong></p>
<p>**(c) 短读长、长读长与直接RNA-seq分析的比较。超过90%的人类基因(gene n)存在可变剪接，它们会形成两个或更多的可表达异构体（转录本x与y）。短读长cDNA测序中就增加了捕获信息的复杂性，短读长对异构体的检测会受到其读长的限制，在这种技术里，短读长无法精确地回贴（注：测序分析方法中的术语“map“在本文中都译为”回贴“）到转录组上，而长读长测序方法则能直接鉴定异构体。在短读长cDNA测序中，有很大比例的读长会不明确地回贴到不同异构相同的外显子上；而那些跨越了外显子-外显子连接处的读长可以提高对异构体的分析效果，但是当不同的异构体都含有这个连接处时，这种操作意义不大。这些问题都加剧了数据分析的复杂性，以及无法对结果进行明确地解释。长读长cDNA方法能够产生全长的异构体读长，从而去除或大幅度降低这些不精确的结果，并改进差异异构表达的分析结果。然而这些方法依赖于cDNA的转换，它去除了RNA碱基的修饰信息，并且只能粗略地估计多聚腺苷酸(poly(A))尾巴长度。直接RNA-seq可以进行全长导构体分析，碱基修饰检测（例如N6-甲基腺苷(M6A)）和poly(A)尾巴长度估计。**</p>
<h3 id="短读长cdna测序">短读长cDNA测序</h3>
<p>短读长已经成了在整个转录组范围内对基因进行检测和定量的事实方法(de facto method)，部分原因是这种方法比芯片成本更低，操作更方便，但是其主要原因还是因为这种方法能生成更全面，更高质量的数据，这种方法能够 对整个转录组中的基因表达水平进行定量。使用Illumina短读长测序平台进行DGE分析的核心步骤包括： RNA提取、cDNA合成、接头连接、PCR扩增、测序和数据分析(FIG1)。在这个过程中，存在打断片段，片段长度选择和基于磁珠的文库纯化这些操作，因此这种方法产生的cDNA片段通常都是在200bp以下。RNA-seq文库的测序读长分配到每个样本上的话，每个样本会测到平均20-30 million条读长(reads)（也就是常说的20-30M条读长），数据经过处理后，使用这些读长对每个基因或转录本进行定量，最后再用统计学方法来统计基因的差异。短读长RNA-seq方法很稳健，并且通过对短读长测序技术的大范围比较发现，这种技术在平台内和平台间的相关性很好。但是，在样本制备和数据分析这两个阶段会引入一些干扰和偏倚。这种局限可能会影响通过实验来解决特定生物学问题的能力，例如准确识别和量化多个异构体中的哪个来源于一个基因。对于研究那些非常长，高度可变的转录本异构的人来说，这种局限表现得尤为明显，例如在人类转录组研究中；人类转录本的长度范围是109bp到186kb，其中50%转录本长度大于2500bp。尽管短读长RNA-seq可以对最长的转录本进行详细的分析，但是涉及的实验方法不能扩展到全转录组分析。其他的偏倚与局限来源于那些大量的计算方法，这些方法包括例如如何处理模糊或多个回贴的读长(multi-mapped reads)。现在出现了一种<strong>合成长读长(synthetic long reads)</strong>的新方法，这种方法可以实现全长的mRNA测序，并试图解决其中的一些局限。这种方法使用了<strong>唯一分子标识符(unique molecular identifiers,UMI)</strong>来标记全长的cDNA，在制备短读长RNA文库之前，加入的UMI会随着单个cDNA分子而进行复制。转录本异构体可以在高达4kd的contigs中重建，用于发现异构体和表达分析。但是，对于从根本上解决短读长cDNA测序固有局限的最可能解决方案则是长读长cDNA测序和dRNA-seq测序 。</p>
<h3 id="长读长cdna测序">长读长cDNA测序</h3>
<p>虽然Illumina测序目前是占主导地位的RNA-seq平台，但PacBio和Oxford Nanopore(ONT)公司都提供了可供选择的长读长技术，能够对完整的单个RNA分子进行单分子水平级的测序。通过消除短RNA-seq测序数据的组装这一步，这些新方法克服了短读长测序方法相关的一些问题。例如，减少了测序读长回贴过程中的歧义，并且可以识别更长的转录本，这样就能获取更完整的异构体多样性信息。这些方法还能降低许多短读长RNA-seq计算工具中关于剪接连接的假阳性。</p>
<p>PacBio的Iso-Seq技术可以读取最高可达15kb的转录本的全长cDNA，这就有利于发现大量以前未注释的转录本，并通过检测物种的全长同源序列证实了早期的基因预测。在标准的Iso-Seq操作流程中，高质量的RNA被一个模板切换凝聚力转录酶(a template-switching reverse transcriptase)反转录为全长的cDNA。生成的cDNAs再经过PCR扩增，加入到PacBio的单分子实时(single-molecule, real-time)文库制备系统中。制备好的短转录本序列可以很快地扩散到测序芯片的活性表面，但由于短转录本的测序存在偏倚，因此在对转录本进行测序时，建议选择片段的长度是1到4kb，这样就能在此范围对长转录本和短转录本进行更加均匀地采样。由于PacBio测序方法需要大量的模板，因此需要进行多轮PCR，不过这一操作还需要进行优化，从而降低扩增导致的偏倚。经过PCR的末端修复和PacBio SMRT接头连接后，就可以进行长读长测序了；通过修改测序芯片的上样条件，就可以在这一步骤进一步控制测序片段长度。</p>
<p>ONT cDNA测序方法也能产生全长的转录本读长，甚至还能在单细胞水平上产生该读长。模板转录逆转录酶也在这种方法中用于制备全长cDNA，制备好的cDNA可以选择使用PCR来进行扩增，随后在产物上加上接头，形成测序文库。直接cDNA测序会消除PCR偏倚，从而形成高质量的测序结果；但是，如果使用PCR来制备测序文库的话，需要的RNA数量更少。ONT cDNA测序法尚未报道过在PacBio测序仪上观察到的片段长度偏倚。</p>
<p>这两种长读长cDNA方法都受到标准模板切换逆转录酶使用的限制，这种逆转录酶能用全长RNA以及截短的RNA来生成cDNA。逆转录酶可以将那些只含5ʹ帽子结构的mRNA置换为cDNA，这样的话，那些由于RNA降解，RNA剪接或不完全cDNA合成而生成的短转录本就不会被反转录为cDNA，从而提高数据质量。但是，有报道指出，逆转录酶会对ONT平台的读长产生不良影响。</p>
<h3 id="长读长直接rna测序">长读长直接RNA测序</h3>
<p>前面我们提到了长读长测序方法，这种测序方法与短读长测序平台一样，它们都依赖于将mRNA转换为cDNA。而最近Oxford Nanopore指出，他们的纳米孔测序技术可以直接对RNA进行测序，也就是说，这种测序手段不需要常规测建库过程中的的cDNA的合成和/或PCR扩增操作。这种方法称为dRNA-seq，这种方法就消除了常规建库过程中的偏倚，并且能够保留表观遗传学信息。这种方法可以从RNA直接进行两个接头的连接来制备文库。首先，带有一个oligo(dT)悬臂的双链核酸接头退火并连接到RNA的多聚腺苷酸(PolyA)尾部，随后就是可选（但不推荐的）的逆转录操作，这一步用于提高测序的通量。第二个连接操作就是添加测序接头，这个测序接头上已经提前安装有驱动测序的马达蛋白。文库随后进行MinION测序，其中RNA直接从3ʹpoly(A)尾部向5ʹcap端进行测序。最初的研究表明，dRNA-seq的测序长度过超过1000bp，最大测序长度过超过10kb。与短读长测序相比，这种长读长测序的几个优势在于：长读长测序可以提高对异构体的检测，并且它们还可以用于下方代码poly(A)尾巴的长度，这对于可变poly(A)分析（ alternative poly(A) analysis）来说非常重要。Nanopolish-polya这个工具可以对那些用纳米孔测序得到的数据进行分析，计算出poly(A)尾的长度，这就包括基因之间的长度，也包括转录亚型之间的长度。这种分析证实了，保留内含子的转录本比完全剪接的转录本具有略长的poly(A)尾巴。虽然dRNA-seq还处于起步阶段，但是它具有检测RNA碱基修饰的潜力，因此它的应用潜力巨大，尤其是能够对表观遗传学转录进行新的分析。</p>
<h3 id="长读长与短读长技术的比较">长读长与短读长技术的比较</h3>
<p>虽然长读长技术在评估转录本方面比短读长技术有一些明显的优势，但是长读长技术也有一些明显的局限。尤其是与短读长技术相比，长读长技术的测序通量更低，错误率更多。但长读长技术的主要优势在于，它们能够捕获更多的单个转录本，不过这依赖于高质量的RNA文库。总体来说，这些局限影响了那些完全依赖于长读长测序实验的灵敏性(sensitivity)与特异性(specificity)。</p>
<p>长读长测序方法的主要局限就是当前的通量。在Illumina平台上，运行单次的RNA-seq可以生成10E9-10E10条短读长，但是在PacBio和ONT平台上，一次RNA-seq则只能产生10E6-10E7条读长。这种低通量限制了应用长读长测序技术进行实验的规模，并降低了对差异基因表达检测的灵敏性。然而，并非所有的实验都需要高深度测序。对于那些主要研究异构体的发现以及其特征的研究者们来说，测序长度比测序深度更重要。例如1百万个PacBio环形一致性测序(circular consensus-sequencing, CCS)的读长几乎就可以保证产生那些大于1kb的高表达基因的检测，ONT测序技术也是如此。因此，对于那些低到中等水平表达的基因来说，测序深度确实是一个主要问题。当进行同期功能基因组学分析(contemporary functional genomics analysis)大规模的DGE实验时，这种低通量测序技术的局限就会表现得明显。在这些研究中，必须对多个样本组进行分析，每组就是由多个生物学重复构成的，这样就能够实现充分的统计功效来有确认那些在整个转录组水平上发生的精确变化。对于这种需求，长读长技术不太可能取代短读长技术，除非长读长的测序读长的生成量能提高2个数量级。随着全长RNA-seq读长数目的增加，转录本检测的灵敏度将会增加到类似于Illumina平台上的这种水平，并同时具有更高的特异性。与此同时，通过将Illumina 的短读长RNA-Seq与PacBio的长读长Iso-Seq结合(并且可能还与ONT方法结合)，可以增加全长RefSeq注释的异构体检测的数量、灵敏性和特异性，同时保留转录本量化的质量。虽然长读长RNA-seq方法目前的实验成本较高，但它们可以检测到短读长方法遗漏的异构体，尤其是那些难以测序但与临床相关的区域，例如高度多态的人类MHC或雄激素受体。</p>
<p>长读长测序平台的第二个主要局限就是其更高的错误率，它比成熟的Illumina测序仪要高出一到两个数量级。长读长测序平台上生成的数据还包含更多的插入-删除错误。虽然这些错误与识别变化(variant calling)有关，但在RNA-seq中，每个碱基都被正确识别并非那么重要而长读长测序的目标是要阐明转录本和异构体（While these error rates are of concern for variant calling, in RNA- seq it is less crucial that every base be called correctly, as the goal is only to disambiguate transcripts and isoforms）。这种错误率对于其应用来说确实是一个值得观注的问题，现在正在解决这一问题。PacBio SMRT测序平台上出现的随机错误通常可以通过使用CCS增加测序深度来进行解决，在这种技术里，cDNA经过长度选择和接头进行环化后，每个分子就可以被多次测序，从而产生长度范围是10-60kb的连续长读长，并且包含许多原始cDNA的拷贝。这些长读长经过数据分析后就被处理为单个cDNA子子读长(subreads)，这些子读长被组合后就可以产生一致的序列。分子测序的次数越多，产生的错误率就越低；CCS已经被证明可以将错误率降低到与短读长相当的水平，甚至更低。但是，将更多的这个平台的测序能力用于重新读取相同的分子，就又加剧了其测序通量的问题，因为可以读取的唯一转录本变得更少了。</p>
<p>长读长RNA-seq方法的灵敏度还受到其他几个因素的限制。首先，它们依赖于长RNA分子以全长转录本的形式进行测序，但是要达到这种情况并非总能实现，因为在样品处理和RNA提取过程中RNA会发生降解或剪接。这种情况在短读长RNA-seq中也存在（3ʹ端的偏倚），但这种问题在短读长中是可控的，对于全长转录组分析进行研究的研究者们来说，即使是低水平的RNA降解，也能限制长读长的RNA-seq效果。因此，对于那些即将使用长读长进行测序的研究者来说，需要仔细地对提取的RNA进行质控。其次，中位数的读长长度会进一步受到文库制备中的技术问题与偏倚的限制，例如有些cDNA合成的截断或某些cDNA是由降解的mRNA合成的，最近开发的高效逆转录酶对此有所改进，这些酶有着更高的链特异性，甚至能够产生更多的3ʹ-5ʹ转录本的覆盖。虽然这些酶还未被广泛使用，但是这些高效逆转录酶也提高了结构稳定的RNAs，例如tRNAs的覆盖率，在oligo-dT和全转录组分析(WTA)方法中使用的逆转录酶很难处理这些结构稳定的RNAs。第三，长读长测序平台固有的偏倚（例如长文库分子在测序芯片表面上的低扩散）会降低更长转录本的覆盖率。</p>
<p>长读长方法(使用cDNA或dRNA-seq)解决了用于异构体分析的短读长测序方法中的一个基本问题，即它们的读长长度。长读长方法可以生成从Poly(A)尾部到5ʹcap的跨异构体的全长转录本读长。因此，这些方法使得分析转录本及其异构体成为可能，从而无需从短的读长中重构它们或推断它们的存在；每个测序的读长仅仅代表了它的起始RNA分子。全长cDNA测序或dRNA-seq用于分析DGE的未来应用将依赖于PacBio和ONT技术的更高通量。长读长RNA-seq分析正被研究者们迅速采用，并与深度短读长RNA-seq数据结合起来，用于更全面的分析，这非常类似于基因组组装所采取的混合方法。随着时间的推移，长读长和dRNA-seq方法可能会用于证明已经鉴定的基因和转录本的列表，即使在研究很透的生物中，对于基因和转录本的研究也还远远不够。随着方法的成熟，以及测序通量的增加，差异转录本分析将会成为常规方法。合成长读长RNA-seq或其它技术的发展将对这个领域产生什么样的影响，还有待观察。然而从目前来看，Illumina短读长RNA-seq依然占据了主导地位，在这篇综述的剩下部分中我们将会集中讨论短读长测序。</p>
<h2 id="改良rna-seq建库方法">改良RNA-seq建库方法</h2>
<p>RNA-seq最初用于分析多聚腺苷酸化的转录本，使用的方法源于早期的表达序列标签(expressed-sequence tag)和芯片研究。然而，下一代测序的使用指出了这些方法的局限性，而这些局限性在芯片数据中并不明显。因此，在RNA-seq首次报道后不久，就有研究报道了文库制备方法的一些重大进展。例如，在cDNA合成之前，对RNA进行片段化可以产生3ʹ:5ʹ偏倚，链特异性文库制备方法能够更好的区分正义链与反义链，这些改进都能够对转录本丰度进行更准确的估计。RNA片段化和链特异性文的制备很快就成了RNA-seq文库制备试剂盒中的标准方法。这里我们简要描述了其它RNA-seq方法的改良，使用这些改进方法的可以让研究者们根据他们的生物学问题以及特定样本进行选择。这些改进的方法包括在选择RNA进行测序时，取代dligo-dT富集的替代方法，或者是那些专门选择转录本的3ʹ或5ʹ末端的方法，或者是使用UMIs进行区分技术重复和生物重复的方法，以及针对RNA易降解特性改良的文库制备方法。这些方法的组合可以使研究者们阐明由可变poly(A)(alternative poly(A),APA)，或替代启动子(alternative promoter)使用和可变剪接(alternative splicing)生成的复杂转录本。</p>
<h3 id="polya富集的替代方法">Poly(A)富集的替代方法</h3>
<p>大多数发表的RNA-seq数据都是基于oligo-dT富集的mRNA方法，这种方法会选择包含poly(A)尾的转录本，并将集中测序测序那些在转录组的蛋白质编码区上。不过这种方法除了产生3ʹ偏倚外，RNA中还有许多非编码RNA，例如miRNA和增强子RNA，这些RNA不含有poly(A)，因此不能使用这种方法进行研究。如果不进行poly(A)富集也无法达到目的，因为这会导致高达95%的读长来源于rRNA。因此，研究者们可以选择使用oligo-dT用于mRNA-seq，或者是剔除rRNA后进行WTA。短的非编码RNAs无法被oligo-dT方法捕获，使用WTA也很难对其进行研究，因此在研究非编码短RNA时需要特定的小RNA方法，这些方法主要是通过顺序RNA连接(sequential RNA ligation)实现的（通常小RNA建库试剂盒中就有相应的说明）。</p>
<p>WTA生成的RNA-seq数据来源于编码和一些非编码RNA。RNA的部分降解也能使用这种方法进行测序，RNA的降解会导致一些poly(A)从转录的末端分离。rRNA的去除有两种方法，一种是将rRNAs从其它RNA中剔除掉（所谓的pull-out法），另一种就是使用RNAse H酶来对rRNA进行降解。这两种方法都是使用序列特异性和物种特异性寡核苷酸探索来实现的，这些探针能与细胞质rRNA(5S rRNA，5.8S rRNA，18S rRNA和28S rRNA)和线粒体rRNA(12S rRNA和16S rRNA)互补。为了简化人类，大鼠，小鼠或细菌(16S和23S rRNA)样本的处理，通常将预先混合的寡核苷酸添加到RNA中，然后让它们与rRNA进行杂交，以便进行下一步的清除。其它高丰度的转录本，例如珠蛋白(globin)或线粒体RNA也可以按照类似的方法去除。pull-out方法结合了生物素化的探针和链霉素包裹的磁珠，它们可以用于除去寡聚的rRNA复合物，留下剩余的RNA用于建库例如Ribo-Zero(Illumina，USA)和RiboMinus(Thermo Fisher，USA)。RNase H酶降解法可以降低那些生成的loigo-DNA:RNA复合物，例如，NEBNext RNA depletion(NEB，USA)和RiboErase(Kapa Biossystems，USA)。最近对这些方法的比较说明，在高质量的RNA中，这两种方法都可以将rRNA降低至后续RNA-seq读长的20%以下。但是，作者说明了，RNase H方法比pull-out法的稳定性要强，并且比较不同试剂盒时，最后得到的DGE长度的偏倚比较明显。作者还描述了另外一种类似于RNase H的方法，这种方法表现不错，并且以前没有报道过。ZapR方法是Takara Bio的一项专有技术，它使用一种酶来降解RNA-seq文中的rRNA片段。rRNA剔除方法的一个局限是，相比对oligo-dT RNA测序方法，rRNA剔除方法需要更高的测序深度，主要是因为里面还会存有一定的rRNA。</p>
<p>Oligo-dT和rRNA剔除法都可以用于后续实验的DGE分析，研究者们可能会默认使用以前在他们的实验室中使用的方法或最容易使用的方法。然而，对于这些方法的使用应该考虑一些因素，尤其是那些易降解的样本，另外，WTA方法会检测到更多的转录本，但是其实验成本要高于oligo-dT方法。</p>
<h3 id="富集的rna-3ʹ末端用于tag-rna-seq以及可变多聚腺苷酸分析enriching-rna-3ʹends-for-tag-rna--seq-and-alternative-polyadenylation-analysis.">富集的RNA 3ʹ末端用于Tag RNA-seq以及可变多聚腺苷酸分析(Enriching RNA 3ʹends for Tag RNA- seq and alternative polyadenylation analysis.)</h3>
<p>标准的短读长Illumina方法需要对每个样本生成1000万到3000万条（10M到30M条）读长用于高质量的DGE分析。对于那些专注于基因水平表达，并从事大型或高度重复实验的研究者们，或资源受限的研究者来说，可以选择使用3ʹtag计数。由于测序集中在转录本的3ʹ末端，因此需要的读长(reads)更少，这就降低了成本，并且一次测序的样本数目也可以更多。富集的3ʹ末端也可以用于确定单个转录本的poly(A)位点，而由于mRNA前体上存在的APA，其3‘末端可能会发生变化。</p>
<p>3ʹ mRNA-seq方法会产生每个转录本的单个标签读长(tag read)，这些读长来源于3ʹ末端，这个标签(tag)丰度与转录本的丰度是成正比的。标签测序法(tag-sequencing protocols)，例如QuantSeq(Lexogen, Austria)通常比标准RNA-seq法流程更为简单。标签测序法已经进行了优化，这种方法使随机引物或锚定的oligo-dT-primed来进行cDNA合成，从而并不需要poly(A)富集这一步骤，并在cDNA合成后立即进行PCR，从而取代了接头连接步骤。这种方法可以在低测序深度上实现与标准RNA-seq类似的灵敏度水平，因此，这种方法可以使用多路复用的形式实现多个文库的同步测序。这种建库方法的数据分析也进行了简化，因为不需要外显子连接检测和基因长度测序读长的归一化。但是，3ʹ mRNA-seq方法可能会被受到转录本同聚区(homopolymeric regions0的影响，这会导致错误标签；这种方法只能提供非常有限的异构体分析，这就会抵消它们较低测序深度带来的任何成本收益，尤其是对于那些仅够一次使用的样本来说。</p>
<p>mRNAs的APA化会产生3ʹ UTR长度不等的异构体。对于一个特定的基因来说，它不仅产生了这个基因的多个亚型，而且由于3ʹUTR中存在着顺式调控元件，这也会影响该转录本的调控。这种方法可以使用那些研究APA的研究者们更详细地研究miRNA的调控作用，mRNA的稳定和定位，以及mRNA的翻译。APA法指在富集转录本的3ʹ末端，从而提升信号与灵敏度，而前面提到的标签测序法非常适合此目的。其它方法多聚腺苷酸位点测序(polyadenylation site sequencing,PAS-seq)，这种方法可以将mRNA打断为150bp左右的片段，并且使用oligo-dT标记的模板转换来生成cDNA用于测序，其中的80%读长就来源于3ʹUTR。TAIL-seq方法能不使用oligo-dT，在对RNA进行打断之前，这种方法会剔除rRNA，并将3ʹ-RNA接头连到的poly(A)的尾部。当片段化后，再加上5ʹ-RNA接头就完成了RNA-seq文库的制备。在RNA-蛋白分析方法中也能评估APA，例如紫外交联免疫沉淀(cross- linking immunoprecipitation, CLIP)测序。</p>
<h3 id="富集的rna-5ʹ末端用于起始位点回贴enriching-rna-5ʹends-for-transcription-start--site-mapping">富集的RNA 5ʹ末端用于起始位点回贴(Enriching RNA 5ʹends for transcription start- site mapping)</h3>
<p>使用富集7-甲基鸟苷5ʹ加帽RNA(7-methylguanosine 5ʹ-capped RNA)也可以进行DGE分析，这种方法可以用来鉴定启动子和转录起始位点(TSSs)。现存有几种方法都可以实现这个目的，但是这些方法很少作为常规手段来进行使用。在对基因表达的加帽分析(CAGE, cap analysis of gene expression)，以及用于基因表达分析的启动子的RNA注释和定位(RAMPAGE, RNA annotation and mapping of promoters for analysis of gene expression)分析中，当使用随机引物生成第一链cDNA后，mRNA 5ʹ的帽子结构就被生物素化，这就可以将5ʹ cDNA通过链霉亲和素进行富集。CAGE使用II型限制性内切酶来生成短的cDNA标签，这种酶会从5ʹ端的接头下游切割21-27p的核核苷酸。相比之下，RAMPAGE操作则使用模板转换(template switching)来生成较长的cDNA，这个cDNAs随后被富集起来，用于测序。单细胞标签逆转录测序技术(single-cell-tagged reverse transcription sequencing, STRT-seq)能够在单细胞水平上实现TSS的回贴(mapping)。STRT-seq技术使用生物素化的模板转换oligos来生成cDNA，被磁珠捕获后，就在5ʹ末端进行片段化，产生短的cDNA标签。作为CAGE基础的5ʹ末端的加帽技术是由日本理化所(Riken)开发的，这种技术用于早期功能基因组学实验中，使全长cDNA克隆数量最大化。日本理化所主导的小鼠功能注释(FANTOM, Functional Annotation of the Mouse)协会通过阐明了1300多个人类和小鼠原代细胞，组织和细胞系的TSS，这充分显示了CAGE的强大。在最近一些方法比较中，CAGE也表示不俗。但是作者却报道说，仅使用5ʹ末端测序产生的假阳性TSS峰也是最多的，他们建议使用正交方法进一步来确认阳性，例如DNase I的回贴或H3K4me3染色质免疫沉淀测序(ChIP-seq)。</p>
<h3 id="使用唯一分子标识符来检测pcr重复">使用唯一分子标识符来检测PCR重复</h3>
<p>RNA-seq数据通常具有较高的重复率(duplication rates)，也就是说许多测序读长会回贴到转录组的相同位置。与全基因组测序不同的是，在全基因组测序中，重复的读长被以认为是PCR这一步中出现的技术偏倚导致的，它会被移除，而在RNA-seq中，这些重复的读长则被认为是真正的生物学信号并被保留。在一个样本中，数百万个起始RNA分子也许代表了高表达的转录本，当对cDNA进行测序时，就会发现很多片段是相同的。因此，在比对(alignment)过程中，并不建议通过计算去除那些不必要的重复，因为这些重复中很多是真正的生物信号。当使用单端测序(single-end sequencing)时更是如此，因为一对片段中只要一端相同，就可以被认为是一个重复(duplicate)，至于双端测序(paired-end sequencing)，两端必须在同一位置时才能被认为是一个重复，但这种情况很少。但是，由于PCR偏倚，在制备cDNA文库时，还会存在着某种程度上技术重复，并且PCR复制偏倚是一种质控问题，它有可能对RNA-seq实验结果造成影响时，很难区分出这些技术重复与生物重复的程度。</p>
<p>现在已经提到将UMIs作为一种解释扩增偏倚的方法。在扩增前将随机UMIs添加到cDNA分子中，使得能够确认PCR重复，并且可以在后续的数据分析中将其除去，同时保护真正的生物学重复，从而改善基因表达的量化和等位基因频率估计的效果。当一对测序读长被确认为一个技术重复时，它们应该包括相同的UMI，并且被回贴到转录组中相同的位置（一端或两端，这取决于使用的是单端测序还是双端测序）。</p>
<p>UMIs已经被证明能够降低变异和错误发现率来提升RNA-seq中的DGE数据分析，并且这种方法在单细胞数据分析方面也有着重要作用，单细胞数据中的扩增偏倚可能更为严重。当试图在RNA-seq数据中进行变异检测(variant calling)时，UMIs也非常有用。 虽然高表达的转录本可以产生适合这种变异检测的高覆盖率，尤其是包含了了这种重复时，但UMIs可以用于去他可能导致第二位基因频率错误计算的扩增假象。UMIs正在成为单细胞RNA-seq(scRNA-seq)的文库制备试剂盒中的标准，同时它也日益频繁地用于常规RNA-seq。</p>
<h3 id="提高降解rna的分析">提高降解RNA的分析</h3>
<p>RNA-seq文库制备方法的发展也改进了低质量或降解RNA的分析，例如从临床相关获得的那些用福尔马林固定石蜡包埋(FFPE)块存储的样本中的RNA。低质量的RNA会导致不均匀的基因覆盖率，更高的DGE假阳性率和更高的重复率，它们与文库的复杂性呈负相关。但是，文库的制备方法已经被改良，改良后的方法能降低RNA降解的影响。这些方法可能在基于RNA-seq的诊断技术的发展中显得尤为重要，例如将来有可能出现的类似于OncotypeDX（目前并不是测序分析）的诊断，这种试剂盒基于21个基因RNA的标签来预测乳腺癌的复发。虽然现在有几种方法可以使用，但是比较后发现两种方法表现最好，即RNase H与RNA exome。我们前面提到，RNase H法使用核酸本科来降低RNA:DNA复合物中的rRNA，但是它却能阻止mRNA的降解。RNA exome方法使用类似于外显子测序(exome sequencing)那样的方法，使用寡核苷酸探针来捕获RNA-seq文库分子。这两种方法都能通过减少rRNA，同时不影响mRNA的手段来产生高质量和高度一致的基因表达数据。3ʹ末端标记测序技术与扩增子测序（在PCR扩增中能产生超过2万个外显子扩增子）方法也可以用于分析降低的RNA，但是这两种方法并没有RNase H方法使用广泛。</p>
<h2 id="设计更好的rna-seq实验">设计更好的RNA-seq实验</h2>
<p>仔细设计DGE RNA-seq实验对于获取高质量和生物意义数据有着非常重要的意义。尤其是要考虑到复制的层次，测序深度以及单端还是双端测序。</p>
<h3 id="重复与实验功效replication-and-experimental-power">重复与实验功效(replication and experimental power)</h3>
<p>在一个实验中，足够的生物学重复(biological replicates)能够捕获不同样本之间的生物学变异；在定量分析中的置信度依赖于测序深度与读长长度。虽然RNA-seq比芯片表现了更低的技术偏倚，但是生物系统中固有的随机变化都要求任何RNA-seq实验要做生物学重复。使用额外的重复能够确定异常样本，在必要情况下，在进行生物学分析之前，移除这些异常样本或降低这些异常样本的权重。确定生物学重复需要考虑几个因素，包括效应大小(effect size)，组内变异，可接受的假阳性和假阴性阈值，以及最大样本数目，有的时候还需要RNA-seq实验设计工具或功效(power)计算工具的辅助。</p>
<p>在一个实验中要想确定一个合适的生物学重复并非是一件简单的事情。一项48个重复的酵母研究表明，当使用3个生物学重复时，计算样本用于DGE分析的工具只能检测出20-40%的差异表达基因。研究表明，至少应该使用6个生物学重复，这个数量要超过文献中常用的3到4个生物重复的数量。最近的一项研究表明，4个生物学重复可能足够的，但是研究指出，在确定合适的重复数目之前，需要做一个预实验来确定生物样本的方差。对于高度多样化的样本，例如来自癌症患者肿瘤的临床组织，可能需要更多的重复，以便能以更高的置信度来确定基因的变化。</p>
<h3 id="确定合适的读取深度determining-the-optimal-read-depth">确定合适的读取深度(Determining the optimal read depth)</h3>
<p>一旦文制备好，就需要决定对它们进行多深的测序。读取深度指的是，每个样本获得的测序读长的目标数目。对于真核基因组中的常规RNA-seq DGE分析来说，一般认为每个样本需要100万-300万条读长（也就是我们常说的10M到30M数量）。但是，在多个物种中的实验结果显示当每个样本的测序读长数量为1M时，那么这个数量级的测序读长提供的转录本丰度信息与转录组中表达最高表达量的一半的转录本30M测序提供的丰度信息类似。如果实验的重点是关注那些最高表达相对较大变化的基因，并且如果有足够的生物学重复，那么就可以使用较低深度的测序就能解决驱动实验的假设。测序完成后，通过检查读长在样本之间的分布以及检查饱和曲线就能评估进一步的测序能够增加实验的灵敏度。随着测序通量的增加，为了控制技术偏倚，可以将一个实验的所有样本都添加一个“混合”文库中进行测序，这已经成了标准做法。一次测序所需要读长总数则是样本数乘以读取深度；然后根据生成所需的读长总数来对这个混合文库进行多次测序。这种合并需要严格检测每个样本RNA-seq文库的浓度，并假设每个文库中的cDNA量相对均值（低方差），因此总的读长数目就会平均地分布在每个样本上。在进行一次昂贵的，多泳道(lane)测序之前，运行单个泳道以验证样本之间的低方差通常是值得的。</p>
<h3 id="选择参数测序长度单端测序或双端测序">选择参数：测序长度，单端测序或双端测序</h3>
<p>最终的测序参数包括测序长度，单端测序还是双端测序。在许多测序应用中，测序读长的长度对于数据的利用有着重要的影响，因此更长的读长可以使测序的DNA覆盖率更高。当使用RNA-seq来进行DGE分析时这种方法并不适用，其中重要的原因则是，确定每个读长来源于转录组的哪个位置的能力有限。一旦一个读长能够明确其回贴位置，那么较长的读长在基于量化的分析中就不会再提供太多的价值。对于那些更定性的RNA-seq分析来说，例如特定异构体的鉴定，更长的读长可能更有用。</p>
<p>单端测序与双端测面临的问题是类似的。在单端测序中，每个cDNA片段只有一个末端(3ʹ端或5ʹ端)用于产生测序读长，但双端测序则是一个片段产生2条读长（一个是3ʹ端，一个是5ʹ端）。在那些需要尽可能高的核苷酸覆盖率的分析实验中，长读长双端测序可能更好。然后，DGE分析不需要对转录本片段的每个碱基都进行测序，在DGE分析中，研究者只需要比对后，统计出那些回贴到转录本上的读长数目即可。例如，通过比较测序读长发现，“短”的50bp单端测序与“长”的100bp双端测序所产生的DGE结果没有区别。这是因为单端测序足以鉴定出大多数测序片段来源的基因。同样的研究表明，使用短的单端测序降低了检测出异构体的能力，因为跨越剪接连接的读长较少。双端测序还有助于消除读长回贴的歧义，并对可变外显子量化(alternative-exon quantification)，融合转录本检测和从头开始(de novo)的转录本发现，尤其是处理那些没有很好注释的转录本来说，双端测序更是首选。</p>
<p>在实际应用中，单端测序或双端测序之间的选择通常基于成本或研究者们可用的测序技术。在Illumina NovaSeq发布之前，在多数情况下，每M读长的单端测序的成本要低于双端测序，因此，在相同实验成本的前提下，单端测序能够实现更高的复制或读长深度。</p>
<p>在Illumina NovaSeq发布之前，在大多数情况下，单端测序的每百万次读取的成本低于成对末端测序，因此允许以相同的实验成本进行更高的复制或读取深度。当选择了更多的短单端测序读长和产生更长的双端测序读长后，那么增加读取深度将对提高DGE实验的灵敏度产生更大的影响。</p>
<h2 id="rna-seq数据分析">RNA-seq数据分析</h2>
<p>用于分析测序读长以确定差异表达的计算方法的数量在过去10年里大量增加，并且即使对于最简单的DGE分析来说，在分析实践中，每个步骤也存在着大量的差异。然而，每个步骤都可以使用不同方法，这些方法的不同组合会对从数据中得到的生物学结论产生重要的影响。 这些工具的最佳组织取决于正在研究的特定生物学问题，以及可用的计算机资源。虽然有着尽可能多的排列组合，但是我们的重点在于研究，每个世界大在样本之间的差异表达的可能性的工具和技术。针对这个目标，我们可以将分析过程划分为4个阶段（FIG 2；TABLE 2）。</p>
<p>第1阶段是将一个测序平台产生的原始测序读长导入工具，并将这些读长回贴到转录组上。</p>
<p>第2阶段，是对每个基因或转录本相关的读长数目进行定量（表达矩阵）。这一过程涉及一个或多个不同的比对(alignment)，组装(assembly)与定量(quantification)亚过程，或者是可以在单个步骤中从读长计数中，整体地生成表达矩阵。</p>
<p>第3阶段是通过过滤低表达特征来改变表达矩阵，这一步的关键步骤是对原始读长计数进行归一化，用于解释样本之间的技术差异。</p>
<p>第4阶段是样本组之间的统计建模与协变量(covariates)，以及计算与差异表达相关的置信统计量。</p>
<h3 id="figure2-差异基因表达的rna-seq数据分析流程">Figure2-差异基因表达的RNA-seq数据分析流程</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805190015.png">

</div>
<p><strong>Figure 2-差异基因表达的RNA-seq数据分析流程。差异基因表达(DGE)分析的第一步是原始RNA测序读长的FASTQ格式的数据，DGE的分析有多种方式。主流的分析流程有三种（用实线划的三个方框，分别用A，B和C表示），并且图上还列出了许多替代工具（用虚线表示）。</strong></p>
<p><strong>在A分析流程中，比对工具例如TopHat，STAR或HISAT2使用一个参考基因组来将读长回贴到基因组的位置上，然后使用一些定量工具，例如HTSeq和featureCounts，来将读长比对于基因的特征上。在归一化后（通常归一化的方式都内嵌到了一些分析工具，例如TMM），基因表达就通过一些计建模工具，例如edgeR，DESeq2和limma+voom进行计算，计算结果是一些差异表达基因或转录本的列表，这数据用于下一步的可视化和生物学解释。</strong></p>
<p><strong>在B分析流程中，使用一些较新的免比对工具，例如Kallisto与Salmon，这些工具会在一步操作中组装转录组并对相应的转录本进行定量。这些工具的输出结果通常是转录本定量的一些估计值（例如tximport，TXI），然后通过与A分析流程中相同的归一化和统计建模，产生出差异基因或转录本列表。</strong></p>
<p><strong>在C分析流程中，第一步是比对读长（这一步的工具通常是TopHat，虽然有些分析方法也会用STAR与HISAT），接头使用CuffLinks来处理原始读长，再然后是使用CuffDiff2包来输出转录本丰度的估计值，以及一个差异表达基因或转录本的列表。</strong></p>
<p><strong>其它常用的工具还包括StringTie，这个工具使用TopHat（或类似工具）的输出结果来组装一个转录本模型，然后将结果输出到RSEM或MMSEQ中，用于估计转录本的丰度值，最后将转录本的丰度值输出给Ballgown来计算差异表达基因或转录本。而SOAPdenovo-trans这个工具则能同时对读长进行比和组装，其结果用于输入给RSEM或MMSEQ。</strong></p>
<p>### TABLE2-RNA-seq数据分析工具</p>
<table>
<colgroup>
<col width="8%">
<col width="24%">
<col width="31%">
<col width="4%">
<col width="31%">
</colgroup>
<thead>
<tr class="header">
<th>工具名称</th>
<th>组装</th>
<th>定量</th>
<th>均一化</th>
<th>差异表达</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TopHat</td>
<td>参考基因组+注释 Reference genome+ annotation</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>STAR</td>
<td>参考基因组+注释 Reference genome+ annotation</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>HISAT</td>
<td>参考基因组+注释 Reference genome+ annotation</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>SOAPdevovo-Trans</td>
<td>De novo assembly</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>StringTie</td>
<td>De novo assembly</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>Kallisto</td>
<td>Alignment-free assembly</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>Salmon</td>
<td>Alignment-free assembly</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>Cufflinks</td>
<td>Transcript assembly</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>RSEM</td>
<td>NA</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>MMSeq</td>
<td>NA</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>HTseq</td>
<td>NA</td>
<td>Read counts from non- overlapping annotated features</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>FeatureCounts</td>
<td>NA</td>
<td>Read counts from non- overlapping annotated features</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>Tximport</td>
<td>NA</td>
<td>Transcript estimates converted to read counts</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>edgeR</td>
<td>NA</td>
<td>NA</td>
<td>TMM</td>
<td>Negative binomial distribution + GLM</td>
</tr>
<tr class="odd">
<td>limma+voom</td>
<td>NA</td>
<td>NA</td>
<td>TMM</td>
<td>Mean–variance transform + GLM</td>
</tr>
<tr class="even">
<td>DESeq2</td>
<td>NA</td>
<td>NA</td>
<td></td>
<td>Negative binomial distribution + GLM</td>
</tr>
<tr class="odd">
<td>Ballgown</td>
<td>NA</td>
<td>NA</td>
<td>Various</td>
<td>Input from StringTie, RSEM or alignment- free quantification, + GLM</td>
</tr>
<tr class="even">
<td>CuffDiff</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>DE from Cufflinks estimates</td>
</tr>
</tbody>
</table>
<h3 id="第1阶段-测序读长的比对alignment与组装assembly">第1阶段-测序读长的比对(alignment)与组装(assembly)</h3>
<p>测序完成后，分析的起点就是数据文件，这个数据文件包含了测序计数的碱基，这些数据文件通常是以FASTQ文件的格式存在。处理这些FASTQ文件最常见的第一步操作就是将测序读长回贴到已知的转录组上（或已经注释的基因组上），将每个测序读长转换为一个或多个基因组坐标。这一过程可以使用多个不同的比对工具，例如TopHat，STAR或HISAT，它们都依赖于一个参考基因组。由于测序的cDNA都源于RNA，而RNA有可能跨外显子边界，因此当与参考基因组（含有内含子与外显子）进行比对时，这些工具进行一个剪接比对后，测序读长之间会出现一些间隙。</p>
<p>如果测序的物种没有一个可用的高质量基因组注释（含有已经知的外显子边界），或者说如果希望将测序读长与转录本（而不是基因）关联起来，那么可以使用比对的读长进行转录组的组装。一些组装工具，例如StringTie，SOAPdenovo-Trans使用利用那些已经比对好的结果中的空隙来推测其外显子边界，以及可能的剪接位点。当参考基因组注释没有或者是不完整时，或者是你感兴趣的组织（例如在肿瘤组织）中转录本异常的情况下，这些从头组装转录本的工具尤其好用。当使用的是双端测序和/或更长的测序技术时，这种转录组组装方法效果更好，因为这些测序技术有更大的可能性跨越了剪接位点。但是，从RNA-seq数据中进行转录本的完整组装对于计算DGE来说，并不是一个必需的步骤。</p>
<p>最近，已经开发出了计算高效的“免比对”(alignment-free)工具，例如Sailfish，Kallisto与Salmon，这些工具可以直接将测序读长与转录本进行关联，从而无需单独的定量步骤（参考后面的第2阶段部分）。这些工具在那些表征更高丰度（以及更长的）转录本方面表现得非常良好；然后它们在那些定量低丰度或短转录本方面表现不佳。</p>
<p>用于将测序读长回贴到转录本的不同的工具在它们如何对测序的子集进行分配方面有着显著的差异，这会影响最终的表达估计值。当有来自一个不同基因，伪基因或转录本的多个读长时，这种效果尤为明显。一项比对12个基因表达估计方法的比较显示，一些比对方法低估了许多与临床相关的基因的表达，这主要是由于其并不精确的回贴读长所导致的。在RNA-seq数据的计算分析中，如何将多个回贴的读长合理进行分析仍然是一个值得研究的方向。通常的做法是将这些读长排除在下一步的分析之外，但这可能会使结果产生偏（参考阶段2-转录本丰度的量化）。其它的估计包括生成“合并“表达特征，这些特征包含了那些共同回贴后的读长的重叠区域，以及要在随后的置信度计算中，对每个估计的基因的回贴的不确定性进行估计。</p>
<p>### 第2阶段-转录本丰度的量化</p>
<p>一旦读长被回贴到基因组的位置或转录组的位置，接下来的步骤就是将这些读长分配到基因或转录本上，以确定它们的丰度。不同的比较研究表明，在量化步骤中采用的不同的方法对最终的结果影响最大，这种影响甚至超过了第1步中比对工具的选择。对每个基因(即该基因所有转录本的亚型)测序读长丰度的量化依赖于转录组注释来对那些重叠到已知基因上的测序读长进行量化。但是，使用短读长对测序读长进行特定异构体分配来说还需要一个估计步骤，因为许多读长并不能跨越剪接位点，因此它们无法精确地分配给特定的异构体。当一个基因的主要表达形式是在不同长度的转录本之间进行转换时，那么即使在仅研究基因层面的差异表达分析的前提下，对这些转录本进行定量则会产生一个更加精确的结果。例如，在一个样本中，一个主要的转录本也许只有另外一个样本中同样转录本的一半长度，但是前者的表达量是后者的2倍，那么单纯地基因基因定量的工具无法区分这个转录本的差异表达。</p>
<p>常用的量化工具包括RSEM，CuffLinks，MMSeq与HTSeq以及前面提到的那些免比对工具。一些基于读长计算的工具，例如HTSeq（或者是R equivalent，featureCounts）通常会丢弃许多比对好的读长，包括那些回贴到多个位置的读长，或者是重叠多个表达特征的读长。其结果就是，在随后的分析中清除了那些同源和重叠的转录本。RSEM会使用期望最大化的方法来分配那些比对不明的读长，Kallisto这个无参比对工具会将比对不明的读长包括在它们相应的转录本计数中，从而导致结果偏倚。使用tximport包可以将转录本丰度估计转化为读长计数值(read count equivalents)。量化步骤中产生的结果通常会合并为一个表达矩阵，在这个矩阵中，每一行是表达特征（基因或转录本），每一列是样本名，表达矩阵中的值要和是实际的读长值，要么是一种估计丰度。</p>
<p>### 第3阶段-过滤和归一化</p>
<p>通常来说，定量后的基因或转录本计数结果还需要过滤和归一化，从而用于解释读长深度，表达模式以及技术偏倚。过滤用于去除那些不均一的低读长丰度特征的值，从而提高对那些真正差异表达值的检测能力。而对表达矩阵进行归一化则更加复杂。直接转换可以调整丰度值，以便能更加说明GC含量的差异以及读长深度。早期用于归一化的方法就是RPKM，但这种方法现在已经淘汰，它已经被那些能够校正样本之间更细微差异的方法所取代，例如四分位数法或中位数归一法。</p>
<p>广泛的研究表明，归一化方法的选择会对最终的结果以及生物学结论产生重要的影响。大多数进行归一化的算法依赖于两个重要的假设：第一，大多数基因的表达水平在重复的样本组之间保持不变；第二，不同的样本组在总体的mRNA水平上不表现出显著差异。当这些基础假设不成立时，那么就需要慎重考虑是否进行归一化，以及如何进行归一化。例如，如果一些基因在一个样本中高表达，同时相同的基因，以及另外的一些基因在同一组中的另外一个样本里正常表达，如果对读长深度进行简单的归一化则明显不够，因为相同数目的测序读长会分配到第二个样本里更多的基因上面。归一化过程，例如截断均值化M值(The Trimmed Mean of M-values,TMM)方法（它已经整合到的edgeR包中）就能解决这个问题。选择一个合适的归一化方法或许很困难；一种做法就是深度使用多种方法进行分析，然后比较它们结果的一致性。如果结果对于归一化方法高度敏度，则应该对数据进行进一步的探索，以确定差异来源。但是，比较不同的归一化方法时，要谨慎确保这种归一化方法的比较不是为了选择与原始假设最兼容的归一化方法。</p>
<p>处理这些问题的一种方法的spike-in control RNAs，这种方法会引入一些外源已知的RNA序列，这些外源已知的RNA序列已知，浓度已知，在建库的过程中，将它们添加到样本中。RNA-seq中的Spike-ins方法包括外部RNA控制协会混合物(External RNA Controls Consortium mix, ERCCs)，spike-in RNA突变物(spike-in RNA variants, SIRVs)与测序spike-ins(sequencing spike-ins, Sequins)。由于预先知道spike-in的浓度，这些浓度直接与生成的读长数相关，因为就可以对这些来自样本转录的表达水平进行校正。也有人指出，如果不进行spike-in控制时，那么就不能对那些有强烈倍数变化基因的实验进行分析。然后在实践中，很难在预设水平上一致地整合spike-ins，并且它们在基因水平上对测序读长数目进行归一化比转录本更加可靠，因为在一个样本中，每个异构体的表达水平不同。目前，spike-in控制法并没有在发表RNA-seq DGE实验中得到广泛使用，如果这种方法被进一步改进，提高其一致性的话，则这种方法会得到广泛使用，但现在很多研究者们在他们的单细胞实验（这种实验里会更加广泛地使用spike-in）使用了这种方法。</p>
<h3 id="第4阶段-差异表达的统计建模">第4阶段-差异表达的统计建模</h3>
<p>一旦测序读长被处理为表达矩阵，那么就可以对实验进行统计建模，从而确定哪些转录本发生了改变。一些工具可以达到这些目的；其中一些工具会对基因水平的读长数目进行统计建模，而一些则依赖于转录本水平的估计。基因水平的工具通常依赖于比对好的读长数目，使用广义线性模型(Generalized Linear Models)处理这些数据，从而能够评估复杂的实验设计。这些工具包括edgeR，DESeq2以及limma+voom，这些工具能够进行有效地计算，并提供比较结果。对差异异构体表达进行统计建模的工具包括CuffDiff，MMSEQ与Ballgown，这些工具通常需要更多的算力(computational power)，并且不同工具的结果中的信息量更大。但是，在进行选择差异表达工具之前做的那些工作，例如比对，定量或过滤以及归一化这些操作对最终结果的总体方差会产生更大的影响。</p>
<h2 id="常规rna-seq进阶">常规RNA-seq进阶</h2>
<p>源于整块组织和/或大量细胞的RNA-seq数据已经彻底改变了我们对生物学的理解，但是这种常规的RNA-seq无法轻易地分辨出特定的细胞类型，也无法保存空间信息，而这两个信息都是理解生物系统复杂性的关键因素。促进研究者们从常规的RNA-seq走出去的情形与常规RNA-seq当初出现的理由类似，但这种进阶能够能够解决很多不同的问题。单细胞测序让人们发现了，即使在被认为研究透彻的疾病背后，还存在着一些未知细胞类型，例如发现了离子细胞(ionocyte cell)，这类细胞可能与囊性纤维化疾病有关。空间分辨RNA-seq则提示了在实体组织中细胞与细胞之间的相互作用，例如发现了成年心脏组织中一小群胎儿标记基因表达的细胞。虽然在可预见的未来，常规RNA-seq仍然是一个占据主导地位的工具。但是，单细胞测序与分析方法正在快速地被研究者利用，并且随着空间RNA-seq方法的成熟，它们有可能成为常规RNA-seq分析中的一部分。这两种方法都将提高我们对多细胞生物体复杂性的理解，它们都有可能与常规RNA-seq方法结合使用。在这里我们简单描述一下主要的单细胞测序以及空间RNA-seq方法，以及它们与常规RNA-seq的不同之处，以及新的研究者们如何着手。</p>
<p>###单细胞分析</p>
<p>scRNA-seq于2009年首次报道，当时的研究者在含有裂解缓冲液的EP管中分离了单个卵母细胞。单细胞测序对生物学新问题的解释，以及现有的实验室和计算方法以极快的速度发展，甚至最近几年综述都已经过时了。每种scRNA-seq方法都需要将实体组织进行分离，分离出单个细胞（使用不同的方法），以及标记上每个细胞的RNA，对RAN扩增后进行测序，所有的这些方法都来源于早期常规RNA-seq的方法。</p>
<p>机械裂解和胶原酶加DNAase的酶解会生成单细胞悬液，从而产生大量可用的细胞，但是这种产生是高度组织特异性的，比较依赖于经验，其过程也需要非常小心。一旦制备好了单细胞悬液，就可以通过各种方法分离单细胞（FIG 3a）；大多数的实验都是使用流式细胞仪来进行单细胞分选，这种方法是最容易，它可以将单个细胞直接分选到含有裂解液的微孔板中。对于更高通量的实验，现存有大量分离单细胞的专门仪器，这些仪器需要自己构建或购买。单个细胞可以通过物理手段被捕获到微流控芯片中，或者是通过Poisson分布的原理被分配到加载到含有纳米孔(nanowell)的芯片中，随后这些单细胞被分离后就被液滴微流分离技术合并到含有试剂的液滴中（例如Drop-Seq与InDrop），或者是单细胞被原位标记上标签（例如单细胞混合索引RNA测序技术, single-cell combinatorial indexing RNA sequencing, sci-RNA-seq以及分离-混合-连接转录组测序技术，split- pool ligation- based transcriptome sequencing,SPLiT-seq）。单细胞分离后，它们就被裂解，将RNA释放到溶解中用于cDNA合成，并将cDNA用于RNA-seq文库制备。在文库制备过程中，来源于每个细胞的RNA会通过PCR进行扩增。这种扩增就引入了PCR偏倚，但是UMIs可以用于校正这种偏倚。由于Poisson采样，一个细胞中只有10-20%的转录本会被逆转录，这就限制了转录本检测的灵敏度，以及各种方法产生的可用数据。在湿实验之外，计算方法也在迅速发展，最近已经出现了关于scRNA-seq的实验设计指南。方法学的快速发展意味着scRNA-seq方法的技术已经快速过时了。然而Ziegenhain等人提供了scRNA-seq方法的详细概述，他着重强调了UMIs的在数据分析方面 的重要性，并报道了提到了的6种方法中哪一种最为灵敏。然而他们的研究范围并不包括现在被广泛使用的10X Geneomics方法。</p>
<h3 id="figure3-单细胞rna-seq与空间rna-seq的概念">Figure3-单细胞RNA-seq与空间RNA-seq的概念</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805190056.png">

</div>
<p><strong>Figure 3-单细胞RNA-seq与空间RNA-seq的概念。(a)单细胞RNA-seq(scRNA-seq)工作流程概述。scRNA-seq的第一步就是从样本中分离单个细胞（例如从解离的皮肤组织），分离单细胞的方式有多种，其中包括微移液管将细胞转移到单独的微管中，或者是使用流式细胞仪将单细胞分选到含有裂解液的96孔板或384孔板中，或者是将细胞捕获到微流控芯片中，或者是将细胞分布到纳米孔(nanowells)中，或者是使用含有试剂的液滴分离系统，或者是使用原位条形码技术。细胞进行逆转录以产生cDNA（通常使用UMIs来对这些cDNA进行标记），用于制备RNA-seq文库和测序。质控(QC)，差异基因表达(DGE)与2D可视化(t-distributed stochastic neighbour embedding, tSNE)以及无监督聚类在和网络分析来对scRNA-seq的数据进行分析，用于区分不同的细胞种群。这些技术通常会标明细胞数据，以及与RNA-seq的策略一样，还会标明测序技术是3’末端还是5’末端还是全长cDNA。(b)空间转录组学工作流程概述。空间编码需要将冷冻组织切片加到含有寡聚核苷酸微阵列的载玻片上，或者是加载到密集包装的被寡核苷酸包被的pucks上。mRNA扩散到载玻片表面，然后与oligo-dT合成引物杂交，这些引物中含有UMIs与空间编码序列。随后mRNA逆转录成cDNA，cDNA汇集起来用于文库制备和测序。空间转录本组学的计算方法以能够将测序读长回贴到它们的空间坐标上，随后是DGE分析与差异空间表达分析的可视化。scRNA-seq与空间RNA-seq数据通常是用短读长测序仪进行测序的。上述图片(a)源于Springer Nature Limited。</strong></p>
<p>当研究者们在选择scRNA-seq方法，需要考虑的主要因素包括：他们是否需要全长转录本的读长，在分析更多细胞表达谱（宽度, breadth）或每个细胞更多转录本（深度，depth）之间进行权衡，以及总体实验成本。全长scRNA-seq系统的通量比较低，因此每个细胞需要单独地处理，直到最终生成scRNA-seq文库。但是，此系统可以让研究者们研究可变剪接与等位基因特异性表达。非全长系统则会从转录本的3’或5’末端生成序列，但这就限制了异构体表达的分析，但是当细胞cDNA合成被混合后，细胞所加工的数量会比前一种高出2到3个数量级。单细胞测序宽度与细胞，组织或样本的数量有关，而深度则是与测序读长数目固定下，要分析的转录组有关。虽然实验中测序的细胞数量是由选择的方法决定的，但是这也允许一些灵活性，不过随着分析的细胞数目的增多，测序成本的增加，往往限制了转录组分析的深度。因此，可以使用宽度和深度两个维度来评估不同的scRNA-seq系统。单细胞测序典型的做法是基于孔板或微流控方法来捕获尽量少的细胞，但同时对每个细胞检测出更多的基因，而基于液滴的系统可以用于分析最大数目的细胞，它已经能从超过一百万个细胞中产生单独的数据集。</p>
<p>scRNA-seq的力量正在推动着大规模的细胞图谱项目，这些项目指在确定生物体或组织中完整的细胞类型。 人类细胞地图集(Human Cell Atlas)与NIH大脑计划(NIH Brain Initiative)项目分别是为了对人体以及大脑中的所有细胞类型进行测序。人类细胞地图集的第1阶段目标是对3000万到1亿个细胞进行测序，并将随着技术的发展在广度和深度上进行增加。这个项目的最新成本包括发现了离子细胞，以及发现肾癌是在儿童和成年人中是由不同的细胞类型发展而来的。不过，scRNA-seq的研究者们应该意识到，这些技术可以用于几乎所有的生物。最近，对A. thaliana根细胞原生质的分析表明，即使是植物的坚韧细胞壁这种障碍也能被解决，能产生用于测序的单细胞。scRNA-seq正在迅速成为生物学家们工具包的标准配置，并有可能在10年后被广泛使用，就像今天的常规RNA-seq一样。</p>
<h3 id="空间分辨rna-seq法">空间分辨RNA-seq法</h3>
<p>当前的常规RNA-seq和scRNA-seq方法为研究者们提供了关于组织或细胞群体的高度详细的数据，但是没有捕获空间信息，就是会降低细胞环境与基因表达之间关系的分析能力。空间转录组学(spatialomics)的两种方法是空间编码(spatial encoding)与原位转录组学(in situ transcriptomics)。在RNA-seq文库制备过重中，空间编码方法能够记录其空间信息，或者是通过分离空间受限的细胞（例如，通过激光捕获显微解剖， laser-capture micro-dissection, LCM）， 或者是通过分离前的位置对RNA加上条形码（通过从组织切片中直接捕获mRNA）(FIG. 3b)。原位转录组学能够在组织切片中，通过对细胞中的RNA进行测序或成像来生成数据。我们建议感兴趣的读者是阅读最近的深度评论，从而对这一领域进行更全面的理解。</p>
<p>LCM已经成功地用于从组织切片中的特定区域分离和分析单个细胞用于RNA-seq。虽然LCM需要专门的设备，但是许多机构已经广泛使用了这种技术。但是，虽然这种技术可能实现高度空间分辨率，但是它消耗人力，并且难以批量使用。使用空间转录学 (Spatial Transcriptomics，10X Genomics)与Slide-seq方法可以直接从冰冻组织切片中直接捕获mRNAs，然后将这些mRNAs直接加载到寡核苷酸微阵列玻片(oligo- arrayed microarray slides)或严密包装寡核苷酸的pucks上。寡核苷酸包括空间条形码、UMI和oligo-dT引物，它们能唯一地识别每个转录本及其位置。测序读长被回贴到玻片的坐标上，用于生成空间基因表达信息。空间转录学方法已经被证明能够在一系列物种的组织中能发挥作用，其中就包括小鼠大脑和人类乳腺癌组织，人类心脏组织和拟南芥(A. thaliana)花序组织。Slide- seq是最近开发的一种技术，它已经被证明能够对小鼠大脑的冰冻切片进行测序。这些直接 mRNA捕获方法并不需要特殊的设备，且有相对简单的分析方法，并有可能大规模地应用于许多组织。然而，还有两个局限需要解决。首先，该技术只能应用于新鲜的冷冻组织。其次，分辨率受到到阵列大小和捕获寡核苷酸点和珠子的间距的限制；目前的分析只能使用6.5x7 mm和3x3mm这两种规格，这就限制了组织切片的尺寸。空间转录组学斑点的直径为100µm，间距为100µm，这意味着它们不够小或不够密集，无法实现单细胞级分辨率。Slide- seq珠子则要小的多，直径只有10µm，而且非常密集，比相对前者具有十倍的空间分辨率，并且测序中的大约一半的珠子似乎是从单个细胞层面产生的数据。从分解的组织和空间编码的数据与scRNA-seq混合起来的计算方法可以改善分辨率，但是需要基础技术的进一步发展，以使其成为更常规的RNA-seq工具。</p>
<p>上述空间分辨RNA-seq方法的替代方案包括原位测序和使用单分子荧光原位杂交的基于成像的方法。这些方法能够产生比RNA-seq方法更窄的转录组信息，但它们能直接检测RNA，并且能够对低丰度的转录本进行分析。同时，它们还能提供组组织结构和微环境的信息，并能产生亚细胞数据。这种方法目前正取得了巨大进步，但是成像方法的一个主要局限就是需要高分辨率或超分辨率显微镜与自动流体技术结合，并且这种技术的成像时间可能要花上数小时，甚至是几天。测序成本的下降比摩尔定律预测的速度更快，与测序成本相比，高通量成规模的成像系统的机会似乎更有限。</p>
<p>上述提到的空间转录组学都受到无法产生深度转录组学数据的限制，以及受到细胞分辨率和/或高成本（时间和/或资金）的限制，但是这些方法正在迅速改进，并且已经应用于临床样本。空间转录组学的具体计算方法开始出现。此外，原位RNA测序和成像方法的进步已经使得10E3到10E5个细胞生成的转录组数据成为可能，这与基于液滴的单细胞方法获得的数据量相近。未来的发展有可能使得空间转录组学让更普通的研究者们使用。然而，大多数的研究们者并不太可能需要真正的单细胞或亚细胞级分辨率。因此，转录组表达谱的宽度和对广泛的组织或样本的应用性可能会推动这些技术在特定小众领域被采用。如果空间转录组学的这些技术限制能够被解决，那么它才有可能被广泛使用。</p>
<h3 id="动态rna-seq分析beyond-steady-state-rna-analysis">动态RNA-seq分析(Beyond steady-state RNA analysis)</h3>
<p>DGE分析是使用RNA-seq来检测稳态下的mRNA表达水平，这一表达水平是通过mRNA的转录，加工和降解速度来决定的。但是，RNA-seq也可以用于研究涉及转录，翻译所涉及的过程与动力学特征，这些研究为基因表达提供了新的思路。</p>
<h3 id="使用新生rnanascent-rna方法来研究活性转录">使用新生RNA(nascent RNA)方法来研究活性转录</h3>
<p>基因表达是一个内在的动态过程，但是在检测复杂转录应答的细微以及快速变化或确定不稳定的非编码RNAs，例如增强子RNAs方面，常规的DGE分析方法就比较受限。RNA-seq可以用于绘制TSSs以及定量新合成的新生RNA，这就可以用来研究RNA动力学。但是，与DGE分析相比，nascent RNA的分析则比较难，因为它们半衰期短，丰度低。因此，为了研究这些动态的重要性，研究者们就开发了多种方法来分析nascent RNA；这些方法揭示了在启动子处的差异转录程度，表明RNA聚合酶II(Pol II)在启动子附近的暂停是基因表达的关键调节步骤，证明了nascent RNA有直接调节转录的作用，并表明其序列和结构影响转录的延伸，暂停和停顿，以及发挥染色体修饰结合和增强了子的作用。nascent RNA- seq方法旨在区分新近转录的RNA和其它RNAs，这些方法可以分为3类：run-on方法，Pol II免疫沉淀法，代谢标记法(FIG. 4)。</p>
<h3 id="figure4-nascent-rna与翻译组分析的关键概念">Figure4-nascent RNA与翻译组分析的关键概念</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805185641.png">

</div>
<p><strong>Figure 4- nascent RNA与翻译组分析的关键概念。nascent RNA分析方法是将那些在一个细胞中新转录的RNAs从其它的RNAs中富集出来，并将它们与未富集的RNA（成熟的RNA）进行比较，富集nascent RNAs的方法主要有三种。(a)Run-on方法是利用一个限时脉冲的方法将修饰过的核糖核酸添加到细胞培养基中，对细胞的RNA进行标记；这一过程可以用使用各种修饰的核苷酸，但是，图中的GRO-seq使用的是Bru修饰的核苷酸。当修饰过的核苷酸整合到RNA后，利用抗BrU的抗体，通过IP的手段将nascent-RNA链富集起来，并用于文库制备以及测序分析。(b)RNA聚合酶II(Pol II)的IP方法则是利用了微球菌核酸酶(micrococcal nuclease)消化了染色质后，使用相应的抗体拉下了与Pol II结合的RNA。在染色质消化过程中，nascent RNA通过其Pol II足迹保护而不受核酸酶活性的影响，并不会被降解。(c)代谢标记方法标记RNA的方法类似于Run-on方法，但前者使用的是核苷酸类似物4 sU。提取RNA后，烷基化4 sU，在逆转录过重中，就会产生G核苷酸的错配，从而通过在碱基对级分辨率的突变分析中直接确定4 sU的整合位点。制备3’末端RNA文库会通过降低未标记的RNA数量来增加测序过程中的信号强度。图片参考文献为214。</strong></p>
<p>Run-on法是将核酸类似物添加到样品中，从而使nascent RNA能够从总的RNA混合物中进行富集，并能够检测瞬时RNA的转录(FIG. 4a)。全局run-on测序(Global run-on sequencing, GRO-seq)与精确核酸run-on测序(Precision nuclear run-on sequencing, PRO-seq)是分别将Bru或生物素修饰的核酸在RNA的转录期整合到nascent RNA中来实现的。其过程大致为，分离细胞核，并通过洗涤除去内源性核苷酸，再添加外源生物素标记的核苷酸，随后恢复转录。通过免疫沉淀或亲和纯化的方法，对富集的新转录RNA进行测序，从而检测参与转录的RNA聚合酶的位置和活性。由于run-on过程中标记的核苷酸的数据，GRO-seq只能测到10-50bp的长度，这就降低的TSS检测的精度。PRO-seq能够实现单个碱基级的分辨率，因为生物素标记的核苷酸掺入后转录就停止，可以识别出转录位点。Run-on方法理解起来很简单，就是RNA分子整合了修饰的核苷酸，并对其进行富集，用于测序，但是在实践中，背景中存在有non-nascent RNA，这就需要增加读长深度。利用这些方法，提示了启动子处，启动子处差异或双向转录本起始的程度，确定了增强子RNA在调节基因表达方面的作用。通过特定富集5’加帽的RNAs，GRO-cap，PRO-cap或small 5’capped RNA测序(small 5ʹ-capped RNA sequencing, START-seq)增加了检测转录起始和捕获RNAs的灵敏度和特异性，这种处理还会降低源于转录后加帽的RNAs的背景信号。</p>
<p>Pol II的免疫共沉淀方法包括，天然延长转录测序(native elongating transcription sequencing, NET-seq)和哺乳动物染色质天然转录测序法(native elongating transcript sequencing for mammalian chromatin, mNET-seq)，使用抗FLAG（用FLAG标记的Pol II）抗体进行沉淀的方法，或各种针对Pol II C末端结构域(CTD)的沉淀方法(FIG. 4b)。与这些染色质复合物结合的nascent RNA的RNA-seq方法用于检测TSSs，虽然non-nascent Pol II结合的RNA与背景mRNA会对读长浓度产生负面影响，影响分析。NET-seq缺乏特异性，因为任何与Pol II强烈结合的RNA都会污染nascent RNA的富集效果，例如在NET-seq数据中就存在有tRNA和small nucleolar RNA。在mNRET-seq中使用多个CTD抗体提示了VTD修饰是如何影响转录的，检测到了RNA加工的中间体，并能能够将特定的Pol II nascent RNAs定位于TSSs。然而，这些检测能力是以更复杂的实验，更多的细胞数量和更高的测序成本为代价的。</p>
<p>使用核苷酸类似物硫代吡啶(4-thiouridine, 4 sU)进行代谢脉冲标记(Metabolic pulse- labelling)的方法可以识别nascent RNA(FIG. 4c)。但是，在那些需要长标记时间的方法中，大多数的转录本都会被标记，这就限制了这种方法的灵敏度。通过专门针对RNAs的3’末端（仅最近拉RNA聚合酶的新转录的RNA）的方法，瞬时转录组测序(transient transcriptome sequence, TT-seq)与硫醇(SH, thiol)连接的烷基化RNA代谢测序(thiol(SH)-linked alkylation for metabolic sequencing of RNA， SLAM-seq)能够降低来源于5’RNA的信号。TT-seq将标记时间限制在5分钟，因此只标记新转录本的3’末端，它在进行生物素亲和纯化前，有一个RNA片段化操作，用于富集标记的RNA。SLAM-seq整合了3’mRNA-seq文库制备方法（虽然它也用于其它的文库制备，例如miRNA）， 它仅针对标记的新转录的RNA进行测序，而非整个转录本进行测序。此外，在SLAM-seq中，提取RNA后，还要加入碘乙酰胺(iodoacetamide)，用于烷基化已经插入到新生成的nascent RNA链中的4 sU残基。这种修饰会诱导反转录式依赖的胞腺嘧啶到胞嘧啶的转换(T &gt; C)，这在测序分析中会被检测为“突变”，从而直接识别为4 su整合位点。然而，低掺入率意味着只有少量的4 sU位点可以被转换为胞嘧啶，这就限制了灵敏性。有两种方法，即TUC-seq与TimeLapse-seq也使用T&gt;C这种突变分析方法，但是它们并不富集3’末端。这两种方法用于研究细胞干扰后的转录应答和RNA的半衰期。</p>
<p>Nascent RNA分析方法还未进行过直接比较。Nascent RNA方法都受到非特异性背景和/或降解的RNA的负面影响，这会影响读取深度。通过仅测序3’末端，那么non-nascent RNA的效应就会在PRO-seq，TT-seq和SLAM-seq中降低，但是几乎没有证据表明是否有其他方法更优。亲和纯化方法费时费力，与代谢标记法相比，前者需要更多的起始材料，但是，确定脉冲标记的时间比较复杂，并且短脉冲产生用于分析的RNA很少，这限制了灵敏度。最近开发的，组织特异性RNA标记方法以及亲折突变分析计算方法或许能够促进研究者转向使用生化（基于生物素）富集的手段来研究富含生物学意义的nascent RNA和其它RNA。Nascent RNA方法以及它们与其它方法的隧和，例如空间转录组学或RNA-RNA与RNA-蛋白质相互作用的方法，将会提高我们对转录过程的理解。</p>
<h3 id="使用核糖体分析方法检测活跃的翻译">使用核糖体分析方法检测活跃的翻译</h3>
<p>RNA-seq的主要用途在于研究样本中的mRNA的种类与数量，但是mRNAs的存在与否并不直接关系到蛋白质的合成。现在有两种方法可以研究转录以外的翻译情况，可以让研究者们更好的理解翻译组(translatome)：一种是多核糖体表达谱(polysomal profiling)，一个是核糖体足迹RNA-seq(Ribo-seq)。核糖体对mRNAs的翻译具有高度的调节作用，蛋白质水平主要由翻译活性决定。多核糖体表达谱与Ribo-seq可以让研究者探索一个转录本占用多少个核糖体以及核糖体在转录本上的分布(FIG. 5)。这种方法可以让研究者推断在特定时间或细胞状态下哪些转录本正在被活跃地翻译。这两种方法都假设mRNA 核糖体的密度与蛋白质合成的水平相关。在不同样本之间进行比较，就能提示治疗条件下，时间推移以及疾病发展过程中，核糖体的动力学特征，上述的这些情况都与翻译的异常调控有关，例如纤维化，朊病毒或癌症。</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805185740.png">

</div>
<p><strong>Figure 5-翻译组的关键概念。翻译组方法是从那些与核糖体结合的RNA中生成RNA-seq数据，这种方法假设mRNA上的核糖体的密度与蛋白质的合成水平相关。(a)多核糖体表达谱的方法是通过离心将RNA分子分成多核糖组分，然后通过RNA-seq的方法进行比较。在多核糖体组分中表达较高的RNA被认为是更活跃的转录。(b)核糖体足迹(Ribo-seq)法使用RNase来降解暴露的RNA，同时保留那些被核糖体保护的未被降解的RNA。通过对这些保护的RNA进行测序，就可以揭示出核糖体的密度与位置。通过修改变标准Ribo-seq方法，定量翻译起始测序(QTI-seq)或翻译复杂表达谱测序(TCP-seq)可以专门富集起始核糖体或其亚基，同时剔除延长的核糖体，因此可以对翻译的动态过程进行更详细的分析。对翻译组RNA-seq数据的过计算 分析可能确定每个mRAN的相对翻译程度，可以研究翻译的起始，延长与终止的动力学过程。</strong></p>
<p>在多核糖体表达谱实验中，使用蔗糖梯度超离心将与多个核糖体(多核糖体组分)结合的mRNA和与单个核糖体结合的mRNA（单核糖体组分）分离开来，前者用于RNA seq文库制备(FIG. 5a)。与单核糖体组分中检测到的mRNA相比，在多核糖体组织中检测到的高丰度mRNAs可以被认为翻译得更频繁。这种方法也可以用于推测单个mRNAs的翻译状态，也可以用于生成高分辨率的核糖体占有信息与密度（尽管它无法确定核糖体的位置）。这类方法的原始方法已经进行了几项改进。例如，使用非线性蔗糖梯度改善了多核糖体收集，使多核糖体在不同浓度蔗糖溶液界面的收集过程更为简单，使用Smart-seq文库构建技术可以让研究者们分析仅10ng级的多核糖体mRNA，使用更高分辨率的蔗糖梯度和深度测序可以检测了转录本异构体的特异性翻译。然而，多核糖体表达谱实验生成的翻译组信息分辨率相对低，这一过程还比较费力，需要特殊的仪器，这就限制了其应用范围。</p>
<p>Ribo-seq是基于RNA足迹的方法，它最初用于酵母研究。这种方法用环己胺(cyclohexamide)来抑制翻译延伸，并诱导核糖体在mRNAs上停滞。用RNase I消化mRNA会留下20-30个核苷酸，这20-30个核苷酸就是受核糖体保护的足迹，这些足迹被处理后用于制备RNA-seq文库(FIG. 5b)。Ribo-seq能生成高分辨率的翻译谱，描绘核糖体丰度和单个转录本的位置。而多核糖体分析中无法提供核糖体的位置信息时，这说明有可能检测到了翻译的暂停，这些检查可以调节蛋白质的表达。当方法修改了缓冲液和对酶进行了优化后，就能更清楚地揭示Ribo-seq数据中3-bp的周期性，以及条形码和UMIs（检测单个分子的事件）。标准的RNA-seq工具可以用于Ribo-seq的计算分析，但最近已经出现了特定的工具用于寻找开放阅读框，用于差异或异构体水平的翻译分析，以及用于研究密码子偏倚。Ribo-seq的主要限制就是超速离心，以及由于核酸酶不同批次间的变化，以需要经验来确定RNase I的消化条件。</p>
<p>这些方法检测的是来自翻译起始、延伸和终止的信号的平均强度，但是对Ribo-seq的修改可使得其能够研究翻译动力学。定量翻译起始测序(Quantitative translation initiation sequencing, QTI-seq)通过化学“冷冻”和富集起始核糖体，同时从结合的mRNA中去除延长的核糖体来定位转录起始位点。翻译复杂谱测序(Translation complex profile sequencing, TCP-seq)也通过在组装成熟核糖体之前富集与40S核糖体小亚基结合的RNA来检测起始位点。然而，由于这种方法中保留了核糖体的完整性，也可以分析和比较80S核糖体组分，从而更全面检测翻译动力学(FIG. 5b)。</p>
<p>所有的翻译组方法在概念上都是相似的；它们假设mRNA核糖体的密度与蛋白质的合成水平相关。虽然它们的样本制备方案不同，但都需要大量的起始细胞数。最终，翻译组与RNA-seq结合起来研究基因的表达水平，并与蛋白质组学一道来研究蛋白水平，这可能就需要对mRNA的翻译进行一个广泛地理解。如果想要了解翻译组的更详细信息，可以阅读最近的综述。</p>
<h2 id="rna结构与相互作用分析beyond-analysis-of-gene-expression">RNA结构与相互作用分析(Beyond analysis of gene expression)</h2>
<p>RNAs在调节其它生物分子和生物过程（例如剪接和翻译）中发挥着重要作用，它们涉及RNA与各种蛋白质和/或其它RNA分子的相互作用。RNA-seq可以用于研究分子内和分子间RNA-RNA的相互作用(RNA-RNA interactions, RRIs)，这可能让研究者更好地理解结构组(structurome)，或者是研究RNA与蛋白质之间的相互作用，这样就可以深入理解转录与翻译(FIG. 6)。针对相互作用组(interactome)分析而开发的各种方法都有一个共同的主题：在RNA中富集出那些与其它RNA有相互作用的RNA。一些方法利用的是天然生物学相互作用，而其它的方法则是在目标分子之间计算瞬时作用力或共价键；大多数方法使用的是抗体pull-dwon、亲和纯化或探针杂交的手段来富集RNA进行测序。在这里我们简要描述一下主要的基于RNA-seq的方法来研究结构组和相互作用体的内容。</p>
<h3 id="figure6rna结构和rna-蛋白质相互作用分析的关键概念">Figure6–RNA结构和RNA-蛋白质相互作用分析的关键概念</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805185828.png">

</div>
<p><strong>Figure 6-RNA结构和RNA-蛋白质相互作用分析的关键概念。(a)结构组分析使用核酸酶或化学标记试剂在全转录组范围内来研究结构化RNA（例如双链RNA，dsRNA）或非结构化RNA（单链RNA，ssRNA）。在大多数实验中，在单独的反应中对ssRNA和dsRNA进行检测，其结果联合反应性分析法来确定其结构特征。核酸酶消化方法使用针对dsRNA和/或ssRNA的一个或多个核酸酶来研究RNA的结构。例如，在对RNA结构要的并行分析(PARS)中，在体外使用RNase V1（一种dsRNA特异性核酸酶）或S1核酸酶（一种ssRNA特异性核酸酶）来酶切并行样本。酶解后剩余的RNA被转化为cDNA，然后进行测序，测序的读长深度与比对区域的反应性成正比。RNA-seq数据的覆盖和比较结果就能推断RNA的结构。化学分析法(Chemical-mapping methods)，例如使用引物延伸的选择性2ʹ-羟基酰化分析法(SHAPE-seq)或突变表达谱分析法(SHAPE-Map)，这些方法通过结构依赖形式在体外或体内对双链或单链区域的核糖核苷酸进行修饰。标记物可以阻断逆转录，导致cDNAs的截短，或者是导致修饰位置错误地掺入突变。RNA被转化为cDNA后进行测序，读长深度或突变率与比对区域的反应性成正比，从而推断RNA的结构。(b)RNA-RNA的相互作用分析方法，例如SPLASH，这种方法的第一步是将有相互作用的RNA分子通过生物素化的补骨脂进行交联，然后以通过链霉亲和素对其进行富集，第二步是在邻近位置加入相互作用RNA的自由端加入邻近连接与及片段化。第三步是进行RNA接头的连接以及环化，制备RNA-seq文库用于测序，从而揭示出分子内（也就是结构）的RNA相互作用以及分子间的相互作用位点。(c)RNA-蛋白质相互作用方法，例如RNA交联免疫沉淀后测序(CLIP-seq)，这种方法使用UV辐射在相互作用的RNA和蛋白质之间产生共价交联。目的蛋白被抗体富集后，与此蛋白结合的RNA也就被富集了下来，这些RNA加上3’接头后，提取出来用于cDNA的合成。从结合了接头的RNA生成的cDNA用于文库制备，测序。</strong></p>
<h3 id="通过研究rna分子内的相互作用来研究rna的结构">通过研究RNA分子内的相互作用来研究RNA的结构</h3>
<p>核糖体RNA和tRNA构成细胞的大部分RNA。它们与其他结构非编码RNA一起在细胞中发挥各种作用，例如从基因调节到翻译。现存主要有两种研究RNA结构的方法：基于核酸酶的方法和化学探针方法。核糖核酸酶消化于1965年首次用于研究RAN(tRNA(Ala))的结构。在接下来的40年中发展了化学方法，例如，通过引物延伸的选择性2ʹ-羟基酰化法(selective 2ʹ-hydroxyl acylation analysed by primer extension, SHAPE)，此种方法用于在单碱基分率水平上检测tRNA(Asp)的结构。但是，只有将各种核酸酶法和化学方法与RNA-seq相结合，才能使方法从单一RNA转移到全转录分析，这正在改变我们对结构复杂性和重要性的理解。在这里，我们集中讨论核酸酶和化学分析方法之间的主要区别(图·6a)，如果想对这方面有进一步的理解，可以看Strobel在这方面的综述。</p>
<p>核酸酶方法，例如RNA结构的平行分析法(Parallel Analysis of RNA Structure，PARS)和片段测序法(fragmentation sequencing, FRAG-seq)，这两种方法使用能消化单链RNA(ssRNA)或双链RNA(dsRNA)的酶。核酸酶消化后剩余的RNA用作RNA-seq的文库构建。随后通过对产生的RNA序列数据进行计算分析来识别结构化(双链)和非结构化(单链)区域。核酸酶易于使用，可以用于研究ssRNA和dsRNA，但是由于核酸酶消化法的随机特性，它们与化学分析法相比，分辨率比较低。此外，由于核酸酶尺寸比较大，这就限制了这些核酸酶进入细胞，这就使得它们不适合体内研究。</p>
<p>​ 化学分析法使用与RNA分子反应的化学探针，来标记结构化或非结构化核苷酸。这些标记要么阻断逆转录，要么导致cDNA的错配，从而可以定位并分析RNA-seq读长，用于揭示结构组。SHAPE之后进行测序，这种技术方法能够RNA骨架上的核糖2’-羟基反应来标记未配对的ssRNA，虽然发夹环中的碱基折叠会降低其效率。Structure-seq与硫酸二甲酯测序(dimethyl sulfate sequencing, DMS-seq)能使用DMS来标记腺嘌呤和胞嘧啶残基，阻断逆转录，最终从生成的截短cDNAs分析中推断出RNA结构。SHAPE和突变表达谱(SHAPE and utational profiling, SHAPE-Map)和DMS突变表达谱测序(DMS-MaPseq)都修改了实验条件，从而提高了逆转录酶的加工能力，并防止cDNA截短。相反，化学标记会导致错配事件，在RNA-seq数据的分析中，能够检测出这些“突变”，从而揭示RNA结构。化学探针是小分子化合物，尽管由于细胞内的环境处于动态变化中，数据有可能更加多变，但是化学探针还是能够用于研究活体内的有生物学意义的结构。化学探针还可以用于nascent RNAs的结构分析，并揭示共转录RAN折叠的顺序。</p>
<p>核酸酶和反转录阻断方法通常产生短RNA片段，并且只报告单个酶切位点或化学标记，而错误结合和突变检测方法可以报告每个读长的多个化学标记。没有方法不存在偏倚；逆转录阻断永远不会100%有效，本应诱导突变的化学标记可以阻断cDNA合成，这两个因素都可以影响数据的解读。Spike-in控制有可能改善结构组分析的质量，但尚未得到广泛使用。SHAPE方法的比较揭示了仅在体内实验中才会出现效率差异，因此这就突显出比较类似复杂方法时所需要谨慎。</p>
<p>这些方法正在产生关于RNA结构如何在基因和蛋白质调控中发挥作用的新理解。例如，DMS分析说明了，RNA结构有可能调控APA，或许会减慢催化活性区域的翻译，使得更多的时间用于蛋白质的折叠，从而减少错误折叠事件。结构RNA-seq方法的结合有可能产生所有的完整结构组信息。随着该领域的扩展，我们可能会发现，RNA的结构与疾病的进展和或疾病的状态有关；最近的结果表明，异常RNA结构在重复扩张性疾病方面可能发挥作用。最终，结构组分析也许会促进那些靶向作用于研究透彻的RNA结构的小分子的开发，从而开辟治疗开发的新领域。</p>
<h3 id="研究分子间rna-rna相互作用">研究分子间RNA-RNA相互作用</h3>
<p>分子间的RRIs在转录后调控中发挥着重要作用，例如miRNA与靶基因的3’UTR结合。现在已经开发了用于研究分子间RRI的工具，它们用于靶向分析和转录组分析。这些分析方法含有一个共同的工作流程，即RNA在打断与邻位连接之前，通过交联来保护其相互作用(FIG. 6b)。大多数并非全部，由不同方法嵌合生成的嵌合cDNA来源于稳定碱基配对（即相互作用）RRNA分子的连接。靶向方法，例如交联，连接和杂交物测序(Crosslinking, ligation and sequencing of hybrids, CLASH)， RNA相互作用组分析和测序(RNA interactome analysis and sequencing, RIA-seq)和RNA反义纯化方法测序(RNA antisense purification followed by RNA sequencing, RAP-RNA)能产生一个RNA或RNA家族的高深度相互作用图谱。CLASH丰富了使用IP来进行特定蛋白复合物介导的RRI分析方法，而RIA-seq使用反应寡核苷酸来回收那些与靶基因有相互作用的RNAs；这两种方法都无法区分直接和间接的RRIs，这就导致其生物学解释变得复杂。为了提高RRI分析的分辨率，RAP-RNA使用补骨脂素(psoralen)和其他交联剂，然后用反义寡核苷酸捕获RNA，以及使用高通量RNA-seq来检测直接和间接RRI。虽然该方法可以进行更具体的分析，它需要制备多个文库（每个交联剂一个文库）。</p>
<p>转录组方法从根本上类似于靶向方法：相互作用的RNA在体外被交联后并被富集。通过减少进入连接反应的非相互作用RNA的量来提高富集的特异性，并且可以通过2D凝胶纯化(如在RNA相互作用和结构的补骨脂素分析(psoralen analysis of RNA interactions and structures, PARIS)或交联RNA的生物素亲和纯化(如在补骨脂素交联，连接和选择的杂交测序， sequencing of psoralen crosslinked, ligated and selected hybrids,SPLASH)来实现，或者通过RNase R酶的消化来清除非交联RNA(如在相互作用的RNA连接之后的RNA-seq, ligation of interacting RNA followed by RNA- seq， LIGR-seq)。连接后，在进行RNA-seq文库制备前，去除交联，然后进行测序。PARIS能够生成所有方法中最高数目的相互作用次数，但是每个样本需要75M的读长，这些任何其他的RRI方法都多，并且所需要的DGE实验平均读长深度是其他实验的2倍。</p>
<p>对整理好的RNA相互作用数据的分析可以对多个相互作用进行可视化，并些这种分析方法已经提示了RNA各类的RRI分布的变化。总之，90%的RRIs涉及mRNAs。近一半涉及miRNA或长链非编码RNA，对于这些RNA，大多数相互作用都与mRNA靶基因相关。对这些整理数据的比较揭示了不同方法对特定RNA物种的偏倚，这导致这些方法之间几乎没有重叠。因此，绘制RRI的完整图谱可能需要使用不止一种方法。然而，RRI方法有几个局限性。也许最具挑战性的就是RRI是动态的，并受结构构象和其他分子间相互作用的影响，这使得在没有重复的情况下，很难对其进行解释。分子内的相互作用为分子间的RRI分析增加了干扰，这就需要过滤并除去那些高度结构化的RNAs，例如rRNAs。其它的问题还包括RNA提取过程中相互相互作用的打断，这就需要稳定的交联方法，但最常用的RRI交联剂是补骨脂素和4’-氨基-甲基三氧沙林(4ʹ-amino- methyltrioxsalen, AMT)，这些交联剂只交联嘧啶，其效率比较低，会降低灵敏度。此外，邻近连接步骤低效，并且这会连接相互作用和非相互作用RNA，进一步降低灵敏度。</p>
<h3 id="研究rna-蛋白质相互作用">研究RNA-蛋白质相互作用</h3>
<p>ChIP-seq已经成了绘制和研究DNA-蛋白质相互作用不可或缺的工具；类似的IP方法也用于研究RNA-蛋白质的相互作用。RNA-蛋白质相互作用方法依赖于IP，利用针对感兴趣的RNA结合蛋白的抗体来捕获其结合的RNA进行分析（第一次报道时是用芯片进行分析的）(FIG. 6c)。各种RNA-蛋白质相互作用方法之间最明显的区别在于相互作用的RNA和蛋白质是否交联以及如何交联：一些方法避免交联(天然IP， native IP)，其他方法使用甲醛进行交联，一些方法使用紫外线(UV)光进行交联。最简单的方法就是RNA免疫沉淀测序(RNA immunoprecipitation and sequencing, RIP-seq)，时常，但并非所有情况下都使用天然IP法，以及并非总进行RNA打断。这种简便性使用该方法易于被采用。这种方法能产生有用的生物学信息，但是它有两个重要的缺陷。第一，用于保存RNA-蛋白质相互作用的前提是需要进行温和地洗涤，这就意味着富集的片段中有相对高的非特异性结合片段。第二，没有进行RNA打断就降低了结合位点的分析。因此，RIP-seq具有高度灵活性，并依赖于RNA-蛋白质结合的自然稳定性。使用甲醛交联在RNA与其相互作用的蛋白质之间产生可逆的共价键提高了稳定性，并减少了非特异性RNA的回收，但甲醛也会导致蛋白质-蛋白质的交联。这种影响可以通过使用0.1%的甲醛（比ChIP-seq研究使用的甲醛低10倍）进行温和的交联来降低，这能在多个蛋白质靶点上产生高质量的结果。</p>
<p>在CLIP中使用254nm的UV来进行联系是一项关键的技术，它提高了RNA-蛋白质相互作用分析方法的特异性和位置分辨率。UV交联在蛋白质和RNA的相互作用位点产生共价键，但最重要的是，它不对蛋白质-蛋白质相互交联。这就稳定了RNA-蛋白质的结合，允许严格的富集，破坏了天然RNA-蛋白质的相互作用，减少了背景信号。CLIP的实验方法随后就构成了许多方法发展的基础。单个核苷酸分辨率的CLIP(iCLIP)将UMIs整合到文库中，用于移除PCR复制。它还利用了cDNA合成在交联核苷酸处常见的过早截短，通过对截短的cDNA进行扩增来获得交联位点的定量，核苷酸级分辨率图谱。光激活核糖核苷增强片段(Photoactivatable- ribonucleotide-enhanced CLIP,PAR-CLIP)通过使用4 sU和356nM的UV来进行交联。在细胞培养过程中，4 sU被整合到内源RNAs中，356nm的UV辐射会在4 sU整合位点处产生交联（产生高度的特异性）。在产生的测序数据中检测反转录诱导的T&gt;C替换就会能够实现碱基对级的分辨率，并且能够区分交联片段和非交联片段，进一步降低背景信号。最近对CLIP的改进提高了它的效应和灵敏度。红外CLIP(infrared CLIP, irCLIP)用红外凝胶成像技术来代替放射性同位素检验，它是基于珠子的纯化技术。与常规的iCLIP使用的1百万到2百万细胞相比，这些技术的改进可分析只有2万个细胞的RNA-蛋白质相互作用。增强型CLIP(enhanced CLIP, eCLIP)抛弃了RNA-蛋白质复合物的质控和可视化操作，而是在RNA接头中添加了条形码，这种改进可能让所有的样本混合到一起，并用珠子来代替了凝胶。这些改进旨在简化实验操作，eCLIP实验已经研究了近200个蛋白，它已经成了ENCODE项目的一部分。但是，irCLIP与eCLIP目前都没有被广泛采用，部分原因是eCLIP和irCLIP的灵敏性增加的原因是由于其特异性降低导致的，比如利用两个方法所鉴定的PTBP1结合位点上结合或有序和调节外显子的富集减少。随着公共数据库中可用的大量数据为计算分析提供了新的机会，因此谨慎考虑CLIP数据的质控，过滤，以及峰值调用(peak calling)和归一化方法就变得非常重要，这些会影响数据的生物学解释。为了更全面地讨论 RNA-蛋白质的相互作用的CLIP实验方法，我们建议读者可以阅读最近关于这个主题的综述。</p>
<p>一些RRI以及所有的RNA-蛋白质结合方法对IP的依赖限制了其对有良好特征抗体蛋白质的研究，而非特异抗体的结合仍然是一个问题（虽然这一问题并非局限于这个领域）。RNA结构也会影响RNA-蛋白质之间的相互作用；一些蛋白质能识别特异的RNA二级结构或与这些结构竞争结合RNA，这使得体外的发现转向体内就变得复杂了。此外，结构和RNA-蛋白质相互作用方法通常报告一个特定转录本或位置的平均值。在实验室方法中，在计算方法和单分子测序方面的未来发展或许有助于破译一些这些生物变异。</p>
<h2 id="结论">结论</h2>
<p>Wang，Gerstein和Snyder关于RNA-seq将“革命性地[如何]分析真核转录体”的预测肯定是正确的。但是，即使是他们，也有可能对这种转型的规模感到惊讶。现在我们可以分析RNA生物学的许多方面，这对于基因组功能、研究开发和确定导致癌症和其他疾病的分子调控异常方面来说是必不可少的。虽然生物学发现阶段还远未结束，但是已经在临床中使用了RNA-seq方法。单细胞测序正在成为许多实验的标准配置，空间转录组学的分析可能会遵循类似的路径，使其能够在与开发当前方法的实验室范围之外使用。长读长测序方法也有可能取代当前相当大比例的研究者们默认选择的Illumina的短读长RNA-seq。对于这种情况的出现，长读长测序技术还需要在增加通量和降低错误率方面做出极大的改进。 然而，长读长mRNA异构体测序的优点是，如果它变得像现在短读长测序一样便宜和可靠，那么对于那些除了易降解材料外，长读长测序就可能是首选。考虑到这些因素，那么任何关于RNA-seq在未来十年可能如何发展的预测都有可能过于保守。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/07/23/BioItem/iTRAQ定量蛋白质组(下)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/23/BioItem/iTRAQ定量蛋白质组(下)/" itemprop="url">iTRAQ定量蛋白质组(下)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-23T12:00:00+08:00">
                2019-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生信实战项目/" itemprop="url" rel="index">
                    <span itemprop="name">生信实战项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  75
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TMT标签</p>
<p>https://www.thermofisher.com/cn/zh/home/life-science/protein-biology/protein-mass-spectrometry-analysis/protein-quantitation-mass-spectrometry/tandem-mass-tag-systems.html</p>
<p>http://www.mtoz-biolabs.com/itraq-tmt.html</p>
<p>http://www.bioinfor.com/quantification/</p>
<p>https://www.sciencedirect.com/topics/medicine-and-dentistry/isobaric-labeling</p>
<p>https://www.thermofisher.com/cn/zh/home/life-science/protein-biology/protein-biology-learning-center/protein-biology-resource-library/pierce-protein-methods/quantitative-proteomics.html</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/07/15/R/R语言中的颜色设置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/15/R/R语言中的颜色设置/" itemprop="url">R语言中的颜色设置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-15T12:00:00+08:00">
                2019-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/R/" itemprop="url" rel="index">
                    <span itemprop="name">R</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  860
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="rcolorbrewer包">RColorBrewer包</h2>
<p>此包的官方配色网站是：http://colorbrewer2.org</p>
<h3 id="brewer.pal"><code>brewer.pal()</code></h3>
<p>参数为：<code>brewer.pal(n ,name)</code>，其中n为不同颜色数，最小为3，最大取决于调色板中的颜色数。name指颜色的名称，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mypalette&lt;-brewer.pal(<span class="number">7</span>,<span class="string">"Greens"</span>)</div><div class="line">mypalette</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; mypalette&lt;-brewer.pal(<span class="number">7</span>,<span class="string">"Greens"</span>)</div><div class="line">&gt; mypalette</div><div class="line">[<span class="number">1</span>] <span class="string">"#EDF8E9"</span> <span class="string">"#C7E9C0"</span> <span class="string">"#A1D99B"</span> <span class="string">"#74C476"</span> <span class="string">"#41AB5D"</span> <span class="string">"#238B45"</span> <span class="string">"#005A32"</span></div></pre></td></tr></table></figure>
<h3 id="display.brewer.pal"><code>display.brewer.pal()</code></h3>
<p>在窗口中显示显示的颜色，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display.brewer.pal(<span class="number">7</span>,<span class="string">"BrBG"</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715095133.png">

</div>
<h3 id="brewer.pal.info可以查看颜色信息"><code>brewer.pal.info()</code>可以查看颜色信息</h3>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brewer.pal.info[<span class="string">"Blues"</span>,]</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; brewer.pal.info[<span class="string">"Blues"</span>,]</div><div class="line">      maxcolors category colorblind</div><div class="line">Blues         <span class="number">9</span>      seq       <span class="literal">TRUE</span></div></pre></td></tr></table></figure>
<h3 id="display.brewer.all"><code>display.brewer.all()</code></h3>
<p>参数为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">display.brewer.all(n=<span class="number">10</span>, type=<span class="string">"all"</span>, select=<span class="literal">NULL</span>, exact.n=<span class="literal">TRUE</span>, </div><div class="line">colorblindFriendly=<span class="literal">FALSE</span>)</div></pre></td></tr></table></figure>
<p>同时显示几个调色板，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715095827.png">

</div>
<h4 id="颜色类型">颜色类型</h4>
<p>其中参数<code>type</code>是显示颜色类型，一共有三种颜色类型，分别是seq连续型，div离散型，qual极端型，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display.brewer.all(type = <span class="string">"seq"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715095816.png">

</div>
<p>如果我们要使用YIOrRd组中的第1，3，4，6，8，9这6种颜色，可以使用下面的代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">barplot(rep(<span class="number">1</span>,<span class="number">6</span>),col = brewer.pal(<span class="number">9</span>,<span class="string">"YlOrRd"</span>)[c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>)])</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715100025.png">

</div>
<p>div离散型颜色，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display.brewer.all(type = <span class="string">"div"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715100112.png">

</div>
<p>这种颜色两边亮，中间暗，比较适合进行高低对比。</p>
<p>现在我们使用BrBG组中的3到8种颜色，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">barplot(rep(<span class="number">1</span>,<span class="number">6</span>),col = brewer.pal(<span class="number">11</span>,<span class="string">"BrBG"</span>)[<span class="number">3</span>:<span class="number">8</span>])</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715100205.png">

</div>
<p>qual极端型颜色</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display.brewer.all(type = <span class="string">"qual"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715100235.png">

</div>
<p>这种颜色比较适合呈现分类变量。</p>
<p>现在使用Set3中的3到8种颜色，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">barplot(rep(<span class="number">1</span>,<span class="number">6</span>),col = brewer.pal(<span class="number">12</span>,<span class="string">"Set3"</span>)[<span class="number">3</span>:<span class="number">8</span>])</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715100306.png">

</div>
<h2 id="rcolorbrewer包使用案例">RColorBrewer包使用案例</h2>
<h3 id="第1案例从现在的颜色中挑选颜色">第1案例：从现在的颜色中挑选颜色</h3>
<p>代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">### Set the display a 1 by 1 grid</span></div><div class="line">par(mfrow=c(<span class="number">1</span>,<span class="number">1</span>))</div><div class="line"><span class="comment">### Generate random data matrix</span></div><div class="line">rand.data &lt;- replicate(<span class="number">8</span>,rnorm(<span class="number">100</span>,<span class="number">100</span>,sd=<span class="number">1.5</span>))</div><div class="line"><span class="comment">### Draw a box plot, with each box coloured by the 'Set3' palette</span></div><div class="line">boxplot(rand.data,col=brewer.pal(<span class="number">8</span>,<span class="string">"Set3"</span>))</div></pre></td></tr></table></figure>
<p>这里使用到了<code>replicate()</code>函数，这个函数在<code>rand.data &lt;- replicate(8,rnorm(100,100,sd=1.5))</code>这个语句中的意思是，将后面的<code>rnorm(100,100,sd=1.5)</code>这个语句运行100次，也就是生成800个均值为100，sd为1.5的，符合正态分布的数据，结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715100823.png">

</div>
<h3 id="第2案例使用colorramppalette来扩展颜色">第2案例：使用<code>colorRampPalette()</code>来扩展颜色</h3>
<p>代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">### 使用colorRampPalette可以扩展颜色。</span></div><div class="line">newpalette&lt;-colorRampPalette(brewer.pal(<span class="number">9</span>,<span class="string">"Blues"</span>))(<span class="number">10</span>)</div><div class="line"><span class="comment">### Generate random data matrix</span></div><div class="line">rand.data &lt;- replicate(<span class="number">10</span>,rnorm(<span class="number">100</span>,<span class="number">100</span>,sd=<span class="number">1.5</span>))</div><div class="line"><span class="comment">### Draw a box plot, with each box coloured by the 'newpalette' palette</span></div><div class="line">boxplot(rand.data,col=newpalette)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715101208.png">

</div>
<p>这里使用到了<code>colorRampPalette()</code>函数，此函数可以自定义一繁殖颜色梯度，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">colors &lt;- colorRampPalette(c(<span class="string">"green"</span>, <span class="string">"red"</span>))(<span class="number">5</span>)</div><div class="line">colors</div><div class="line">rand.data &lt;- replicate(<span class="number">10</span>,rnorm(<span class="number">100</span>,<span class="number">100</span>,sd=<span class="number">1.5</span>))</div><div class="line">boxplot(rand.data,col=colors)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715101512.png">

</div>
<p>这种功能在绘制热图时很有用。</p>
<h2 id="wesanderson颜色包"><code>wesanderson</code>颜色包</h2>
<p>可用的颜色有好几个，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; names(wes_palettes)</div><div class="line"> [<span class="number">1</span>] <span class="string">"BottleRocket1"</span>  <span class="string">"BottleRocket2"</span>  <span class="string">"Rushmore1"</span>      <span class="string">"Rushmore"</span>      </div><div class="line"> [<span class="number">5</span>] <span class="string">"Royal1"</span>         <span class="string">"Royal2"</span>         <span class="string">"Zissou1"</span>        <span class="string">"Darjeeling1"</span>   </div><div class="line"> [<span class="number">9</span>] <span class="string">"Darjeeling2"</span>    <span class="string">"Chevalier1"</span>     <span class="string">"FantasticFox1"</span>  <span class="string">"Moonrise1"</span>     </div><div class="line">[<span class="number">13</span>] <span class="string">"Moonrise2"</span>      <span class="string">"Moonrise3"</span>      <span class="string">"Cavalcanti1"</span>    <span class="string">"GrandBudapest1"</span></div><div class="line">[<span class="number">17</span>] <span class="string">"GrandBudapest2"</span> <span class="string">"IsleofDogs1"</span>    <span class="string">"IsleofDogs2"</span></div></pre></td></tr></table></figure>
<p>查看一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wes_palette(<span class="string">"BottleRocket1"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715102342.png">

</div>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wes_palette(<span class="string">"BottleRocket2"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715102408.png">

</div>
<p>看一下使用案例：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(<span class="string">"ggplot2"</span>)</div><div class="line">ggplot(mtcars, aes(factor(cyl), fill=factor(vs))) +  geom_bar() +</div><div class="line">  scale_fill_manual(values = wes_palette(<span class="string">"Royal1"</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715102457.png">

</div>
<p>看一下热图案例：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pal &lt;- wes_palette(<span class="string">"Zissou1"</span>, <span class="number">100</span>, type = <span class="string">"continuous"</span>)</div><div class="line"><span class="comment"># heatmap is a local dataset</span></div><div class="line">ggplot(heatmap, aes(x = X2, y = X1, fill = value)) +</div><div class="line">  geom_tile() + </div><div class="line">  scale_fill_gradientn(colours = pal) + </div><div class="line">  scale_x_discrete(expand = c(<span class="number">0</span>, <span class="number">0</span>)) +</div><div class="line">  scale_y_discrete(expand = c(<span class="number">0</span>, <span class="number">0</span>)) + </div><div class="line">  coord_equal()</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715102638.png">

</div>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://www.cnblogs.com/homewch/archive/2016/07/25/5704153.html" target="_blank" rel="external">R语言配色方案 — RColorBrewer包</a></li>
<li><a href="https://www.cnblogs.com/huzs/p/3742000.html" target="_blank" rel="external">R语言编程入门–replicate()函数比较有意思!</a></li>
<li><a href="https://www.cnblogs.com/xudongliang/p/6932195.html" target="_blank" rel="external">R语言colorRampPalette函数-创建颜色梯度(渐变色)</a></li>
<li><a href="https://www.cnblogs.com/sanmenyi/p/7219574.html" target="_blank" rel="external">R语言可视化–颜色</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/07/12/Literature/炎性小体/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/12/Literature/炎性小体/" itemprop="url">炎性小体</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-12T12:00:00+08:00">
                2019-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/文献笔记/" itemprop="url" rel="index">
                    <span itemprop="name">文献笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,213
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念">概念</h2>
<p>胚系编码的一一些受体，例如NLR，ALR，TRIM在外界刺激（通常是病原体）下，会形成一个更大分子量的复合物，也就是炎性小体，炎性小体会通过ASC来招募促炎性的蛋白，即caspase-1。</p>
<p>炎性小体的大致结构如下所示<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190712153128.png">

</div>
<p>炎性小体的核心结构进而会招募并寡聚化(oligomerize)半胱氨酸蛋白酶caspase-1，其中caspase-1是以丝状的形式存在的，如上图所示，这种丝状的结构会促进caspase-1自身的活化。</p>
<p>ASC蛋白位于中间，它的N端是PYD，C末端是CARD，其中CARD参与caspase-1的相互作用。caspase-1会切除炎症细胞因子IL-1beta与IL-18的前体，将它们释放到细胞外。</p>
<p>炎性小体的活化会诱导细胞的裂解死亡，这种形式称为<strong>焦亡(pyroptosis)</strong>，这是细胞对抗病原体的一种免疫机制。</p>
<p>在天然免疫中，炎性小体是一个重要的组成成分，书中对炎性小体的定义如下所示<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>：</p>
<blockquote>
<p>By definition, inﬂammasomes are scaffolds for activation of the inﬂammatory cysteine-dependent aspartate-specific protease caspase-1.</p>
</blockquote>
<p>也就是说，炎性小体是一类脚手架蛋白(scaffold)，其功能是参与光胱氨酸依赖的天冬氨酸特异性蛋白酶caspase-1的活化，这种酶活化后参与炎性细胞因子，IL-1beta，IL-18的成熟与分泌， 以及参与焦亡，与焦亡相关的另外一个酶是caspase-11。</p>
<p>pyroptosis是宿主细胞的一种防御机制，它能裂解那些被病原体感染的细胞，从而将病原体暴露出来，与免疫细胞接触。pyroptosis相关的细胞裂解还会释放DAMP，例如IL-1瞢a和HMGB1。</p>
<h3 id="prrs作为炎性小体的脚手架蛋白">PRRs作为炎性小体的脚手架蛋白</h3>
<p>常见的炎性小体结构如下所示<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190712171054.png">

</div>
<p>NLRP1， NLRP2，NLRP3，NLRP6，NLRC4以及NLRP12它们都含有一个NBD，NBD也被称为NACHT。还含有一个LRR，剩下的要么含有CARD，要么含有PYD。</p>
<p>AIM2与IFI16是PYHIN家族成员，它们都含有PYD与HIN200结构域，这两个结构域参与配体结合<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>。</p>
<p>其它文献关于它们的结构总结如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190715105613.png">

</div>
<p>其中的缩写如下所示：</p>
<ol style="list-style-type: decimal">
<li>PYD: Pyrin domain</li>
<li>NLR: nucleotide-binding domain and leucine-rich repeat containing receptors</li>
<li>NACHT：NAIP-CIITA-HET-E domain</li>
<li>NAIP: neuronal apoptosis inhibitor protein</li>
<li>LRR: leucine-rich repeat</li>
<li>NOD: nucleotide-binding oligomerization domain</li>
<li>FIND:‘Function to find’ domain</li>
<li>CARD: Caspase recruitment domain</li>
<li>BIR: Baculovirus inhibitor repeat(Baculovirus是杆状病毒)</li>
<li>NLRP: NLR family, pyrin domain containing</li>
<li>NLRC: containing a caspase recruitment domain</li>
<li>NLRB: containing a Baculovirus inhibitor repeat (BIR) domain</li>
<li>Hin200: Hematopoietic interferon-inducible nuclear protein family, 200 amino acid repeat</li>
<li>CC: coiled-coil</li>
</ol>
<p>NLRs（这个s指的是P，C，B，也就是NLRP，NLRB，NLRC这3种炎性小体）这种结构的炎性小体的结构前文已经提及，它含有NACHT/NBD，LRR，这两个组件(NACHT与LRR）通常位于中央。多数的NLRs型炎性小体在氨基端还有BIR，PYD,CARD这些结构。</p>
<p>NLR家族一共有22个人类炎性小体，有34个鼠源炎性小体。</p>
<h2 id="炎性小体功能">炎性小体功能</h2>
<p>哺乳动物的NLRs有几个阐明功能了，其余的功能还不清楚。其中研究比较透彻的是NOD1和NOD2(nucleotide-binding oligomerization domain containing proteins 1/2)，他们能促进RIPK2与CARD9依赖的NF-kappaB与AP1靶基因的活化。MHC II在抗原提呈中也需要NLR蛋白CIITA的参与。</p>
<p>另一个NLRs亚家族，也就是NLRP1，NLRP3，NLRC4和NAIP通过炎性小体信号转导参与免疫应答。</p>
<p>信号转导诱导PRR的聚集与招募，促进procaspase-1丝状物的成核，随后procaspase-1会经历邻近诱导的自我活化(proximity-induced autoactivation)。</p>
<h2 id="相关细胞因子">相关细胞因子</h2>
<p>IL-1beta与IL-18的分泌与其它的细胞因子不同，proIL-1beta和proIL-18最先是以非活性的形式（前体）分泌到细胞质中，然后再经caspase-1的切割，形成生物活性形式。</p>
<h2 id="nlrp3">NLRP3</h2>
<p>NLRP3能对大量的激活剂产生应答，它需要NF-kappaB信号的诱导才能活化。NF-kappaB信号是第一信号 （signal 1或priming）。例如NF-kappaB调控物A20/TNFAIP3缺陷的小鼠就无法出现 NLRP3的活化。</p>
<p>signla 2：细菌，真菌的一些成分会诱导NLRP3的活化，除了经典的刺激（细菌成分）诱导 NLRP3炎性小体外，还有一些其它的蛋白能诱导NLRP3的活化，这些属于NLRP3的非经典活化内容，例如人类的caspase-11或它的鼠源直系同源蛋白 caspase-4和caspase-5参与细胞质LPS诱导的NLRP3炎性小体的活化。在这些非经典信号通路中，caspase-11诱导的pyroptosis并不依赖于NLRP3炎性小体 ，但是proIL-1beta与por-IL-18的切割却要通过NLRP3来实现 。在观其NLRP3活化过程中，K+是一种重要的诱导物。</p>
<p>非经典NLRP3炎性小体信号转导通常在格兰氏阴性菌的识别过程中有着重要作用。</p>
<p>pyroptosis的一个关键事件就是Gasdermin D的切割，它的切割与LPS诱导的caspase-11和caspase-1有关。</p>
<p>线粒体膜的破坏，以及线粒体DNA的氧化是NLRP3活化的一个因素。</p>
<p>线粒体异常有时候伴随着离子流的异常，这种行为也会控制NLRP3的活化。心磷脂(cardiolipin)的释放，氧化的线粒体DNA与线粒体膜的破坏都是NLRP3活化的第二信使。最近发现的Nek7是NLRP3活化的一个关键蛋白，它控制K+的流入来影响NLRP3的组装。</p>
<h2 id="nlrp1">NLRP1</h2>
<p>NLRP1是第1个发现的炎性小体，它通常FIIND结构域进行自我切割，FIIND位于CARD与LRR中间。人类有1个NLRP1基因，小鼠有3个，分别是Nlrp1a，Nlrp1b与Nlrp1c。Nlrp1b在Bacillus anthracis的LeTx(lethal toxin)诱导下进行组装。ASC对于Nlrp1b依赖的IL-1beta和IL-18分泌来说并非是必不可少的，只是ASC能够增强这两种细胞因子的分泌。这表明，proaspase-1招募到Nlrp1b平台上后，会诱导caspase-1构象的改变，诱导其活化，而ASC依赖的caspase-1自我切割则会锁定这种活化构象。</p>
<p>炎性小体活化的经典与非经典通路：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190713103622.png">

</div>
<h2 id="nlrc4">NLRC4</h2>
<p>NLRC4与其它炎性小体的结构如下所示<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190713104104.png">

</div>
<p>上图列出了NLRC4活化的上游机制，NLRC4在氨基末端有一个CARD，在没有ASC的前提下，NLRC4通过CARD与procaspase-1相互作用。一些微生物能活化NLRC4的活化，例如Salmonella enterica serovar Typhimurium， Legionella pneumophila，Pseudomonas auruginosa，Shigella ﬂ exneri， Listeria monocytogenes），这些细菌的毒力因子都是依赖于鞭毛蛋白(flagellin)介导的运行，会向宿主细胞传递T3SS和T4SS。NLRC4不直接检测这些毒力因子，而是NAIP检测到这些成分后，再作用于NLRC4。人类的全长NAIP与小鼠的Naip5，Naip6是鞭毛蛋白的受体。人类短的NAIP与小鼠的Nip1能识别T3SS的针状蛋白(needle protein)，但Naip2则能与T3SS杆状蛋白(rod protein)结合。S. Typhimurium能诱导NLRC4在Ser533位点的磷酸化，进而活化NLRC4。</p>
<p>在Naip5缺陷的巨噬中，falgellin依赖的NLRC4磷酸化并不依赖地Naip5。这说明，Nlrc4的活化机制分两步，先是在Ser533位点磷酸化，随后，Naip5再诱导NLRC4的活化。NLRC4与天然免疫有关，也与自身免疫性疾病有关。</p>
<h2 id="aim2">AIM2</h2>
<p>AIM2全称是absent in melanoma2，这是一个HIN200家族/AIM2家族的一个成员(ALR)。当细菌或病毒来源的dsDNA与Hin200结构域结合时，就会诱发AIM2炎性小体的组装。AIM2会诱导髓系细胞(myeloid cells)产生IL-1beta和IL-18，诱导细胞的pyroptosis。AIM2在控制一些病原体感染方面有着重要作用，例如 Francisella tularensis,Listeria monocytogenes,mouse cytomegalovirus,vaccinia virus。</p>
<h2 id="pyrin">Pyrin</h2>
<p>人类MEFV基因编码Pyrin/TRIM20蛋白，这是一个TRIM家族的成员。Pyrin主要表达于髓系细胞(myeloid cell)，在单核细胞向巨噬分化过程中，Pyrin的表达会降低。RhoA-inactivating bacterial toxins会诱导Pyrin组装成炎性小体，激活caspase-1，参与IL-1beta的分泌。</p>
<h2 id="炎性小体的组装与信号转导">炎性小体的组装与信号转导</h2>
<p>ASC依赖的炎性小体的组装过程：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190713152009.png">

</div>
<p>上游的NLR或ALR识别其配体后，会通过PYD或CARD聚集，聚集的NLR或ALR会形成一个平台，通过PYD-PYD或CARD-CARD的相互作用来招募ASC，形成一个丝状的核心。其中ASC(CARD)位于外层，它形成另外一个平台，通过CARD-CARD的相互作用来招募caspase-1，高度聚合化折caspase-1会诱导自身的切割，产生活性炎性小体。</p>
<h2 id="listeria-monocytogenes与炎性小体">Listeria monocytogenes与炎性小体</h2>
<p>Lm能激活不同的炎性小体。</p>
<h3 id="nlrp3与lm">NLRP3与Lm</h3>
<p>Lm是第一个发现的能激活NLRP3的病原体。Mariathasan发现，细胞质中的Lm能激活NLRP3炎性小体，但是被囊泡包裹的Lm无法激活炎性小体，这说明被囊泡包裹这一过程对于炎性小体的活化非常重要。Kannengati观察到，Lm的总RNA能刺激NLRP3的活化，这进一步说明，LM能通过各种机制来刺激NLRP3。</p>
<p>胞外的LLO形成的孔洞会诱导K+外流，导入NLRP3炎性小体的活化。除此之外，Lm的RNA，iap基因编码的p60也能激活NLRP3。p60的N端LysM与SH3结构域刺激IL-1beta和IL-18的释放，这些活动独立于细胞的焦亡形式死亡。使用DPI抑制ROS能降低IL-1beta的分泌，但IL-18的分泌不受影响。这些实验是在小鼠细胞上做的。</p>
<p>在人类PBMC实验方面，使用Lm感染PBMC，细胞会经历LLO诱导的NLRP3依赖的炎性小体活化，这种炎性小体一的活化依赖于吞噬泡的西化与cathepsin B的释放，这些现象与小鼠的细胞有所不同。</p>
<p>Lm诱导的快速NRLP3的活化依赖于TLR信号转导，因为MyD88缺陷的细胞无法活化炎性小体。这些应答依赖于MyD88的下游信号分子IRAK1，因此IRAK1缺陷的细胞无法激活炎性小体，以及无法分泌IL-1beta和IL-18。但是，在致敏状态(priming)，IRAK1对于炎性小体的活化又不是必需的。另外，延长感染时间会出现Lm诱导的非NLRP3依赖的炎性小体活化。总之就是，LM在早期感染中激活NLRP3。</p>
<h3 id="nlrc4与lm">NLRC4与Lm</h3>
<p>NRLC4识别鞭毛蛋白(flagellin)与T3SS(Type III secretion system)。</p>
<p>Lm是格兰阳性菌，不含T3SS成分，它的鞭毛蛋白是激活NLRC4的成分。但Lm鞭毛蛋白似乎并非只激活NRLC4，因为使用鞭毛蛋白缺陷菌ΔflaA来感染，也能产生caspase-1的活化以及形成IL-1beta。</p>
<h3 id="aim2与lm">AIM2与Lm</h3>
<p>AIM2通常HIN200结构域来识别dsDNA。前面提到，在NLRP3缺失的情况下，鞭毛蛋白缺陷菌ΔflaA也能诱导caspase-1的活化。但在AIM2缺陷的细胞中，caspase-1的活化则会消失。</p>
<p>Lm的DNA激活AIM2。</p>
<h3 id="其它炎性小体">其它炎性小体</h3>
<p>NLRC5与NLRP3结合参与NLRP3的活化。NLRC5敲除的小鼠感染Lm后，载菌是不是更多，机制不明。NLRP6敲除的小鼠载菌量低，NLRPP6在LM感染方面的作用，不依赖于炎性小体的信号转导。Lm在刺激炎性小体方面的作用，体外数据很好，但是体内数据研究机制不明，其中AIM2有可能与体内相关炎性小体最密切的一个炎性小体。</p>
<p>在体外实验中，虽然LM能激活很多炎性小体，但是在体内感染方面，Lm会避免过度激活炎性小体，从而避免自身被清除，它已经进化出了逃避炎性小体监测的机制。</p>
<p>Lm会通过调控自身LLO，鞭毛蛋白(flagellin)来逃避宿主细胞的监测。</p>
<p>Lm的感染会诱导caspase-11的表达，但是敲除caspase-11后，caspase-1的功能不受影响，这说明caspase-11对于Lm的感染来说是可有可无的。</p>
<p>ASC敲除的异噬细胞无法激活caspase-1，不能分泌IL-1beta和IL-18.</p>
<p>Lm激活与逃避炎性小体监测的机制：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190713165831.png">

</div>
<p>Fig1：WT LM能最小程度地激活caspase-1，维持Lm在细胞内的存活，最终形成感染。相比之下，那些能激活炎性小体的Lm会诱导强烈的caspase-1以及pyroptosis，释放IL-1beta和IL-18，最终导致Lm的清除，增强活化巨噬细胞的招募，中性粒细胞的流入。</p>
<p>炎性小体的活化能清除Lm。</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190713170002.png">

</div>
<p>炎性小体相互关的炎症会损伤宿主针对Lm的细胞免疫。</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190713170251.png">

</div>
<h2 id="炎性小体研究思路">炎性小体研究思路</h2>
<h2 id="参考资料">参考资料</h2>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>Janeway immunobiology. 9th<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Backert S . Inflammasome Signaling and Bacterial Infections[M]. Springer International Publishing, 2016.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Backert S . Inflammasome Signaling and Bacterial Infections[M]. Springer International Publishing, 2016.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Inflammasomes in health and disease.Nature. 2012 Jan 18;481(7381):278-86. doi: 10.1038/nature10759.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Lamkanfi, M. and Vishva M. Dixit (2014). “Mechanisms and Functions of Inflammasomes.” Cell 157(5): 1013-1022.<a href="#fnref5">↩</a></p></li>
</ol>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/07/11/Literature/支架蛋白与脚手架蛋白/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/11/Literature/支架蛋白与脚手架蛋白/" itemprop="url">支架蛋白与脚手架蛋白</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-11T12:00:00+08:00">
                2019-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/文献笔记/" itemprop="url" rel="index">
                    <span itemprop="name">文献笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  812
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>信号转导通路（Signaling pathway）本身就是一种机制，或者说是一种过程，在这个过程中，一个信号到达细胞后（细胞表面，或者是细胞内部），这个信号就会触发一系列有序的事件（信号转导通路），最终导致细胞内出现一些变化。这些变化通常伴随着基因的表达或者是某些物质浓度的变化，这些事件能够使细胞对某种信号作出反应，并根据当前环境调整细胞自身的代谢活动。</p>
<p>信号转导通路始于某个信号本身，这个信号分子与细胞表面的信号分子受体结合，受体通过大量的不同的蛋白来将信号传递到细胞内部。从本质上来说，衔接蛋白（adaptor protein）与脚手架蛋白（Scaffold protein）都位于前述的这些蛋白集合中，它们负责将信号从受体进一步传递到细胞内部。</p>
<p>衔接蛋白与脚手架蛋白的区别就在于它们的功能和结构上的不同。脚手架蛋白的作用是通过“吸引”大量的，信号转导通路所需的不同蛋白来协调信号转导，这从一点我们可以知道，脚手架蛋白本身比较大。它们本质上是将信号通路中的执行者锭定到一个蛋白复合物中，并将它们定位到特定的位置，从而使信号转导更加有效，脚手架蛋白是发挥一个平台作用，将很多蛋白招募到一起，让它们之间发生相互作用。由于有这种作用，脚手架蛋白还能通过正反馈与负反馈信号来调控信号转导通路，脚手架蛋白还能将特定的蛋白（例如当前活跃的信号通路）从其它不需要的竞争性蛋白复合物中的分离出来。</p>
<p>衔接蛋白（有的译为接头蛋白），即adaptor protein，这种蛋白的分子量相对比较小，它们有助于形成蛋白复合物，但是衔接蛋白通常只与两类蛋白质结合。衔接蛋白通过特定的结构域（通常是SH2和SH3）来与其它蛋白结合，这两个结构域能识别靶蛋白的特定氨基酸序列。衔接蛋白本身可能没有酶活性，但它们会招募那些有功能的蛋白来发挥作用，例如MyD88，Grb2，SHC1等。</p>
<p>我们以脚手架蛋白MEKK1为例说明一下，此蛋白存在于MAPK通路中，此通路会将信号传递到细胞核，调控与细胞周期和细胞分化相关的特定转录因子的表达。而GRB2（生长因子受体结合蛋白2，Growthfactor receptor=bound protein 2）是一种衔接蛋白，它通过SH2结构域与EGF受体结合，并通过SH3结构域吸引此信号通路中下一个蛋白（Sos蛋白）。</p>
<p>MAPK信号通路图片如下所示：</p>
<p>[](https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190712163909.jpg</p>
<p>参考资料</p>
<ol style="list-style-type: decimal">
<li>https://www.biotechnologyforums.com/thread-3331.html</li>
<li>https://cshperspectives.cshlp.org/content/4/11/a011254.full%22</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/07/08/BioItem/iTRAQ定量蛋白质组(上)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/08/BioItem/iTRAQ定量蛋白质组(上)/" itemprop="url">iTRAQ定量蛋白质组(上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-08T12:00:00+08:00">
                2019-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生信实战项目/" itemprop="url" rel="index">
                    <span itemprop="name">生信实战项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,685
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是腾讯课堂上的蛋白质组数据分析教程的笔记，教程的全称是<a href="https://ke.qq.com/course/400449" target="_blank" rel="external">《iTRAQ定量蛋白质组》</a>教程中涉及到的蛋白质谱使用的方法是iTRAQ，分析的物种是玉米，虽然与我的方向不一致，但是原理与数据分析的思路都是相通的，这一部分仅是背景知识。</p>
<p>这个视频教程笔记分2篇，上篇主要是蛋白质谱背景知识介绍，以及文献中的常规思路分析。</p>
<p>下篇主要是进行案例训练。</p>
<h2 id="蛋白质组知识背景">蛋白质组知识背景</h2>
<p>蛋白质组(proteome)：由一个细胞、一个组织或一个机体的基因组所表达的全部相应的蛋白质，是一个整体的概念。</p>
<p>蛋白质组学(proteomics)：以蛋白质组为研究对象，从蛋白质整体水平来认识重合活动规律的科学，是后基因组计划的重要组成部分。</p>
<p>蛋白质组学本质上指的是在大规模水平上研究蛋白质的特征，包括蛋白质的表达水平、翻译后的修饰、蛋白质与蛋白质相互作用等，由此获得蛋白质水平上的关于疾病机理、细胞代谢等过程的整体而全面的认识。</p>
<h3 id="蛋白质组学分类">蛋白质组学分类</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190709172614.png">

</div>
<p>常用的是非标Label Free，以及标记的iTRAQ分板技术。</p>
<h3 id="定量蛋白组学">定量蛋白组学</h3>
<p>定量蛋白组学：研究不同条件下蛋白表达水平的变化（上下调情况）。</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190709172748.png">

</div>
<h2 id="itraq知识背景">iTRAQ知识背景</h2>
<p><strong>iTRAQ</strong>的全称是<strong>Isobaric tag for relative and absolute quantitation</strong>，翻译为中文就是<strong>同重元素标记的相对与绝对定量技术</strong>。这是由AB SCIEX公司研发的一种体外同重同位素标记的相对与绝对定量技术。该技术利用同位素试剂可同时标记8个多肽样品，标记的多肽样品等量混匀后，经液相色谱分离及串联质谱（MS/MS）分析，可得到各肽段的一、二级质谱信息。</p>
<p>在一级质谱中，不同样品来源的同一肽段表现出相同的质荷比；</p>
<p>在二级质谱中，化学键断裂释放出iTRAQ报告离子，在质谱低质量区产生了8个报告离子峰，其强度反应了该肽段在不同样品中的相对表达量信息，另外二级质谱中的肽段碎片离子峰质荷比反应了该肽段的序列信息；这些质谱原始数据经过数据库检索，可得到蛋白质的定性和相对定量信息。</p>
<p>iTRAQ技术在微生物抗协迫机制和动植物发育分化机理研究及医学生物标记物筛选领域都有广泛应用。</p>
<p><strong>iTRAQ</strong>：采用4种或8种同位素标签，通过特异性标记多肽的氨基基团，进行串联质谱分析从而比较不同样本中蛋白质的相对含量，其特点是：</p>
<ul>
<li><p>蛋白通量高，覆盖度高；</p></li>
<li><p>定量准确，可信度高；</p></li>
<li><p>分离能力强、分析范围广，定性结果可靠；</p></li>
<li><p>自动化程度高、分析时间快，分离效果好。</p></li>
</ul>
<h2 id="定量蛋白质组原理">定量蛋白质组原理</h2>
<h3 id="itraq试剂">iTRAQ试剂</h3>
<ul>
<li>iTRAQ试剂是可与氨基酸末端及赖氨酸侧链连接的胺标记的同位素元素；</li>
<li>iTRAQ试剂由三部分组成：报告基团、质量平衡基团和肽反应标记试剂基团；</li>
<li>报告基因：常见4标或8标，可同时标记4组或8组样品，报告基团有8种分子量，范围从113到121（无120）；</li>
<li>平衡基因：保证iTRAQ标记的同一肽段的质荷比相同，平衡基团也8有种不同的分子量，与不同的报告基团搭配，能保证被标记的不同来源的同一肽段在一级质谱中具有相同的质荷比，就是下图中右侧的部分，在上图，也就是a图中，它们的荷质比都是145.10，在下图，也就是b图中，荷质比都是305.10；</li>
<li>肽反应标记基团：可与肽段N端及辣氨酸侧链发生共价连接，从而标记上肽段。</li>
</ul>
<p>这几个试剂的结构如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190709185729.png">

</div>
<p>（图片来源于：Aggarwal S., Yadav A.K. (2016) Dissecting the iTRAQ Data Analysis. In: Jung K. (eds) Statistical Analysis in Proteomics. Methods in Molecular Biology, vol 1362. Humana Press, New York, NY,277）</p>
<h3 id="itraq的实验流程原理">iTRAQ的实验流程原理</h3>
<p>在质谱峰图中，虽然不同样本带有不同的同位素标签，但是经过质量平衡基因的平衡，任何一种试剂标记不同样本中的同一蛋白多肽表现为相同的质荷比，从而形成单一的峰。</p>
<p>在串联质谱结果中，经过激光通量轰击肽段，iTRAQ试剂的三部分之间的键断裂，平衡基因断裂，平衡基团丢失，不同同位素标签的同一多肽的离子信号表现为不同质荷比的峰，因此可根据波峰的高度和面积比较同一蛋白不同处理的定量信息，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190709190427.png">

</div>
<p>（图片出处为：Aggarwal S., Yadav A.K. (2016) Dissecting the iTRAQ Data Analysis. In: Jung K. (eds) Statistical Analysis in Proteomics. Methods in Molecular Biology, vol 1362. Humana Press, New York, NY，P278）</p>
<p>一级质谱：</p>
<p>二级质谱：</p>
<h4 id="常规实验流程">常规实验流程</h4>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190709184551.jpg">

</div>
<h4 id="实验流程如下所示">实验流程如下所示：</h4>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190709185226.png">

</div>
<p>第一步：蛋白酶解样本，也就是将蛋白样本酶解为肽段；</p>
<p>第二步：使用iTRAQ同位素标记，也就是使用不同的iTRAQ标签来标记不同的肽段样本；</p>
<p>第三步：SCX预分级，使用强阳离子交换SCX（HPLC）将肽段分为多个组分；</p>
<p>第四步：使用LC-MS对每个组分进行质谱检测。</p>
<h4 id="质谱仪的组成部分">质谱仪的组成部分</h4>
<p>蛋白质谱的核心就质谱，原理就是样本在特定条件下转变为高速运动的离子，根据离子质荷比的不同在静电场和磁场作用下进行分离，再用特定检测器记录不同质荷比的各离子的相对强度并形成质谱图。</p>
<h5 id="质谱仪">质谱仪</h5>
<p><strong>质谱仪</strong>：在真空状态下分析离子的质荷比m/z，质谱仪主要是由离子源、质量分析器和离子检测器组成，iTRAQ技术中常用LC-MS/MS，液相色谱串联质谱。</p>
<ul>
<li><p>离子源：将蛋白或多肽变成气态的带电离子，常用的有2类：①电喷雾电泳ESI；②基质辅助激光解吸电离MALDI（脉冲方式使用样本离子化0；</p></li>
<li><p>质量分析器：将离子源形成的离子按质荷比大小分开：常见有的5类：①四级杆(Quadrupole)；②离子阱(Ion trap)；③飞行时间(TOF)；④傅里叶(FTICR)；⑤轨道阱(Qrbitrap)。</p></li>
</ul>
<p>质量分析器的参数</p>
<p>质量分析器的质量范围是指测定质荷比范围，它决定了能检测到的离子范围，例如ESI离子源可产生许多质荷比大于3000的离子，但是如果质量分析器的上限达不到3000，则就无法检测大于3000的离子。</p>
<p>分辨率：观测到的质谱峰的质荷比/半峰高处的峰宽(FWHM)。</p>
<h4 id="不同类型质量分析器的比较">不同类型质量分析器的比较</h4>
<p>不同质量分析器有不同的分辨率，其中傅里叶&gt;轨道阱&gt;时间飞行&gt;离子阱&gt;四级杆，具体的参数如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717184549.png">

</div>
<p>市场上不同型号质谱仪的比较：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717184735.png">

</div>
<p>其中在使用iTRAQ分析时，比较常用的是Thermo的Q-Exactive与Q-Exactive HF。</p>
<ul>
<li><p>离子检测器：①直接检测器；②电子倍增器；③闪烁检测器。</p></li>
<li><p>液相色谱LC：利用物质在流动相和固定相中的分配系数差异，进行分离检测。</p></li>
<li><p>质谱MS：把不同质荷比的离子分开排列成谱。</p></li>
</ul>
<h2 id="实验方案设计">实验方案设计</h2>
<p>教学视频中的案例是植物方向，其实原理跟动物方向一样的，以下的都是植物蛋白质谱的实验设计。</p>
<h3 id="方案设计-生物学重复">方案设计-生物学重复</h3>
<ol style="list-style-type: decimal">
<li>至少设置3个以上的生物学重复；</li>
<li>为了增加实验结果的可靠性，可通过增加质谱的技术重复上机次数；</li>
<li>严谨的实验通常进行3次生物学重复和3次技术重复，也就是一共9批MS数据；</li>
<li>出于经费考虑，有的文献也只进行2-3次技术重复（在动物实验方面，技术重复就是同一个样本上3针质谱即可）。</li>
</ol>
<h3 id="方案设计-不同组样本的标记选择和上机组合">方案设计-不同组样本的标记选择和上机组合</h3>
<h4 id="两组样品">两组样品</h4>
<p>常见的组合包括2组，3组，4组，5组，6组样本，现在以植物干旱无罪推定研究为例说明一下。</p>
<p>假设我们有2组样本，对照组这里用CK表示，它表示正常浇水；实验组使用Treatment不胜感激，它表示不浇水3天，现在有2个方案：</p>
<p>第一个方案：每组2个生物学重复，1个3标；</p>
<p>第二个方案：第组3个生物学重复，1个6标，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717185946.png">

</div>
<h4 id="三组样本">三组样本</h4>
<p>现在将实验扩展一下，我们使用3组：</p>
<p>对照组：CK，正常浇水；</p>
<p>干预组不浇水，包括2组：</p>
<p>不浇水3天：T1</p>
<p>不浇水6天：T2</p>
<p>第一个方案：每组两个生物学重复，1个6标；</p>
<p>第二个方案：每组3个生物学重复，3个4标或1个9标，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717190254.png">

</div>
<h4 id="四组样本">四组样本</h4>
<p>对照组：CK，正常浇水</p>
<p>处理组：Treatment</p>
<p>不浇水3天：T1</p>
<p>不浇水6天：T2</p>
<p>不浇水9天：T3</p>
<p>方案一：每组2个生物学重复，1个8标；</p>
<p>方案二：每组3个生物学重复，3个4组，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717190615.png">

</div>
<h4 id="五组样本">五组样本</h4>
<p>对照组：CK，正常浇水</p>
<p>处理组：Treatment</p>
<p>不浇水1天：T1</p>
<p>不浇水2天：T2</p>
<p>不浇水3天：T3</p>
<p>不浇水4天：T4</p>
<p>方案一：每组3个生物学重复，3个5标；</p>
<p>方案二：每组3个生物学重复，3个6标，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717190812.png">

</div>
<h4 id="六组样本">六组样本</h4>
<p>对照组：CK，正常浇水</p>
<p>处理组：</p>
<p>不浇水1天：T1</p>
<p>不浇水2天：T2</p>
<p>不浇水3天：T3</p>
<p>不浇水4天：T4</p>
<p>不浇水5天：T5，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717190946.png">

</div>
<h3 id="实验方案小结">实验方案小结</h3>
<ul>
<li>需要比较的差异分组放在同一组标记中；</li>
<li>不同组织部位不要放在一组标记中检测；</li>
<li>生物学重复可分批上机，此时可不需要内参；</li>
<li>可将所有样本混合作为内参，分析时可通过内参间接找到有无变化的蛋白质。</li>
</ul>
<h1 id="蛋白数据分析流程">蛋白数据分析流程</h1>
<p>iTRAQ定量蛋白组数据分析流程如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717191336.png">

</div>
<p>从质谱仪上拿到的数据是原始质谱数据，然后要将原始数据进行一个数据格式转换，数据转换后，要进行搜库来鉴定蛋白质，这一步是要看找到了多少个蛋白质，随后对找到的蛋白进行蛋白定量。</p>
<p>定量后就是各种分析，包括GO，KEGG，蛋白相互作用等。</p>
<h3 id="一搜库">[一]搜库</h3>
<p><code>搜库</code>是指通过实验得到的谱图与数据库中的理论谱图进行匹配，得到可能的肽段序列，从而鉴定蛋白质，进行搜库的操作就是将质谱仪得到的谱图输入到搜库软件，常用的搜库软件包括：</p>
<ul>
<li>ProteinPilot(AB SCIEX)</li>
<li>Proteome Discoverer(Thermo scientific)</li>
<li>Mascot（这个软件是上述2个软件的核心）</li>
</ul>
<p>数据的产生其实就是：<code>蛋白-&gt;肽段-&gt;谱图</code>；而数据分析就是这个过程的逆过程，即<code>谱图-&gt;肽段-&gt;蛋白</code>。</p>
<p>整个流程如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717191954.png">

</div>
<h4 id="搜库的原理">搜库的原理</h4>
<p>搜库软件运行的主要步骤包括：</p>
<ol style="list-style-type: decimal">
<li>从数据库中选择分子量与输入值相等的肽段；</li>
<li>形成理论碎片，并进一步生成理论谱图；</li>
<li>将实验谱图与理论谱图进行匹配；</li>
<li>对匹配进行打分；</li>
<li>按打分进行排序，通过统计学分析，确定最佳的匹配结果并导出。</li>
</ol>
<p>流程示意图如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717192309.png">

</div>
<h4 id="搜库数据库的选择">搜库数据库的选择</h4>
<p>数据库的选择是基于质谱数据的蛋白质鉴定策略中的重要一步，最终鉴定到的蛋白序列都来源于被选择的数据库。</p>
<ul>
<li>如果是已经测序的生物，直接选用该物种蛋白数据库(NCBI)，或同批样本转录组数据构建的蛋白库。</li>
<li>如果是非测序生物，则选择与被测样本最为相关的大类蛋白质组数据库；</li>
<li>NCBInr分类库，包括动物全库、植物全库、微生物全库、细菌全部库等。</li>
<li>SwissProt/UniProt分类库，动物全库、植物全库、微生物全库、细菌库等。</li>
</ul>
<h4 id="蛋白质谱鉴定的结果">蛋白质谱鉴定的结果</h4>
<p>定量蛋白质鉴定数目一般在几千左右，远少于转录组检测的表达的基因数目和参考基因组的基因数目，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717192758.png">

</div>
<p>右上图是根据分析量来确定的蛋白数据，右下图是根据肽段来确定的鉴定的蛋白数目。蛋白鉴定的数目跟转录鉴定的基因不在一个数量级上，这是因为蛋白质谱在实验的通量，数据库，实验技术方面都有一定的局限。</p>
<h3 id="二蛋白质功能注释">[二]蛋白质功能注释</h3>
<p>通过搜库对蛋白质进行鉴定后，接着就是对这些搜到的蛋白进行功能注释，这有助于了解蛋白的功能，从而解析样本相关表型，常用于功能注释的数据库有：GO、COG、KEGG、NR、Pfam、Swiss-Prot，下图是一个玉米的项目，玉米的蛋白在各个数据库中的注释结果：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717193450.png">

</div>
<h4 id="数据库介绍">数据库介绍</h4>
<h5 id="nr">NR</h5>
<p>全称是Non-redundant protein sequences，包含GenBank所有编码序列，以及PDB，swissprot，PIR，PRF数据库的所有编码序列的一个非冗余数据库，其数据库完整度高；这是一个氨基酸序列数据库。</p>
<h5 id="pfam">Pfam</h5>
<p>全称是Protein families database，通过蛋白序列的比对建立了每个家族的氨基酸序列的HMM统计模型，是最全面的蛋白结构域注释的分类系统；通过识别蛋白质的结构域序列，可以预测蛋白质的功能。</p>
<h5 id="swiss-prot">Swiss-Prot</h5>
<p>这是上EBI维护的数据库，主要收录人工注释的序列及其相关文献信息和经过计算机辅助分析的序列；注释结果包括对蛋白质功能、酶学特性、剪接异构体、相关疾病信息的注释等待，注释结果无冗余。</p>
<h5 id="cog">COG</h5>
<p>全称是Clusters of Orthologous Groups of proteins，这是一个蛋白质直系同源数据库。通过对菌类，藻类和真核生物等66个完整基因组的编码蛋白，根据系统进化关系构建而成。这对于预测单个蛋白的功能和整个基因组中蛋白质的功能具有重要的作用。</p>
<h5 id="go与kegg">GO与KEGG</h5>
<p>常见，不介绍。</p>
<h3 id="三定量">[三]定量</h3>
<h4 id="蛋白定量原理回顾">蛋白定量原理回顾</h4>
<p>先来了解一下iTRAQ蛋白质定量的原理，如下所示：</p>
<ul>
<li>iTRAQ试剂是等量的，因此不同同位素在标记同一多肽后在一级质谱检测中，分子量完全相同。</li>
<li>在一级质谱检测到前体离子后进行碰撞诱导解离，产物离子通过二级质谱进行分析。</li>
<li>在二级质谱中，报告基团、质量平衡基团和多肽反应基团之间的键断裂，质量平衡基团丢失，产生低质荷比(m/z)的报告离子。</li>
<li>由于二级质谱可分析相对分子质量相差为1的报告基团，不同报告基团离子强度的差异就代表了它所标记的多肽相对丰度。</li>
<li>多肽内的酰胺键断裂，形成一系列b离子和y离子，得到离子片段的质量数，通过搜库就可以鉴别出相应蛋白质。</li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717195201.png">

</div>
<h4 id="蛋白定量分析工具">蛋白定量分析工具</h4>
<ul>
<li>常用的软件前面已经提了，包括：IQuant(BGI), ProteinPilot(AB SCIEX)、Proteome Discoverer(Thermo scientific)</li>
<li><a href="https://onlinelibrary.wiley.com/doi/full/10.1002/pmic.201300361" target="_blank" rel="external">IQuant</a>：整合了Mascot算法，采用机器学习算法自动对搜索结果进行重新打分，提高结果的鉴定率。</li>
</ul>
<p>核心的值有3个：</p>
<ol style="list-style-type: decimal">
<li>在谱图/肽段水平进行1%FDR的过滤(PSM-level PDF&lt;=0.01)，获得显性性鉴定的谱图和肽段列表。</li>
<li>基于<strong>简约原则</strong>(the parsimony principle)， 利用肽段进行蛋白组装，并生产一系列的蛋白组。</li>
<li>在蛋白质水平以FDR 1%再次进行过滤(Protein-level FDR&lt;=0.01)，以控制蛋白的假阳性。</li>
</ol>
<p>IQuant的工作流程为：</p>
<p><code>蛋白质过滤 --&gt; 报告基团标签纯度校正 --&gt; 定量值归一化 --&gt; 缺失值补全 --&gt; 蛋白定量值计算 --&gt; 统计检验</code>。</p>
<h3 id="四差异蛋白筛选">[四]差异蛋白筛选</h3>
<p>对蛋白进行定量后，需要对蛋白的差异进行筛选，筛选的内容包括3个，如下所示：</p>
<ul>
<li>根据实验设计来设置差异分析，例如<code>A_VS_B</code>；</li>
<li>显示差异蛋白选择的阈值，Fold Change &gt; 1.2或1.5和Q-value &lt; 0.05；</li>
<li>统计学方法：t-test或ANOVA。</li>
</ul>
<p>现在来看一个差异计算后的结果：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717200544.png">

</div>
<p>第1列是蛋白名称；</p>
<p>第2列到第4列是3个生物学重复；</p>
<p>第5列与第6列是FC与pvalue。</p>
<h3 id="五富集分析">[五]富集分析</h3>
<p>富集分析常见的就是GO分析与KEGG分析，不介绍。</p>
<h3 id="六表达聚类和蛋白互作">[六]表达聚类和蛋白互作</h3>
<p>表达聚类分析的核心就是热图与聚类图，不介绍。</p>
<p>蛋白相互作用通常使用的数据库是STRING数据库，它能分析预测差异蛋白质之间的互作关系，这个数据库的主要信息如下</p>
<ul>
<li>STRING是一个搜索已知蛋白之间和预测蛋白之间相互作用系统的数据库，包括蛋白质直接物理的相互作用，也包括蛋白质之间间接功能相关性；</li>
<li>数据包括：实验数据、从PubMed摘要中挖掘结果，利用生物信息学方法预测的结果；</li>
<li>通过打分对不同方法得来的结果给予一定权重，得到综合打分，且可根据打分结果绘制蛋白相互作用网络图，它的网络图如下所示：</li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717201930.png">

</div>
<h2 id="案例解析">案例解析</h2>
<p>先来看一篇文献，文献内容如下所示：</p>
<p>Liancheng Wu, Shunxi Wang, Lei Tian, Liuji Wu, Mingna Li, Jun Zhang, Pei Li, Weiqiang Zhang, Yanhui Chen Comparative proteomic analysis of the maize responses to early leaf senescence induced by preventing pollination,Journal of Proteomics,Volume 177,2018,Pages 75-87,ISSN 1874-3919.</p>
<h3 id="研究背景">研究背景</h3>
<p>玉米是一种一年生作物，叶片衰老的过早或过晚都可能会影响产量，在成熟后期，营养物质的再活化受到负面影响，导致幼叶的光合作用受损和系列能力下降，相反，过早的叶片衰老则阻碍了植物生长并降低其CO2的同化能力。叶片衰老是一个高度调控的过程，由几个称为衰老相关基因(SAGs)的基因介导，然后在蛋白质水平上仅鉴定了少数SAG。目前，使用蛋白质组学分析全体蛋白质波动比功能分析的转录组学更有效，因为蛋白质与功能更直接相关。本研究的目的是，研究玉米阻断授粉诱导叶片衰老过程中蛋白质的全局差异积累和代谢物质的变化。</p>
<h4 id="叶片衰老的生理特征">叶片衰老的生理特征</h4>
<p>叶片衰老通常与植物衰老以及开花和种子形成有关。叶色也与叶片衰老有关，是植物重合周期阶段的可见指标。叶片衰老时会出现一系列的生理过程，包括叶绿素分解、光合作用停止、蛋白质和核酸降解、分解代谢和营养物质的运输，以及细胞死亡反应，从而导致营养物质再循环到新发育的营养器官和生殖器官。</p>
<h4 id="分子机制研究进展">分子机制研究进展</h4>
<p>叶片衰老可以通过许多环境和内源信号来调节，包括年龄、发育信号和植物生长调节剂。植物激素与植物中的各种生物过程（包括叶片衰老）相关，如外源施用脱落酸(ABA)可促进叶片衰老，内源ABA水平在几种植物叶片衰老后增加。</p>
<p>水杨酸(SA)是另一种对叶片衰老正调控的植物激素，而生长素、细胞分裂素和赤霉素对叶片衰老有负调控作用。</p>
<p>糖代谢是与叶片衰老相关的另一因素，如糖类直接应用于拟南芥的叶细胞会导致早衰。</p>
<h4 id="表型分析糖">表型分析－糖</h4>
<p>实验材料：授粉(POL)和不授粉(NPNPOL)的玉米自交系Yu816。</p>
<p>发育时间：吐丝扣6天到21天(DAS)。</p>
<p>参数检测：叶片的可溶性糖含量和淀粉含量。</p>
<p>分析结果：</p>
<p>可溶性糖，6-18 DAS两种材料中均增加；21 DAS和POL中稍微下降，而NONPL的大量下降。</p>
<p>淀粉：趋势与可溶性糖类似，数据如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717203730.png">

</div>
<h4 id="表型分析-叶片形态和叶绿素分析">表型分析-叶片形态和叶绿素分析</h4>
<ul>
<li><p>穗叶和上部的叶片；</p></li>
<li><p>两组材料在6-14 DAS时一样保持绿色。</p></li>
<li><p>NONPOL组，18 DAS时叶脉积累红色色素，尖端变黄且干燥；21 DAS时穗叶的三分之二变黄；27 DAS时叶片完全干燥。</p></li>
<li><p>POL组，仅在27 DAS时表现出轻微黄色。</p></li>
<li><p>叶绿素含量：</p></li>
<li><p>NONPOL组，穗叶尖端在6-27 DAS显著下降（相对中部和基部），而同时POL组只是稍微一些辞职。</p></li>
<li><p>相同的趋势也发生在穗叶的中部和基部。</p></li>
<li><p>在两组中Chl含量随着发育而下降，但是NONPOL组比POL组下降得更快，数据如下所示：</p></li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717204222.png">

</div>
<h3 id="itaaq蛋白组实验设计">iTAAQ蛋白组实验设计</h3>
<p>样本数目：7组样本，8标，每个3个生物学重复</p>
<p>实验材料：玉米自交系Yu816</p>
<p>实验处理：授粉(POL)、不授粉(NONPOL)</p>
<p>取样部位：叶片</p>
<p>取样时间点：吐丝后6天(DAS)、14天、18天和21天</p>
<p>生物学重复：3个</p>
<p>方法与仪器：iTRAQ、LC-MS/MS(Thermo Fisher Scientific, Q-exactive)</p>
<p>流程如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717204548.png">

</div>
<h3 id="蛋白质组整体分析">蛋白质组整体分析</h3>
<p>文章的附件中列出了蛋白质谱的一些数据，得到了959464个广谱，其中150650匹配上肽段谱图，通过Mascot软件匹配上已知多肽，且28605个匹配上唯一多肽。</p>
<p>鉴定了6941个蛋白，其中4371个唯一蛋白时至少有两个以上肽段匹配的，数据如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717205151.png">

</div>
<h3 id="筛选差异蛋白分析">筛选差异蛋白分析</h3>
<ul>
<li>文献中使用了ANOVA来筛选差异蛋白(DAP)，其中阈值为：FC大于1.2或小于0.83(0.83其实就是1.2的倒数)，p值小于0.05。</li>
<li>POL组有700个显著差异积累的蛋白，NONPOL组有1832个；</li>
<li>其中261中仅在POL中显著积累，1393个只在NONPOL组中显著积累，而439个在两组均显著积累；</li>
<li>分析不同时间诱导的衰老：A1 VS B1， A2 vs B2， A3 VS B3；1443个显著差异积累，其中809个仅在NONPOL中显著差异积累，然后进一步分析在14 DAS、18 DAS和21 DAS的做好心理情况下，以及上下调情况；</li>
<li>通过比较本研究和之前文献报告的玉米自交系B73阻断授粉诱导衰老的转录组研究，发现两个数据集仅有154个重叠的基因，这说明在Yu816中有着相对不同的调控机制：</li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717205707.png">

</div>
<h3 id="差异蛋白功能分析go和kegg分析">差异蛋白功能分析—GO和KEGG分析</h3>
<ul>
<li>对NONPOL组809个DAP进分别进行GO和KEGG分析，使用cytoscape、Cluego和Cluepedia软件绘制GO注释和KEGG网络图；</li>
<li>通过评分得到65条边连接的36个Term， 表明在鉴定的蛋白质相互作用组中相当多的富集(P&lt;0.05)；</li>
<li>显著富集的Term：光合作用、光合作用光系统II、生长素生物合成过程、JA代谢过程、器官衰老、络氨酸代谢、脯氨酸生物合成过程；</li>
<li>从亚细胞定位角度来看，显著宝座的蛋白主要定位于叶绿体、光合体系、过氧化酶体和核糖体，如下所示：</li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717210255.png">

</div>
<h3 id="差异蛋白表达分析">差异蛋白表达分析</h3>
<p>表达分析的核心就是热图与聚类。</p>
<ul>
<li>在诱导叶片衰老过程中，大多数核糖体蛋白质丰度下降，包括50S核糖体蛋白L5-1(B6SST7)， 其在14 DAS时稍微下降了0.98倍，在18 DAS时下降了0.8倍，但在21 DAS下降到了0.6。</li>
<li>NONPOL组蛋白酶丰度增加，如光胱氨酸蛋白酶1(B6TGM9)在14 DAS增加1.09倍，在18 DAS时增加1.43位，21 DAS时增加到了2.89倍。</li>
<li>在差异积累的蛋白质中，29种与光合作用有关，并且大部分光合作用相关蛋白丰度减少，例如PSII反应中心蛋白H(P24993)在14 DAS时减少了1.00倍，在18 DAS时为0.72倍，在21 DAS时为0.46倍，如下所示：</li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717210704.png">

</div>
<ul>
<li>糖代谢相关的蛋白质在NONPOL组中丰度增加，如淀粉合酶，和叶绿体/淀粉体蛋白（B6U167)在14 DAS时半圆了0.98倍，在18 DAS时增加了1.18倍，21 DAS的1.65倍；</li>
<li>参与ROS过程的蛋白质，抗氧化蛋白质在诱导叶片衰老过程中丰度降低了，例如铁氧还原蛋白(Q6JAD2)在14 DAs时减少了0.84位，在18 DAS时减少了0.76倍，在21 DAS时减少了0.55倍；</li>
<li>但是氧化蛋白质各类如脂氧合酶(Q8W0V2)在14 DAS时增加了0.87倍，在18 DAS时增加了1.78倍，在21 DAS时增加了2.26倍；</li>
<li>ABA响应蛋白(B6U8P6)在14 DAS时增加了0.88倍，在18 DAS时增加了1.32倍，在21 DAS时增加了1.5倍；但与生长素和赤霉素相关的蛋白质丰度降低，数据如下所示：</li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717211150.png">

</div>
<p>文章最后使用WB进行验证，测序类文章中基本上都要有验证，这一部分略去不表。</p>
<p>文章到此就结束了，整个文献的数据分析思路如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717211539.png">

</div>
<p>简化一下就是下图：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190717211604.png">

</div>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="http://www.fitgene.com/fuwu/danbaizhizuxue/iTRAQ.html" target="_blank" rel="external">iTRAQ标记定量蛋白质组学.辉骏生物</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28203867" target="_blank" rel="external">iTRAQ(稳定同位素标记蛋白质组学技术)</a></li>
<li><a href="https://sciex.com/products/consumables/itraq-reagent" target="_blank" rel="external">iTRAQ® Reagents</a></li>
<li><a href="iTRAQ/TMT.MtoZ%20Biolabs%20Experit%20in%20Mass%20Spectrometry%20Analysis">iTRAQ/TMT.MtoZ Biolabs Experit in Mass Spectrometry Analysis</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/07/02/Python/Python数据处理笔记02-Excel文件处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/Python/Python数据处理笔记02-Excel文件处理/" itemprop="url">Python数据分析02-Excel文件处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-02T12:00:00+08:00">
                2019-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,929
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="python处理excel的包">Python处理Excel的包</h2>
<p>在PYthon中处理Excel文件（扩展名为<code>.xls</code>和<code>.xlsx</code>的文件）的扩展包为<code>xlrd</code>和<code>xlwt</code>，这两个包对Excel中的日期型数据支持非常好。而在Anaconda Python中，已经含有了这两个包，不用额外安装。如果是最原始版本的Python，则需要下载这两个包。</p>
<p>书中关于这两个包的介绍并不多，因此一些参数只是告诉你了要么用，至于这个参数具体是做什么的，这个包的某些函数还有没有其它的参数，作者并没有多讲，因此可以检索一下<code>xlrd</code>和<code>xlwt</code>这两个包的文档。</p>
<p><a href="https://xlrd.readthedocs.io/en/latest/index.html" target="_blank" rel="external">xlrd文档</a></p>
<p><a href="https://xlwt.readthedocs.io/en/latest/" target="_blank" rel="external">xlwt文档</a></p>
<h2 id="练习数据下载">练习数据下载</h2>
<p>《Python数据分析基础》这本书中的<a href="https://github.com/cbrownley/foundations-for-analytics-with-python" target="_blank" rel="external">源数据和源代码</a>已经上传至Github上，自己可以下载下来。</p>
<p>下载后的Excel练习数据一共是3个，名称分别为：<code>sales_2013</code>，<code>sales_2014</code>和<code>sales_2015</code>。其中以<code>sales_2013</code>为例说明一下，这个文件中一共有3个Excel表格，名称分别为<code>january_2013</code>，<code>february_2013</code>和<code>march_2013</code>。</p>
<p>Excel与csv文件的不同之处在于，一个Excel文件（后文称为一个Exce工作薄）含有多个工作表（sheet）。通过工作簿的内省可以获取工作表的信息：</p>
<blockquote>
<p>Python的内省（Introspection）是一种自我检查行为。在编程过程中，自省能够获取对象的类型与属性。</p>
</blockquote>
<p>注：在这篇笔记中，工作簿是指一个Excel文件，而一个工作簿中则中含有多个工作表。</p>
<h2 id="获取工作表的信息">获取工作表的信息</h2>
<p>下面的代码命名为<code>1excel_introspect_workbook.py</code>，它的功能在于获取一个Excel文件中工作表的数量、名称和每个工作表中行与列的数量，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> xlrd <span class="keyword">import</span> open_workbook</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">workbook = open_workbook(input_file)</div><div class="line">print(<span class="string">'Number of worksheets:'</span>, workbook.nsheets)</div><div class="line"><span class="keyword">for</span> worksheet <span class="keyword">in</span> workbook.sheets():</div><div class="line">    print(<span class="string">"Worksheet name:"</span>, worksheet.name, <span class="string">'\tRows:'</span>, \</div><div class="line">          worksheet.nrows, <span class="string">'\tColumns:'</span>, worksheet.ncols)</div></pre></td></tr></table></figure>
<p>运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python <span class="number">1</span>excel_introspect_workbook.py sales_2013.xlsx</div><div class="line">Number of worksheets: <span class="number">3</span></div><div class="line">Worksheet name: january_2013    Rows: <span class="number">7</span>         Columns: <span class="number">5</span></div><div class="line">Worksheet name: february_2013   Rows: <span class="number">7</span>         Columns: <span class="number">5</span></div><div class="line">Worksheet name: march_2013      Rows: <span class="number">7</span>         Columns: <span class="number">5</span></div></pre></td></tr></table></figure>
<p>解释代码：</p>
<ol style="list-style-type: decimal">
<li>使用<code>open_workbook</code>函数打开了一个Excel主文件，并赋给了一个名为<code>workbook</code>的对象，这个对象中包含了工作簿中的所有可用的信息，可以查看一下，如下所示：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(workbook)</div><div class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__enter__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__exit__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'_all_sheets_count'</span>, <span class="string">'_all_sheets_map'</span>, <span class="string">'_externsheet_info'</span>, <span class="string">'_externsheet_type_b57'</span>, <span class="string">'_extnsht_count'</span>, <span class="string">'_extnsht_name_from_num'</span>, <span class="string">'_repr_these'</span>, <span class="string">'_resources_released'</span>, <span class="string">'_rich_text_runlist_map'</span>, <span class="string">'_sh_abs_posn'</span>, <span class="string">'_sharedstrings'</span>, <span class="string">'_sheet_list'</span>, <span class="string">'_sheet_names'</span>, <span class="string">'_sheet_num_from_name'</span>, <span class="string">'_sheet_visibility'</span>, <span class="string">'_sheethdr_count'</span>, <span class="string">'_supbook_addins_inx'</span>, <span class="string">'_supbook_count'</span>, <span class="string">'_supbook_locals_inx'</span>, <span class="string">'_supbook_types'</span>, <span class="string">'_xf_epilogue_done'</span>, <span class="string">'_xf_index_to_xl_type_map'</span>, <span class="string">'actualfmtcount'</span>, <span class="string">'addin_func_names'</span>, <span class="string">'biff2_8_load'</span>, <span class="string">'biff_version'</span>, <span class="string">'builtinfmtcount'</span>, <span class="string">'codepage'</span>, <span class="string">'colour_map'</span>, <span class="string">'countries'</span>, <span class="string">'datemode'</span>, <span class="string">'derive_encoding'</span>, <span class="string">'dump'</span>, <span class="string">'encoding'</span>, <span class="string">'fake_globals_get_sheet'</span>, <span class="string">'filestr'</span>, <span class="string">'font_list'</span>, <span class="string">'format_list'</span>, <span class="string">'format_map'</span>, <span class="string">'formatting_info'</span>, <span class="string">'get2bytes'</span>, <span class="string">'get_record_parts'</span>, <span class="string">'get_record_parts_conditional'</span>, <span class="string">'get_sheet'</span>, <span class="string">'get_sheets'</span>, <span class="string">'getbof'</span>, <span class="string">'handle_boundsheet'</span>, <span class="string">'handle_builtinfmtcount'</span>, <span class="string">'handle_codepage'</span>, <span class="string">'handle_country'</span>, <span class="string">'handle_datemode'</span>, <span class="string">'handle_externname'</span>, <span class="string">'handle_externsheet'</span>, <span class="string">'handle_filepass'</span>, <span class="string">'handle_name'</span>, <span class="string">'handle_obj'</span>, <span class="string">'handle_sheethdr'</span>, <span class="string">'handle_sheetsoffset'</span>, <span class="string">'handle_sst'</span>, <span class="string">'handle_supbook'</span>, <span class="string">'handle_writeaccess'</span>, <span class="string">'initialise_format_info'</span>, <span class="string">'load_time_stage_1'</span>, <span class="string">'load_time_stage_2'</span>, <span class="string">'logfile'</span>, <span class="string">'mem'</span>, <span class="string">'name_and_scope_map'</span>, <span class="string">'name_map'</span>, <span class="string">'name_obj_list'</span>, <span class="string">'names_epilogue'</span>, <span class="string">'nsheets'</span>, <span class="string">'on_demand'</span>, <span class="string">'palette_record'</span>, <span class="string">'parse_globals'</span>, <span class="string">'props'</span>, <span class="string">'ragged_rows'</span>, <span class="string">'raw_user_name'</span>, <span class="string">'read'</span>, <span class="string">'release_resources'</span>, <span class="string">'sheet_by_index'</span>, <span class="string">'sheet_by_name'</span>, <span class="string">'sheet_loaded'</span>, <span class="string">'sheet_names'</span>, <span class="string">'sheets'</span>, <span class="string">'style_name_map'</span>, <span class="string">'unload_sheet'</span>, <span class="string">'use_mmap'</span>, <span class="string">'user_name'</span>, <span class="string">'verbosity'</span>, <span class="string">'xf_list'</span>, <span class="string">'xfcount'</span>]</div></pre></td></tr></table></figure>
<ol start="2" style="list-style-type: decimal">
<li><code>name</code>属性则是获取每个sheet的名称，<code>nrow</code>与<code>ncol</code>则是获取每个sheet的行与列的数目</li>
</ol>
<h2 id="处理单个sheet">处理单个sheet</h2>
<h3 id="读写excel文件">读写Excel文件</h3>
<p>下面的代码功能在于读取一个excel文件，名称为<code>2excel_parsing_and_write.py</code>，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> xlrd <span class="keyword">import</span> open_workbook</div><div class="line"><span class="keyword">from</span> xlwt <span class="keyword">import</span> Workbook</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line">output_workbook = Workbook()</div><div class="line"><span class="comment"># Create an Workbook object</span></div><div class="line"><span class="comment"># Workbook object is intended for output</span></div><div class="line"></div><div class="line">output_worksheet = output_workbook.add_sheet(<span class="string">'jan_2013_output'</span>)</div><div class="line"><span class="comment"># add_sheet function is adding an sheet</span></div><div class="line"><span class="keyword">with</span> open_workbook(input_file) <span class="keyword">as</span> workbook:</div><div class="line">    worksheet = workbook.sheet_by_name(<span class="string">'january_2013'</span>)</div><div class="line">    <span class="keyword">for</span> row_index <span class="keyword">in</span> range(worksheet.nrows):</div><div class="line">        <span class="keyword">for</span> column_index <span class="keyword">in</span> range(worksheet.ncols):</div><div class="line">            output_worksheet.write(row_index, column_index, \</div><div class="line">                                   worksheet.cell_value(row_index, column_index))</div><div class="line">            <span class="comment"># write function is use for writing data into output files</span></div><div class="line">output_workbook.save(output_file)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python <span class="number">2</span>excel_parsing_and_write.py sales_2013.xlsx <span class="number">2</span>output.xls</div></pre></td></tr></table></figure>
<p>打开<code>2output.xls</code>后如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190630141416.png">

</div>
<p>其中第5列，也就是<code>Purchase Date</code>这一列是数字，而不是日期。Excel会将日期和时间保存为浮点数，这个浮点数代表从1900年1月0日起经过的日期数，加上一个24小时的小数部分。例如数值1表示1900年1月1日，因为从1900年1月0日是过去了1天，因此这一列中的数值代表日期，只是这是没有经过格式化的日期数据。</p>
<p><code>xlrd</code>能够格式化这种日期。</p>
<h2 id="格式化日期">格式化日期</h2>
<h3 id="常规方法">常规方法</h3>
<p>格式化日期的Python代码保存为<code>3excel_parsing_and_write_keep_dates.py</code>，代码内容如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</div><div class="line"><span class="comment"># date function is used to format date data</span></div><div class="line"><span class="keyword">from</span> xlrd <span class="keyword">import</span> open_workbook, xldate_as_tuple</div><div class="line"><span class="comment"># xldate_as_tuple is to transform data representing date, time into tuple</span></div><div class="line"><span class="keyword">from</span> xlwt <span class="keyword">import</span> Workbook</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line">output_workbook = Workbook()</div><div class="line">output_worksheet = output_workbook.add_sheet(<span class="string">'jan_2013_output'</span>)</div><div class="line"></div><div class="line"><span class="keyword">with</span> open_workbook(input_file) <span class="keyword">as</span> workbook:</div><div class="line">    worksheet = workbook.sheet_by_name(<span class="string">'january_2013'</span>)</div><div class="line">    <span class="keyword">for</span> row_index <span class="keyword">in</span> range(worksheet.nrows):</div><div class="line">        row_list_output = []</div><div class="line">        <span class="keyword">for</span> col_index <span class="keyword">in</span> range(worksheet.ncols):</div><div class="line">            <span class="keyword">if</span> worksheet.cell_type(row_index, col_index) == <span class="number">3</span>:</div><div class="line">                <span class="comment"># value 3 represents cell that include date data</span></div><div class="line">                date_cell = xldate_as_tuple(worksheet.cell_value\</div><div class="line">                                                (row_index, col_index), workbook.datemode)</div><div class="line">                <span class="comment"># datemode determine date is based on 1900 or 1904 </span></div><div class="line">                date_cell = date(*date_cell[<span class="number">0</span>:<span class="number">3</span>]).strftime\</div><div class="line">                    (<span class="string">'%m/%d/%Y'</span>)</div><div class="line">                row_list_output.append(date_cell)</div><div class="line">                output_worksheet.write(row_index, col_index, date_cell)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                non_date_cell = worksheet.cell_value\</div><div class="line">                    (row_index, col_index)</div><div class="line">                row_list_output.append(non_date_cell)</div><div class="line">                output_worksheet.write(row_index, col_index, \</div><div class="line">                                       non_date_cell)</div><div class="line">output_workbook.save(output_file)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python <span class="number">3</span>excel_parsing_and_write_keep_dates.py sales_2013.xlsx date_output.xls</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190630150632.png">

</div>
<h2 id="使用pandas读取excel文件">使用<code>pandas</code>读取Excel文件</h2>
<p>使用<code>pandas</code>也可以读取Excel文件，将下面的代码保存为<code>pandas_read_and_write_excel.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">data_frame = pd.read_excel(input_file, sheetname = <span class="string">'january_2013'</span>)</div><div class="line">writer = pd.ExcelWriter(output_file)</div><div class="line">data_frame.to_excel(writer, sheet_name = <span class="string">'jan_13_output'</span>, index = <span class="keyword">False</span>)</div><div class="line">writer.save()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS D:\netdisk\python_data&gt; python .\pandas_read_and_write_excel.py .\sales_2013.xlsx pandas_output.xls</div></pre></td></tr></table></figure>
<h2 id="选取特定的行">选取特定的行</h2>
<p>现在挑出那些<code>Sale Amount</code>超过1400的行。</p>
<h3 id="常规python选择某一行">常规Python选择某一行</h3>
<p>保存下面代码，命名为<code>4excel_value_meets_condition.py</code>，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</div><div class="line"><span class="keyword">from</span> xlrd <span class="keyword">import</span> open_workbook,xldate_as_tuple</div><div class="line"><span class="keyword">from</span> xlwt <span class="keyword">import</span> Workbook</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line">output_workbook = Workbook()</div><div class="line">output_worksheet = output_workbook.add_sheet(<span class="string">'jan_2013_output'</span>)</div><div class="line">sale_amount_column_index = <span class="number">3</span></div><div class="line"><span class="keyword">with</span> open_workbook(input_file) <span class="keyword">as</span> workbook:</div><div class="line">    worksheet = workbook.sheet_by_name(<span class="string">'january_2013'</span>)</div><div class="line">    data = []</div><div class="line">    header = worksheet.row_values(<span class="number">0</span>)</div><div class="line">    data.append(header)</div><div class="line">    <span class="keyword">for</span> row_index <span class="keyword">in</span> range(<span class="number">1</span>, worksheet.nrows):</div><div class="line">        row_list = []</div><div class="line">        sale_amount = worksheet.cell_value\</div><div class="line">            (row_index, sale_amount_column_index)</div><div class="line">        <span class="keyword">if</span> sale_amount &gt; <span class="number">1400</span>:</div><div class="line">            <span class="keyword">for</span> column_index <span class="keyword">in</span> range(worksheet.ncols):</div><div class="line">                cell_value = worksheet.cell_value\</div><div class="line">                    (row_index, column_index)</div><div class="line">                cell_type = worksheet.cell_type\</div><div class="line">                    (row_index, column_index)</div><div class="line">                <span class="keyword">if</span> cell_type == <span class="number">3</span>:</div><div class="line">                    date_cell = xldate_as_tuple\</div><div class="line">                        (cell_value, workbook.datemode)</div><div class="line">                    date_cell = date(*date_cell[<span class="number">0</span>:<span class="number">3</span>])\</div><div class="line">                    .strftime(<span class="string">'%m/%d/%Y'</span>)</div><div class="line">                    row_list.append(date_cell)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    row_list.append(cell_value)</div><div class="line">        <span class="keyword">if</span> row_list:</div><div class="line">            data.append(row_list)</div><div class="line">    <span class="keyword">for</span> list_index, output_list <span class="keyword">in</span> enumerate(data):</div><div class="line">        <span class="keyword">for</span> element_index, element <span class="keyword">in</span> enumerate(output_list):</div><div class="line">            output_worksheet.write(list_index, element_index, element)</div><div class="line">output_workbook.save(output_file)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS D:\netdisk\python_data&gt; python .\<span class="number">4</span>excel_value_meets_condition.py .\sales_2013.xlsx <span class="number">4</span>output.xls</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190701153503.png">

</div>
<h3 id="pandas包选取某一行"><code>pandas</code>包选取某一行</h3>
<p>在下面的案例中，使用<code>pandas</code>挑出那些<code>Sale Amount</code>列大于1400的行。如果需要多个条件，则需要添加<code>&amp;</code>与<code>|</code>符号，代码文件保存为<code>pandas_value_meets_condition.py</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line">data_frame = pd.read_excel(input_file, <span class="string">'january_2013'</span>, index_col = <span class="keyword">None</span>)</div><div class="line">data_frame_value_meets_condition = \</div><div class="line">    data_frame[data_frame[<span class="string">'Sale Amount'</span>].astype(float) &gt; <span class="number">1400</span>]</div><div class="line">writer = pd.ExcelWriter(output_file)</div><div class="line">data_frame_value_meets_condition.to_excel(writer, sheet_name = <span class="string">'jan_13_output'</span>,\</div><div class="line">                                          index = <span class="keyword">False</span>)</div><div class="line">writer.save()</div></pre></td></tr></table></figure>
<p>运行代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS D:\netdisk\python_data&gt; python .\pandas_value_meets_condition.py .\sales_2013.xlsx pandas_output.xlsx</div></pre></td></tr></table></figure>
<p>打开<code>pandas_output.xlsx</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190702100612.png">

</div>
<h2 id="挑选满足多个条件的行">挑选满足多个条件的行</h2>
<p>例如在前面的数据中，我们要挑选<code>01/24/2013</code>与<code>01/31/2013</code>这两个购买日期的行，代码保存为<code>5excel_value_in_set.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">data_frame = pd.read_excel(input_file, <span class="string">'january_2013'</span>, index_col=<span class="keyword">None</span>)</div><div class="line">important_dates = [<span class="string">'01/24/2013'</span>,<span class="string">'01/31/2013'</span>]</div><div class="line">data_frame_value_in_set = data_frame[data_frame[<span class="string">'Purchase Date'</span>].isin(important_dates)]</div><div class="line">writer = pd.ExcelWriter(output_file)</div><div class="line">data_frame_value_in_set.to_excel(writer, sheet_name=<span class="string">'jan_13_output'</span>, index=<span class="keyword">False</span>)</div><div class="line">writer.save()</div></pre></td></tr></table></figure>
<p>运行以下代码即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\netdisk\python_data&gt;python <span class="number">5</span>excel_value_in_set.py sales_2013.xlsx pandas_output.xls</div></pre></td></tr></table></figure>
<h3 id="挑选满足某一特定模式的行">挑选满足某一特定模式的行</h3>
<p>任务：选择那些顾客的名字里，首字母是<code>J</code>的行，使用pandas来实现，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line">data_frame = pd.read_excel(input_file, <span class="string">'january_2013'</span>, index_col=<span class="keyword">None</span>)</div><div class="line">data_frame_value_matches_pattern = data_frame[data_frame[<span class="string">'Customer Name'</span>]\</div><div class="line">    .str.startswith(<span class="string">"J"</span>)]</div><div class="line">writer = pd.ExcelWriter(output_file)</div><div class="line">data_frame_value_matches_pattern.to_excel(writer, sheet_name=<span class="string">'jan_13_output'</span>,\</div><div class="line">                                          index=<span class="keyword">False</span>)</div><div class="line">writer.save()</div></pre></td></tr></table></figure>
<p>按如下方式运行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">λ python pandas_value_matches_pattern.py sales_2013.xlsx output_files\pandsa_output.xls</div></pre></td></tr></table></figure>
<h3 id="选取特定列">选取特定列</h3>
<p>使用Python选取特定的列的时，可以采用列索引值，也可以采用列标题来实现。</p>
<p>按索引值来提取列。****</p>
<p>现在假设我们想保留Customer Name和Purchase Date这两列，使用Pandas来实现，保存代码为<code>pandas_column_by_index.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line">data_frame = pd.read_excel(input_file, <span class="string">'january_2013'</span>, index_col = <span class="keyword">None</span>)</div><div class="line">data_frame_column_by_index = data_frame.iloc[:, [<span class="number">1</span>,<span class="number">4</span>]]</div><div class="line">writer  = pd.ExcelWriter(output_file)</div><div class="line">data_frame_column_by_index.to_excel(writer, sheet_name = <span class="string">'jan_13_output'</span>,index=<span class="keyword">False</span>)</div><div class="line">writer.save()</div></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/07/01/Python/Python数据处理笔记01-argv函数与读取csv文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/Python/Python数据处理笔记01-argv函数与读取csv文件/" itemprop="url">Python数据分析01-argv函数与读取或导出csv文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-01T12:00:00+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,352
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  28
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记的主要参考书是《Python数据分析基础》（[美] 克林顿·布朗利（Clinton，W.，Brownley） 著，陈光欣 译），封面如下：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629130344.png">

</div>
<p>作者在Github上已经放了<a href="https://github.com/cbrownley/foundations-for-analytics-with-python" target="_blank" rel="external">书中的源代码与数据文件</a>。</p>
<h2 id="sys.argv函数"><code>sys.argv[]</code>函数</h2>
<p><code>sys.argv[]</code>是用来获取命令行输入的参数的，<code>argv</code>的是<code>argument variable</code>的缩写。这个变量其实是一个List列表，其中参数和参数之间空格区分，<code>sys.argv[0]</code>表示代码本身文件路径，而<code>sys.argv[1]</code>表示获取的参数。现在看使用案例。</p>
<p>首选我们在桌面上新建一个<code>test.py</code>文件，输入内容如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">result = sys.argv[<span class="number">0</span>]</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>现在运行这段代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>&gt;cd Desktop</div><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python test.py</div><div class="line">test.py</div></pre></td></tr></table></figure>
<p>从上面的结果可以看出来，运行<code>test.py</code>文件返回了一个<code>test.py</code>字符，这是因为<code>sys.argv[0]</code>这个参数本身指的就是这个程序本身，这个程序就是<code>test.py</code>文件。现在更改一下<code>test.py</code>代码，将第2行的<code>result = sys.argv[0]</code>改为<code>result = sys.argv[1:]</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">result = sys.argv[<span class="number">1</span>:]</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>再次运行，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python test.py Hello, Python</div><div class="line">[<span class="string">'Hello,'</span>, <span class="string">'Python'</span>]</div><div class="line"></div><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python test.py Hello,Python</div><div class="line">[<span class="string">'Hello,Python'</span>]</div></pre></td></tr></table></figure>
<p>从上面看到，当我们输入<code>python test.py Hello, Python</code>时（请注意，<code>Hello,</code>与<code>Python</code>之间有一个空格），<code>sys.argv[1:]</code>就会接收输入的参数，并且以空格来进行区分，当用空格进行区分，这就是2个参数，这个列表中就有2个参数。当我们直接输入<code>Hello,python</code>（中间没有空格）时，就是一个参数，这个列表中就只有一个元素。</p>
<p>使用<code>sys.argv[]</code>来读取文件的代码如下所示：</p>
<p>在桌面上新建一个文本文档<code>test_text</code>，再新建一个<code>test.py</code>Python文件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">print(<span class="string">"Output:  "</span>)</div><div class="line">filereader = open(input_file, <span class="string">'r'</span>, newline= <span class="string">''</span>)</div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">    print(<span class="string">"&#123;&#125;"</span>.format(row.strip()))</div><div class="line"></div><div class="line">filereader.close()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python test.py test_text.txt</div><div class="line">Output:</div><div class="line">这是第<span class="number">1</span>行；</div><div class="line">这是第<span class="number">2</span>行；</div><div class="line">这是第<span class="number">3</span>行；</div><div class="line">这是第<span class="number">4</span>行；</div><div class="line">这是第<span class="number">5</span>行；</div></pre></td></tr></table></figure>
<p>还有一种代码，就是使用<code>with</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">print(<span class="string">"Output:  "</span>)</div><div class="line"><span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline= <span class="string">''</span>) <span class="keyword">as</span> filereader:</div><div class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">        print(<span class="string">"&#123;&#125;"</span>.format(row.strip()))</div><div class="line"></div><div class="line">filereader.close()</div></pre></td></tr></table></figure>
<h2 id="读取多个文本文件glob">读取多个文本文件<code>glob</code></h2>
<p>在实际应用过程中，有可能要同时读取多个文件。读取多个文件的实现方式之一就是在命令行中将包含输入文件目录的路径名写在Python脚本之后，如果要使用这种方法，就需要<code>os</code>模块与<code>glob</code>模块，那么完整的代码如下所示，这段代码位于桌面，命令为<code>directory_test.py</code>，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span>  exp, log, sqrt</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, time, datetime, timedelta</div><div class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</div><div class="line"><span class="keyword">import</span> glob</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">print(<span class="string">"Output:  "</span>)</div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line"><span class="keyword">for</span> input_file <span class="keyword">in</span> glob.glob(os.path.join(input_file, <span class="string">'*.txt'</span>)):</div><div class="line">    <span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> filereader:</div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">            print(<span class="string">"&#123;&#125;"</span>.format(row.strip()))</div></pre></td></tr></table></figure>
<p>使用<code>os</code>模块可以使用其提供的与路径相关的函数，例如<code>os.path.join</code>函数可以将一个或多个路径成分连接在一起，在上面的代码中，</p>
<p><code>glob</code>模块可以找出与特定模式相匹配的所有路径名。它可以将某目录下面跟通配符模式相同的文件放到一个列表中，有了这个函数中，我们想于生成所有文件的列表就不需要使用for循环遍历目录了，而是直接使用<code>glob.glob(path + pattern)</code>的方式进行获取，可以看一下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(glob.glob(<span class="string">r'.\*.py'</span>))</div><div class="line">[<span class="string">'.\\12csv_reader_add_header_row.py'</span>, <span class="string">'.\\8csv_reader_counts_for_multiple_ﬁles.py'</span>, <span class="string">'.\\pandas_add_header_row.py'</span>]</div></pre></td></tr></table></figure>
<p>这段代码表示的内容就是，搜索当前目录下的所有<code>.py</code>文件，并显示出来。</p>
<p>另外一个类似的函数则是<code>iglob</code>，此函数则是一次只检索一个文件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = glob.iglob(<span class="string">r'.\*.py'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> py <span class="keyword">in</span> f:</div><div class="line"><span class="meta">... </span>    print(py)</div><div class="line">...</div><div class="line">.\<span class="number">12</span>csv_reader_add_header_row.py</div><div class="line">.\<span class="number">8</span>csv_reader_counts_for_multiple_ﬁles.py</div><div class="line">.\pandas_add_header_row.py</div></pre></td></tr></table></figure>
<p><code>os</code>模块和<code>glob</code>模块组合在一起可以找出符合特定模式的某个文件夹下的所有文件。在这段代码的<code>for</code>循环中使用了<code>os.path.join</code>函数和<code>glob.glob</code>函数来找出符合特定模式的某个文件夹下面的所有文件。指向这个文件夹的路径包含在变量<code>input_file</code>中，这个变量需要在命令行中提供。<code>os.path.join</code>函数将这个文件夹路径和这个文件夹中所有符合特定模式的文件名连接起来，这种特定模式可以由<code>glob.glob</code>函数扩展。 这段代码使用是的模式<code>*.txt</code>来匹配由<code>.txt</code>结尾的所有文件名。</p>
<p>现在来演示一下这个案例。</p>
<p>在桌面上新建一个文件夹，命令为<code>test_directory</code>，在此目录下新建一个文本文件，命名为<code>test_1.txt</code>，输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">This </div><div class="line">text </div><div class="line">comes </div><div class="line">from </div><div class="line">a </div><div class="line">different </div><div class="line">text </div><div class="line">file.</div></pre></td></tr></table></figure>
<p>在此目录新建第二个文本文件，命名为<code>test_2.txt</code>，输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">这是第<span class="number">2</span>个txt文件；</div><div class="line">这是第<span class="number">2</span>个txt文件；</div><div class="line">这是第<span class="number">2</span>个txt文件；</div><div class="line">这是第<span class="number">2</span>个txt文件；</div><div class="line">这是第<span class="number">2</span>个txt文件；</div></pre></td></tr></table></figure>
<p>现在运行<code>directory_test.py</code>代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python directory_test.py <span class="string">"test_directory"</span></div><div class="line">Output:</div><div class="line">This</div><div class="line">text</div><div class="line">comes</div><div class="line"><span class="keyword">from</span></div><div class="line">a</div><div class="line">different</div><div class="line">text</div><div class="line">file.</div><div class="line">这是第<span class="number">2</span>个txt文件；</div><div class="line">这是第<span class="number">2</span>个txt文件；</div><div class="line">这是第<span class="number">2</span>个txt文件；</div><div class="line">这是第<span class="number">2</span>个txt文件；</div><div class="line">这是第<span class="number">2</span>个txt文件；</div></pre></td></tr></table></figure>
<h2 id="读取csv文件">读取<code>csv</code>文件</h2>
<p><code>csv</code>文件的全称为<code>comma-separated value</code>，即<code>逗号分隔值</code>，这是一种常用的数据存储格式。在Python中专门的<code>csv</code>模块，但这里先用最原始的python代码来实现一下。</p>
<h3 id="非csv模块读取csv文件">非csv模块读取csv文件</h3>
<p>在桌面上新建一个名为<code>read_csv.py</code>的Python文件，输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline = <span class="string">""</span>) <span class="keyword">as</span> filereader:</div><div class="line">    <span class="keyword">with</span> open(output_file, <span class="string">'w'</span>, newline = <span class="string">""</span>) <span class="keyword">as</span> filewriter:</div><div class="line">        header = filereader.readline() <span class="comment"># Read first line as header</span></div><div class="line">        header = header.strip()</div><div class="line">        header_list = header.split(<span class="string">','</span>)</div><div class="line">        print(header_list)</div><div class="line">        filewriter.wirte(<span class="string">','</span>.join(map(str,header_list)) + <span class="string">'\n'</span>)</div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">            row = row.strip()</div><div class="line">            row_list = row.split(<span class="string">','</span>)</div><div class="line">            print(row_list)</div><div class="line">            filewriter.write(<span class="string">','</span>.join(map(str, row_list)) + <span class="string">'\n'</span>)</div></pre></td></tr></table></figure>
<p>在桌面上新建一个<code>test_csv.csv</code>文件，输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">header1,header2</div><div class="line">test1,test2</div><div class="line"><span class="number">123</span>,<span class="number">345</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python read_csv.py test_csv.csv <span class="string">"test_out.csv"</span></div><div class="line">[<span class="string">'header1'</span>, <span class="string">'header2'</span>]</div><div class="line">[<span class="string">'test1'</span>, <span class="string">'test2'</span>]</div><div class="line">[<span class="string">'123'</span>, <span class="string">'345'</span>]</div></pre></td></tr></table></figure>
<p>现在桌面上就有了一个输出文件，名称为<code>test_out.csv</code>。</p>
<h3 id="使用pandas模块读取csv文件">使用<code>pandas</code>模块读取csv文件</h3>
<p><code>pandas</code>是一个开源的，BSD许可的库，为Python编程语言提供高性能，易于使用的数据结构和数据分析工具。pandas可以用于读取csv文件，在下面的这段代码中，会读取csv文件，然后输出读取的内容，在桌上上新建<code>pandas_test.py</code>文件，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line">data_frame = pd.read_csv(input_file)</div><div class="line">print(data_frame)</div><div class="line">data_frame.to_csv(output_file, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python pandas_test.py test_csv.csv <span class="string">"pandas_test.csv"</span></div><div class="line">  header1 header2</div><div class="line"><span class="number">0</span>   test1   test2</div><div class="line"><span class="number">1</span>     <span class="number">123</span>     <span class="number">345</span></div></pre></td></tr></table></figure>
<p>此时在桌面上生成一个叫<code>pandas_test.csv</code>的文件。</p>
<h3 id="使用csv模块读取csv文件">使用csv模块读取csv文件</h3>
<p>python内置的<code>csv</code>模块可以读取csv文件，现在在桌上新建一个名为<code>csv_module.py</code>的文件，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> csv</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">out_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_in_file:</div><div class="line">    <span class="keyword">with</span> open(out_file, <span class="string">'w'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_out_file:</div><div class="line">        filereader = csv.reader(csv_in_file, delimiter = <span class="string">','</span>) <span class="comment"># delimiter是指默认分割符，如果导入的文件是csv，其实是不用这个参数的</span></div><div class="line">        filewriter = csv.writer(csv_out_file, delimiter = <span class="string">','</span>)</div><div class="line">        <span class="keyword">for</span> row_list <span class="keyword">in</span> filereader:</div><div class="line">            print(row_list)</div><div class="line">            filewriter.writerow(row_list)</div></pre></td></tr></table></figure>
<p>现在运行一下这个文件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python csv_module.py test_csv.csv <span class="string">"csv_module_test.csv"</span></div><div class="line">[<span class="string">'header1'</span>, <span class="string">'header2'</span>]</div><div class="line">[<span class="string">'test1'</span>, <span class="string">'test2'</span>]</div><div class="line">[<span class="string">'123'</span>, <span class="string">'345'</span>]</div></pre></td></tr></table></figure>
<p>现在在桌上上生成了一个名为<code>csv_module_test.csv</code>的csv文件。</p>
<h2 id="读取特定的行">读取特定的行</h2>
<p>数据处理过程中通常会有一项操作是要把满足某个条件的某行数据给挑出来，通常有这几种方法：</p>
<ul>
<li>行中的值满足某个条件；</li>
<li>行中的值属于某个集合</li>
<li>行中的值匹配于某个模式（正则表达式）</li>
</ul>
<h3 id="满足某条件行的通用代码结构">满足某条件行的通用代码结构</h3>
<p>现在看一下以下的这段虚拟代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">    ***<span class="keyword">if</span> value <span class="keyword">in</span> row meets some business rule <span class="keyword">or</span> set of rules:***</div><div class="line">        do something</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    do something <span class="keyword">else</span></div></pre></td></tr></table></figure>
<p>这段代码描述的是在输入文件中筛选出特定行的通用代码结构。</p>
<p>在平时写代码过程中只需要修改<code>***</code>中的代码，以使脚本满足具体需要即可。</p>
<h3 id="行中的值满足某个条件">行中的值满足某个条件</h3>
<p>有数据分析的实现情况中，有的时候有这种需要：当行中的值满足一个具体条件时需要保留些行。例如，我们可能希望在数据集中保留那些成本高于某个阈值的行，或者希望保留所有购买日期在一个具体日期之前的行。</p>
<p>在这种情况下，我们就可以检验行中的值是否满足具体的条件，然后筛选出满足条件的行。现在我们来描述这么一个案例：</p>
<p>保留某个供应商名字为<code>Suuplier Z</code>的行，或者是成本大于600的行，并将结果写入某个文件中。</p>
<h3 id="使用csv模块某列-索引方法">使用<code>csv</code>模块某列-索引方法</h3>
<p>在csv文中选取特定列的一种方法就是使用列的索引值来提取。例如，如果想提取数据的第1列和最后1列，就使用<code>row[0]</code>和<code>row[-1]</code>来提取。</p>
<p>在下面的这个案例中，我们只想提取供应商姓名和成本这两列，就要使用索引值来聚会这两列。</p>
<p>现在我们在桌面上新建一个名为<code>select_meets_condition.py</code>的文件，输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> csv</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">my_columns = [<span class="number">0</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_in_file:</div><div class="line">    <span class="keyword">with</span> open(output_file, <span class="string">'w'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_out_file:</div><div class="line">        filereader = csv.reader(csv_in_file)</div><div class="line">        filewriter = csv.writer(csv_out_file)</div><div class="line">        <span class="keyword">for</span> row_list <span class="keyword">in</span> filereader:</div><div class="line">            row_list_output = []</div><div class="line">            <span class="keyword">for</span> index_value <span class="keyword">in</span> my_columns:</div><div class="line">                row_list_output.append(row_list[index_value])</div><div class="line">            filewriter.writerow(row_list_output)</div></pre></td></tr></table></figure>
<p>现在新建一个csv文件，这个文件就是我们要使用数据文件，把它命名为<code>supplier_data_unnecessary_header_footer</code>，内容如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">I don<span class="string">'t care about this row,,,,</span></div><div class="line"><span class="string">I don'</span>t care about this row,,,,</div><div class="line">I don<span class="string">'t care about this row,,,,</span></div><div class="line"><span class="string">Supplier Name,Invoice Number,Part Number,Cost,Purchase Date</span></div><div class="line"><span class="string">Supplier X,001-1001,2341,$500.00,1/20/14</span></div><div class="line"><span class="string">Supplier X,001-1001,2341,$500.00,1/20/14</span></div><div class="line"><span class="string">Supplier X,001-1001,5467,$750.00,1/20/14</span></div><div class="line"><span class="string">Supplier X,001-1001,5467,$750.00,1/20/14</span></div><div class="line"><span class="string">Supplier X,50-9501,7009,$250.00,1/30/14</span></div><div class="line"><span class="string">Supplier X,50-9501,7009,$250.00,1/30/14</span></div><div class="line"><span class="string">Supplier X,50-9501,6650,$125.00,2/3/14</span></div><div class="line"><span class="string">Supplier X,50-9501,6650,$125.00,2/3/14</span></div><div class="line"><span class="string">Supplier X,920-4803,3321,$615.00,2/3/14</span></div><div class="line"><span class="string">Supplier X,920-4803,3321,$615.00,2/10/14</span></div><div class="line"><span class="string">Supplier X,920-4803,3321,$615.00,2/17/14</span></div><div class="line"><span class="string">Supplier X,920-4803,3321,$615.00,2/24/14</span></div><div class="line"><span class="string">I don'</span>t want this row either,,,,</div><div class="line">I don<span class="string">'t want this row either,,,,</span></div><div class="line"><span class="string">I don'</span>t want this row either,,,,</div></pre></td></tr></table></figure>
<p>用Excel打开就是下面的这个样子：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190628183046.png">

</div>
<p>现在解释一下源代码：</p>
<ol style="list-style-type: decimal">
<li>在代码中我们使用了<code>my_columns = [0, 3]</code>这个变量，0与3就是我们要提取的列的位置，也就是对应的是<code>Supplier Name</code>和<code>Cost</code>这两列。</li>
<li>代码中有2个for循环，对于输入的文件，每一行都要执行这些代码。在第1个for循环中，创建了一个空列表变量<code>row_list_output</code>。这个变量保存的是，每行中需要保留的值。</li>
<li><code>for index_value in my_columns</code>这个语句是第2个for循环语句，在<code>my_cloumns</code>中的各个索引值之间进行迭代。</li>
<li><code>row_list_output.append(row_list[index_value])</code>：使用每行中<code>my_columns</code>索引位置的值添加到<code>row_list_output</code>这个列表中。</li>
<li>现在描述一下这段代码对于第一次外部for循环的运行过程：当读取了文件的第一行后。<code>index_value</code>的值为0，随后，<code>append</code>将<code>row[3]</code>，也就是csv文件中对应的成本那一列加入到<code>row_list_output</code>。</li>
<li>再往下运行，<code>filewriter.writerow(row_list_output)</code>将提取的这个值写入输出文件。</li>
</ol>
<p>现在运行这段代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python select_meets_condition.py supplier_data_unnecessary_header_footer.csv <span class="string">"output.csv"</span> <span class="comment">#其实不加引号也行</span></div></pre></td></tr></table></figure>
<p>现在在桌面上就出现了一个新的csv文件，名称为<code>output.csv</code>，打开这个文件，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190628191313.png">

</div>
<h3 id="使用pandas模块挑出某列-索引方法">使用<code>pandas</code>模块挑出某列-索引方法</h3>
<p>使用<code>pandas</code>模块来选取某列的代码如下所示，代码保存在桌面上，命名为<code>pandas_column_by_index.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">data_frame = pd.read_csv(input_file)</div><div class="line">data_frame_column_by_index = data_frame.iloc[:, [<span class="number">0</span>, <span class="number">3</span>]]</div><div class="line">data_frame_column_by_index.to_csv(output_file, index = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python pandas_column_by_index.py supplier_data_unnecessary_header_footer.csv pandas_output.csv</div></pre></td></tr></table></figure>
<p>这里用到了<code>iloc</code>函数，这个函数的功能是：基于索引位置来选择数据集，那么代码中的<code>[:0, 3]</code>表示的就是选取第0列与第3列。</p>
<h4 id="iloc与loc函数的用法"><code>iloc</code>与<code>loc</code>函数的用法</h4>
<p>iloc的用法可以通过代码来演示一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="comment">#创建一个Dataframe</span></div><div class="line">data=pd.DataFrame(np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>),index=list(<span class="string">'abcd'</span>),columns=list(<span class="string">'ABCD'</span>))</div><div class="line">data</div><div class="line">data.loc[<span class="string">'a'</span>] <span class="comment">#取索引为'a'的行</span></div><div class="line">data.iloc[<span class="number">0</span>] <span class="comment"># 取第一行数据，索引为'a'的行就是第一行，所以结果相同</span></div><div class="line">data.loc[:,[<span class="string">'A'</span>]] <span class="comment">#取'A'列所有行，多取几列格式为 data.loc[:,['A','B']]</span></div><div class="line">data.iloc[:,[<span class="number">0</span>]] <span class="comment">#取第0列所有行，多取几列格式为 data.iloc[:,[0,1]]</span></div><div class="line">data.loc[[<span class="string">'a'</span>,<span class="string">'b'</span>],[<span class="string">'A'</span>,<span class="string">'B'</span>]] <span class="comment">#提取index为'a','b',列名为'A','B'中的数据</span></div><div class="line">data.iloc[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]] <span class="comment">#提取第0、1行，第0、1列中的数据</span></div><div class="line">data.loc[:,:] <span class="comment">#取A,B,C,D列的所有行</span></div><div class="line">data.iloc[:,:] <span class="comment">#取第0,1,2,3列的所有行</span></div><div class="line">data.loc[data[<span class="string">'A'</span>]==<span class="number">0</span>] <span class="comment">#提取data数据(筛选条件: A列中数字为0所在的行数据)</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>data</div><div class="line">    A   B   C   D</div><div class="line">a   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></div><div class="line">b   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></div><div class="line">c   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></div><div class="line">d  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.loc[<span class="string">'a'</span>] <span class="comment">#取索引为'a'的行</span></div><div class="line">A    <span class="number">0</span></div><div class="line">B    <span class="number">1</span></div><div class="line">C    <span class="number">2</span></div><div class="line">D    <span class="number">3</span></div><div class="line">Name: a, dtype: int32</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.iloc[<span class="number">0</span>] <span class="comment"># 取第一行数据，索引为'a'的行就是第一行，所以结果相同</span></div><div class="line">A    <span class="number">0</span></div><div class="line">B    <span class="number">1</span></div><div class="line">C    <span class="number">2</span></div><div class="line">D    <span class="number">3</span></div><div class="line">Name: a, dtype: int32</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.loc[:,[<span class="string">'A'</span>]] <span class="comment">#取'A'列所有行，多取几列格式为 data.loc[:,['A','B']]</span></div><div class="line">    A</div><div class="line">a   <span class="number">0</span></div><div class="line">b   <span class="number">4</span></div><div class="line">c   <span class="number">8</span></div><div class="line">d  <span class="number">12</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.iloc[:,[<span class="number">0</span>]] <span class="comment">#取第0列所有行，多取几列格式为 data.iloc[:,[0,1]]</span></div><div class="line">    A</div><div class="line">a   <span class="number">0</span></div><div class="line">b   <span class="number">4</span></div><div class="line">c   <span class="number">8</span></div><div class="line">d  <span class="number">12</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.loc[[<span class="string">'a'</span>,<span class="string">'b'</span>],[<span class="string">'A'</span>,<span class="string">'B'</span>]] <span class="comment">#提取index为'a','b',列名为'A','B'中的数据</span></div><div class="line">   A  B</div><div class="line">a  <span class="number">0</span>  <span class="number">1</span></div><div class="line">b  <span class="number">4</span>  <span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.iloc[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]] <span class="comment">#提取第0、1行，第0、1列中的数据</span></div><div class="line">   A  B</div><div class="line">a  <span class="number">0</span>  <span class="number">1</span></div><div class="line">b  <span class="number">4</span>  <span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.loc[:,:] <span class="comment">#取A,B,C,D列的所有行</span></div><div class="line">    A   B   C   D</div><div class="line">a   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></div><div class="line">b   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></div><div class="line">c   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></div><div class="line">d  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.iloc[:,:] <span class="comment">#取第0,1,2,3列的所有行</span></div><div class="line">    A   B   C   D</div><div class="line">a   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></div><div class="line">b   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></div><div class="line">c   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></div><div class="line">d  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data.loc[data[<span class="string">'A'</span>]==<span class="number">0</span>] <span class="comment">#提取data数据(筛选条件: A列中数字为0所在的行数据)</span></div><div class="line">   A  B  C  D</div><div class="line">a  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div></pre></td></tr></table></figure>
<h3 id="基于标题选取列">基于标题选取列</h3>
<p>选取特定的列也可以使用列标题来选取，尤其是当处理的文件中有相同的标题，但是列不同的时候就可以采用这种方法。在这个案例中，还以前面的那个csv文件说明一下，现在只需要保留发票号码列和购买日期列，我们采用列标题的方式来选取，输入以下代码，命名为<code>reader_column_by_name.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> csv</div><div class="line"><span class="keyword">import</span> sys</div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">my_columns = [<span class="string">'Invoice Number'</span>,<span class="string">'Purchase Date'</span>]</div><div class="line">my_columns_index = []</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_in_file:</div><div class="line">    <span class="keyword">with</span> open(output_file, <span class="string">'w'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_out_file:</div><div class="line">        filereader = csv.reader(csv_in_file)</div><div class="line">        filewriter = csv.writer(csv_out_file)</div><div class="line">        header = next(filereader, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">for</span> index_value <span class="keyword">in</span> range(len(header)):</div><div class="line">            <span class="keyword">if</span> header[index_value] <span class="keyword">in</span> my_columns:</div><div class="line">                my_columns_index.append(index_value)</div><div class="line">        filewriter.writerow(my_columns)</div><div class="line">        <span class="keyword">for</span> row_list <span class="keyword">in</span> filereader:</div><div class="line">            row_list_output = []</div><div class="line">            <span class="keyword">for</span> index_value <span class="keyword">in</span> my_columns_index:</div><div class="line">                row_list_output.append(row_list[index_value])</div><div class="line">        filewriter.writerow(row_list_output)</div></pre></td></tr></table></figure>
<p>解释一下代码（略去前面已经提到的内容）：</p>
<ol style="list-style-type: decimal">
<li><code>header  = next(filereader, None)</code>:这里使用了<code>next</code>函数，它的功能是返回迭代器的下一项。<code>next</code>函数的用法是<code>next(iterator[, default])</code>，其中<code>iterator</code>是一个迭代器，而<code>default</code>则是一个可选对象，也就是说，在没有下一个元素返回时，就返回该默认值，如果不设置，又没有下一个元素时，就会触发<code>StopIteration</code>异常。</li>
</ol>
<p>这段代码是《Python数据分析基础》中的代码，根据书后面的csv文件，它的前两行是其它数据，使用上面的代码无法正确读取（只会生成标题，而没有内容），因此需要手工将前面的数据删除，形成如下内容才行：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190628203042.png">

</div>
<p>现在运行代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python reader_column_by_name.py supplier_data_unnecessary_header_footer.csv index_output.csv</div></pre></td></tr></table></figure>
<p>此时就会在桌面上生成一个名为<code>index_output.csv</code>的csv文件，打开如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190628203136.png">

</div>
<h3 id="使用pandas按标题行进行读取">使用<code>pandas</code>按标题行进行读取</h3>
<p>要使用<code>pandas</code>来读取数据，需要输入以下代码（命名为<code>pandas_column_by_name.py</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">data_frame = pd.read_csv(input_file)</div><div class="line">data_frame_column_by_name = data_frame.loc[:, [<span class="string">'Invoice Number'</span>,<span class="string">'Purchase Date'</span>]]</div><div class="line">data_frame_column_by_name.to_csv(output_file, index = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>需要注意的是，这个也要删除原始csv文件的前两行。</p>
<h3 id="常规方法选取连续的行">常规方法选取连续的行</h3>
<p>在前面的原始csv表格中，我们可以发现，前两行的内容是<code>I don’t care about this line</code>，后三行的内容是<code>I  don’t  want  this line either</code>，这些内容不是我们想要的，我们只想要中间的那些内容，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190628210317.png">

</div>
<p>因此下面演示一下如何选取中间的内容，输入以下代码，命名为<code>11csv_reader_select_contiguous_rows.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> csv</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">row_counter = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_in_file:</div><div class="line">    <span class="keyword">with</span> open(output_file, <span class="string">'w'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_out_file:</div><div class="line">        filereader = csv.reader(csv_in_file)</div><div class="line">        filewriter = csv.writer(csv_out_file)</div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">            <span class="keyword">if</span> row_counter &gt;=<span class="number">3</span> <span class="keyword">and</span> row_counter &lt;= <span class="number">15</span>:</div><div class="line">                filewriter.writerow([value.strip() <span class="keyword">for</span> value <span class="keyword">in</span> row])</div><div class="line">                print(row_counter, [value.strip() <span class="keyword">for</span> value <span class="keyword">in</span> row])</div><div class="line">            row_counter += <span class="number">1</span></div></pre></td></tr></table></figure>
<p>运行代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python <span class="number">11</span>csv_reader_select_contiguous_rows.py supplier_data_unnecessary_header_footer.csv <span class="number">11.</span>csv</div><div class="line"><span class="number">3</span> [<span class="string">'Supplier X'</span>, <span class="string">'001-1001'</span>, <span class="string">'5467'</span>, <span class="string">'$750.00'</span>, <span class="string">'1/20/14'</span>]</div><div class="line"><span class="number">4</span> [<span class="string">'Supplier X'</span>, <span class="string">'001-1001'</span>, <span class="string">'5467'</span>, <span class="string">'$750.00'</span>, <span class="string">'1/20/14'</span>]</div><div class="line"><span class="number">5</span> [<span class="string">'Supplier X'</span>, <span class="string">'50-9501'</span>, <span class="string">'7009'</span>, <span class="string">'$250.00'</span>, <span class="string">'1/30/14'</span>]</div><div class="line"><span class="number">6</span> [<span class="string">'Supplier X'</span>, <span class="string">'50-9501'</span>, <span class="string">'7009'</span>, <span class="string">'$250.00'</span>, <span class="string">'1/30/14'</span>]</div><div class="line"><span class="number">7</span> [<span class="string">'Supplier X'</span>, <span class="string">'50-9501'</span>, <span class="string">'6650'</span>, <span class="string">'$125.00'</span>, <span class="string">'2002/3/14'</span>]</div><div class="line"><span class="number">8</span> [<span class="string">'Supplier X'</span>, <span class="string">'50-9501'</span>, <span class="string">'6650'</span>, <span class="string">'$125.00'</span>, <span class="string">'2002/3/14'</span>]</div><div class="line"><span class="number">9</span> [<span class="string">'Supplier X'</span>, <span class="string">'920-4803'</span>, <span class="string">'3321'</span>, <span class="string">'$615.00'</span>, <span class="string">'2002/3/14'</span>]</div><div class="line"><span class="number">10</span> [<span class="string">'Supplier X'</span>, <span class="string">'920-4803'</span>, <span class="string">'3321'</span>, <span class="string">'$615.00'</span>, <span class="string">'2002/10/14'</span>]</div><div class="line"><span class="number">11</span> [<span class="string">'Supplier X'</span>, <span class="string">'920-4803'</span>, <span class="string">'3321'</span>, <span class="string">'$615.00'</span>, <span class="string">'2/17/14'</span>]</div><div class="line"><span class="number">12</span> [<span class="string">'Supplier X'</span>, <span class="string">'920-4803'</span>, <span class="string">'3321'</span>, <span class="string">'$615.00'</span>, <span class="string">'2/24/14'</span>]</div><div class="line"><span class="number">13</span> [<span class="string">"I don't want this row either"</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</div><div class="line"><span class="number">14</span> [<span class="string">"I don't want this row either"</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</div><div class="line"><span class="number">15</span> [<span class="string">"I don't want this row either"</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</div></pre></td></tr></table></figure>
<p>此时就在桌面上生成了一个名为<code>11.csv</code>的csv文件。</p>
<h2 id="添加标题行">添加标题行</h2>
<p>当电子表格中没有标题行 的时候，就需要添加列标题。此时还以前面的ccsv文件为例说明一下，删除前后几行，菾下面的样式：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629130029.png">

</div>
<p>将文保存为<code>supplier_data_no_header_row.csv</code>格式。</p>
<h3 id="使用常规方式添加标题行">使用常规方式添加标题行</h3>
<p>在桌面上新建一个名为<code>12csv_reader_add_header_row.py</code>的Python文件，输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> csv</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csv_in_file:</div><div class="line">    <span class="keyword">with</span> open(output_file, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csv_out_file:</div><div class="line">        filereader = csv.reader(csv_in_file)</div><div class="line">        filewriter = csv.writer(csv_out_file)</div><div class="line">        header_list = [<span class="string">'Supplier Name'</span>, <span class="string">'Invoice Number'</span>,<span class="string">'Part Number'</span>,\</div><div class="line">                       <span class="string">'Cost'</span>, <span class="string">'Purchase Date'</span>]</div><div class="line">        filewriter.writerow(header_list)</div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">            filewriter.writerow(row)</div></pre></td></tr></table></figure>
<p>运行代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python <span class="number">12</span>csv_reader_add_header_row.py supplier_data_no_header_row.csv add_header.csv</div></pre></td></tr></table></figure>
<p>在桌面上就生成了<code>add_header.csv</code>的新文件，打开如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629132100.png">

</div>
<h3 id="使用pandas包添加列标题">使用<code>pandas</code>包添加列标题</h3>
<p><code>pandas</code>包中的<code>read_csv</code>函数可以直接指定输入文件不包含标题行，并哦可以提供一个列标题列表。如果要给一个没有标题行的数据集添加标题行，此文件命名为<code>pandas_add_header_row.py</code>，实现方式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_file = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">header_list = [<span class="string">'Supplier Name'</span>, <span class="string">'Invoice Number'</span>, <span class="string">'Part Number'</span>, \</div><div class="line">               <span class="string">'Cost'</span>, <span class="string">'Purchase Date'</span>]</div><div class="line"></div><div class="line">data_frame = pd.read_csv(input_file, header=<span class="keyword">None</span>, names= header_list)</div><div class="line">data_frame.to_csv(output_file, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>运行代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python pandas_add_header_row.py supplier_data_no_header_row.csv pandas_header.csv</div></pre></td></tr></table></figure>
<p>这里需要注意一下最后一行<code>data_frame.to_csv(output_file, index=False)</code>里面的<code>index=False</code>，如果设置为<code>True</code>，则会在数据集的前面再添加1列，这1列是索引，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629133022.png">

</div>
<h2 id="读取多个csv文件">读取多个csv文件</h2>
<p>数据处理过程中常常会遇到同时处理多个csv文件的情况。</p>
<h3 id="创建3个演示csv文件">创建3个演示csv文件</h3>
<p>在桌面上创建第1个csv文件（这个文件也可以从作者的Github上下载），命名为<code>sales_january_2014.csv</code>文件内容如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629135448.png">

</div>
<p>创建第2个csv文件，命名为<code>sales_february_2014.csv</code>，内容如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629135656.png">

</div>
<p>创建第3个csv文件，命名为<code>sales_march_2014.csv</code>，内容如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629135922.png">

</div>
<h3 id="文件计数与文件中的行列计数">文件计数与文件中的行列计数</h3>
<p>这一部分是要计算一下每个文件中行与列的数量，代码文件为<code>8csv_reader_counts_for_multiple_ﬁles.py</code>，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> csv</div><div class="line"><span class="keyword">import</span> glob</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_path = sys.argv[<span class="number">1</span>]</div><div class="line">file_counter = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> input_file <span class="keyword">in</span> glob.glob(os.path.join(input_path, <span class="string">'sales_*'</span>)):</div><div class="line">    row_counter = <span class="number">1</span></div><div class="line">    <span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_in_file:</div><div class="line">        filereader = csv.reader(csv_in_file)</div><div class="line">        header = next(filereader, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">            row_counter += <span class="number">1</span></div><div class="line">    print(<span class="string">'&#123;0!s&#125;: \t&#123;1:d&#125; rows \t&#123;2:d&#125; columns'</span>.format(os.path.basename(input_file), row_counter, len(header)))</div><div class="line">    file_counter += <span class="number">1</span></div><div class="line">print(<span class="string">'Number of files: &#123;0:d&#125;'</span>.format(file_counter))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python <span class="number">8</span>csv_reader_counts_for_multiple_ﬁles.py <span class="string">"C:\Users\20161111\Desktop"</span></div><div class="line">sales_february_2014.csv:        <span class="number">7</span> rows  <span class="number">5</span> columns</div><div class="line">sales_january_2014.csv:         <span class="number">7</span> rows  <span class="number">5</span> columns</div><div class="line">sales_march_2014.csv:   <span class="number">7</span> rows  <span class="number">5</span> columns</div><div class="line">Number of files: <span class="number">3</span></div></pre></td></tr></table></figure>
<p>代码解释：</p>
<ol style="list-style-type: decimal">
<li><code>for input_file in glob.glob(os.path.join(input_path, 'sales_*')):</code>这里使用了<code>glob</code>模块中的<code>glob</code>函数，这个模块可以匹配某个特定模式的所有路径名，在这段代码中，搜索的模式是<code>sales_*</code>。这个模式表示要搜索所有文件名以<code>sale_</code>形状并且下划线后面可以是任意字符的文件。由于我们创建了3个csv文件，所以应该知道使用这段代码可以识别出这3个文件，它们的文件名都是以<code>sales_</code>形状的。如果我们要检索某个目录下的所有csv文件，则要将<code>sales_*</code>改为<code>*.csv</code>。</li>
<li><code>os.path.basename(path)</code>：这是返回<code>path</code>的基本文件名。即如果<code>path</code>是<code>C:\Users\Clinton\Desktop\my_input_file.csv</code>，那么<code>os.path.basename(path)</code>则返回的是是<code>my_input_file.csv</code>。</li>
</ol>
<h2 id="合并多个文件">合并多个文件</h2>
<p>有的时候需要将多个csv文件合并为一个csv文件，现在有几种合并方式。</p>
<h3 id="常规合并方式">常规合并方式</h3>
<p>先看常规方式来合并多个csv文件，输入以下代码，命名为<code>9csv_reader_concat_rows_from_multiple_ﬁles.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> csv</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> glob</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">input_path = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line">first_file = <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> input_file <span class="keyword">in</span> glob.glob(os.path.join(input_path,<span class="string">'sales_*'</span>)):</div><div class="line">    print(os.path.basename(input_file))</div><div class="line">    <span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csv_in_file:</div><div class="line">        <span class="keyword">with</span> open(output_file, <span class="string">'a'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csv_out_file:</div><div class="line">            filereader = csv.reader(csv_in_file)</div><div class="line">            filewriter = csv.writer(csv_out_file)</div><div class="line">            <span class="keyword">if</span> first_file:</div><div class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">                    filewriter.writerow(row)</div><div class="line">                first_file = <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                header = next(filereader, <span class="keyword">None</span>)</div><div class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">                    filewriter(row)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python <span class="number">9</span>csv_reader_concat_rows_from_multiple_ﬁles.py <span class="string">"C:\Users\20161111\Desktop"</span> merge.csv</div><div class="line">sales_february_2014.csv</div><div class="line">sales_january_2014.csv</div><div class="line">sales_march_2014.csv</div></pre></td></tr></table></figure>
<p>此时在桌面上生成了一名为<code>merge.csv</code>的文件，打开后，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629202951.png">

</div>
<h3 id="使用pandas包合并">使用<code>pandas</code>包合并</h3>
<p><code>pandas</code>包可以直接将多个csv文件合并为一个csv文件。基本过程就是将每个输入文件读取到pandas的数据框中，将所有数据框追加到一个数据框列表，然后使用<code>concat</code>函数将所有数据框连接成一个数据框。<code>concat</code>函数可以使用<code>axis</code>函数来设置合并数据框的试，其中<code>axis=0</code>表示从头到尾垂直合并，<code>axis=1</code>表示并排地合并。</p>
<p>使用<code>pandas</code>包合并多个csv文件的过程如下所示（文件命名为<code>pandas_concat_rows_from_multiple_ﬁles.py</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> glob</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">input_path = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">all_files = glob.glob(os.path.join(input_path, <span class="string">'sales_*'</span>))</div><div class="line">all_data_frames = []</div><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> all_files:</div><div class="line">    data_frame = pd.read_csv(file, index_col = <span class="keyword">None</span>)</div><div class="line">    all_data_frames.append(data_frame)</div><div class="line"></div><div class="line">data_frame_concat = pd.concat(all_data_frames, axis = <span class="number">0</span>, ignore_index = <span class="keyword">True</span>)</div><div class="line">data_frame_concat.to_csv(output_file, index = <span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python pandas_concat_rows_from_multiple_ﬁles.py <span class="string">"C:\Users\20161111\Desktop"</span> pandas_merge.csv</div></pre></td></tr></table></figure>
<h2 id="计算每个文件值中的总和与均值">计算每个文件值中的总和与均值</h2>
<p>在数据处理过程中，有的时候需要计算多个csv文件中的一些统计量，例如均值和总和。现在以前面的3个csv文件为例说明一下如何计算。</p>
<h3 id="常规计算方式">常规计算方式</h3>
<p>现在使用Python的常规方式来计算前面3个csv文件某列的总和和均值。代码如下所示（代码名称为<code>10csv_reader_sum_average_from_multiple_ﬁles.py</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> csv</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> glob</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line">input_path = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line"></div><div class="line">output_header_list = [<span class="string">'file_name'</span>, <span class="string">'total_sales'</span>, <span class="string">'average_sales'</span>]</div><div class="line">csv_out_file = open(output_file, <span class="string">'a'</span>, newline=<span class="string">''</span>)</div><div class="line">filewriter = csv.writer(csv_out_file)</div><div class="line">filewriter.writerow(output_header_list)</div><div class="line"></div><div class="line"><span class="keyword">for</span> input_file <span class="keyword">in</span> glob.glob(os.path.join(input_path, <span class="string">'sales_*'</span>)):</div><div class="line">    <span class="keyword">with</span> open(input_file, <span class="string">'r'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csv_in_file:</div><div class="line">        filereader = csv.reader(csv_in_file)</div><div class="line">        output_list = []</div><div class="line">        output_list.append(os.path.basename(input_file))</div><div class="line">        header = next(filereader,<span class="keyword">None</span>)</div><div class="line">        total_sales = <span class="number">0.0</span></div><div class="line">        number_of_sales = <span class="number">0.0</span></div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> filereader:</div><div class="line">            sale_amount = row[<span class="number">3</span>]</div><div class="line">            total_sales += float(str(sale_amount).strip(<span class="string">'$'</span>).replace(<span class="string">','</span>, <span class="string">''</span>))</div><div class="line">            number_of_sales += <span class="number">1</span></div><div class="line">        average_sales = <span class="string">'&#123;0:.2f&#125;'</span>.format(total_sales / number_of_sales)</div><div class="line">        output_list.append(total_sales)</div><div class="line">        output_list.append(average_sales)</div><div class="line">        filewriter.writerow(output_list)</div><div class="line">csv_out_file.close()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>\Desktop&gt;python <span class="number">10</span>csv_reader_sum_average_from_multiple_ﬁles.py <span class="string">"C:\Users\20161111\Desktop"</span> add_col.csv</div></pre></td></tr></table></figure>
<p>此时就会在桌面上创建一个<code>add_col.csv</code>文件，打开后如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190629211507.png">

</div>
<h3 id="pandas计算"><code>pandas</code>计算</h3>
<p><code>pandas</code>包中提供了各种统计函数，例如<code>sum</code>和<code>mean</code>。下面的代码功能是对多个文件中的某一列计算这两个统计量（总和与均值），并将每个输入文件的计算结果写入输出文件，代码保存文件为<code>pandas_sum_average_from_multiple_files.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> glob</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">input_path = sys.argv[<span class="number">1</span>]</div><div class="line">output_file = sys.argv[<span class="number">2</span>]</div><div class="line">all_files = glob.glob(os.path.join(input_path, <span class="string">'sales_*'</span>))</div><div class="line">all_data_frames = []</div><div class="line"><span class="keyword">for</span> input_file <span class="keyword">in</span> all_files:</div><div class="line">    data_frame = pd.read_csv(input_file, index_col=<span class="keyword">None</span>)</div><div class="line"></div><div class="line">    total_sales = pd.DataFrame([float(str(value).strip(<span class="string">'$'</span>).replace(<span class="string">','</span>, <span class="string">''</span>)) \</div><div class="line">                               <span class="keyword">for</span> value <span class="keyword">in</span> data_frame.loc[:, <span class="string">'Sale Amount'</span>]]).sum()</div><div class="line"></div><div class="line">    average_sales = pd.DataFrame([float(str(value).strip(<span class="string">'$'</span>).replace(<span class="string">','</span>, <span class="string">''</span>)) \</div><div class="line">                                 <span class="keyword">for</span> value <span class="keyword">in</span> data_frame.loc[:, <span class="string">'Sale Amount'</span>]]).mean()</div><div class="line">    data = &#123;<span class="string">'file_name'</span>: os.path.basename(input_file),</div><div class="line">            <span class="string">'total_sales'</span>: total_sales,</div><div class="line">            <span class="string">'average_sales'</span>: average_sales&#125;</div><div class="line"></div><div class="line">    all_data_frames.append(pd.DataFrame(data, \</div><div class="line">                                        columns=[<span class="string">'file_name'</span>, <span class="string">'total_sales'</span>, <span class="string">'average_sales'</span>]))</div><div class="line">data_frames_concat = pd.concat(all_data_frames, axis=<span class="number">0</span>, ignore_index=<span class="keyword">True</span>)</div><div class="line">data_frames_concat.to_csv(output_file, index=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PS D:\netdisk\pyton_data&gt; python .\pandas_read_and_write_excel.py sales_2013.xlsx pandas_out.xlsx</div><div class="line">PS D:\netdisk\pyton_data&gt;</div></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://www.zhihu.com/question/23711222" target="_blank" rel="external">sys.argv是什么？</a></li>
<li>克林顿·布朗利（Clinton，W.，Brownley） 著，陈光欣 译. Python数据分析基础[M]. 2017.</li>
<li><a href="https://www.pypandas.cn/" target="_blank" rel="external">Panadas中文文档</a></li>
<li><a href="https://blog.csdn.net/w_weiying/article/details/81411257" target="_blank" rel="external">Pandas中loc和iloc函数用法详解（源码+实例）</a></li>
<li><a href="https://github.com/cbrownley/foundations-for-analytics-with-python" target="_blank" rel="external">《Python数据分析基础》中源代码与数据文件</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/06/28/Experiment/6xHis标签/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/28/Experiment/6xHis标签/" itemprop="url">6xHis标签</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-28T12:00:00+08:00">
                2019-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物实验笔记/" itemprop="url" rel="index">
                    <span itemprop="name">生物实验笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,724
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="xhis标签简介">6xHis标签简介</h3>
<p>6xHis标签，也称为多组氨酸标签（polyhistidine ），His6标签或hexa组氨酸标签，这是一种在转染的细胞中目标蛋白的C端或N端上由至少6个组氨酸残基链接上所组成的氨基酸序列，它的序列如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">碱基序列：</div><div class="line">	CATCATCATCATCATCAT</div><div class="line">    或</div><div class="line">    CACCACCACCACCACCAC</div><div class="line"></div><div class="line">氨基酸序列：</div><div class="line">	HHHHHH</div></pre></td></tr></table></figure>
<h3 id="xhis标签的优点">6xHis标签的优点</h3>
<p>相对小的分子量，低的免疫原性，亲水性和在去污剂和其他添加剂存在的情况下的易变性，因此在天然和变性的条件下，多组氨酸标签是被公认为最广泛使用的亲和标签用于一系列的蛋白纯化目的。</p>
<p>可以检测和纯化重组蛋白而无需使用蛋白特异性的抗体或探针，同时抗His标签抗体的存在用于His标签蛋白的检测中使6xHis标签更加的普遍和受欢迎。</p>
<h3 id="his标签的用途">His标签的用途</h3>
<h4 id="亲和纯化蛋白">1. 亲和纯化蛋白</h4>
<p>6xHis标签通常在重组蛋白的纯化中使用，这是因为组氨酸残基的序列可以在特定的缓冲液条件下结合到几种类型固定的离子上（比如镍，钴和铜），从而达到容易检测和纯化His标签蛋白的目的。例如在大肠杆菌和其他原核系统中表达的多组氨酸标签重组蛋白通常使用固定的金属离子亲和色谱来纯化或称为IMAC，IMAC的全称是 <code>immobilized metal-affinity chromatography</code>，即<code>固定金属亲和层析</code>。</p>
<blockquote>
<p><code>亲和</code>的意思就是指采用抗原-抗体之间的特异性结合来分离出自己的目标抗原或抗体。</p>
</blockquote>
<p>IAMC一种非常有效的分离技术，它利用组氨酸能够与金属离子发生亲和作用的原理对蛋白质加以分离。例如伯乐的Profinity IMAC 介质以UNOsphere™ 为基质，含有作为二价、三价金属离子螯合配位体的亚氨基二乙酸 ( IDA )。当配位体结合有 Zn2+、Ni2+ 或 Cu2+ 等金属离子时，含组氨酸的蛋白会与此层析介质结合。</p>
<p>在亲和层析过程中，支撑物(通常是珠状琼脂糖凝胶或磁珠颗粒)用合适的耦合试剂来进行衍生，比如氨三乙酸nitrilotriaceticacid(NTA)或亚氨乙酸iminodiaceticacid(IDA)。这些螯合的基团会<strong>固定所需要的二价金属离子(比如镍，铜，钴和锌)</strong>，从而这些金属离子最后<strong>负责结合和分离混合液蛋白中的目标分子</strong>。在选择使用哪个配基上，你需要考虑IMAC树脂的结合能力主要取决于被纯化蛋白的性质和在纯化过程中所使用的金属离子。</p>
<p>镍，钴，铜是进行纯化His标签蛋白首选的被广泛使用的离子，由于它们在水溶液中对于<strong>组氨酸</strong>和<strong>半胱氨酸</strong>良好的亲和性。在这三个离子中，<strong>镍是最广泛使用的金属离子</strong>，它呈现出最高的亲和性和选择性对于His标签蛋白.然而，它也会非特异性的结合包含组氨酸群的内源蛋白。而钴提供最特异性的结合和组氨酸标签因此当纯度是首要选择时钴是二价阳离子的首选。铜离子和镍钴离子相比和His标签蛋白的结合非常强劲，但是它的特异性在三种离子中是最弱的。由于这个原因，当纯度不是最主要的目的时铜离子IMAC被使用。</p>
<p>在制备样品时，细胞被捕获和裂解通过酶法或机械条件。因为多组氨酸标签在生理PH值和离子强度下很好的结合到IMAC树脂上。结合在几乎中性缓冲液的条件下完成。大部分科研人员使用包含10-25mM咪唑的TBS溶液作为结合/漂洗缓冲液来防止带有组氨酸残基内源蛋白的非特异性的结合.被捕获的组氨酸标签蛋白的洗脱和回复通常使用增加的咪唑浓度(至少200mM)来实现，低PH值或一个过量的强螯合剂比如EDTA。</p>
<h4 id="检测目标蛋白">2. 检测目标蛋白</h4>
<p>ELISA或免疫印迹检测：可以使用镍螯合的辣根过氧化物酶来进行基于HRP组氨酸标签蛋白的检测而无需使用抗体。同时，抗6xHis的抗体是高度灵敏和特异性的对于那些含有组氨酸标签的蛋白。</p>
<p>凝胶染色：几种免疫分析方法利用多组氨酸标签通过抗多组氨酸标签抗体或通过SDS-PAGE来检测靶蛋白。</p>
<h4 id="蛋白相互作用">3. 蛋白相互作用</h4>
<p>蛋白相互作用pull-down：镍琼脂糖树脂可以用于纯化，鉴定和检测组氨酸标签蛋白的相互作用。</p>
<h3 id="文献解读">文献解读</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190613142813.png">

</div>
<p>上面的图片来源于2016年发表在《Immunity》上的<code>Analysis of the Rab GTPase Interactome in Dendritic Cells Reveals Anti-microbial Functions of the Rab32 Complex in Bacterial Containment</code>，文献中就采用了<code>6xHis</code>标签来纯化Rab蛋白，只是文献中为了提高蛋白相互作用的可信度，提高蛋白的纯化效果，采用的是2个标签的纯化方法。</p>
<p>从<code>(a)</code>图中可以看到<code>FUYW-exact-6His-Rab</code>字样，这说明在Rab分子的N端加上了一个<code>6xHis</code>标签与<code>eXact</code>标签，eXact标签是一个能够自割切的枯草杆菌结构蛋白。在<code>(b)</code>图中我们可以继续看到，6xHis与Rab分子之间还加上了一个EYFP标签，这主要是为了方便构建慢病毒稳转细胞时筛选，因此文献中还提到了使用空的EYFP质粒来做了阴性对照。</p>
<p>文献中做蛋白相互作用的大致流程如下所示（其实图(b)就是纯化蛋白的过程）：</p>
<ol style="list-style-type: decimal">
<li>构建稳定表达的<code>eXact-6xHis-EYFP-Rab</code>整合蛋白的DC2.4细胞；</li>
<li>通过<code>eXact-6xHis</code>两个标签进行亲和纯化，其中<code>eXact</code>这个标签的特征在于它无需抗体进行纯化，因此就会降低引入高浓度外源抗体对质谱分析的影响，当溶液中的N3-离子浓度升高后，就会诱导eXact标签与目的蛋白之间的酶切，从而导致eXact标签被固定的蛋白酶滞留在介质上，此时洗脱下来的就是<code>6xHis-EYFP-Rab</code>重组蛋白；</li>
<li>使用Ni-NTA纯化柱来纯化<code>6xHis-EYFP-Rab</code>蛋白。</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://www.biomart.cn/experiment/430/465/469/2712861.htm" target="_blank" rel="external">6xHis 标签的特点以及它的使用方法</a></li>
<li><a href="https://www.sciencedirect.com/science/article/abs/pii/016777998590068X" target="_blank" rel="external">Purification of proteins by IMAC</a></li>
<li>Janeway’s Immunobiology 9th</li>
<li><a href="http://www.bio-rad.com/zh-cn/product/profinity-imac-resin?ID=e54ab03c-d281-4e6b-aa0d-193b7737626d&amp;pcp_loc=catprod" target="_blank" rel="external">Profinity IMAC 树脂</a></li>
<li>Analysis of the Rab GTPase Interactome in Dendritic Cells Reveals Anti-microbial Functions of the Rab32 Complex in Bacterial Containment</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/06/28/Experiment/双荧光素酶实验笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/28/Experiment/双荧光素酶实验笔记/" itemprop="url">双荧光素酶笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-28T12:00:00+08:00">
                2019-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物实验笔记/" itemprop="url" rel="index">
                    <span itemprop="name">生物实验笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,847
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-什么是双荧光素酶">(一) 什么是双荧光素酶？</h3>
<p>答：双荧光素酶通常是指萤火虫荧光素酶和海肾荧光素。其中荧火虫荧光素是从甲虫（Photinus pyralis）中分离得到，分子量为61kDa；而海肾（Renilla）荧光素酶则是从海肾（Renilla reniformis）中分离，分子量为36kDa。这两种酶的区别之一是他们的底物和辅因子不同：萤火虫荧光素酶需要荧光素、氧气、ATP和镁离子同时存在才能发光；而海肾荧光素酶仅需要腔肠素（coelenterazine）和氧气。萤火虫荧光素酶和海肾荧光素酶的区别之二是发光的颜色不同：萤火虫荧光素酶产生的光颜色呈现黄绿色，波长550-570nm；而海肾荧光素酶产生蓝光，波长480nm。正是由于这两种酶的底物和发光颜色不同，所以在双报告实验中得到广泛应用，它们的发光原理如下所示：<br>
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190707175539.png"></p>
<h3 id="二-为什么要采用双荧光素酶报告系统">(二) 为什么要采用双荧光素酶报告系统？</h3>
<p>答：单报告基因实验往往会受到各种实验条件的影响，而双报告基因则通过共转染的“对照”作为内参为试验提供一基准线，从而可以在最大程度上减小细胞活性和转染效率等外在因素对实验的影响，使得数据结果更为可信。</p>
<h3 id="三-双荧光素酶在mirna验证其靶基因方面的原理是什么">(三) 双荧光素酶在miRNA验证其靶基因方面的原理是什么？</h3>
<p>答：双萤光素酶报告基因检测系统在细胞中同时表达萤火虫萤光素酶和海肾萤光素酶，两者没有种源同源性并对应不同的反应底物，故而没有交叉干扰。得益于超强的光信号和超高的信噪比，本系统被广泛用于 miRNA 靶基因验证。 miRNA 主要通过作用于靶基因的 3’UTR 起作用，可以将目的基因 3’UTR 区域构建至载体中报告基因 luciferase 的后面，通过比较过表达或者干扰 miRNA 后，报告基因表达的改变（监测萤光素酶的活性变化）可以定量反映 miRNA 对目的基因的抑制作用，也即用荧光值来判断miRNA是否和靶基因结合。</p>
<h3 id="四-在利用双荧光素酶验证mirna的靶基因方面插入的3utr长度应该是多少">(四) 在利用双荧光素酶验证miRNA的靶基因方面，插入的3’UTR长度应该是多少？</h3>
<p>答：靶基因的3’UTR长度不一，将全长都插入载体中不切实际，通常只插入包括miRNA结合位点前后200bp左右的序列，大概就是400bp[1]，但也有文献插入的是80个bp[2]，有文献选择了200多个bp[3]，但严格来讲，应该选择400bp，以结合位点为中心，上游200bp，下游200bp。</p>
<h3 id="五-常用的双荧光素酶载体有哪些">(五) 常用的双荧光素酶载体有哪些？</h3>
<p>答：常用的载体有两种策略。第一种是两种荧光素分别位于两个载体上，第二种是两种荧光素酶位于同一个载体上。以第一种为例，这两种载体分别为pMIR-REPORT miRNA载体和pRL-TK载体。经检索发现，pMIR-REPORT miRNA载体是由Ambion开发的载体，它用来克隆插入miRNA靶序列，评估细胞内miRNA功能的载体，该载体的图谱如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190707175303.png"> 另外的一个载体是pRL-TK载体，这个载体是由Promega开发的，pRL-TK是海肾荧光素酶报告载体，含有SV40增强子，质粒图谱如下所示： <img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190707175327.png"> 从这两个图谱中可以发现，pMIR-REPORT miRNA这个载体主要是用于评估miRNA与靶基因3’UTR的结合，靶基因的3’UTR放在荧光素酶的后面，这个荧光素酶是荧火虫荧光素酶，而pRL-TK这个载体则表达海肾荧光素酶，将这两个质粒共同转染进入293细胞中来检测荧光时，pRL-TK这个质粒起到一个内参的作用。</p>
<p>第二种方案就是将荧火虫荧光素酶与海肾荧光素酶构建到一个载体上，这样偏差更小，毕竟转染一个质粒比转染两个质粒要容易，在这方面，根据检索到的资料显示，现在的这类质比较有名的是Promega公司的pmirGLO质粒，图谱如下所示： <img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190707175348.png"> 另外的质粒就是国产的，即复能基因的pEZX-MT06质粒，图谱如下所示： <img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190707175405.png"></p>
<h3 id="六-在检测mirna靶基因时需要设置多少个分组">(六) 在检测miRNA靶基因时，需要设置多少个分组？</h3>
<p>答：首先要知道，插入的靶基因原始3’UTR的质粒叫野生型质粒，除此之外，还需要在萤火虫荧光素酶3’UTR插入miRNA结合位点突变的序列载体，这个质粒通常叫突变型质粒，最后还有各种对照载体，包括萤火虫荧光素酶空载体，miRNA空载体，还有海肾素荧光载体，以文献中的案例[4]说明，此文献使用了6组来进行验证，其分组以及分组说明如下所示： <img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190707175421.png"> 注：pGL3是荧光素酶报告质粒，绿色的是对照组，即不加miRNA质粒，红色的是正常组，加miRNA质粒。思路即为荧光素酶质粒（3种情况：①空质粒；②加了WT靶基因3’UTR的质粒；③加了MUT的靶基因3’UTR的质粒）×miRNA precursor（两种情况，即加与不加），经排列组合，即为6组，详细说明如下所示：</p>
<p>第一组 荧光素酶质粒pGL3不加3’UTR片段 + miRNA载体质粒 第二组 荧光素酶质粒pGL3不加3’UTR片段 + miR-200c质粒 第三组 荧光素酶质粒pGL3 -WT-3’UTR+ + miRNA载体质粒 第四组 重点：荧光素酶质粒pGL3 -WT3’UTR + miR-200c质粒 第五组 荧光素酶质粒pGL3 -MUT-3‘UTR+ miRNA载体质粒 第六组 重点：荧光素酶质粒pGL3 -MUT-3‘UTR + miR-200c质粒 理想结果：第四组降低，即miRNA能够与靶基因的3UTR结合，第六组不变，即突变后靶基因3‘UTR不与miRNA结合。</p>
<h3 id="七-在检测荧光方面所使用的仪器是哪些">(七) 在检测荧光方面，所使用的仪器是哪些？</h3>
<p>答：最经典的仪器就是Promega的GloMax 20/20 发光检测仪，但这种仪器只适合一次检测一个酝酿。但也可以用多功能酶标仪来检测（本实验室的仪器是VARIOSKAN LUX），这种酶标仪可以实现多通量检测。萤火虫荧光素酶产生的光颜色呈现黄绿色，波长550-570nm；而海肾荧光素酶产生蓝光，波长480nm。</p>
<h3 id="八-测得结果的数据如何处理">(八) 测得结果的数据如何处理？</h3>
<p>答：测得的结果一个萤火虫荧光素酶产生的光信号，记为RL1，，海肾荧光素酶产生的信号，记为RL2。RL1/RL2将数据均一化后，每两组之间用ANOVA检测即可。</p>
<h3 id="九-参考资料">(九) 参考资料</h3>
<ol style="list-style-type: decimal">
<li>Nicolas, F.E., Experimental Validation of MicroRNA Targets Using a Luciferase Reporter System, in MicroRNAs in Development: Methods and Protocols, T. Dalmay, Editor. 2011, Humana Press: Totowa, NJ. p. 139-152.</li>
<li>Zhu, J., et al., TNF-alpha mRNA is negatively regulated by microRNA-181a-5p in maturation of dendritic cells induced by high mobility group box-1 protein. Sci Rep, 2017. 7(1): p. 12239.</li>
<li>Zhu, S., et al., MicroRNA-21 targets the tumor suppressor gene tropomyosin 1 (TPM1). J Biol Chem, 2007. 282(19): p. 14328-36.</li>
<li>Shimono, Y., et al., Downregulation of miRNA-200c links breast cancer stem cells with normal stem cells. Cell, 2009. 138(3): p. 592-603.</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">193</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">83</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>

<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:30px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共767.6k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
