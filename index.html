<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/10/BioTools/fgsea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/BioTools/fgsea/" itemprop="url">fgsea包做GSEA分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T12:00:00+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生信工具/" itemprop="url" rel="index">
                    <span itemprop="name">生信工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,259
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="gsea图">GSEA图</h2>
<p>这篇教程翻译自生信博客DAVE TANGE’S BLOG(https://davetang.org/muse/)上的一篇教程，参考资料中已经列出了地址。</p>
<p><code>fgsea</code>这个包用于做GSEA分析，先来看一下使用这个包做的图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911114456.png">

</div>
<p>现在简单解释一下这个图形：</p>
<p>x轴——排序后的基因列表<code>L</code>位置对应的坐标，也就是我们自己通过RNA-seq，芯片，qPCR等手段获得的基因表达值倍数变化，或p值排序，总之，这是一个有序列表。</p>
<p>垂直的黑色细胞——上图中类似条形码的图形，这是指的是某一个基因集<code>S</code>中基因对应于<code>L</code>基因中，的位置，在上图中，这个基因集是细胞周期(Cell Cycle)，明天看到<code>S</code>中的成员在<code>L</code>的左侧比较密集。</p>
<p>y轴——富集分布，从上面我们可以看到，细胞周期(Cell Cycle)这个基因集在左侧富集，也就是绿色曲线表示的位置。</p>
<h2 id="fgsea使用">fgsea使用</h2>
<h3 id="安装">安装</h3>
<p>先安装<code>fgsea</code>包，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"BiocManager"</span>)</div><div class="line">BiocManager::install(<span class="string">"fgsea"</span>)</div><div class="line"><span class="keyword">library</span>(fgsea)</div></pre></td></tr></table></figure>
<h3 id="数据">数据</h3>
<p><code>fgsea</code>包中内置的有数据集<code>examplePathways</code>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(fgsea)</div><div class="line"></div><div class="line">data(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># examplePathways是从'reactome.db'包中</span></div><div class="line"><span class="comment"># 提取的信息，并以列表的形式存了这些信息，</span></div><div class="line"><span class="comment"># 这些信息主要是小鼠的基因</span></div><div class="line">help(<span class="string">"examplePathways"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 这个数据集是一个列表</span></div><div class="line">class(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># 一共有1,457 "通路"</span></div><div class="line">length(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># 第1列含有Meiotic_Synapsis pathway的EntrezID</span></div><div class="line">examplePathways[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment"># exampleRanks储存的是排序信息</span></div><div class="line">data(exampleRanks)</div><div class="line"></div><div class="line"><span class="comment"># exampleRnak是一个数字型的向量</span></div><div class="line">class(exampleRanks)</div><div class="line"></div><div class="line"><span class="comment"># exampleRanks中的向量名称则是对称的Entrez ID</span></div><div class="line">head(exampleRanks)</div><div class="line">tail(unname(exampleRanks))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(fgsea)</div><div class="line">&gt; </div><div class="line">&gt; data(examplePathways)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># examplePathways是从'reactome.db'包中</span></div><div class="line"><span class="comment"># 提取的信息，并以列表的形式</span></div><div class="line">&gt; <span class="comment"># 储存了这些信息，这些信息主要是小鼠的基因</span></div><div class="line">&gt; help(<span class="string">"examplePathways"</span>)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 这个数据集是一个列表</span></div><div class="line">&gt; class(examplePathways)</div><div class="line">[<span class="number">1</span>] <span class="string">"list"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 一共有1,457 "通路"</span></div><div class="line">&gt; length(examplePathways)</div><div class="line">[<span class="number">1</span>] <span class="number">1457</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 第1列含有Meiotic_Synapsis pathway的EntrezID</span></div><div class="line">&gt; examplePathways[<span class="number">1</span>]</div><div class="line">$`1221633_Meiotic_Synapsis`</div><div class="line"> [<span class="number">1</span>] <span class="string">"12189"</span>     <span class="string">"13006"</span>     <span class="string">"15077"</span>     <span class="string">"15078"</span>     <span class="string">"15270"</span>     <span class="string">"15512"</span>    </div><div class="line"> [<span class="number">7</span>] <span class="string">"16905"</span>     <span class="string">"16906"</span>     <span class="string">"19357"</span>     <span class="string">"20842"</span>     <span class="string">"20843"</span>     <span class="string">"20957"</span>    </div><div class="line">[<span class="number">13</span>] <span class="string">"20962"</span>     <span class="string">"21749"</span>     <span class="string">"21750"</span>     <span class="string">"22196"</span>     <span class="string">"23856"</span>     <span class="string">"24061"</span>    </div><div class="line">[<span class="number">19</span>] <span class="string">"28113"</span>     <span class="string">"50878"</span>     <span class="string">"56739"</span>     <span class="string">"57321"</span>     <span class="string">"64009"</span>     <span class="string">"66654"</span>    </div><div class="line">[<span class="number">25</span>] <span class="string">"69386"</span>     <span class="string">"71846"</span>     <span class="string">"74075"</span>     <span class="string">"77053"</span>     <span class="string">"94244"</span>     <span class="string">"97114"</span>    </div><div class="line">[<span class="number">31</span>] <span class="string">"97122"</span>     <span class="string">"97908"</span>     <span class="string">"101185"</span>    <span class="string">"140557"</span>    <span class="string">"223697"</span>    <span class="string">"260423"</span>   </div><div class="line">[<span class="number">37</span>] <span class="string">"319148"</span>    <span class="string">"319149"</span>    <span class="string">"319150"</span>    <span class="string">"319151"</span>    <span class="string">"319152"</span>    <span class="string">"319153"</span>   </div><div class="line">[<span class="number">43</span>] <span class="string">"319154"</span>    <span class="string">"319155"</span>    <span class="string">"319156"</span>    <span class="string">"319157"</span>    <span class="string">"319158"</span>    <span class="string">"319159"</span>   </div><div class="line">[<span class="number">49</span>] <span class="string">"319160"</span>    <span class="string">"319161"</span>    <span class="string">"319565"</span>    <span class="string">"320332"</span>    <span class="string">"320558"</span>    <span class="string">"326619"</span>   </div><div class="line">[<span class="number">55</span>] <span class="string">"326620"</span>    <span class="string">"360198"</span>    <span class="string">"497652"</span>    <span class="string">"544973"</span>    <span class="string">"625328"</span>    <span class="string">"667250"</span>   </div><div class="line">[<span class="number">61</span>] <span class="string">"100041230"</span> <span class="string">"102641229"</span> <span class="string">"102641751"</span> <span class="string">"102642045"</span></div><div class="line"></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRanks储存的是排序信息</span></div><div class="line">&gt; data(exampleRanks)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRnak是一个数字型的向量</span></div><div class="line">&gt; class(exampleRanks)</div><div class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRanks中的向量名称则是对称的Entrez ID</span></div><div class="line">&gt; head(exampleRanks)</div><div class="line">   <span class="number">170942</span>    <span class="number">109711</span>     <span class="number">18124</span>     <span class="number">12775</span>     <span class="number">72148</span>     <span class="number">16010</span> </div><div class="line">-<span class="number">63.33703</span> -<span class="number">49.74779</span> -<span class="number">43.63878</span> -<span class="number">41.51889</span> -<span class="number">33.26039</span> -<span class="number">32.77626</span> </div><div class="line">&gt; tail(unname(exampleRanks))</div><div class="line">[<span class="number">1</span>] <span class="number">47.58235</span> <span class="number">49.87543</span> <span class="number">50.25179</span> <span class="number">50.86532</span> <span class="number">51.16110</span> <span class="number">53.28400</span></div></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<p>现在我们使用上面的数据进行GSEA分析，进行GSEA分析时，我们的通路文件（也就是GSEA官网中的GMT文件，对应的就是基因集<code>S</code>）储存在<code>pathways</code>参数中，用户自己的数据（排过序的数据）放在<code>stats</code>数据集中，剩下的参数不用管，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fgseaRes &lt;- fgsea(pathways = examplePathways, </div><div class="line">                  stats = exampleRanks,</div><div class="line">                  minSize=<span class="number">15</span>,</div><div class="line">                  maxSize=<span class="number">500</span>,</div><div class="line">                  nperm=<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>分析的结果fgseaRes是一个<code>data.table</code>格式的文件，使用<code>plotEnrichment</code>函数可以绘制出GSEA分析的结果，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">library(ggplot2)</div><div class="line"># 参考 https://github.com/Rdatatable/data.table/wiki</div><div class="line"># 来查看data.table相关的信息</div><div class="line">class(fgseaRes)</div><div class="line"></div><div class="line"># 查看p值小于0.01的通路的数目</div><div class="line">sum(fgseaRes[, padj &lt; 0.01])</div><div class="line"></div><div class="line"># 绘制出最显著的富集通路</div><div class="line">plotEnrichment(examplePathways[[head(fgseaRes[order(pval), ], 1)$pathway]],</div><div class="line">               exampleRanks) + </div><div class="line">               labs(title=head(fgseaRes[order(pval), ], 1)$pathway)</div></pre></td></tr></table></figure></p>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; class(fgseaRes)</div><div class="line">[<span class="number">1</span>] <span class="string">"data.table"</span> <span class="string">"data.frame"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 查看p值小于0.01的通路的数目</span></div><div class="line">&gt; sum(fgseaRes[, padj &lt; <span class="number">0.01</span>])</div><div class="line">[<span class="number">1</span>] <span class="number">78</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911122517.jpeg">

</div>
<p>可以画出具体的某条通路，如下所示；</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plotEnrichment(examplePathways[[<span class="string">"5991130_Programmed_Cell_Death"</span>]],</div><div class="line">               exampleRanks) + </div><div class="line">  labs(title=<span class="string">"Programmed Cell Death"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911125331.jpeg">

</div>
<p>还可以在一张图中绘制出前10个富集通路，以及后10个富集通路，一共20个，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">topPathwaysUp &lt;- fgseaRes[ES &gt; 0][head(order(pval), n=10), pathway]</div><div class="line">topPathwaysDown &lt;- fgseaRes[ES &lt; 0][head(order(pval), n=10), pathway]</div><div class="line">topPathways &lt;- c(topPathwaysUp, rev(topPathwaysDown))</div><div class="line">plotGseaTable(examplePathways[topPathways], exampleRanks, fgseaRes, </div><div class="line">              gseaParam = 0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911122626.jpeg">

</div>
<h3 id="reactome">Reactome</h3>
<p>也可以使用<a href="https://reactome.org/" target="_blank" rel="external">Reactome</a>通路来进行GSEA分析，此时需要安装<code>reactome.db</code>包，这个包很大，600多M，下载的时间很长，安装过程如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BiocManager::install("reactome.db")</span></div><div class="line"><span class="keyword">library</span>(reactome.db)</div><div class="line"></div><div class="line">my_pathways &lt;- reactomePathways(names(exampleRanks))</div><div class="line"> </div><div class="line"><span class="comment"># Reactome pathways have a median of 11 genes</span></div><div class="line">summary(sapply(my_pathways, length))</div><div class="line">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </div><div class="line">    <span class="number">1.0</span>     <span class="number">4.0</span>    <span class="number">11.0</span>    <span class="number">30.3</span>    <span class="number">30.0</span>  <span class="number">1140.0</span></div><div class="line"> </div><div class="line">fgsea_reactome &lt;- fgsea(pathways = my_pathways, </div><div class="line">                        stats = exampleRanks,</div><div class="line">                        minSize=<span class="number">15</span>,</div><div class="line">                        maxSize=<span class="number">500</span>,</div><div class="line">                        nperm=<span class="number">100000</span>)</div><div class="line"> </div><div class="line">head(fgsea_reactome[order(pval), ])</div><div class="line">sum(fgsea_reactome[, padj &lt; <span class="number">0.01</span>])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&gt; head(fgsea_reactome[order(pval), ])</div><div class="line">                    pathway         pval         padj</div><div class="line"><span class="number">1</span>:               Cell Cycle <span class="number">1.212856e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">2</span>:      Cell Cycle, Mitotic <span class="number">1.236552e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">3</span>: Neutrophil degranulation <span class="number">1.274974e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">4</span>: Signaling by Rho GTPases <span class="number">1.291339e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">5</span>:                  M Phase <span class="number">1.303509e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">6</span>:   Cell Cycle Checkpoints <span class="number">1.350749e-05</span> <span class="number">0.0002571089</span></div><div class="line">          ES      NES nMoreExtreme size</div><div class="line"><span class="number">1</span>: <span class="number">0.5324037</span> <span class="number">2.674889</span>            <span class="number">0</span>  <span class="number">414</span></div><div class="line"><span class="number">2</span>: <span class="number">0.5475346</span> <span class="number">2.719737</span>            <span class="number">0</span>  <span class="number">363</span></div><div class="line"><span class="number">3</span>: <span class="number">0.4258088</span> <span class="number">2.074081</span>            <span class="number">0</span>  <span class="number">296</span></div><div class="line"><span class="number">4</span>: <span class="number">0.4073481</span> <span class="number">1.966039</span>            <span class="number">0</span>  <span class="number">271</span></div><div class="line"><span class="number">5</span>: <span class="number">0.5022189</span> <span class="number">2.408762</span>            <span class="number">0</span>  <span class="number">255</span></div><div class="line"><span class="number">6</span>: <span class="number">0.6085986</span> <span class="number">2.836881</span>            <span class="number">0</span>  <span class="number">200</span></div><div class="line">                                  leadingEdge</div><div class="line"><span class="number">1</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line"><span class="number">2</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line"><span class="number">3</span>:    <span class="number">11676</span>,<span class="number">14190</span>,<span class="number">53381</span>,<span class="number">12306</span>,<span class="number">20430</span>,<span class="number">12505</span>,<span class="keyword">...</span></div><div class="line"><span class="number">4</span>: <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">20430</span>,<span class="number">104215</span>,<span class="number">233406</span>,<span class="number">107995</span>,<span class="keyword">...</span></div><div class="line"><span class="number">5</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="number">52276</span>,<span class="keyword">...</span></div><div class="line"><span class="number">6</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="number">12428</span>,<span class="keyword">...</span></div><div class="line">&gt; sum(fgsea_reactome[, padj &lt; <span class="number">0.01</span>])</div><div class="line">[<span class="number">1</span>] <span class="number">103</span></div></pre></td></tr></table></figure>
<h3 id="leading-edge">Leading edge</h3>
<p>在GSEA分析中，我们通常会提取那些构成高得分的核心基因。我们对高得分的核心基因的定义就是，基因集<code>S</code>中位于排序基因列表<code>L</code>位置中的得分最大处之前或之后的那些基因集（也就是GSEA结果中绿色曲线最高点的前面或后面）。</p>
<p>前面我们注意到，GSEA分析的结果中有1列被命名为<code>leadingEdge</code>。这一列包含了高得分的基因。我们使用Reactome通路的富集结果来提取这些基因，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># the most significant pathway</span></div><div class="line">fgsea_reactome[order(pval),][<span class="number">1</span>,]</div><div class="line"></div><div class="line"><span class="comment"># list of Entrez gene IDs that contributed to the enrichment score</span></div><div class="line">fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge</div><div class="line"></div><div class="line"><span class="comment"># how many genes are in the leading edge?</span></div><div class="line">length(fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge[[<span class="number">1</span>]])</div><div class="line"></div><div class="line"><span class="comment"># how many genes are in the Cell Cycle pathway?</span></div><div class="line">length(my_pathways[[<span class="string">'Cell Cycle'</span>]])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment"># the most significant pathway</span></div><div class="line">&gt; fgsea_reactome[order(pval),][<span class="number">1</span>,]</div><div class="line">      pathway         pval         padj        ES</div><div class="line"><span class="number">1</span>: Cell Cycle <span class="number">1.212856e-05</span> <span class="number">0.0002571089</span> <span class="number">0.5324037</span></div><div class="line">        NES nMoreExtreme size</div><div class="line"><span class="number">1</span>: <span class="number">2.674889</span>            <span class="number">0</span>  <span class="number">414</span></div><div class="line">                                leadingEdge</div><div class="line"><span class="number">1</span>: <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># list of Entrez gene IDs that contributed to the enrichment score</span></div><div class="line">&gt; fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge</div><div class="line">[[<span class="number">1</span>]]</div><div class="line">  [<span class="number">1</span>] <span class="string">"66336"</span>  <span class="string">"66977"</span>  <span class="string">"15366"</span>  <span class="string">"12442"</span>  <span class="string">"107995"</span></div><div class="line">  [<span class="number">6</span>] <span class="string">"66442"</span>  <span class="string">"12571"</span>  <span class="string">"12428"</span>  <span class="string">"52276"</span>  <span class="string">"54392"</span> </div><div class="line"> [<span class="number">11</span>] <span class="string">"66311"</span>  <span class="string">"215387"</span> <span class="string">"67629"</span>  <span class="string">"12649"</span>  <span class="string">"72415"</span> </div><div class="line"> [<span class="number">16</span>] <span class="string">"56150"</span>  <span class="string">"57441"</span>  <span class="string">"20877"</span>  <span class="string">"67121"</span>  <span class="string">"12615"</span> </div><div class="line"> [<span class="number">21</span>] <span class="string">"11799"</span>  <span class="string">"66468"</span>  <span class="string">"67849"</span>  <span class="string">"19053"</span>  <span class="string">"73804"</span> </div><div class="line"> [<span class="number">26</span>] <span class="string">"76044"</span>  <span class="string">"20878"</span>  <span class="string">"15270"</span>  <span class="string">"13555"</span>  <span class="string">"60411"</span> </div><div class="line"> [<span class="number">31</span>] <span class="string">"12580"</span>  <span class="string">"17219"</span>  <span class="string">"69270"</span>  <span class="string">"12575"</span>  <span class="string">"69263"</span> </div><div class="line"> [<span class="number">36</span>] <span class="string">"12448"</span>  <span class="string">"14211"</span>  <span class="string">"20873"</span>  <span class="string">"18005"</span>  <span class="string">"72119"</span> </div><div class="line"> [<span class="number">41</span>] <span class="string">"71988"</span>  <span class="string">"12189"</span>  <span class="string">"17215"</span>  <span class="string">"12534"</span>  <span class="string">"66156"</span> </div><div class="line"> [<span class="number">46</span>] <span class="string">"208628"</span> <span class="string">"237911"</span> <span class="string">"22390"</span>  <span class="string">"68240"</span>  <span class="string">"228421"</span></div><div class="line"> [<span class="number">51</span>] <span class="string">"68014"</span>  <span class="string">"269582"</span> <span class="string">"19348"</span>  <span class="string">"12236"</span>  <span class="string">"72151"</span> </div><div class="line"> [<span class="number">56</span>] <span class="string">"18817"</span>  <span class="string">"21781"</span>  <span class="string">"18968"</span>  <span class="string">"217653"</span> <span class="string">"66934"</span> </div><div class="line"> [<span class="number">61</span>] <span class="string">"272551"</span> <span class="string">"227613"</span> <span class="string">"67141"</span>  <span class="string">"67951"</span>  <span class="string">"68612"</span> </div><div class="line"> [<span class="number">66</span>] <span class="string">"68298"</span>  <span class="string">"108000"</span> <span class="string">"23834"</span>  <span class="string">"106344"</span> <span class="string">"56452"</span> </div><div class="line"> [<span class="number">71</span>] <span class="string">"242705"</span> <span class="string">"18141"</span>  <span class="string">"223921"</span> <span class="string">"26886"</span>  <span class="string">"13557"</span> </div><div class="line"> [<span class="number">76</span>] <span class="string">"26909"</span>  <span class="string">"72787"</span>  <span class="string">"268697"</span> <span class="string">"72155"</span>  <span class="string">"56371"</span> </div><div class="line"> [<span class="number">81</span>] <span class="string">"17535"</span>  <span class="string">"107823"</span> <span class="string">"12531"</span>  <span class="string">"327762"</span> <span class="string">"12567"</span> </div><div class="line"> [<span class="number">86</span>] <span class="string">"229841"</span> <span class="string">"67052"</span>  <span class="string">"16319"</span>  <span class="string">"66634"</span>  <span class="string">"171567"</span></div><div class="line"> [<span class="number">91</span>] <span class="string">"26931"</span>  <span class="string">"67203"</span>  <span class="string">"12235"</span>  <span class="string">"19891"</span>  <span class="string">"74470"</span> </div><div class="line"> [<span class="number">96</span>] <span class="string">"72083"</span>  <span class="string">"381318"</span> <span class="string">"66570"</span>  <span class="string">"17216"</span>  <span class="string">"76308"</span> </div><div class="line">[<span class="number">101</span>] <span class="string">"19687"</span>  <span class="string">"17218"</span>  <span class="string">"102920"</span> <span class="string">"29870"</span>  <span class="string">"18973"</span> </div><div class="line">[<span class="number">106</span>] <span class="string">"16881"</span>  <span class="string">"17463"</span>  <span class="string">"75786"</span>  <span class="string">"19645"</span>  <span class="string">"19075"</span> </div><div class="line">[<span class="number">111</span>] <span class="string">"26417"</span>  <span class="string">"69736"</span>  <span class="string">"19357"</span>  <span class="string">"76816"</span>  <span class="string">"70385"</span> </div><div class="line">[<span class="number">116</span>] <span class="string">"70645"</span>  <span class="string">"22628"</span>  <span class="string">"225182"</span> <span class="string">"22627"</span>  <span class="string">"52683"</span> </div><div class="line">[<span class="number">121</span>] <span class="string">"19076"</span>  <span class="string">"18972"</span>  <span class="string">"231863"</span> <span class="string">"26932"</span>  <span class="string">"12544"</span> </div><div class="line">[<span class="number">126</span>] <span class="string">"17997"</span>  <span class="string">"51788"</span>  <span class="string">"26440"</span>  <span class="string">"68549"</span>  <span class="string">"12445"</span> </div><div class="line">[<span class="number">131</span>] <span class="string">"19088"</span>  <span class="string">"269113"</span> <span class="string">"26444"</span>  <span class="string">"19324"</span>  <span class="string">"103733"</span></div><div class="line">[<span class="number">136</span>] <span class="string">"59001"</span>  <span class="string">"107976"</span> <span class="string">"19179"</span>  <span class="string">"12579"</span>  <span class="string">"232987"</span></div><div class="line">[<span class="number">141</span>] <span class="string">"17420"</span>  <span class="string">"228769"</span> <span class="string">"219072"</span> <span class="string">"26445"</span>  <span class="string">"105988"</span></div><div class="line">[<span class="number">146</span>] <span class="string">"69745"</span>  <span class="string">"18538"</span>  <span class="string">"69928"</span>  <span class="string">"11651"</span>  <span class="string">"235559"</span></div><div class="line">[<span class="number">151</span>] <span class="string">"68097"</span>  <span class="string">"57296"</span>  <span class="string">"63955"</span>  <span class="string">"14235"</span>  <span class="string">"19170"</span> </div><div class="line">[<span class="number">156</span>] <span class="string">"17246"</span>  <span class="string">"17220"</span>  <span class="string">"12144"</span>  <span class="string">"50793"</span>  <span class="string">"77605"</span> </div><div class="line">[<span class="number">161</span>] <span class="string">"18392"</span>  <span class="string">"236930"</span> <span class="string">"67151"</span>  <span class="string">"70024"</span>  <span class="string">"59126"</span> </div><div class="line">[<span class="number">166</span>] <span class="string">"66296"</span>  <span class="string">"16906"</span>  <span class="string">"109145"</span> <span class="string">"71819"</span>  <span class="string">"67733"</span> </div><div class="line">[<span class="number">171</span>] <span class="string">"50883"</span>  <span class="string">"12447"</span>  <span class="string">"12532"</span>  <span class="string">"14156"</span>  <span class="string">"26442"</span> </div><div class="line">[<span class="number">176</span>] <span class="string">"19177"</span>  <span class="string">"230376"</span> <span class="string">"245688"</span></div><div class="line"></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># how many genes are in the leading edge?</span></div><div class="line">&gt; length(fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge[[<span class="number">1</span>]])</div><div class="line">[<span class="number">1</span>] <span class="number">178</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># how many genes are in the Cell Cycle pathway?</span></div><div class="line">&gt; length(my_pathways[[<span class="string">'Cell Cycle'</span>]])</div><div class="line">[<span class="number">1</span>] <span class="number">414</span></div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>GSEA是于2005年首次提出来的，现在已经成了基因表达分析中的常规分析手段，它不同于GO分析，GO分析只关注差异基因，而GSEA分析则关注所有的基因。<code>fgsea</code>包可以使用预先排列好的基因一R中进行GSEA分析。p值的计算结果是基于置换检验(permutation test)，这种方法并不是十分精我，因为它忽略了基因之间的相关性，有可能会导致假阳性。但是，在这种方法在研究上调与上调基因方面还是很有用的。即使你计算出的GSEA结果中，p值大于0.05，但是是也可以参考leading edge基因集，为你的实验进行指导。</p>
<h2 id="案例分析">案例分析</h2>
<p>作者提供了用于生成类似于<strong>exampleRanks</strong>文件的R脚本，不过使用的GEO的数据，平时自己利用<code>fgsea</code>包进行GSEA分析时，生成就好，现在看一下如何将GEO的数据生成类似于****exampleRanks****文件的排序信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span>(<span class="string">"https://raw.githubusercontent.com/assaron/r-utils/master/R/exprs.R"</span>)</div><div class="line"><span class="keyword">library</span>(GEOquery)</div><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">gse14308 &lt;- getGEO(<span class="string">"GSE14308"</span>)[[<span class="number">1</span>]]</div><div class="line">pData(gse14308)$condition &lt;- sub(<span class="string">"-.*$"</span>, <span class="string">""</span>, gse14308$title)</div><div class="line">es &lt;- collapseBy(gse14308, fData(gse14308)$ENTREZ_GENE_ID, FUN=median)</div><div class="line">es &lt;- es[!grepl(<span class="string">"///"</span>, rownames(es)), ]</div><div class="line">es &lt;- es[rownames(es) != <span class="string">""</span>, ]</div><div class="line">exprs(es) &lt;- normalizeBetweenArrays(log2(exprs(es)+<span class="number">1</span>), method=<span class="string">"quantile"</span>)</div><div class="line">es.design &lt;- model.matrix(~<span class="number">0</span>+condition, data=pData(es))</div><div class="line">fit &lt;- lmFit(es, es.design)</div><div class="line">fit2 &lt;- contrasts.fit(fit, makeContrasts(conditionTh1-conditionNaive,</div><div class="line">                                         levels=es.design))</div><div class="line">fit2 &lt;- eBayes(fit2)</div><div class="line">de &lt;- data.table(topTable(fit2, adjust.method=<span class="string">"BH"</span>, number=<span class="number">12000</span>, sort.by = <span class="string">"B"</span>), keep.rownames = <span class="literal">T</span>)</div><div class="line">ranks &lt;- de[order(t), list(rn, t)]</div><div class="line">head(ranks)</div><div class="line">tail(ranks)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; head(ranks)</div><div class="line">       rn         t</div><div class="line"><span class="number">1</span>: <span class="number">109711</span> -<span class="number">50.99316</span></div><div class="line"><span class="number">2</span>:  <span class="number">18124</span> -<span class="number">44.40559</span></div><div class="line"><span class="number">3</span>:  <span class="number">12775</span> -<span class="number">43.22109</span></div><div class="line"><span class="number">4</span>:  <span class="number">72148</span> -<span class="number">33.74441</span></div><div class="line"><span class="number">5</span>:  <span class="number">16010</span> -<span class="number">33.34034</span></div><div class="line"><span class="number">6</span>:  <span class="number">16206</span> -<span class="number">30.67962</span></div><div class="line">&gt; tail(ranks)</div><div class="line">      rn        t</div><div class="line"><span class="number">1</span>: <span class="number">80901</span> <span class="number">47.55618</span></div><div class="line"><span class="number">2</span>: <span class="number">58801</span> <span class="number">48.53756</span></div><div class="line"><span class="number">3</span>: <span class="number">15937</span> <span class="number">49.88068</span></div><div class="line"><span class="number">4</span>: <span class="number">13730</span> <span class="number">50.17693</span></div><div class="line"><span class="number">5</span>: <span class="number">12772</span> <span class="number">50.32302</span></div><div class="line"><span class="number">6</span>: <span class="number">80876</span> <span class="number">51.72987</span></div></pre></td></tr></table></figure>
<p>现在绘制一下上述数据中6个上升与6个下降的基因热图：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(pheatmap)</div><div class="line"> </div><div class="line">my_group &lt;- data.frame(group = pData(es)$condition)</div><div class="line">row.names(my_group) &lt;- colnames(exprs(es))</div><div class="line"> </div><div class="line">pheatmap(</div><div class="line">  mat = es[c(head(de[order(t), <span class="number">1</span>])$rn, tail(de[order(t), <span class="number">1</span>])$rn),],</div><div class="line">  annotation_col = my_group,</div><div class="line">  cluster_rows = <span class="literal">FALSE</span>,</div><div class="line">  cellwidth=<span class="number">25</span>,</div><div class="line">  cellheight=<span class="number">15</span></div><div class="line">)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911133906.png">

</div>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/fgsea/inst/doc/fgsea-tutorial.html" target="_blank" rel="external">Using fgsea package</a></li>
<li><a href="https://www.r-bloggers.com/comparison-of-clusterprofiler-and-gsea-p/" target="_blank" rel="external">Comparison of clusterProfiler and GSEA-P</a></li>
<li><a href="https://davetang.org/muse/2018/01/10/using-fast-preranked-gene-set-enrichment-analysis-fgsea-package/" target="_blank" rel="external">Using the fast preranked gene set enrichment analysis (fgsea) package</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/07/Experiment/HIPC介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Experiment/HIPC介绍/" itemprop="url">HIPC介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T12:00:00+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物实验笔记/" itemprop="url" rel="index">
                    <span itemprop="name">生物实验笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  803
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>最近在看GSEA有关的内容，GSEA官网里涉及到一个基因集，即<code>C7 collection: Immunologic signatures</code>，这是一个与免疫相关的基因集，根据官网的介绍，这个基因集是由BROAD实验室与丹娜法伯癌症研究院（Dana-Farber Cancer Institute）的Haining Lab和人类免疫学项目联合合会(HIPC)合作的一部分，当时还发了一篇Immunity，文献信息如下：</p>
<p>Godec J, Tan Y, Liberzon A, Tamayo P, Bhattacharya S, Butte A, Mesirov JP, Haining WN, Compendium of Immune Signatures Identifies Conserved and Species-Specific Biology in Response to Inflammation, 2016, Immunity 44(1), 194-206.</p>
<p>以下内容是HIPC官网的一些资料。</p>
<h2 id="hipc简介">HIPC简介</h2>
<p>HIPC英文全称是Human Immunology Project Consortium，即人类免疫学项目研究联合会，成立于2010年，后又于2015年重组，即由原来的NIAID的过敏所（注：NIAID的全称为National Institute of Allergy and Infectious Diseases，即<strong>国家过敏与感染性疾病研究院</strong>），免疫所和移植所进行合并，统一作为NIAID的构成部分，集中研究人类免疫学。</p>
<p>注：上面一段话是我按原文翻译后理解的，不一定准确，为了避免歧义我，这里贴出原文：</p>
<blockquote>
<p>The Human Immunology Project Consortium (HIPC) program was established in 2010, and renewed in 2015, by the NIAID Division of Allergy, Immunology, and Transplantation as part of the overall NIAID focus on human immunology.</p>
</blockquote>
<p>通过HIPC计划，研究者们使用各种现代分析工具分析人类多个免疫学方面的数据，其中包括多重转录(multiplex transcriptional)，细胞因子，蛋白质谱；白细胞亚型的多参数表型(multiparameter phenotyping of leukocyte subsets)；评估白细胞功能状态以及开发多种算法。</p>
<p>HIPC项目旨在建立一个集中的研究中心，以及一个广泛的，中心化的数据库，从而让更多的研究者们使用。HIPC项目产生的信息将会有助于研究者们广泛地理解人类免疫系统方方面面，包括免疫系统的调控，发现免疫系统组分与其它生物系统的新型关系，从而确定新的免疫介质与通路，以及构建不同种群疫苗案安全性的预测因子，从而确保对不同疫苗配方的快速评估，确立接种方案等。该知识库还将会构建起免疫系统介导的人类疾病的研究基础，这些人类免疫性疾病包括过敏，哮喘，移植排斥和自身免疫性疾病以及各种炎症性疾病。</p>
<h2 id="hipc的任务">HIPC的任务</h2>
<h3 id="目标">目标</h3>
<ol style="list-style-type: decimal">
<li>定义稳定和活化的人类免疫系统的表达谱/标签/足迹(Define profiles/signatures/fingerprints of steady-state and activated human immune system)</li>
<li>创建一个中心化的知识库或资源：</li>
</ol>
<ul>
<li>有利于研究人类免疫系统；</li>
<li>针对人类疾病开发新的疗法。</li>
</ul>
<h3 id="研究">研究</h3>
<ol style="list-style-type: decimal">
<li>感染导致的稳态异常(Perturbations of the steady-state by infection)；</li>
<li>疫苗；</li>
<li>佐剂研究(Adjuvant administration )</li>
</ol>
<h3 id="方法">方法</h3>
<ol style="list-style-type: decimal">
<li>定义人类转录组/蛋白质谱；</li>
<li>多重分析(multiplex assays)；</li>
<li>多参数表型，系统生物学；</li>
<li>质谱。</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>https://www.immuneprofiling.org/hipc/page/showPage?pg=sci-about</li>
<li>http://software.broadinstitute.org/gsea/msigdb/collection_details.jsp#C7</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/27/DAL/DALS027_Batch_Effect03_AdjustBatchEffect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/27/DAL/DALS027_Batch_Effect03_AdjustBatchEffect/" itemprop="url">DALS027-如何对批次效应校正</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T12:00:00+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  59
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第10章批次效应的第3小节，这一部分的主要内容涉及批次效应(Batch Effects)的校正，有关这一部分Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/adjusting_with_linear_models.Rmd" target="_blank" rel="external">Github</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/26/DAL/DALS026_Batch_Effect02_DiscoteryBatchEffect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/DAL/DALS026_Batch_Effect02_DiscoteryBatchEffect/" itemprop="url">DALS026-如何发现批次效应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T12:00:00+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,117
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第10章批次效应的第2小节，这一部分的主要内容涉及批次效应(Batch Effects)的发现与处理，有关这一部分Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/tree/master/batch/eda_with_pca.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经介绍过了PCA，我们在实际运用过程中就可以使用PCA来进行探索性数据分析了。为了说明这一点，我们将会使用一个实际中的数据集，出于我们教学的目的，这个数据还是原始数据，并没有经过数据清洗。我们首先从公共数据库中下载这个原始数据，接着你要做的就是预处理这些数据，并使用Bioconductor中的一个包进行后续的数据分析。</p>
<h2 id="基因表达数据">基因表达数据</h2>
<p>第一步，下载数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="comment"># devtools::install_github("genomicsclass/GSE5859")</span></div><div class="line"><span class="keyword">library</span>(GSE5859) <span class="comment">##Available from GitHub</span></div><div class="line">data(GSE5859)</div></pre></td></tr></table></figure>
<p>注：这里书本中有所出入，</p>
<p>第二步，数据探索。这里先从探索样本相关性矩阵开始，我们注意到有一对样本的相关性是1.这就问题时着有一个样本被上传到了公共数据库2次，但是上传后的名称不同，下面的代码将会剔除这个样本，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cors &lt;- cor(exprs(e))</div><div class="line">Pairs=which(abs(cors)&gt;<span class="number">0.9999</span>,arr.ind=<span class="literal">TRUE</span>)</div><div class="line">out = Pairs[which(Pairs[,<span class="number">1</span>]&lt;Pairs[,<span class="number">2</span>]),,drop=<span class="literal">FALSE</span>]</div><div class="line"><span class="keyword">if</span>(length(out[,<span class="number">2</span>])&gt;<span class="number">0</span>) e=e[,-out[<span class="number">2</span>]]</div></pre></td></tr></table></figure>
<p>还可以移除控制组的探针名，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">out &lt;- grep(<span class="string">"AFFX"</span>,featureNames(e))</div><div class="line">e &lt;- e[-out,]</div></pre></td></tr></table></figure>
<p>第三步，处理数据。现在我们创建一个去趋势(detrended)基因表达数据矩阵，并从样本注释表中提取日期与结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y &lt;- exprs(e)-rowMeans(exprs(e))</div><div class="line">dates &lt;- pData(e)$date</div><div class="line">eth &lt;- pData(e)$ethnicity</div></pre></td></tr></table></figure>
<p>原始数据集中不包括样本信息中的性别。但是，我们为了出于教学的目的，我们使用下面的数据来研究一下这个性别问题，也就是说，在下面的代码中，我们会展示一下如何预测每个样本的性别。这种计算的基本思想就是观察Y染色体中基因的中位数基因表达水平。男性的这个数字应该更高。为此，我们需要上传一个注释包，用于提供这个实验中所用平台的一些特征信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">annotation(e)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; annotation(e)</div><div class="line">[<span class="number">1</span>] <span class="string">"hgfocus"</span></div></pre></td></tr></table></figure>
<p>此时，我们需要下载并安装<code>hgfocus.db</code>包，然后提取染色体位置的信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">map2gene &lt;- mapIds(hgfocus.db, keys=featureNames(e),</div><div class="line">                   column=<span class="string">"ENTREZID"</span>, keytype=<span class="string">"PROBEID"</span>,</div><div class="line">                   multiVals=<span class="string">"first"</span>)</div><div class="line"><span class="keyword">library</span>(Homo.sapiens)</div><div class="line">map2chr &lt;- mapIds(Homo.sapiens, keys=map2gene,</div><div class="line">                  column=<span class="string">"TXCHROM"</span>, keytype=<span class="string">"ENTREZID"</span>,</div><div class="line">                  multiVals=<span class="string">"first"</span>)</div><div class="line">chryexp &lt;- colMeans(y[which(unlist(map2chr)==<span class="string">"chrY"</span>),])</div></pre></td></tr></table></figure>
<p>如果我们创建Y染色体中位数基因表达水平的直方图，我们就能清楚地看到差异，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">hist(chryexp)</div></pre></td></tr></table></figure>
<p>现在我们预测一下性别，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sex &lt;- factor(ifelse(chryexp&lt;<span class="number">0</span>,<span class="string">"F"</span>,<span class="string">"M"</span>))</div></pre></td></tr></table></figure>
<h3 id="计算主成分">计算主成分</h3>
<p>现在我们计算一下主成分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(y)</div><div class="line">dim(s$v)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; s &lt;- svd(y)</div><div class="line">&gt; dim(s$v)</div><div class="line">[<span class="number">1</span>] <span class="number">207</span> <span class="number">207</span></div></pre></td></tr></table></figure>
<p>我们也可以使用<code>prcomp()</code>函数来创建一个主成分对象。</p>
<h3 id="变异解释">变异解释</h3>
<p>第一步就是解释由结构(structure)诱导的样本的相关性程度是什么样的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(RColorBrewer)</div><div class="line">cols=colorRampPalette(rev(brewer.pal(<span class="number">11</span>,<span class="string">"RdBu"</span>)))(<span class="number">100</span>)</div><div class="line">image ( cor(y) ,col=cols,zlim=c(-<span class="number">1</span>,<span class="number">1</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916131005.jpeg">

</div>
<p>上图显示了相关性。每个小单元络的i与j代表了样本i和样本j的相关性。红色表示高，白色表示0，蓝色表示低。</p>
<p>这时我们使用了术语结构(structure)，结构是指，如果样本实际上是相互独立时我们所能发现的偏差。从上面图片上我们可以明显看到，样本实际上有分组，也就是说，不同组内的样本相关性比组外的更强。</p>
<p>我们需要生成一个简单的探索性图来确定我们㙘多少主成分来描述这种结构，这就是方差解释图。 如果数据是独立的，那么方差的解释就如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y0 &lt;- matrix( rnorm( nrow(y)*ncol(y) ) , nrow(y), ncol(y) )</div><div class="line">d0 &lt;- svd(y0)$d</div><div class="line">plot(d0^<span class="number">2</span>/sum(d0^<span class="number">2</span>),ylim=c(<span class="number">0</span>,<span class="number">.25</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916133405.jpeg">

</div>
<p>事实上，我们看到的方差解释图是下面的这个样子：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916133542.jpeg">

</div>
<p>至少有20个PC高于我们对独立数据的预期。我们下一步就是尝试用检测的变量来解释这些PC。这些PC是由种族(ethnicity)，性别(sex)还是时间(date)或其它的因素驱动的吗？</p>
<h3 id="mds图">MDS图</h3>
<p>如前面一样，我们可以先用MDS图来探索一下数据，回答上述提到的问题。探索感兴趣的变量和PC之间的关系的一种方法就是使用颜色来表示这些变量，例如，以下是使用表示了颜色来标记种族(ethnicity)这个变量，通过前两个PC来展示的数据结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cols = as.numeric(eth)</div><div class="line">mypar()</div><div class="line">plot(s$v[,<span class="number">1</span>],s$v[,<span class="number">2</span>],col=cols,pch=<span class="number">16</span>,</div><div class="line">     xlab=<span class="string">"PC1"</span>,ylab=<span class="string">"PC2"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(eth),col=seq(along=levels(eth)),pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916134050.jpeg">

</div>
<p>从上图来看，第1 PC与种族(ethnicity)有着很强的联系。但是，我们也会看到一些橙色的点有的形成了亚簇(subslusters)。我们从以前的预分析中也知道，种族(ethnicity)和预处理时间(preprocessing date)有相关性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">year = factor(format(dates,<span class="string">"%y"</span>))</div><div class="line">table(year,eth)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; table(year,eth)</div><div class="line">    eth</div><div class="line">year ASN CEU HAN</div><div class="line">  <span class="number">02</span>   <span class="number">0</span>  <span class="number">32</span>   <span class="number">0</span></div><div class="line">  <span class="number">03</span>   <span class="number">0</span>  <span class="number">54</span>   <span class="number">0</span></div><div class="line">  <span class="number">04</span>   <span class="number">0</span>  <span class="number">13</span>   <span class="number">0</span></div><div class="line">  <span class="number">05</span>  <span class="number">80</span>   <span class="number">3</span>   <span class="number">0</span></div><div class="line">  <span class="number">06</span>   <span class="number">2</span>   <span class="number">0</span>  <span class="number">23</span></div></pre></td></tr></table></figure>
<p>因此，我们通过与前面相同的图来研究一下，日期作为主要变异来源的可能性，在下面的图形中，我们使用颜色来表示年，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cols = as.numeric(year)</div><div class="line">mypar()</div><div class="line">plot(s$v[,<span class="number">1</span>],s$v[,<span class="number">2</span>],col=cols,pch=<span class="number">16</span>,</div><div class="line">     xlab=<span class="string">"PC1"</span>,ylab=<span class="string">"PC2"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(year),col=seq(along=levels(year)),pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916140347.jpeg">

</div>
<p>从上面图形我们看到，日期（以年为单位）也与第1PC非常相关。那么到底是哪个变量促进了这种情况呢？由于存在着很高的混杂(confounding)效应，现在还不清楚是哪个因素起了重要作用。但是，在解决这个问题方面，我们还会进一步探索数据。</p>
<h3 id="pc箱线图">PC箱线图</h3>
<p>样本之间的相关性的图形可以展示出一个复杂的结构，它似乎有5个以的因素（其中一个是年份）参与其中。很明显，这种复杂程度远非种族(ethnicity)这一个因素能解释的。我们此时还探索一下月份之间的相关性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">month &lt;- format(dates,<span class="string">"%y%m"</span>)</div><div class="line">length( unique(month))</div><div class="line">variable &lt;- as.numeric(month)</div><div class="line">mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span>)&#123;</div><div class="line">  boxplot(split(s$v[,i],variable),las=<span class="number">2</span>,range=<span class="number">0</span>)</div><div class="line">  stripchart(split(s$v[,i],variable),add=<span class="literal">TRUE</span>,vertical=<span class="literal">TRUE</span>,pch=<span class="number">1</span>,cex=<span class="number">.5</span>,col=<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一共有21个月份，下图是按照不同月份划分场次层后，根据第1PC到第4PC来绘制的箱线图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916141037.jpeg">

</div>
<p>从上图我们可以看到，月份与第1PC有着非常强烈的相关性，即使按照种族(ethnicity)和其它因素来划分层次，也是如此。我们要知道，2002-2004之间处理的样本都来自于同一种族群体。在这样的情况下，我们可以使用方差分析来查看一下PC与哪个月份相关，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">corr &lt;- sapply(<span class="number">1</span>:ncol(s$v),<span class="keyword">function</span>(i)&#123;</div><div class="line">  fit &lt;- lm(s$v[,i]~as.factor(month))</div><div class="line">  <span class="keyword">return</span>( summary(fit)$adj.r.squared )</div><div class="line">&#125;)</div><div class="line">mypar()</div><div class="line">plot(seq(along=corr), corr, xlab=<span class="string">"PC"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916141913.jpeg">

</div>
<p>从上图我们可以看到，第1 PC的相关性非常强，而对于前20左右的PC，相关性较强。我们还可以计算一下月份内与月份之间的F统计量，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Fstats&lt;- sapply(<span class="number">1</span>:ncol(s$v),<span class="keyword">function</span>(i)&#123;</div><div class="line">  fit &lt;- lm(s$v[,i]~as.factor(month))</div><div class="line">  Fstat &lt;- summary(aov(fit))[[<span class="number">1</span>]][<span class="number">1</span>,<span class="number">4</span>]</div><div class="line">  <span class="keyword">return</span>(Fstat)</div><div class="line">&#125;)</div><div class="line">mypar()</div><div class="line">plot(seq(along=Fstats),sqrt(Fstats))</div><div class="line">p &lt;- length(unique(month))</div><div class="line">abline(h=sqrt(qf(<span class="number">0.995</span>,p-<span class="number">1</span>,ncol(s$v)-<span class="number">1</span>)))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916142249.jpeg">

</div>
<p>上图展示的是，方差分析的F平方根，用于解释PC与月份的关系。</p>
<p>至此为止，我们就了解了如何使用PCA联合EDA来做为一个强大的功能检测并理解批次效应的。在后面的部分里，我们将会了解如何使用PC用于因子分析(factor analysis)，用于改进模型估计。</p>
<h2 id="练习">练习</h2>
<p>P431</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/25/DAL/DALS025_Batch_Effect01_Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/DAL/DALS025_Batch_Effect01_Introduction/" itemprop="url">DALS025-批次效应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T12:00:00+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,824
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第10章批次效应的第1小节，这一部分的主要内容涉及批次效应(Batch Effects)的介绍，有关批次效应的前言部分Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/intro_to_batch_effects.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="什么是批次效应">什么是批次效应</h2>
<p>高通量研究中一个经常被忽视的问题就是批次效应(batch effects)，批次效应受到当时检测的实验室条件、试剂批次和人员差异的影响。当批次效应与我们目标结果混淆并惬以不正确的结果时，这就成了一个主要问题。在这一章中，我们将详细地描述批次效应：对于批次效应如何检测、解释、建模和调整。</p>
<p>批次效应是基因组学研究中面临的最大挑战，尤其是在精确医学这个背景下。大多数情况（但并非全部）下，高通量技术已经被报道存在着一种形式或另外一种形式的批次效应[Leek et al. (2010) Nature Reviews Genetics 11, 733-739]。但是，批次效应并非基因组学所特有的。实际上， 在1972年一篇文献中，Mj Youden就在对物理常数的经验估计的背景下提到了批次效应。他指出，物理常数“存在着主观估计的特征”，以及如何在不同实验室之间变化的。例如，在下面的Table1中，Youden就展示了来自于不同实验室又的天文单的估计值。这些报告包括对离差(spread)（现在我们称之为置信区间）的估计。</p>
<figure class="highlight plain"><figcaption><span>astronomical_units,echo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(downloader)</div><div class="line">##Download the data from</div><div class="line">url &lt;- &quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/astronomicalunit.csv&quot;</div><div class="line">filename &lt;- tempfile() </div><div class="line">if (!file.exists(filename)) download(url, destfile=filename)</div><div class="line"></div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">year &lt;-  jitter(dat[,2]) ##add jitter so points are not on top of each other</div><div class="line"></div><div class="line">##Use color to denote the labs that reported more than one measurement</div><div class="line">labs &lt;- as.character(dat[,1]) ##what lab did it</div><div class="line">labs[ !labs%in%c(&quot;Jodrell Bank&quot;,&quot;Spencer Jones&quot;)] &lt;- &quot;Others&quot;</div><div class="line">labs &lt;- factor(labs, levels=c(&quot;Others&quot;,&quot;Spencer Jones&quot;,&quot;Jodrell Bank&quot;))</div><div class="line">cols=as.numeric(labs)</div><div class="line"></div><div class="line">current &lt;- 92.956039 ##this is the current estimate in millions of mph</div><div class="line"></div><div class="line">mypar()</div><div class="line">plot(year, dat[,3], ylim=c(min(dat[,4]),max(dat[,5])), pch=16, col=cols, </div><div class="line">     xlab=&quot;Year&quot;,ylab=&quot;Astronomical unit (millions of miles)&quot;)</div><div class="line">for(i in 1:nrow(dat))</div><div class="line">  lines(c(year[i],year[i]),c(dat[i,4],dat[i,5]),col=cols[i],lwd=3)</div><div class="line">legend(&quot;topright&quot;, legend=levels(labs), col=seq_along( labs ) ,cex=0.75, lty=1,pch=16)</div><div class="line">abline(h=current,lty=2)</div><div class="line">text(1905,current,&quot;Current estimate&quot;,pos=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914105414.jpeg">

</div>
<p>从不同实验室之间的可变性以及报道的界限（可以理解为置信区间）来看，都不能解释这种可变性，这就清楚地表明不同实验室之间，而非某个实验室内部存在着某些效应。这种类型的变异就是我们所谓的批次效应。请注意，有些实验室报告了两个估计值（紫色和橙色），这样我们就在相同的实验室也看到了批次效应。 我们可以使用统计学符号来精确地描述这个问题。我们使用下面的公式来表示这些检测值： <span class="math display">\[
Y_{i,j} = 
\mu + \varepsilon_{i,j}, j=1,\dots,N
\]</span></p>
<p>其中，<span class="math inline">\(Y_{i,j}\)</span> 表示第 <span class="math inline">\(i\)</span> 个实验室的第 <span class="math inline">\(j\)</span> 个检测值，而 <span class="math inline">\(\mu\)</span> 表示真实的物理常数，<span class="math inline">\(\varepsilon_{i,j}\)</span> 表示独立的检测误差。为了解释可变性，我们引入了 <span class="math inline">\(\varepsilon_{i,j}\)</span> ，随后我们根据数据来计算标准误。就像本书前面提到的那样，我们使用 <span class="math inline">\(N\)</span> 值均值来估计物理物理常数，如下所示： <span class="math display">\[
\bar{Y}_i = 
\frac{1}{N} \sum_{i=1}^{N} Y_{i,j}
\]</span></p>
<p>再来构建一个置信区间： <span class="math display">\[
\bar{Y}_i 
 \pm 2 s_i / \sqrt{N} \mbox{ with }
s_i^2= 
\frac{1}{N-1} \sum_{i=1}^N (Y_{i,j} - 
\bar{Y}_i)^2
\]</span></p>
<p>但是，这个置信区间太小，它无法覆盖批次效应的变异，下面是一个更加合适的模型： <span class="math display">\[
Y_{i,j} = \mu +
\gamma_i + \varepsilon_{i,j}, j=1, \dots, N
\]</span></p>
<p>其中 <span class="math inline">\(\gamma_i\)</span> 表示一个实验室特定的偏差或批次效应(batch effect)。从图片上我们可以明显看出来，实验室之间 <span class="math inline">\(\gamma\)</span> 的变化要远大于一个实验室内部 <span class="math inline">\(\varepsilon\)</span> 的变化。用统计学的术语来描述这个问题就是，<span class="math inline">\(\mu\)</span> 和 <span class="math inline">\(\gamma\)</span> 无法被识别。我们可以估计 <span class="math inline">\(\mu_i+\gamma_i\)</span> ，但是无法区分开。我们可以将 <span class="math inline">\(\gamma\)</span> 视为一个随机变量。在这个案例中，每个实验室都有一个错误项 <span class="math inline">\(\gamma_i\)</span> ，这一项在贯穿于该实验室的所有检测值，在每个检测值中，这一项是相同的，但是实验室与实验室间的这一项则不同。因此，这个问题就可以用以下方程表示： <span class="math display">\[
 s_i / \sqrt{N} \mbox{ with } 
 s_i^2= 
\frac{1}{N-1} \sum_{i=1}^N (Y_{ij} - 
\bar{Y}_i)^2
\]</span></p>
<p>这是对标准差的低估，因为它没有解释由 <span class="math inline">\(\gamma\)</span> 导致的实验室内的相关性（这一句不懂，原文如下：</p>
<blockquote>
<p>Under this interpretation the problem is that:is an underestimate of the standard error since it does not account for the within lab correlation induced by <span class="math inline">\(\gamma\)</span>.</p>
</blockquote>
<p>如果我们假设 <span class="math inline">\(\gamma=0\)</span> ，那么利用来自几个实验室的数据，我们实际上可以估计出 <span class="math inline">\(\gamma\)</span> 。或者说我们可以将它们视为随机效应，简单地将它们当成一个新的估计值，并使用所有的检测值来计算其标准差。以下是我们将报告中的均值值视为随机观察值的置信区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">avg &lt;- mean(dat[,3])</div><div class="line">se &lt;- sd(dat[,3]) / sqrt(nrow(dat))</div><div class="line">cat(&quot;95% confidence interval is: [&quot;,avg-1.96*se,&quot;,&quot;, avg+1.96*se,&quot;]&quot;)</div><div class="line">cat(&quot;which does include the current estimate is:&quot;,current)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"95% confidence interval is: ["</span>,avg-<span class="number">1.96</span>*se,<span class="string">","</span>, avg+<span class="number">1.96</span>*se,<span class="string">"]"</span>)</div><div class="line"><span class="number">95</span>% confidence interval is: [ <span class="number">92.8727</span> , <span class="number">92.98542</span> ]&gt; cat(<span class="string">"which does include the current estimate is:"</span>,current)</div><div class="line">which does include the current estimate is: <span class="number">92.95604</span></div></pre></td></tr></table></figure>
<p>Youden的论文还包括最近关于光速以及策略常数的批次效应估计的案例。在这一章里，我们只展示高通量生物数据中批次效应的广泛性和复杂性。</p>
<p>## 混杂</p>
<p>书中有一个术语，即<code>confounding</code>，这里译为<code>混杂</code>。这一部分内容的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/confounding.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>当批次效应与我们的目标结果混杂时，就会导致严重的𨤹。这里我们描述一下混杂(confounding)，以及它与我们数据解释的关系。</p>
<p>我们从这本书或者说从任何其它数据分析课程中尝到最重要的思想之一就是“相关不等于因果”。这句话多数情况就是真的，一个常见的案例就是混杂(confounding)。简单地讲，当我们观察到 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 之间存在着相关(correlation)或关联(association)时，往往就会存在着混杂，但严格来说，这是因为 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 都依赖于一个无关的变量 <span class="math inline">\(Z\)</span> 。这里我们会描述一个Simposon悖论，这是一个基于一个著名的法律案件的案例，接着，我们还会提到一个在高通量生物学研究中的一个混杂案例。</p>
<h3 id="案例之simpson悖论">案例之Simpson悖论</h3>
<p>加州大学伯克分校(UCB)1973年的入学数据显示，在录取的学生中，44%是男性，30%是女性，显著男性更多，以下是这些数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">library(dagdata)</div><div class="line">data(admissions)</div><div class="line">admissions$total=admissions$Percent*admissions$Number/100</div><div class="line">##percent men get in</div><div class="line">sum(admissions$total[admissions$Gender==1]/sum(admissions$Number[admissions$Gender==1]))</div><div class="line">##percent women get in</div><div class="line">sum(admissions$total[admissions$Gender==0]/sum(admissions$Number[admissions$Gender==0]))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; sum(admissions$total[admissions$Gender==<span class="number">1</span>]/sum(admissions$Number[admissions$Gender==<span class="number">1</span>]))</div><div class="line">[<span class="number">1</span>] <span class="number">0.4451951</span></div><div class="line">&gt; <span class="comment">##percent women get in</span></div><div class="line">&gt; sum(admissions$total[admissions$Gender==<span class="number">0</span>]/sum(admissions$Number[admissions$Gender==<span class="number">0</span>]))</div><div class="line">[<span class="number">1</span>] <span class="number">0.3033351</span></div></pre></td></tr></table></figure>
<p>卡方检验的结果明确拒绝零假设，即录取的性别是独立的，两者不受影响（也就是说，男女录取公平），如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">##make a 2 x 2 table</div><div class="line">index = admissions$Gender==1</div><div class="line">men = admissions[index,]</div><div class="line">women = admissions[!index,]</div><div class="line">menYes = sum(men$Number*men$Percent/100)</div><div class="line">menNo = sum(men$Number*(1-men$Percent/100))</div><div class="line">womenYes = sum(women$Number*women$Percent/100)</div><div class="line">womenNo = sum(women$Number*(1-women$Percent/100))</div><div class="line">tab = matrix(c(menYes,womenYes,menNo,womenNo),2,2)</div><div class="line">print(chisq.test(tab)$p.val)</div></pre></td></tr></table></figure>
<p>p值如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(chisq.test(tab)$p.val)</div><div class="line">[<span class="number">1</span>] <span class="number">9.139492e-22</span></div></pre></td></tr></table></figure>
<p>但经过更仔细的观察会发现一个自相矛盾的结果，以下是按专业划分后，不同性别的录取百分比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,c(1,3)],admissions[7:12,3])</div><div class="line">colnames(y)[2:3]=c(&quot;Male&quot;,&quot;Female&quot;)</div><div class="line">y</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; y</div><div class="line">  Major Male Female</div><div class="line"><span class="number">1</span>     A   <span class="number">62</span>     <span class="number">82</span></div><div class="line"><span class="number">2</span>     B   <span class="number">63</span>     <span class="number">68</span></div><div class="line"><span class="number">3</span>     C   <span class="number">37</span>     <span class="number">34</span></div><div class="line"><span class="number">4</span>     D   <span class="number">33</span>     <span class="number">35</span></div><div class="line"><span class="number">5</span>     E   <span class="number">28</span>     <span class="number">24</span></div><div class="line"><span class="number">6</span>     <span class="literal">F</span>    <span class="number">6</span>      <span class="number">7</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，不同专业之间没有性别偏见。</p>
<p>但是，我们在前面使用了卡方检验发现，入学和性别之间存在着某种关系。然而，当我们的数据按照不同专业进行分组时，这种依赖性似乎消失了，这是怎么一回事呢？</p>
<p>这就是Simpson悖论的一个案例。</p>
<p>我们上面进行的卡方检验表明，入学和性别之间存在依赖关系。然而，当数据按专业分组时，这种依赖性似乎消失了。到底怎么回事？现在我们绘制一个能显示申请专业的人，以及最终进入这个专业读书的人的百分比的图形，用于说明男女在录取比例方面的问题，如下所示：</p>
<figure class="highlight plain"><figcaption><span>hard_major_confounding, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,5],admissions[7:12,5])</div><div class="line">y=sweep(y,2,colSums(y),&quot;/&quot;)*100</div><div class="line">x=rowMeans(cbind(admissions[1:6,3],admissions[7:12,3]))</div><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">matplot(x,y,xlab=&quot;percent that gets in the major&quot;,</div><div class="line">        ylab=&quot;percent that applies to major&quot;,</div><div class="line">        col=c(&quot;blue&quot;,&quot;red&quot;),cex=1.5)</div><div class="line">legend(&quot;topleft&quot;,c(&quot;Male&quot;,&quot;Female&quot;),col=c(&quot;blue&quot;,&quot;red&quot;),pch=c(&quot;1&quot;,&quot;2&quot;),box.lty=0)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914162851.jpeg">

</div>
<p>从图片上我们可以发现，男生更想申请那些“容易”的专业。也就是说，男生这个变量与“容易”专业这个变量发生了混杂。</p>
<h3 id="混杂的图形解释">混杂的图形解释</h3>
<p>在这一部分里，我们将混杂图形化。在下面的图形中，每个字母表示一个学生。被录取的人用绿色表示，字母表示专业。在第1张图中，所有相同性别的学生都被放在一起，我们可以发现，男生中绿色的比较更大，如下所示：</p>
<figure class="highlight plain"><figcaption><span>simpsons_paradox_illustration, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">###make data for plot</div><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">CEX=0.5</div><div class="line">NC &lt;- 70</div><div class="line">tmp=rowSums(tab)</div><div class="line">FNC &lt;- round(NC*tmp[2]/tmp[1])</div><div class="line">SCALE &lt;- 1</div><div class="line">makematrix&lt;-function(x,n,addx=0,addy=0)&#123;</div><div class="line">  m&lt;-ceiling(length(x)/n)</div><div class="line">  expand.grid(1:n+addx,addy+1:m)[seq(along=x),] </div><div class="line">&#125;</div><div class="line">males&lt;- sapply(1:6,function(i)&#123;</div><div class="line">  tot=admissions[i,2]*SCALE</div><div class="line">  p=admissions[i,3]/100</div><div class="line">  x=rep(c(0,1),round(tot*c(1-p,p)))</div><div class="line">&#125;)</div><div class="line">allmales&lt;-Reduce(c,males)</div><div class="line">females&lt;- sapply(7:12,function(i)&#123;</div><div class="line">  tot=admissions[i,2]*SCALE</div><div class="line">  p=admissions[i,3]/100</div><div class="line">  rep(c(0,1),round(tot*c(1-p,p)))</div><div class="line">&#125;)</div><div class="line">allfemales&lt;-Reduce(c,females)</div><div class="line">mypar(1,1)</div><div class="line">malepoints &lt;- makematrix(allmales,NC)</div><div class="line">femalepoints &lt;- makematrix(allfemales,FNC,NC+NC/10)</div><div class="line">NR &lt;- max(c(malepoints[,2],femalepoints[,2]))</div><div class="line">plot(0,type=&quot;n&quot;,xlim=c(min(malepoints[,1]),max(femalepoints[,1])),ylim=c(0,NR),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;)</div><div class="line">PCH=LETTERS[rep(1:6,sapply(males,length))]</div><div class="line">o&lt;-order(-allmales)</div><div class="line">points(malepoints,col=2-allmales[o],pch=PCH[o],cex=CEX)</div><div class="line">PCH=LETTERS[rep(1:6,sapply(females,length))]</div><div class="line">o&lt;-order(-allfemales)</div><div class="line">points(femalepoints,col=2-allfemales[o],pch=PCH[o],cex=CEX)</div><div class="line">abline(v=NC+NC/20)</div><div class="line">axis(side=3,c(NC/2,NC+NC/2),c(&quot;Male&quot;,&quot;Female&quot;),tick=FALSE)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163227.jpeg">

</div>
<p>现在我们按照专业对不同性别的学生进行分级。这里我们要注意，大多数被录取的学生（绿色）来源于两个容易的专业，即A和B，如下所示：</p>
<figure class="highlight plain"><figcaption><span>simpsons_paradox_illustration2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">malepoints &lt;- vector(&quot;list&quot;,length(males))</div><div class="line">femalepoints &lt;- vector(&quot;list&quot;,length(males))</div><div class="line">N&lt;- length(males)</div><div class="line"> </div><div class="line">ADDY &lt;- vector(&quot;numeric&quot;,N+1)</div><div class="line">for(i in 1:N)&#123;</div><div class="line">  malepoints[[i]] &lt;- makematrix(males[[i]],NC,0,ADDY[i])</div><div class="line">  femalepoints[[i]] &lt;- makematrix(females[[i]],FNC,NC+NC/10,ADDY[i])</div><div class="line">   ADDY[i+1] &lt;- max(malepoints[[i]][,2],femalepoints[[i]][,2])+1</div><div class="line">&#125;</div><div class="line">plot(0,type=&quot;n&quot;,</div><div class="line">     xlim=c( min(sapply(malepoints,function(x)min(x[,1]))),max(sapply(femalepoints,function(x)max(x[,1])))),</div><div class="line">  ylim=c(0,max(sapply(femalepoints,function(x)max(x[,2])))),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;)</div><div class="line">          </div><div class="line">for(i in 1:N)&#123;</div><div class="line">  points(malepoints[[i]],col=2+sort(-males[[i]]),pch=LETTERS[i],cex=CEX)</div><div class="line">  points(femalepoints[[i]],col=2+sort(-females[[i]]),pch=LETTERS[i],cex=CEX)</div><div class="line">  if(i&gt;1) abline(h=ADDY[i])</div><div class="line">  &#125;</div><div class="line">abline(v=NC+NC/20)</div><div class="line">axis(side=3,c(NC/2,NC+FNC/2),c(&quot;Male&quot;,&quot;Female&quot;),tick=FALSE)</div><div class="line">axis(side=2,ADDY[-1]/2+ADDY[-length(ADDY)]/2,LETTERS[1:N],tick=FALSE,las=1)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163301.jpeg">

</div>
<h3 id="分层后的均值">分层后的均值</h3>
<p>在下图中，我们可以看到，我们根据专业设定条件或分层后，然后再看差异，也就是说，当我们控制了混杂项后，这就混杂效应就消失了，如下所示：</p>
<figure class="highlight plain"><figcaption><span>admission_by_major, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,3],admissions[7:12,3])</div><div class="line">matplot(1:6,y,xaxt=&quot;n&quot;,xlab=&quot;major&quot;,ylab=&quot;percent&quot;,col=c(&quot;blue&quot;,&quot;red&quot;),cex=1.5)</div><div class="line">axis(1,1:6,LETTERS[1:6])</div><div class="line">legend(&quot;topright&quot;,c(&quot;Male&quot;,&quot;Female&quot;),col=c(&quot;blue&quot;,&quot;red&quot;),pch=c(&quot;1&quot;,&quot;2&quot;),</div><div class="line">       box.lty=0)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163912.jpeg">

</div>
<p>事实上，在不同专业录取的学生中，性别差异仅表示为，男生比女生高3.5%，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mean(y[,1]-y[,2])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y[,<span class="number">1</span>]-y[,<span class="number">2</span>])</div><div class="line">[<span class="number">1</span>] -<span class="number">3.5</span></div></pre></td></tr></table></figure>
<h3 id="棒球中的simpson悖论">棒球中的Simpson悖论</h3>
<p>在棒球比赛的统计中我们也经常看到Simpson悖论，现在我们来看一个有名的案例，在1995年和1996年，David Justice的平均击球率高于Derek Jeter，但是Jeter的击球率却高于整体平均水平，如下所示：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>1995</th>
<th>1996</th>
<th>Combined</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Derek Jeter</td>
<td>12/48 (.250)</td>
<td>183/582 (.314)</td>
<td>195/630 (.310)</td>
</tr>
<tr class="even">
<td>David Justice</td>
<td>104/411 (.253)</td>
<td>45/140 (.321)</td>
<td>149/551 (.270)</td>
</tr>
</tbody>
</table>
<p>这里的混杂项就是比赛场次，Jeter的比赛场次数目更多，但是结果却是Justice击球率更高。</p>
<h3 id="混杂之高通量案例">混杂之高通量案例</h3>
<p>为了描述我们在生物学中遇到的混杂问题，我们将会使用<a href="https://www.ncbi.nlm.nih.gov/pubmed/17206142" target="_blank" rel="external">《Common genetic variants account for differences in gene expression among ethnic groups》</a>这篇文献中的数据集，这篇文献指出，两个不同种族的血液大约有50%的差异基因，现在我们来下载这个数据集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(Biobase) ##available from Bioconductor</div><div class="line">library(genefilter) </div><div class="line">load(&quot;GSE5859.rda&quot;) ##available from github</div></pre></td></tr></table></figure>
<p>我们使用Bioconductor中的函数<code>exprs</code>和<code>pData</code>就能提取基因的表达数据与样本信息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">geneExpression = exprs(e)</div><div class="line">sampleInfo = pData(e)</div></pre></td></tr></table></figure>
<p>需要注意，样本按照不同的时间进行了处理，如下所示：</p>
<p>Note that some samples were processed at different times.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">head(sampleInfo)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(sampleInfo)</div><div class="line">  ethnicity       date        filename</div><div class="line"><span class="number">1</span>       CEU <span class="number">2003</span>-<span class="number">02</span>-<span class="number">04</span> GSM25349.CEL.gz</div><div class="line"><span class="number">2</span>       CEU <span class="number">2003</span>-<span class="number">02</span>-<span class="number">04</span> GSM25350.CEL.gz</div><div class="line"><span class="number">3</span>       CEU <span class="number">2002</span>-<span class="number">12</span>-<span class="number">17</span> GSM25356.CEL.gz</div><div class="line"><span class="number">4</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">30</span> GSM25357.CEL.gz</div><div class="line"><span class="number">5</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">03</span> GSM25358.CEL.gz</div><div class="line"><span class="number">6</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">16</span> GSM25359.CEL.gz</div></pre></td></tr></table></figure>
<p>日期是一个无关的变量，它理论上不影响这个数据集中基因的表达值，然而，正如我们在前面分析中看到的那样，这个日期似乎也起了一些作用，因此我们在这里就来讲一下这个日期的因素。 我们可以明显看到，日期和种族这两个因素几乎完全混杂了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">year = factor( format(sampleInfo$date,&quot;%y&quot;) )</div><div class="line">tab = table(year,sampleInfo$ethnicity)</div><div class="line">print(tab)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; print(tab)</div><div class="line">    </div><div class="line">year ASN CEU HAN</div><div class="line">  <span class="number">02</span>   <span class="number">0</span>  <span class="number">32</span>   <span class="number">0</span></div><div class="line">  <span class="number">03</span>   <span class="number">0</span>  <span class="number">54</span>   <span class="number">0</span></div><div class="line">  <span class="number">04</span>   <span class="number">0</span>  <span class="number">13</span>   <span class="number">0</span></div><div class="line">  <span class="number">05</span>  <span class="number">80</span>   <span class="number">3</span>   <span class="number">0</span></div><div class="line">  <span class="number">06</span>   <span class="number">2</span>   <span class="number">0</span>  <span class="number">24</span></div></pre></td></tr></table></figure>
<p>通过t检验以及生成的火山图我们可以发现，不同种族之间似乎存在着数千个差异基因。但是，当我们仅仅对2002年和2003年的CEU人群进行比较发现，我们又发现了数千个差异基因：</p>
<figure class="highlight plain"><figcaption><span>volcano_plots, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">library(genefilter)</div><div class="line">##remove control genes</div><div class="line">out &lt;- grep(&quot;AFFX&quot;,rownames(geneExpression))</div><div class="line">eth &lt;- sampleInfo$ethnicity</div><div class="line">ind&lt;- which(eth%in%c(&quot;CEU&quot;,&quot;ASN&quot;))</div><div class="line">res1 &lt;- rowttests(geneExpression[-out,ind],droplevels(eth[ind]))</div><div class="line">ind &lt;- which(year%in%c(&quot;02&quot;,&quot;03&quot;) &amp; eth==&quot;CEU&quot;)</div><div class="line">res2 &lt;- rowttests(geneExpression[-out,ind],droplevels(year[ind]))</div><div class="line">XLIM &lt;- max(abs(c(res1$dm,res2$dm)))*c(-1,1)</div><div class="line">YLIM &lt;- range(-log10(c(res1$p,res2$p)))</div><div class="line">mypar(1,2)</div><div class="line">plot(res1$dm,-log10(res1$p),xlim=XLIM,ylim=YLIM,</div><div class="line">     xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;,main=&quot;Populations&quot;)</div><div class="line">plot(res2$dm,-log10(res2$p),xlim=XLIM,ylim=YLIM,</div><div class="line">     xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;,main=&quot;2003 v 2002&quot;)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914165820.jpeg">

</div>
<h2 id="练习">练习</h2>
<p>P419</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/24/DAL/DALS024_Basic_Machine_Learning03_Class_Prediction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/24/DAL/DALS024_Basic_Machine_Learning03_Class_Prediction/" itemprop="url">DALS024-机器学习03-分类预测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-24T12:00:00+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,035
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第3小节，这一部分的主要内容涉及类预测(Class Prediction)，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/machine_learning.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在这一部分中我们主要介绍分类预测(class prediction)。实际上，许多人将分类预测称为机器学习，有的时候我们会交替使用这两个术语。我们会对这个庞杂的主题做一个非常简单的介绍，重点关注一些具体的案例。</p>
<p>我们这里使用的案例来源于统计学的经典书籍，即Trevor Hastie, Robert Tibshirani and Jerome Friedman的《<em>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</em>》。与回归中的推断类似，机器学习(ML)也是研究结果 <span class="math inline">\(Y\)</span> 和协变量 <span class="math inline">\(X\)</span> 之间的关系。在ML中，我们将 <span class="math inline">\(X\)</span> 称为预测因子或特征值，ML和推断之间的主要区别在于，在ML中，我们主要研究使用 <span class="math inline">\(X\)</span> 来预测 <span class="math inline">\(Y\)</span> 。关于统计模型，我在常规的推断中，我们主要用来估计和解释模型参数，但在ML中，统计模型只是我们达到目的的手段，即预测 <span class="math inline">\(Y\)</span> 。</p>
<p>这里我们介绍理解ML的主要概念，以及两个具体的算法：回归(regression)和k近似算法(kNN,k nearest neighbors)。我们需要知道，绐中学习有几十种流行的算法，我们这里不一一列举。</p>
<p>在前面部分里，我们介绍了非常简单的单一预测因子案例。但是，大多数与这种案例相关的案例往往不止一个预测因子。为了说明这个问题，我们现在再介绍一个案例，其中 <span class="math inline">\(X\)</span> 是一个二维数据，<span class="math inline">\(Y\)</span> 是一个二分类结果。这个案例来源于Hastie, Tibshirani 和 Friedman的书中，在这个案例中， <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 并不线性关系。在下面的图形中，使用不 的颜色表示了实际的 <span class="math inline">\(f(x_1,x_2)=E(Y \mid X_1=x_1,X_2=x_2)\)</span> 值。下面的代码用于生成一个相对复杂的条件概率函数。我们随后会使用测试数据集与训练数据集。在下图中，我们使用红色来表示 <span class="math inline">\(f(x_1,x_2)\)</span>中接近于1的数据，使用蓝色表示接近于0的数据，中间过渡态使用黄色表示，如下所示：</p>
<figure class="highlight plain"><figcaption><span>conditional_prob, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(RColorBrewer)</div><div class="line">hmcol &lt;- colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(100)</div><div class="line">mycols=c(hmcol[1],hmcol[100])</div><div class="line">set.seed(1)</div><div class="line">##create covariates and outcomes</div><div class="line">##outcomes are alwasy 50 0s and 50 1s</div><div class="line">s2=0.15</div><div class="line">##pick means to create a non linear conditional expectation</div><div class="line">library(MASS)</div><div class="line">M0 &lt;- mvrnorm(10,c(1,0),s2*diag(2)) ##generate 10 means</div><div class="line">M1 &lt;- rbind(mvrnorm(3,c(1,1),s2*diag(2)),</div><div class="line">            mvrnorm(3,c(0,1),s2*diag(2)),</div><div class="line">            mvrnorm(4,c(0,0),s2*diag(2)))</div><div class="line">###funciton to generate random pairs</div><div class="line">s&lt;- sqrt(1/5)</div><div class="line">N=200</div><div class="line">makeX &lt;- function(M,n=N,sigma=s*diag(2))&#123;</div><div class="line">  z &lt;- sample(1:10,n,replace=TRUE) ##pick n at random from above 10</div><div class="line">  m &lt;- M[z,] ##these are the n vectors (2 components)</div><div class="line">  return(t(apply(m,1,function(mu) mvrnorm(1,mu,sigma)))) ##the final values</div><div class="line">&#125;</div><div class="line">###create the training set and the test set</div><div class="line">x0 &lt;- makeX(M0)##the final values for y=0 (green)</div><div class="line">testx0 &lt;- makeX(M0)</div><div class="line">x1 &lt;- makeX(M1)</div><div class="line">testx1 &lt;-makeX(M1)</div><div class="line">x &lt;- rbind(x0,x1) ##one matrix with everything</div><div class="line">test &lt;- rbind(testx0,testx1)</div><div class="line">y &lt;- c(rep(0,N),rep(1,N)) #the outcomes</div><div class="line">ytest &lt;- c(rep(0,N),rep(1,N))</div><div class="line">cols &lt;- mycols[c(rep(1,N),rep(2,N))]</div><div class="line">colstest &lt;- cols</div><div class="line">##Create a grid so we can predict all of X,Y</div><div class="line">GS &lt;- 150 ##grid size is GS x GS</div><div class="line">XLIM &lt;- c(min(c(x[,1],test[,1])),max(c(x[,1],test[,1])))</div><div class="line">tmpx &lt;- seq(XLIM[1],XLIM[2],len=GS)</div><div class="line">YLIM &lt;- c(min(c(x[,2],test[,2])),max(c(x[,2],test[,2])))</div><div class="line">tmpy &lt;- seq(YLIM[1],YLIM[2],len=GS)</div><div class="line">newx &lt;- expand.grid(tmpx,tmpy) #grid used to show color contour of predictions</div><div class="line">###Bayes rule: best possible answer</div><div class="line">p &lt;- function(x)&#123; ##probability of Y given X</div><div class="line">  p0 &lt;- mean(dnorm(x[1],M0[,1],s)*dnorm(x[2],M0[,2],s))</div><div class="line">  p1 &lt;- mean(dnorm(x[1],M1[,1],s)*dnorm(x[2],M1[,2],s))</div><div class="line">  p1/(p0+p1)</div><div class="line">&#125;</div><div class="line">###Create the bayesrule prediction</div><div class="line">bayesrule &lt;- apply(newx,1,p)</div><div class="line">colshat &lt;- bayesrule</div><div class="line">colshat &lt;- hmcol[floor(bayesrule*100)+1]</div><div class="line">mypar()</div><div class="line">plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912170040.jpeg">

</div>
<p>如果我们将那些 <span class="math inline">\(E(Y \mid X=x)&gt;0.5\)</span> 的点用红色表示，剩下的点用蓝色表示，我们就能看到一条明显的分界线，它将0与1的区域分开了，如下所示：</p>
<figure class="highlight plain"><figcaption><span>bayes_rule,fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">colshat[bayesrule&gt;=0.5] &lt;- mycols[2]</div><div class="line">colshat[bayesrule&lt;0.5] &lt;- mycols[1]</div><div class="line">plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div><div class="line">contour(tmpx,tmpy,matrix(round(bayesrule),GS,GS),levels=c(1,2),</div><div class="line">        add=TRUE,drawlabels=FALSE)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912170527.jpeg">

</div>
<p>通过上面的图形我们并没有看到“真相”(truth)。大多数的ML方法涉及估计的 <span class="math inline">\(f(x)\)</span> 。通常第一步就是将一个样本作为参数，也就是训练集(training set)，用它来估计 <span class="math inline">\(f(x)\)</span> 。我们将回顾一下两种具体的ML技术。首先，我们需要回顾一下我们用评估这些方法性能的主要概念。</p>
<h3 id="训练集">训练集</h3>
<p>在第一张图中，我们创建了一个训练集和一个测试集，现在我们画出来，如下所示：</p>
<figure class="highlight plain"><figcaption><span>test_train, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#x, test, cols, and coltest were created in code that was not shown</div><div class="line">#x is training x1 and x2, test is test x1 and x2</div><div class="line">#cols (0=blue, 1=red) are training observations</div><div class="line">#coltests are test observations</div><div class="line">mypar(1,2)</div><div class="line">plot(x,pch=21,bg=cols,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">plot(test,pch=21,bg=colstest,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912171217.jpeg">

</div>
<p>从上面我们可以看到，训练集（左侧）与测试集（右侧）有着相似的全局属性，因为它们是用相同的随机谈量生成的（蓝色点都趋向分布于右下角），但是它们的构建的过程还是不同的。原因在于，我们创建测试集和训练集的原因是通过测试与用于拟合模型或训练算法的数据不同的数据来检测过度训练。 我们将在下面看到它的重要性。</p>
<h4 id="利用回归进行预测">利用回归进行预测</h4>
<p>关于ML问题的第一个简单方法就是拟合一个双变量线性回归模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##x and y were created in the code (not shown) for the first plot</div><div class="line">#y is outcome for the training set</div><div class="line">X1 &lt;- x[,1] ##these are the covariates</div><div class="line">X2 &lt;- x[,2] </div><div class="line">fit1 &lt;- lm(y~X1+X2)</div></pre></td></tr></table></figure>
<p>一旦我们有了这些拟合的数据，我们就能使用 <span class="math inline">\(\hat{f}(x_1,x_2)=\hat{\beta}_0 + \hat{\beta}_1x_1 +\hat{\beta}_2 x_2\)</span> 来估计 <span class="math inline">\(f(x_1,x_2)\)</span> 。为了提供一个实际的预测结果，我们仅仅预测当 <span class="math inline">\(\hat{f}(x_1,x_2)&gt;0.5\)</span> 时结果为1（这一段不懂）。我们现在检测一个在训练集与测试集中的错误率，并绘制出边界区域，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">##prediction on train</div><div class="line">yhat &lt;- predict(fit1)</div><div class="line">yhat &lt;- as.numeric(yhat&gt;0.5)</div><div class="line">cat(&quot;Linear regression prediction error in train:&quot;,1-mean(yhat==y),&quot;\n&quot;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Linear regression prediction error <span class="keyword">in</span> train: <span class="number">0.295</span></div></pre></td></tr></table></figure>
<p>我们使用<code>predict()</code>函数就能很快地从任意数据集中来获得预测值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yhat &lt;- predict(fit1,newdata=data.frame(X1=newx[,1],X2=newx[,2]))</div></pre></td></tr></table></figure>
<p>现在我们生成图片，用于展示我们预测的1和0在图片上的分布，以及边界。我们还可以使用<code>predict()</code>函数从我们的测试集中生成预测数据。需要注意的是，我们无法在测试集中拟合模型：</p>
<figure class="highlight plain"><figcaption><span>regression_prediction, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">colshat &lt;- yhat</div><div class="line">colshat[yhat&gt;=0.5] &lt;- mycols[2]</div><div class="line">colshat[yhat&lt;0.5] &lt;- mycols[1]</div><div class="line">m &lt;- -fit1$coef[2]/fit1$coef[3] #boundary slope</div><div class="line">b &lt;- (0.5 - fit1$coef[1])/fit1$coef[3] #boundary intercept</div><div class="line">##prediction on test</div><div class="line">yhat &lt;- predict(fit1,newdata=data.frame(X1=test[,1],X2=test[,2]))</div><div class="line">yhat &lt;- as.numeric(yhat&gt;0.5)</div><div class="line">cat(&quot;Linear regression prediction error in test:&quot;,1-mean(yhat==ytest),&quot;\n&quot;)</div><div class="line">plot(test,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">abline(b,m)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div><div class="line">##test was created in the code (not shown) for the first plot</div><div class="line">points(test,bg=cols,pch=21)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912173537.jpeg">

</div>
<p>在上图中，我们使用 <span class="math inline">\(X_{1}\)</span>和 <span class="math inline">\(X_{2}\)</span> 作为预测因子估计了1的概率，预测的结果将高于0.5的数据标注成了红色，低于0.5的标注为了蓝色。</p>
<p>从计算结果来年地，训练集与测试集的错误率非常相似。因此我们可以相信似乎没有过度训练。这并不奇怪，因为我们使用了2参数模型来拟合400个数据点。不过需要注意的是，边界是一个直线。因为我们为这些数据拟合了一个平面，所以这里没有其它选择。线性回归方法过于僵化。这种僵化会让它稳定，并且避免过度训练。，但是线性回归也不能适合对 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(X\)</span> 之间的非线性关系进行拟合。我们之前在平滑部分中看到了这些东西。下一个ML技术将会达到我们之间平滑处理的那种效果。</p>
<h4 id="knn">kNN</h4>
<p>kNN的全称是K-nearest neighbors，即<code>k最近邻</code>，这种算法类似于微区间平滑处理，但是kNN更适合于多维数据。总的来说，只要给定我们想要估计的任意点 <span class="math inline">\(x\)</span> ，我们会寻找k个最近的点，然后取这些点的平均值。这就会估计 <span class="math inline">\(f(x_1,x_2)\)</span> , 跟微区间平滑处理生成一个条曲线类似。我们现在通过 <span class="math inline">\(k\)</span> 来控制灵活性。这时我们比较一下 <span class="math inline">\(k=1\)</span> 和 <span class="math inline">\(k=100\)</span> 时的计算结果：</p>
<figure class="highlight plain"><figcaption><span>message</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">mypar(2,2)</div><div class="line">for(k in c(1,100))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=k)</div><div class="line">  cat(&quot;KNN prediction error in train:&quot;,1-mean((as.numeric(yhat)-1)==y),&quot;\n&quot;)</div><div class="line">  ##make plot</div><div class="line">  yhat &lt;- knn(x,test,y,k=k)</div><div class="line">  cat(&quot;KNN prediction error in test:&quot;,1-mean((as.numeric(yhat)-1)==ytest),&quot;\n&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">&gt; <span class="keyword">for</span>(k <span class="keyword">in</span> c(<span class="number">1</span>,<span class="number">100</span>))&#123;</div><div class="line">+   <span class="comment">##predict on train</span></div><div class="line">+   yhat &lt;- knn(x,x,y,k=k)</div><div class="line">+   cat(<span class="string">"KNN prediction error in train:"</span>,<span class="number">1</span>-mean((as.numeric(yhat)-<span class="number">1</span>)==y),<span class="string">"\n"</span>)</div><div class="line">+   <span class="comment">##make plot</span></div><div class="line">+   yhat &lt;- knn(x,test,y,k=k)</div><div class="line">+   cat(<span class="string">"KNN prediction error in test:"</span>,<span class="number">1</span>-mean((as.numeric(yhat)-<span class="number">1</span>)==ytest),<span class="string">"\n"</span>)</div><div class="line">+ &#125;</div><div class="line">KNN prediction error <span class="keyword">in</span> train: <span class="number">0</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> test: <span class="number">0.375</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> train: <span class="number">0.2425</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> test: <span class="number">0.2825</span></div></pre></td></tr></table></figure>
<p>为了说明，当我们设定 <span class="math inline">\(k=1\)</span>时，训练集中没有错误，以及 <span class="math inline">\(k=100\)</span> 时错误升高的原因，我们用图片直观地展示一下上面的结果，如下所示：</p>
<figure class="highlight plain"><figcaption><span>knn, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">mypar(2,2)</div><div class="line">for(k in c(1,100))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=k)</div><div class="line">  ##make plot</div><div class="line">  yhat &lt;- knn(x,newx,y,k=k)</div><div class="line">  colshat &lt;- mycols[as.numeric(yhat)]</div><div class="line">  plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">  points(newx,col=colshat,cex=0.35,pch=16)</div><div class="line">  contour(tmpx,tmpy,matrix(as.numeric(yhat),GS,GS),levels=c(1,2),</div><div class="line">          add=TRUE,drawlabels=FALSE)</div><div class="line">  points(x,bg=cols,pch=21)</div><div class="line">  title(paste(&quot;Train: KNN (&quot;,k,&quot;)&quot;,sep=&quot;&quot;))</div><div class="line">  </div><div class="line">  plot(test,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">  points(newx,col=colshat,cex=0.35,pch=16)</div><div class="line">  contour(tmpx,tmpy,matrix(as.numeric(yhat),GS,GS),levels=c(1,2),</div><div class="line">          add=TRUE,drawlabels=FALSE)</div><div class="line">  points(test,bg=cols,pch=21)</div><div class="line">  title(paste(&quot;Test: KNN (&quot;,k,&quot;)&quot;,sep=&quot;&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912174226.jpeg">

</div>
<p>从图上我们可以发现，当 <span class="math inline">\(k=1\)</span> 时，在训练集中并没有出现错误，因为每个点都是它最接近的点，这个就是它自身。但是，我们可以看到一些蓝色的岛（由几个点构成的区域）在红色区域中，一旦我们将数据集移向测试集，就会出现一些错误。当 <span class="math inline">\(k=100\)</span> 时，我们没有这个问题（也就是说红蓝区域分得很开），我们可以看到，错误率比线性回归有着明显的降低。我们还看到，我们估计的 <span class="math inline">\(f(x_1,x_2)\)</span> 比较接近于真实情况。</p>
<h4 id="贝叶斯规则">贝叶斯规则</h4>
<p>在这一部分里，我们会比较了不同 <span class="math inline">\(k\)</span> 值下的训练集与测试集。我们还会比较当我们知道 <span class="math inline">\(\mbox{E}(Y \mid X_1=x1,X_2=x_2)\)</span> 时的错误率，这也就是所谓的贝叶斯规则(Bayes Rule)。</p>
<p>我们先来计算一下错误率，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">###Bayes Rule</div><div class="line">yhat &lt;- apply(test,1,p)</div><div class="line">cat(&quot;Bayes rule prediction error in train&quot;,1-mean(round(yhat)==y),&quot;\n&quot;)</div><div class="line">bayes.error=1-mean(round(yhat)==y)</div><div class="line">train.error &lt;- rep(0,16)</div><div class="line">test.error &lt;- rep(0,16)</div><div class="line">for(k in seq(along=train.error))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=2^(k/2))</div><div class="line">  train.error[k] &lt;- 1-mean((as.numeric(yhat)-1)==y)</div><div class="line">  ##prediction on test    </div><div class="line">  yhat &lt;- knn(x,test,y,k=2^(k/2))</div><div class="line">  test.error[k] &lt;- 1-mean((as.numeric(yhat)-1)==y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后绘制出不同 <span class="math inline">\(k\)</span> 值下的错误率。我们还以一条水平线来展示贝叶斯规则错误率，如下所示</p>
<figure class="highlight plain"><figcaption><span>bayes_rule2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ks &lt;- 2^(seq(along=train.error)/2)</div><div class="line">mypar()</div><div class="line">plot(ks,train.error,type=&quot;n&quot;,xlab=&quot;K&quot;,ylab=&quot;Prediction Error&quot;,log=&quot;x&quot;,</div><div class="line">     ylim=range(c(test.error,train.error)))</div><div class="line">lines(ks,train.error,type=&quot;b&quot;,col=4,lty=2,lwd=2)</div><div class="line">lines(ks,test.error,type=&quot;b&quot;,col=5,lty=3,lwd=2)</div><div class="line">abline(h=bayes.error,col=6)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;Train&quot;,&quot;Test&quot;,&quot;Bayes&quot;),col=c(4,5,6),lty=c(2,3,1),box.lwd=0)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913013135.jpeg">

</div>
<p>在上图中，粉色是训练集的错误率，绿色的是测试集的错误率。黄色是贝叶斯规则的错误率。</p>
<p>我们要知道，错误率是一个随机变量，它有着标准差。在下面的部分里，我们会提到交叉验证，这种方法有助于降低一些变异（这里我自己的理解就是错误率的变异）。然而即使将这些变异降低，从图中我们就可以看出来，当 <span class="math inline">\(k\)</span> 低于20时就会出现过拟合(over-fitting)，当 <span class="math inline">\(k\)</span> 超过100时就会出现低拟合(under-fitting)。</p>
<h2 id="交叉验证">交叉验证</h2>
<p>这里我们描述一下交叉验证(cross-validation)，交叉验证是机器学习中有关方法评估的一个基础工具，它能在一项预测或机器学习任务中进行参数选择。假设我们有一组许多特征值的观测值，并且每个观测值都与一个标签关联。我们将这个集合称为我们的训练集。我们的任务就是通过从训练数据中学习模式来预测任何新样本的标签。对于一个具体的例子来说，例如我们会将每个基因看作是一个特征值，然后我们再来计算一组没有标签的数据（测试数据集），看一下这组数据是新样本中的哪些组织类型。</p>
<p>如果我们选择了一个可调参数的机器学习算法，那么我们必须要有一个策略来这个参数选择一个最佳值。我们可以尝试着先计算一批数据，例如可以把一些已知样本的数据当作训练集，然后算法会计算出这些值产生的错误数据，然后我们会选择在我们的训练集中表现最好的值。</p>
<p>现在我们使用前面提到过的组织基要因表达数据集来看一下，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">library(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div></pre></td></tr></table></figure>
<p>为了说明我们这么做的目的，我们把那些样本数目较少的组织剔除掉，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">table(tissue)</div><div class="line">ind &lt;- which(tissue != &quot;placenta&quot;)</div><div class="line">y &lt;- tissue[ind]</div><div class="line">X &lt;- t( e[,ind] )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; table(tissue)</div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们把<code>placenta(胎盘)</code>这个组织去掉了，现在我们使用kNN法来进行归类，先使用 <span class="math inline">\(k=5\)</span> 这个参数试一下。当我们把这个参数用于训练集和测试集时，我们在预测训练集中的组织时，平均误差是多少呢？</p>
<p>计算过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">pred &lt;- knn(train =  X, test = X, cl=y, k=5)</div><div class="line">mean(y != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当我们使用 <span class="math inline">\(k=5\)</span> 这个参数时，没有发现错误，如果是 <span class="math inline">\(k=1\)</span> 呢？如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pred &lt;- knn(train=X, test=X, cl=y, k=1)</div><div class="line">mean(y != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当我们试图通过对观测值进行分类用于训练(train)模型时，这一过程可能有误导性。事实时，对于kNN法来说，使用 <span class="math inline">\(k=1\)</span> 这个参数时，总是能在训练集中得到0个分类错误，因为我们使用的是数据本身。了解算法是否可靠的方法就让它对未见过的样本进行预测。类似地，如果我们想知道可调参数的最佳值是什么，我们查看不同的参数值在那些不在训练集中的样本上表现如何。</p>
<p>交叉验证是机器学习中广泛使用的一种方法，它解决了训练集和测试集的问题，同时它仍然可以使用所有的数据用于检测预测的准确性。它通过将所有的数据分散成一定数据的折叠(fold)（注：这里有关交叉验证的问题，可以参考以前的文章<a href="http://rvdsd.top/2018/07/05/StatQuest/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B022-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/">《StatQuest学习笔记22——交叉验证》</a>）。如果我们有 <span class="math inline">\(N\)</span> 个折叠，那么算法的第一步就是使用 <span class="math inline">\((N-1)\)</span> 个折叠来训练算法，并且剩下一个折叠用于测试算法的准确性。然后重复 <span class="math inline">\(N\)</span> 次，直到所有的折叠都在测试集中一样被使用。如果我们有M个参数需要进行尝试，那么我们需要在外部循环中完成这个过程，因为我们需要总共拟合 <span class="math inline">\(N \times M\)</span>次。</p>
<p>在R中，我们使用<code>caret</code>包中的<code>createFolds()</code>函数来实现这个过程,在下面的案例中，我们使用5个折叠来计算我们的基因表达数据，这个数字与组织的数目比较接近。此外，<code>createFold()</code>函数中有个参数<code>k</code>，这里不要与kNN算法中的<code>k</code>混淆，它们只是相同的字符，具体意义不一样，它们完全不相关。<code>createFolds()</code>会寻问用户要创建多少个折叠，也就是上文提到的 <span class="math inline">\(N\)</span> 。而<code>knn()</code>中的参数<code>k</code>则是说明在一个新的样本中，使用多少个最接近的观测值。现在我们创建10个折叠，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">library(caret)</div><div class="line">set.seed(1)</div><div class="line">idx &lt;- createFolds(y, k=10)</div><div class="line">sapply(idx, length)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; sapply(idx, length)</div><div class="line">Fold01 Fold02 Fold03 Fold04 Fold05 Fold06 Fold07 Fold08 Fold09 Fold10 </div><div class="line">    <span class="number">18</span>     <span class="number">19</span>     <span class="number">17</span>     <span class="number">17</span>     <span class="number">18</span>     <span class="number">20</span>     <span class="number">19</span>     <span class="number">19</span>     <span class="number">20</span>     <span class="number">16</span></div></pre></td></tr></table></figure>
<p>折叠会以数字索引列表的形式返回，因此数据的第一个折叠是：</p>
<p>The folds are returned as a list of numeric indices. The first fold of data is therefore:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y[idx[[1]]] ##the labels</div><div class="line">head( X[idx[[1]], 1:3] ) ##the genes (only showing the first 3 genes...)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; y[idx[[<span class="number">1</span>]]] <span class="comment">##the labels</span></div><div class="line"> [<span class="number">1</span>] <span class="string">"kidney"</span>      <span class="string">"kidney"</span>      <span class="string">"hippocampus"</span> <span class="string">"hippocampus"</span> <span class="string">"hippocampus"</span> <span class="string">"cerebellum"</span> </div><div class="line"> [<span class="number">7</span>] <span class="string">"cerebellum"</span>  <span class="string">"cerebellum"</span>  <span class="string">"colon"</span>       <span class="string">"colon"</span>       <span class="string">"colon"</span>       <span class="string">"colon"</span>      </div><div class="line">[<span class="number">13</span>] <span class="string">"kidney"</span>      <span class="string">"kidney"</span>      <span class="string">"endometrium"</span> <span class="string">"endometrium"</span> <span class="string">"liver"</span>       <span class="string">"liver"</span>      </div><div class="line">&gt; head( X[idx[[<span class="number">1</span>]], <span class="number">1</span>:<span class="number">3</span>] ) <span class="comment">##the genes (only showing the first 3 genes...)</span></div><div class="line">                1007_s_at  1053_at   117_at</div><div class="line">GSM12075.CEL.gz  <span class="number">9.966782</span> <span class="number">6.060069</span> <span class="number">7.644452</span></div><div class="line">GSM12098.CEL.gz  <span class="number">9.945652</span> <span class="number">5.927861</span> <span class="number">7.847192</span></div><div class="line">GSM21214.cel.gz <span class="number">10.955428</span> <span class="number">5.776781</span> <span class="number">7.493743</span></div><div class="line">GSM21218.cel.gz <span class="number">10.757734</span> <span class="number">5.984170</span> <span class="number">8.525524</span></div><div class="line">GSM21230.cel.gz <span class="number">11.496114</span> <span class="number">5.760156</span> <span class="number">7.787561</span></div><div class="line">GSM87086.cel.gz  <span class="number">9.798633</span> <span class="number">5.862426</span> <span class="number">7.279199</span></div></pre></td></tr></table></figure>
<p>我们可以看到，事实上组织在10个折叠中表现非常平均：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sapply(idx, function(i) table(y[i]))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; sapply(idx, <span class="keyword">function</span>(i) table(y[i]))</div><div class="line">            Fold01 Fold02 Fold03 Fold04 Fold05 Fold06 Fold07 Fold08 Fold09 Fold10</div><div class="line">cerebellum       <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span></div><div class="line">colon            <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">3</span></div><div class="line">endometrium      <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span></div><div class="line">hippocampus      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span></div><div class="line">kidney           <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span></div><div class="line">liver            <span class="number">2</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span>      <span class="number">2</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span></div></pre></td></tr></table></figure>
<p>因为不同组织的表达谱不一样，因此使用所有的基因来预测组织非常容易。为了说明这种算法的原理，我们这里只使用二维数据来进行预测，现在我们使用<code>cmdscale()</code>函数进行降低处理：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">Xsmall &lt;- cmdscale(dist(X))</div><div class="line">plot(Xsmall,col=as.fumeric(y))</div><div class="line">legend(<span class="string">"topleft"</span>,levels(factor(y)),fill=seq_along(levels(factor(y))))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913180841.jpeg">

</div>
<p>现在我们在单个折叠上试一下kNN法。我们使用<code>Xsmall</code>中的样本（不用第1个样本），用<code>knn()</code>函数计算一下。我们使用<code>-idx[[1]]</code>移除第1个样本，这样将剩下来的样本当作测试集。参数<code>cl</code>用于指定真分类（true classificaiton）或者是训练集的标签（这里指的是组织）。现在我们使用5个观测值来为我们的kNN算法指定分类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pred &lt;- knn(train=Xsmall[ -idx[[1]] , ], test=Xsmall[ idx[[1]], ], cl=y[ -idx[[1]] ], k=5)</div><div class="line">table(true=y[ idx[[1]] ], pred)</div><div class="line">mean(y[ idx[[1]] ] != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=y[ idx[[<span class="number">1</span>]] ], pred)</div><div class="line">             pred</div><div class="line">true          cerebellum colon endometrium hippocampus kidney liver</div><div class="line">  cerebellum           <span class="number">2</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  colon                <span class="number">0</span>     <span class="number">4</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  endometrium          <span class="number">0</span>     <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span></div><div class="line">  hippocampus          <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">2</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  kidney               <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">4</span>     <span class="number">0</span></div><div class="line">  liver                <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">0</span>     <span class="number">2</span></div><div class="line">&gt; mean(y[ idx[[<span class="number">1</span>]] ] != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0.1666667</span></div></pre></td></tr></table></figure>
<p>现在我们出现了一些分类错误，我们计算一下剩余折叠，看一下情况怎么样？</p>
<p>Now we have some misclassifications. How well do we do for the rest of the folds?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (i in 1:10) &#123;</div><div class="line">  pred &lt;- knn(train=Xsmall[ -idx[[i]] , ], test=Xsmall[ idx[[i]], ], cl=y[ -idx[[i]] ], k=5)</div><div class="line">  print(paste0(i,&quot;) error rate: &quot;, round(mean(y[ idx[[i]] ] != pred),3)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>) &#123;</div><div class="line">+   pred &lt;- knn(train=Xsmall[ -idx[[i]] , ], test=Xsmall[ idx[[i]], ], cl=y[ -idx[[i]] ], k=<span class="number">5</span>)</div><div class="line">+   print(paste0(i,<span class="string">") error rate: "</span>, round(mean(y[ idx[[i]] ] != pred),<span class="number">3</span>)))</div><div class="line">+ &#125;</div><div class="line">[<span class="number">1</span>] <span class="string">"1) error rate: 0.111"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"2) error rate: 0.105"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"3) error rate: 0.118"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"4) error rate: 0.118"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"5) error rate: 0.278"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"6) error rate: 0.1"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"7) error rate: 0.105"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"8) error rate: 0.158"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"9) error rate: 0.15"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"10) error rate: 0.312"</span></div></pre></td></tr></table></figure>
<p>所以，我们会看到每个折叠都会发生一些变化，其错误率徘徊在0.1-0.3之间。但是，<span class="math inline">\(k=5\)</span> 是最佳的参数吗？为了研究 <span class="math inline">\(k\)</span> 的最佳数值，我们需要创建一个外部循环，我们会在其中尝试不同的 <span class="math inline">\(k\)</span> 值，然后计算出所有折叠的平均测试集误差。我们将会尝试从1到12的每个 <span class="math inline">\(k\)</span> 值。不过这里我们不使用<code>for</code>循环，我们将使用<code>sapply</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">set.seed(1)</div><div class="line">ks &lt;- 1:12</div><div class="line">res &lt;- sapply(ks, function(k) &#123;</div><div class="line">  ##try out each version of k from 1 to 12</div><div class="line">  res.k &lt;- sapply(seq_along(idx), function(i) &#123;</div><div class="line">    ##loop over each of the 10 cross-validation folds</div><div class="line">    ##predict the held-out samples using k nearest neighbors</div><div class="line">    pred &lt;- knn(train=Xsmall[ -idx[[i]], ],</div><div class="line">                test=Xsmall[ idx[[i]], ],</div><div class="line">                cl=y[ -idx[[i]] ], k = k)</div><div class="line">    ##the ratio of misclassified samples</div><div class="line">    mean(y[ idx[[i]] ] != pred)</div><div class="line">  &#125;)</div><div class="line">  ##average over the 10 folds</div><div class="line">  mean(res.k)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>对于每个 <span class="math inline">\(k\)</span> 值，我们都有一个来自于交叉验证的关联测试集错误率，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; res</div><div class="line"> [<span class="number">1</span>] <span class="number">0.1978212</span> <span class="number">0.1703423</span> <span class="number">0.1882933</span> <span class="number">0.1750989</span> <span class="number">0.1613291</span> <span class="number">0.1500791</span> <span class="number">0.1552670</span> <span class="number">0.1884813</span></div><div class="line"> [<span class="number">9</span>] <span class="number">0.1822020</span> <span class="number">0.1763197</span> <span class="number">0.1761318</span> <span class="number">0.1813197</span></div></pre></td></tr></table></figure>
<p>我们可以绘制出每个 <span class="math inline">\(k\)</span> 值下的错误率图，它可以帮助我们查看哪个区域中的错误率最小，如下所示：</p>
<figure class="highlight plain"><figcaption><span>misclassification_error, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(ks, res, type=&quot;o&quot;,ylab=&quot;misclassification error&quot;)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913184146.jpeg">

</div>
<p>我们要记住一点就是，训练集是一个随机变量，因为我们生成折叠的程序涉随机数的生成，因此，在产生“最好”的 <span class="math inline">\(k\)</span> 值时，这个 <span class="math inline">\(k\)</span> 值的产生过程也是一个随机变量。如果我们有新的训练集，并且如果我们再创建折叠，那么我们有可能会得到一个新的优化的 <span class="math inline">\(k\)</span> 值。</p>
<p>最后，为了说明基因表达数据能够很好的预测组织类型，我们使用5维数据，而非是2维数据来展示这个过程，毕竟5维数据的信息量更丰富，如下所示：</p>
<figure class="highlight plain"><figcaption><span>misclassification_error2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Xsmall &lt;- cmdscale(dist(X),k=5)</div><div class="line">set.seed(1)</div><div class="line">ks &lt;- 1:12</div><div class="line">res &lt;- sapply(ks, function(k) &#123;</div><div class="line">  res.k &lt;- sapply(seq_along(idx), function(i) &#123;</div><div class="line">    pred &lt;- knn(train=Xsmall[ -idx[[i]], ],</div><div class="line">                test=Xsmall[ idx[[i]], ],</div><div class="line">                cl=y[ -idx[[i]] ], k = k)</div><div class="line">    mean(y[ idx[[i]] ] != pred)</div><div class="line">  &#125;)</div><div class="line">  mean(res.k)</div><div class="line">&#125;)</div><div class="line">plot(ks, res, type=&quot;o&quot;,ylim=c(0,0.20),ylab=&quot;misclassification error&quot;)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913184233.jpeg">

</div>
<p>上图显示的是，使用5维数据后，错误分配与 <span class="math inline">\(k\)</span> 值变化的关系。</p>
<p>重要提示：我们使用<code>cmdscale()</code>函数来计算整个数据集，用于创建一个较小的数据集来说明kNN的计算过程。然而在真正的机器学习应用中，这样的处理会低估小样本测试数据集的错误，但是，使用未标记的完全数据集进行降维会改善这种情况。一个种更安全的做法就是为每个折叠分别转换数据（这句不懂， 我个人的猜测就是，对每个折叠进行计算，把几个折叠中的每一个都当作测试集，而不是将几个折叠放一块当作测试集），方法就是仅用训练集来计算旋转和降维，并将其应用于测试集。</p>
<p>最后一段实在没读懂，这里放原文：</p>
<blockquote>
<p>However, in a real machine learning application, this may result in an underestimation of test set error for small sample sizes, where dimension reduction using the unlabeled full dataset gives a boost in performance. A safer choice would have been to transform the data separately for each fold, by calculating a rotation and dimension reduction using the training set only and applying this to the test set.</p>
</blockquote>
<h2 id="练习">练习</h2>
<p>P407</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/23/DAL/DALS023_Basic_Machine_Learning02_Loess/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/DAL/DALS023_Basic_Machine_Learning02_Loess/" itemprop="url">DALS023-机器学习02-条件概率与Loess拟合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T12:00:00+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,248
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第2小节，这一部分的主要内容涉及条件概率与Loess回归，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/tree/master/ml/conditional_expectation.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="条件概率与期望">条件概率与期望</h2>
<p>预测问题的结果可以分为两类，分别为分类结果(categorical outcomes)和连续型结果(continuous outcomes)。但是，许多算法都可以应用于这两种情况，这是因为条件概率(conditional probabilities)和条件期望(conditional expectations)之间有着一定联系。</p>
<p>对于分类数据，例如二分类结果，如果我们知道给在一组预测因子<span class="math inline">\(X=(X_1,\dots,X_p)^\top\)</span>下预测的概率<span class="math inline">\(Y\)</span>可能是<span class="math inline">\(k\)</span>个结果中的任意一个，这种情况用方程表示就是： <span class="math display">\[
f_k(x) = \mbox{Pr}(Y=k \mid X=x)
\]</span> 我们就可以优化我们的预测结果。尤其是，对于任意的 <span class="math inline">\(x\)</span> ，我们可能预测出最大概率 <span class="math inline">\(f_k(x)\)</span> 时的 <span class="math inline">\(k\)</span> 。</p>
<p>为了简化我们的描述，我们只考虑二分类变量。我们可以认为 <span class="math inline">\(\mbox{Pr}(Y=1 \mid X=x)\)</span> 是当 <span class="math inline">\(X=x\)</span> 时，第1层的某结果在总体中的比例。考虑到期望是所有 <span class="math inline">\(Y\)</span> 值的均值，在这个案例中，期望的概率就等于：<span class="math inline">\(f(x) \equiv \mbox{E}(Y \mid X=x)=\mbox{Pr}(Y=1 \mid X=x)\)</span>。因此，我们在后面的描述中，就会使用期望，因为这种表示更加普遍。</p>
<p>通常来说，期望值是有着比较受欢迎的数学属性，因为它能够缩小预测值 <span class="math inline">\(\hat{Y}\)</span> 和 <span class="math inline">\(Y\)</span> 之间的距离： <span class="math display">\[
\mbox{E}\{ (\hat{Y} - Y)^2  \mid  X=x \}
\]</span></p>
<h4 id="预测中的回归问题">预测中的回归问题</h4>
<p>我们在前面使用了父子的身高数据来介绍了回归，这里我们使用机器学习来解释一下这个数据分析过程。在我们前面的那个案例中，我们试图通常父母的身高<span class="math inline">\(X\)</span>来预测儿子的身高<span class="math inline">\(Y\)</span>。这里我们只有一个预测值(predictor)。现在如果我们被问到随机选择一个儿子，这个儿子的身高是多少，我们也许会使用平均值来回答，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">data(<span class="string">"father.son"</span>)</div><div class="line">x=round(father.son$fheight) <span class="comment">##round to nearest inch</span></div><div class="line">y=round(father.son$sheight)</div><div class="line">hist(y,breaks=seq(min(y),max(y)))</div><div class="line">abline(v=mean(y),col=<span class="string">"red"</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911232411.jpeg">

</div>
<p>在这个案例中，我们也可以使用<span class="math inline">\(Y\)</span>的分布近似服从正态分布来进行预测，那么也就是说，当我们回答平均值的时候，回答对的概率最大。</p>
<p>现在我们再来考虑一些情况，当我们有了更多的信息后，如何进行预测。例如，我们被告之，这个随机选择的这个儿子的父亲身高是71英寸（高于均值1.25个SD）。那么我们如何预测？</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y,xlab=<span class="string">"Father's height in inches"</span>,ylab=<span class="string">"Son's height in inches"</span>,main=paste(<span class="string">"correlation ="</span>,signif(cor(x,y),<span class="number">2</span>)))</div><div class="line">abline(v=c(-<span class="number">0.35</span>,<span class="number">0.35</span>)+<span class="number">71</span>,col=<span class="string">"red"</span>)</div><div class="line">hist(y[x==<span class="number">71</span>],xlab=<span class="string">"Heights"</span>,nc=<span class="number">8</span>,main=<span class="string">""</span>,xlim=range(y))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911232626.jpeg">

</div>
<p>上图的左侧是儿子身高的散点图，其中红色围起来的部分是给定父亲身高是71英寸这个数据后，对应的儿子的身高。条件分布：儿子的身高数据分布就是被父亲71英寸这个数据限定了。</p>
<p>有了父亲身高是71英寸这个数据后，那么我们来猜儿子的身高时，最好的回答还是期望值(expectation)，但是，我们的数据层(strata)已经发生了改变，也就是说，我们来猜测儿子身高<span class="math inline">\(Y\)</span>时，要考虑到限制因素，即<span class="math inline">\(Y=71\)</span>。因此，我们可以在这个条件之上，再来计算均值，这个均值就是条件期望(conditional expectation)，因此我们对于任意<span class="math inline">\(x\)</span>值来预测时，公式如下所示： <span class="math display">\[
f(x) = E(Y \mid X=x)
\]</span></p>
<p>通过微积分我们可以发现，这个结果更加接近于二元正态分布，我们可以换成下面的表示形式： <span class="math display">\[
f(x) = \mu_Y + \rho \frac{\sigma_Y}{\sigma_X} (X-\mu_X)
\]</span></p>
<p>如果我们使用样本的数据来估计这5个参数，那么我们就会得到回归线：</p>
<figure class="highlight plain"><figcaption><span>regression, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mypar(1,2)</div><div class="line">plot(x,y,xlab=&quot;Father&apos;s height in inches&quot;,ylab=&quot;Son&apos;s height in inches&quot;,</div><div class="line">     main=paste(&quot;correlation =&quot;,signif(cor(x,y),2)))</div><div class="line">abline(v=c(-0.35,0.35)+71,col=&quot;red&quot;)</div><div class="line">fit &lt;- lm(y~x)</div><div class="line">abline(fit,col=1)</div><div class="line">hist(y[x==71],xlab=&quot;Heights&quot;,nc=8,main=&quot;&quot;,xlim=range(y))</div><div class="line">abline(v = fit$coef[1] + fit$coef[2]*71, col=1)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911234623.jpeg">

</div>
<p>在这个特殊的案例中，回归线提供了对 <span class="math inline">\(Y\)</span> 更优化的预测函数，但是通常情况下这种情况并不真实，因为在典型的机器学习问题中，优化后的 <span class="math inline">\(f(x)\)</span> 很少是一条直线。</p>
<h2 id="练习">练习</h2>
<p>P379</p>
<h2 id="平滑">平滑</h2>
<p>相关的Rmarkdown文档见作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/smoothing.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在所有的数据分析中，平滑(Smoothing)是一个非常强大的工具。当数据的分布的形状未知时，我们可以假定这些数据是平滑(smooth)的，我们就能够估计 <span class="math inline">\(f(x)\)</span> 。平滑的主要思路就是将那些有着类似期望的数据归类，然后计算这些归类后的平均值，或者是对其进行简单的参数模型拟合。我们使用基因表达数据来介绍两个平滑工具。</p>
<p>下面的数据是源于相同RNA样本的基因表达数据。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##Following three packages are available from Bioconductor</span></div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="comment"># BiocManager::install("SpikeIn")</span></div><div class="line"><span class="keyword">library</span>(SpikeIn)</div><div class="line"><span class="comment"># BiocManager::install("hgu95acdf")</span></div><div class="line"><span class="keyword">library</span>(hgu95acdf)</div><div class="line">data(SpikeIn95)</div></pre></td></tr></table></figure>
<p>我们可以使用MA图 (<span class="math inline">\(Y\)</span> = log ratios and <span class="math inline">\(X\)</span> = averages) 来比较这两个重复样本的质量，我们可能通过一种方式对这些数据进行采样，这些采样方式要能平衡 <span class="math inline">\(X\)</span> 中不同层的数据点的数目，如下所示：</p>
<figure class="highlight plain"><figcaption><span>echo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">##Example with two columns</div><div class="line">i=10;j=9</div><div class="line">##remove the spiked in genes and take random sample</div><div class="line">library(GEOquery)</div><div class="line">siNames&lt;-colnames(pData(SpikeIn95))</div><div class="line">ind &lt;- which(!probeNames(SpikeIn95)%in%siNames)</div><div class="line">pms &lt;- pm(SpikeIn95)[ ind ,c(i,j)]</div><div class="line">##pick a representative sample for A and order A</div><div class="line">Y=log2(pms[,1])-log2(pms[,2])</div><div class="line">X=(log2(pms[,1])+log2(pms[,2]))/2</div><div class="line">set.seed(4)</div><div class="line">ind &lt;- tapply(seq(along=X),round(X*5),function(i)</div><div class="line">  if(length(i)&gt;20) return(sample(i,20)) else return(NULL))</div><div class="line">ind &lt;- unlist(ind)</div><div class="line">X &lt;- X[ind]</div><div class="line">Y &lt;- Y[ind]</div><div class="line">o &lt;-order(X)</div><div class="line">X &lt;- X[o]</div><div class="line">Y &lt;- Y[o]</div></pre></td></tr></table></figure>
<p>采样结束后，我们来绘制散点图，如下所示：</p>
<figure class="highlight plain"><figcaption><span>MAplot, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">plot(X,Y)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912000435.jpeg">

</div>
<p>在上面的MA图中我们可以看到 <span class="math inline">\(Y\)</span> 取决于 <span class="math inline">\(X\)</span>。这种取决关系存在着偏差，因为我们发现，它们在重复性方面有着偏差，这就意味着，如果不考虑 <span class="math inline">\(X\)</span>， 那么 <span class="math inline">\(Y\)</span> 的均值就是0。现在我们想预测 <span class="math inline">\(f(x)=\mbox{E}(Y \mid X=x)\)</span> ，以便于移除假这种偏差。线性回归无法捕捉到表示上图曲线 <span class="math inline">\(f(x)\)</span> 的曲率(curvature)，如下所示：</p>
<figure class="highlight plain"><figcaption><span>MAplot_with_regression_line, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">plot(X,Y)</div><div class="line">fit &lt;- lm(Y~X)</div><div class="line">points(X,Y,pch=21,bg=ifelse(Y&gt;fit$fitted,1,3))</div><div class="line">abline(fit,col=2,lwd=4,lty=2)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912000854.jpeg">

</div>
<h2 id="微区间平滑bin-smoothing">微区间平滑(Bin Smoothing)</h2>
<p>对于上述的数据，我们无法使用直线进行拟合，此时我们就要使用平滑处理的思想，也就是说把这些点分散到不同的组里，计算这些不同组的均值，这就是所谓的<code>微区间平滑</code>处理（我没有找到bin smoothing相应的中文翻译，这里说的<code>微区间平滑</code>是我自己造的词）。这种处理的通常思路就是，我们假定这些数据点分为很多微区间(bin)，这样拟合的曲线是足够”平滑“的，那么在这个微区间中的这个曲线就会近似于常数(approximately constant)。如果我们假设这个曲线是常数(constant)的，那么所有位于某个微区间(bin)中的 <span class="math inline">\(Y\)</span> 就有了相同的期望值。例如，在下面的图形中，如果我们将微区间的宽度设为1，我们标记出了在8.6和12.1处的微区间。我们还显示了，在这两个区间中拟合的 <span class="math inline">\(Y\)</span> 的均值，如下所示：</p>
<figure class="highlight plain"><figcaption><span>binsmoother, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">centers &lt;- seq(min(X),max(X),0.1)</div><div class="line">plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">windowSize &lt;- .5</div><div class="line">i &lt;- 25</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-mean(Y)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">lines(c(min(X[ind]),max(X[ind])),c(fit,fit),col=2,lty=2,lwd=4)</div><div class="line">i &lt;- 60</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-mean(Y[ind])</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">lines(c(min(X[ind]),max(X[ind])),c(fit,fit),col=2,lty=2,lwd=4)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001103.jpeg">

</div>
<p>我们通过计算每一个点附近的小区间，我们就能对构成的曲线的函数 $f(x) $ 进行估计。下图显示了这个计算过程，即我们从最小的 <span class="math inline">\(x\)</span> 值扩展到最大值过程中的这个估计值，同时我们还展示了最小值与最大值之间的10个值，一共是10张图片，如下所示：</p>
<figure class="highlight plain"><figcaption><span>bin_smoothing_demo, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">windowSize&lt;-0.5</div><div class="line">smooth&lt;-rep(NA,length(centers))</div><div class="line">mypar (4,3)</div><div class="line">for(i in seq(along=centers))&#123;</div><div class="line">  center&lt;-centers[i]</div><div class="line">  ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">  smooth[i]&lt;-mean(Y[ind])</div><div class="line">  if(i%%round(length(centers)/12)==1)&#123; ##we show 12</div><div class="line">    plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">    points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">    lines(c(min(X[ind]),max(X[ind])),c(smooth[i],smooth[i]),col=2,lwd=2)</div><div class="line">    lines(centers[1:i],smooth[1:i],col=&quot;black&quot;)</div><div class="line">    points(centers[i],smooth[i],col=&quot;black&quot;,pch=16,cex=1.5)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001146.jpeg">

</div>
<p>最终的结果就如下所示：</p>
<figure class="highlight plain"><figcaption><span>bin_smooth_final, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(centers,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001229.jpeg">

</div>
<p>在R中有许多函数可以进行平滑处理(bin smoothers)，例如<code>ksmooth</code>。但是在实际计算过程中，我们更偏向使用一些稍微复杂的模型来对数据进行拟合。在最后一个案例，也就是最后一张图，这个曲线就不怎么平滑，有一些粗糙。我们后面会介绍<code>loess</code>方法会改善这一点。</p>
<h2 id="loess">Loess</h2>
<p>Loess的全称是Local weighted regression，即局部权重回归，它在原理上类似于微区间平滑处理。但Loess与微区间平滑处理的主要区别就在于，在微区间中我是使用直线，还是抛物线进行拟合。Loess计算会增大微区间的数目，但这会使我们的估计更稳定。下图展示了两个微区间的拟合曲线，这两个区间比较宽，使用宽区间主要是因为拟合曲线提供了更多的灵活性，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">centers &lt;- seq(min(X),max(X),0.1)</div><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">windowSize &lt;- 1.25</div><div class="line">i &lt;- 25</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-lm(Y~X,subset=ind)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lty=2,lwd=3)</div><div class="line">i &lt;- 60</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-lm(Y~X,subset=ind)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lty=2,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912124609.jpeg" alt="当我们">
<p class="caption">当我们</p>
</div>
<p>现在我们展示一下通过12步处理来对这些数据进行loess拟合，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess_demo, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">mypar (4,3)</div><div class="line">windowSize&lt;-1.25</div><div class="line">smooth&lt;-rep(NA,length(centers))</div><div class="line">for(i in seq(along=centers))&#123;</div><div class="line">  center&lt;-centers[i]</div><div class="line">  ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">  fit&lt;-lm(Y~X,subset=ind)</div><div class="line">  smooth[i]&lt;-fit$coef[1]+fit$coef[2]*center</div><div class="line">  if(i%%round(length(centers)/12)==1)&#123; ##we show 12</div><div class="line">    plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">    points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">    a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">    lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lwd=2)</div><div class="line">    </div><div class="line">    lines(centers[1:i],smooth[1:i],col=&quot;black&quot;)</div><div class="line">    points(centers[i],smooth[i],col=&quot;black&quot;,pch=16,cex=1.5)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912124842.jpeg">

</div>
<p>最终的结果就是生成一条更加平滑的拟合曲线用于估计我们的局部参数，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess_final, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(centers,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912125359.jpeg">

</div>
<p>R中的函数<code>loess()</code>可以进行上述的分析，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fit &lt;- loess(Y~X, degree=1, span=1/3)</div><div class="line">newx &lt;- seq(min(X),max(X),len=100) </div><div class="line">smooth &lt;- predict(fit,newdata=data.frame(X=newx))</div><div class="line">mypar ()</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(newx,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912125636.jpeg">

</div>
<p><code>loess()</code>函数与其它的曲线平滑处理函数(bin smoother)还有三点重要的区别：</p>
<p>第一，<code>loess()</code>函数会保持局部拟合中的点数不变，而非保持区间的数目不变。局部拟合中的点数是通过<code>span</code>参数决定的，这是一个比值。例如，如果 <code>N</code> 是数据点的数目，那么 <code>span = 0.5</code> 则表示针对一个确定的 <code>x</code> ， <code>loess()</code>将会使用 <code>0.5*N</code> 个最接近的点对 <code>x</code> 进行拟合。</p>
<p>第二，使用参数模型来对 <span class="math inline">\(f(x)\)</span> 进行拟合时，<code>loess()</code>会使用加权最小平方和来进行计算，那些权重比较大的点就是那些更接近 <code>x</code> 的点。</p>
<p>第三，<code>loess()</code>函数会选择更稳健(robustly)的局部模型来进行拟合。这是一种迭代算法，其中在一次迭代中拟合了模型之后，对于那些检测到的异常值就会在下一次迭代中降低其权重。如果要想使用这个参数，可以设定<code>family = &quot;symmetric&quot;</code>。</p>
<h2 id="练习-1">练习</h2>
<p>P389</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/22/DAL/DALS022_Basic_Machine_Learning01_ Cluster_heatmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/DAL/DALS022_Basic_Machine_Learning01_ Cluster_heatmap/" itemprop="url">DALS022-机器学习01-聚类与热图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:00:00+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,120
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第1小节，这一部分的主要内容涉及聚类与热图，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/clustering_and_heatmaps.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>机器学习是一个非常广泛的主题和高度活跃的研究领域。 在生命科学中，涉及到“精准医学”的大部分内容都是与机器学习在生物医学数据方面的处理有关。 常规的思路就是从检测的指标中预测或发现一些信息。例如，我们能够从基因表达谱中发现新的癌症吗？我们能通过一系列的基因型来预测药物反应吗？在这一部分中，我们主要介绍两个机器学习的方法，即聚类(clustering)和类预测(class prediction)。</p>
<h2 id="聚类">聚类</h2>
<p>我们还使用前面的组织基因表达的数据来深圳一下聚类的概念和思路：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div></pre></td></tr></table></figure>
<p>为了说明聚类在生命科学方面的应用，我们先假设我们并不知道上面的几个样本是不同的组织，我们通过聚类来看一下它们的表达谱情况，第一步就是计算不同的样本之间的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist( t(e) )</div></pre></td></tr></table></figure>
<h3 id="层次聚类">层次聚类</h3>
<p>当我们计算了每对样本之间的距离后，我们需要使用聚类算法将它们聚成不同的组。层次聚类算是众多聚类算法中的一个。每个样本首先会被当作一组(group)，然后不断地通过聚类算法迭代，将两个相似的组结合起来，一直到所有的样本都聚为一组。对于样本之间的距离我们已经了解了，但是，不同组之间的距离我们并不了解。关于组与组之间的距离计算方法有很多种，这些方法的核心都是通过计算组与组之间的成员的距离实现的。具体的可以查看<code>hclust()</code>函数的帮助文档。</p>
<p>我们通过<code>hclust()</code>函数来对不同组之间的距离进行层次聚类分析。这个函数会返回一个<code>hclust</code>对象，它描述的我们通过上述算法进行的组划分(grouping)。随后使用<code>plot()</code>函数绘制出树状图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">hc &lt;- hclust(d)</div><div class="line">hc</div><div class="line">plot(hc,labels=tissue,cex=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(rafalib)</div><div class="line">&gt; mypar()</div><div class="line">&gt; hc &lt;- hclust(d)</div><div class="line">&gt; hc</div><div class="line"></div><div class="line">Call:</div><div class="line">hclust(d = d)</div><div class="line"></div><div class="line">Cluster method   : complete </div><div class="line">Distance         : euclidean </div><div class="line">Number of objects: <span class="number">189</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215025.jpeg">

</div>
<p>使用这种算法能否发现不同组织的簇(clusters)？在上面的这个图形里，我们不太容易发现这些不同的组织，因此我们需要使用<code>myclust()</code>函数来给它们加上颜色，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">myplclust(hc, labels=tissue, lab.col=as.fumeric(tissue), cex=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215224.jpeg">

</div>
<p>从图形上我们可以看出来，似乎聚类算法能够发现这些不同的组织。但是，层次聚类并没有定义特定的簇，而是定义了上在树状图。从树状图上我们可以描述任意两组之间的距离。为了定义一些簇，我们需要将把树在某些距离上”切开“，所有的样本在这个距离以下分成不同的组。我们可以绘制出一条水平线，我们就使用120这个距离来切，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myplclust(hc, labels=tissue, lab.col=as.fumeric(tissue),cex=<span class="number">0.5</span>)</div><div class="line">abline(h=<span class="number">120</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215559.jpeg">

</div>
<p>当我们在高度为120上对树进行切割时，我们可以看一下这个线能够把线以下的样本分为几组，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hclusters &lt;- cutree(hc, h=<span class="number">120</span>)</div><div class="line">table(true=tissue, cluster=hclusters)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=tissue, cluster=hclusters)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span>  <span class="number">0</span> <span class="number">12</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">9</span> <span class="number">18</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>从上面可以看出来，分为了8组，另外通过<code>cutreee()</code>函数，我们可以直接指定返回几组簇，这个函数会自动返回结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hclusters &lt;- cutree(hc, k=<span class="number">8</span>)</div><div class="line">table(true=tissue, cluster=hclusters)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; hclusters &lt;- cutree(hc, k=<span class="number">8</span>)</div><div class="line">&gt; table(true=tissue, cluster=hclusters)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span> <span class="number">12</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney      <span class="number">37</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">6</span></div></pre></td></tr></table></figure>
<p>从上面两组计算方法我们可以看出来，除了个别情况外（例如endometrium和kidney），其余的簇中，基本上每簇代表一个组织。在某些情况下，一个组织有可能存在于两个簇中，这是因为选择的簇太多了。在聚类分析中，关于如何选择簇的个数也是一个很活跃的研究领域。</p>
<h3 id="k-means">K-means</h3>
<p>我们还可以使用<code>kmeans()</code>函数来进行k-means聚类。现在我们来演示一下如何使用这个函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">km &lt;- kmeans(t(e[<span class="number">1</span>:<span class="number">2</span>,]), centers=<span class="number">7</span>)</div><div class="line">names(km)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(e[<span class="number">1</span>,], e[<span class="number">2</span>,], col=as.fumeric(tissue), pch=<span class="number">16</span>)</div><div class="line">plot(e[<span class="number">1</span>,], e[<span class="number">2</span>,], col=km$cluster, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; set.seed(<span class="number">1</span>)</div><div class="line">&gt; km &lt;- kmeans(t(e[<span class="number">1</span>:<span class="number">2</span>,]), centers=<span class="number">7</span>)</div><div class="line">&gt; names(km)</div><div class="line">[<span class="number">1</span>] <span class="string">"cluster"</span>      <span class="string">"centers"</span>      <span class="string">"totss"</span>        <span class="string">"withinss"</span>     <span class="string">"tot.withinss"</span></div><div class="line">[<span class="number">6</span>] <span class="string">"betweenss"</span>    <span class="string">"size"</span>         <span class="string">"iter"</span>         <span class="string">"ifault"</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911220200.jpeg">

</div>
<p>上图我们使用的是不同组织的前2个基因表达情况，其中颜色表示不同的组织。在在图中，颜色表示通过<code>kmeans()</code>函数计算的聚类结果。从下面的这个列表中我们就可以看到，这个聚类效果并不好：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(true=tissue,cluster=km$cluster)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line">&gt; table(true=tissue,cluster=km$cluster)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">0</span> <span class="number">23</span></div><div class="line">  colon        <span class="number">2</span> <span class="number">11</span>  <span class="number">2</span> <span class="number">15</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">8</span></div><div class="line">  hippocampus <span class="number">19</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">7</span>  <span class="number">8</span> <span class="number">20</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">18</span>  <span class="number">8</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>这个结果不太好很有可能就是我们选择的这2个基因信息量不足以将不同组织区分开来，如果我们使用所有的基因进行kmeans计算，那么我们就能极大地改善聚类结果，现在我们使用MDS图来展示这个结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">km &lt;- kmeans(t(e), centers=<span class="number">7</span>)</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(mds[,<span class="number">1</span>], mds[,<span class="number">2</span>])</div><div class="line">plot(mds[,<span class="number">1</span>], mds[,<span class="number">2</span>], col=km$cluster, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911220820.jpeg">

</div>
<p>上图礣是使用前两个PC来绘制的聚类结果，右图是使用所有的基因来绘制的MDS图，使用颜色标明了不同的组织。</p>
<p>通过查看结果中的列表，我们就可以看到聚类的效果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(true=tissue,cluster=km$cluster)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=tissue,cluster=km$cluster)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">2</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span> <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">0</span> <span class="number">37</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div></pre></td></tr></table></figure>
<h2 id="热图">热图</h2>
<p>在遗传学文献中，热图的使用非常广泛。它们能够查看所有样本的不同基因的表达情况，有的时候还会在热图的上面或旁边添加上聚类后的树状图。现在我们来看一下如何创建热图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(RColorBrewer)</div><div class="line">hmcol &lt;- colorRampPalette(brewer.pal(<span class="number">9</span>, <span class="string">"GnBu"</span>))(<span class="number">100</span>)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line"></div><div class="line">rv &lt;- rowVars(e)</div><div class="line"><span class="comment"># We will create heatmp using th e50 most variable genes and the function heatmap.2</span></div><div class="line"></div><div class="line">idx &lt;- order(-rv)[<span class="number">1</span>:<span class="number">40</span>]</div></pre></td></tr></table></figure>
<p>现在我们使用<code>gplots</code>包中的<code>heatmap.2</code>了娄来绘制热图，并在热图的顶部添加组织信息，如下所示</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(gplots) <span class="comment">##Available from CRAN</span></div><div class="line">cols &lt;- palette(brewer.pal(<span class="number">8</span>, <span class="string">"Dark2"</span>))[as.fumeric(tissue)]</div><div class="line">head(cbind(colnames(e),cols))</div><div class="line"></div><div class="line">heatmap.2(e[idx,], labCol=tissue,</div><div class="line">          trace=<span class="string">"none"</span>,</div><div class="line">          ColSideColors=cols,</div><div class="line">          col=hmcol)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(cbind(colnames(e),cols))</div><div class="line">                       cols     </div><div class="line">[<span class="number">1</span>,] <span class="string">"GSM11805.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">2</span>,] <span class="string">"GSM11814.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">3</span>,] <span class="string">"GSM11823.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">4</span>,] <span class="string">"GSM11830.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">5</span>,] <span class="string">"GSM12067.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">6</span>,] <span class="string">"GSM12075.CEL.gz"</span> <span class="string">"#1B9E77"</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911221507.jpeg">

</div>
<p>在热图中我们并没有使用组织信息，我们仅用了最显著的40个基因就发现了不同的组织。</p>
<h2 id="练习">练习</h2>
<p>P374</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/21/DAL/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/DAL/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/" itemprop="url">DALS021-MDS与PCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T12:00:00+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,847
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第2小节，这一部分的主要内容涉及MDS和PCA，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/highdim/mds.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="mds">MDS</h2>
<p>MDS的全称为multi-dimensional scaling，即多维数据缩放。在这 一部分中，我们会使用基因表达的数据来作为案例讲解一下。为了简化说明，我们仅考虑3个组织：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">colind &lt;- tissue%<span class="keyword">in</span>%c(<span class="string">"kidney"</span>,<span class="string">"colon"</span>,<span class="string">"liver"</span>)</div><div class="line">mat &lt;- e[,colind]</div><div class="line">group &lt;- factor(tissue[colind])</div><div class="line">dim(mat)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; dim(mat)</div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>    <span class="number">99</span></div></pre></td></tr></table></figure>
<p>现在我们要研究一下这个数据集，我们想知道，储存在<code>mat</code>列中的基因表达谱的数据在不同的组织间的相似性如何。由于数据很大，无法直接画出相应的多维点图。我们通常只能绘制出二维图形，如果我们要绘制出每两个样本之间的基因表达情况不现实。而MDS图形就是为了解决这个问题而提出来的。</p>
<h3 id="mds背后的数学原理">MDS背后的数学原理</h3>
<p>前面我们已经知道了SVD和矩阵代数，那么我们理解MDS就相对清楚了。为了说明MDS，我们先来看一下SVD分解，如下所示： <span class="math display">\[
\mathbf{Y} = \mathbf{UDV}^\top
\]</span> 我们假设 <span class="math inline">\(\mathbf{U^\top Y=DV^\top}\)</span> 的前两列的平方和剩余列的平方和。因此它们可以写为<span class="math inline">\(d_1+ d_2 \gg d_3 + \dots + d_n\)</span> 其中 <span class="math inline">\(d_i\)</span> 是<span class="math inline">\(\mathbf{D}\)</span> 是第i列（原文是i-th entry）。当出现这种情况时，我们就会得到如下公式：</p>
<p><span class="math display">\[
\mathbf{Y}\approx [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&amp;0\\
    0&amp;d_{2}\\
  \end{pmatrix}
  [\mathbf{V}_1 \mathbf{V}_2]^\top
\]</span></p>
<p>这就表明，第<span class="math inline">\(i\)</span>列近似等于： <span class="math display">\[
\mathbf{Y}_i \approx
[\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&amp;0\\
    0&amp;d_{2}\\
  \end{pmatrix}
  \begin{pmatrix}
    v_{i,1}\\
    v_{i,2}\\
     \end{pmatrix}
    =
    [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}
\]</span> 如果我们们定义下面的二维向量：</p>
<p><span class="math display">\[
\mathbf{Z}_i=\begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}
\]</span></p>
<p>那么： <span class="math display">\[
\begin{align*}
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) &amp;\approx \left\{ [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \right\}^\top \left\{[\mathbf{U}_1 \mathbf{U}_2]  (\mathbf{Z}_i-\mathbf{Z}_j)\right\}\\
&amp;= (\mathbf{Z}_i-\mathbf{Z}_j)^\top [\mathbf{U}_1 \mathbf{U}_2]^\top [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \\
&amp;=(\mathbf{Z}_i-\mathbf{Z}_j)^\top(\mathbf{Z}_i-\mathbf{Z}_j)\\
&amp;=(Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\end{align*}
\]</span> 上面的这个推导告诉我们，在样本<span class="math inline">\(i\)</span>和样本<span class="math inline">\(j\)</span>之最的距离近拟等于下面二维数据点的距离：</p>
<p><span class="math display">\[
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) \approx
 (Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\]</span></p>
<p>因为<span class="math inline">\(Z\)</span>是一个二维向量，因此我们可以通过绘制<span class="math inline">\(\mathbf{Z_{1}}\)</span>和<span class="math inline">\(\mathbf{Z_{2}}\)</span>来发展示这两个样本的距离。现在我们绘制出它们的距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(mat-rowMeans(mat))</div><div class="line">PC1 &lt;- s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 &lt;- s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC1,PC2,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090640.jpeg">

</div>
<p>从图片上我们可以看出，数据点按照相应的组织区分开来了。上面的这种分开的精确近似取决于前两个主成分解释变异的程度。像上面那样所示，我们可以绘制出每个主成分可以解释的变异程度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090819.jpeg">

</div>
<p>虽然前两个主成分解释了超过50%的变异，不过前面的图形还是没有展示出大量的信息。但是这种图已经足够用于进行可视化大量的数据了。此外，我们还可以注意到，我们能够绘制其它的主成分来研究这些数据点，例如我们绘制第3个和第4个主成分：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PC3 &lt;- s$d[<span class="number">3</span>]*s$v[,<span class="number">3</span>]</div><div class="line">PC4 &lt;- s$d[<span class="number">4</span>]*s$v[,<span class="number">4</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC3,PC4,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091057.jpeg">

</div>
<p>从上面图形中我们可以看到，第4个主成分能够将肾脏组织的样本强烈分开。在后面的部分中，我们会讲到批次效应(batch effects)会解释这种情况。</p>
<h3 id="cmdscale函数"><code>cmdscale()</code>函数</h3>
<p>我们在上面使用了<code>svd()</code>函数来进行计算，不过R中有一个专门的函数用于计算MDS，生成MDS图。这个函数就是<code>cmdscale()</code>函数，这个函数将距离对象作为参数，然后使用主成分分析来对这些距离进行近似计算。这个函数比使用<code>svd()</code>函数更高效（因为不可能实现完全的<code>svd()</code>函数计算，那样比较花时间）。此函数默认返回二维的数据，不过我们通过设定参数<code>k</code>（默认情况下，<code>k=2</code>）可以改变结果中的维度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(mat))</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar()</div><div class="line">plot(mds[,<span class="number">1</span>],mds[,<span class="number">2</span>],bg=as.numeric(group),pch=<span class="number">21</span>,</div><div class="line">xlab=<span class="string">"First dimension"</span>,ylab=<span class="string">"Second dimension"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091915.jpeg">

</div>
<p>再看另外一个：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">2</span>)&#123;</div><div class="line">plot(mds[,i],s$d[i]*s$v[,i],main=paste(<span class="string">"PC"</span>,i))</div><div class="line">b = ifelse( cor(mds[,i],s$v[,i]) &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</div><div class="line">abline(<span class="number">0</span>,b) <span class="comment">##b is 1 or -1 depending on the arbitrary sign "flip"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911092010.jpeg">

</div>
<h3 id="任意符号">任意符号</h3>
<p>SVD并非是唯一的，只要我们用<code>-1</code>乘以<span class="math inline">\(\mathbf{U}\)</span>的样本列，我们就能使用<code>-1</code>乘以<span class="math inline">\(\mathbf{V}\)</span>的任意列，通过下面的转换我们就能看出来（这一段不懂）： <span class="math display">\[
\mathbf{-1UD(-1)V}^\top = \mathbf{UDV}^\top
\]</span></p>
<h3 id="扣除平均值">扣除平均值</h3>
<p>在所有的计算中，当我们计算SVD时，都会扣除行(row)的均值。如果我们要试图计算两列之间的近似距离，那么在<span class="math inline">\(\mathbf{Y}_{i}\)</span>和<span class="math inline">\(\mathbf{Y}_{j}\)</span>之间的距离就与<span class="math inline">\(\mathbf{Y}_i - \mathbf{\mu}\)</span>和<span class="math inline">\(\mathbf{Y}_j - \mathbf{\mu}\)</span>之间的距离相同，因为当我们过计算时，中间的<span class="math inline">\(\mu\)</span>就会被消去： <span class="math display">\[
\left\{ ( \mathbf{Y}_i- \mathbf{\mu} ) - ( \mathbf{Y}_j - \mathbf{\mu} ) \right\}^\top \left\{ (\mathbf{Y}_i- \mathbf{\mu}) - (\mathbf{Y}_j - \mathbf{\mu} ) \right\} = \left\{  \mathbf{Y}_i-  \mathbf{Y}_j  \right\}^\top \left\{ \mathbf{Y}_i - \mathbf{Y}_j  \right\}
\]</span> 因为扣除行均值可以降低总的变异，它可以使得SVD的结果近更为逼近。</p>
<h2 id="练习">练习</h2>
<p>P357</p>
<h2 id="pca">PCA</h2>
<p>PCA的相关资料可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/PCA.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经提到了PCA，这里继续深入一步，讲一下PCA背后的数学原理。</p>
<h3 id="案例双胞胎身高">案例：双胞胎身高</h3>
<p>我们先使用模拟数据的案例展示一个旋转，这个旋转与PCA有着很大的有关系：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">Y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(Y[<span class="number">1</span>,], Y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=thelim, ylim=thelim)</div><div class="line">points(Y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], Y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911094030.jpeg">

</div>
<p>这里我们专门来解释一下什么是什么成分（principla components）。</p>
<p>我们使用 <span class="math inline">\(\mathbf{Y}\)</span> 这个 <span class="math inline">\(2 \times N\)</span> 矩阵来表示我们的数据。这个类似于我们检测了两组基因的信息，每列表示1个样本。现在我们的任何就是，找到一个 <span class="math inline">\(2 \times 1\)</span> 向量 <span class="math inline">\(\mathbf{u}_1\)</span> ，使其满足 <span class="math inline">\(\mathbf{u}_1^\top \mathbf{v}_1 = 1\)</span>，它能使 <span class="math inline">\((\mathbf{u}_1^\top\mathbf{Y})^\top (\mathbf{u}_1^\top\mathbf{Y})\)</span> 最大。这个过程可以被视为每个样本，或<span class="math inline">\(\mathbf{Y}\)</span>向子空间 <span class="math inline">\(\mathbf{u}_1\)</span> 的投影。因此，我们需要将坐标系进行置换，使新的坐标系能够显示出最大变异。</p>
<p>我先试一下 <span class="math inline">\(\mathbf{u}=(1,0)^\top\)</span>。这个投影公仅能够给出双胞胎1的身高（橘黄色）。图片标题中显示的是平方和。</p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1, fig.align</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(t(Y), xlim=thelim, ylim=thelim,</div><div class="line">     main=paste(&quot;Sum of squares :&quot;,round(crossprod(Y[1,]),1)))</div><div class="line">abline(h=0)</div><div class="line">apply(Y,2,function(y) segments(y[1],0,y[1],y[2],lty=2))</div><div class="line">points(Y[1,],rep(0,ncol(Y)),col=2,pch=16,cex=0.75)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911160126.jpeg">

</div>
<p>我们能否找到一个方向，使得坐标系旋转后，能够表示更高的变异？例如</p>
<p><span class="math inline">\(\mathbf{u} =\begin{pmatrix}1\\-1\end{pmatrix}\)</span> 这个怎么样？它不满足 <span class="math inline">\(\mathbf{u}^\top\mathbf{u}= 1\)</span> ，因此我们可以使用另外一个向量，即 <span class="math inline">\(\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\-1/\sqrt{2}\end{pmatrix}\)</span></p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1_either, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">u &lt;- matrix(c(1,-1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar(1,1)</div><div class="line">plot(t(Y),</div><div class="line">     main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),xlim=thelim,ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,-1,col=2)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i],Z[2,i],Y[1,i],Y[2,i],lty=2)</div><div class="line">points(t(Z), col=2, pch=16, cex=0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161254.jpeg">

</div>
<p>这个图形与双胞胎的差异有关，我们知道这个差异很少的。通常平方和我们可以确实这一点，最后我们试一下这个向量：</p>
<p><span class="math display">\[
\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\1/\sqrt{2}\end{pmatrix}
\]</span></p>
<figure class="highlight plain"><figcaption><span>PC1, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">u &lt;- matrix(c(1,1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar()</div><div class="line">plot(t(Y), main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),</div><div class="line">     xlim=thelim, ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,1,col=2)</div><div class="line">points(u%*%w, col=2, pch=16, cex=1)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i], Z[2,i], Y[1,i], Y[2,i], lty=2)</div><div class="line">points(t(Z),col=2,pch=16,cex=0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161447.jpeg">

</div>
<p>这个图形与重新缩放(re-scaled)后的平均高度有关，它有着最大的平方和。这是一个数学计算程序，它能够计算出一个 <span class="math inline">\(\mathbf{v}\)</span> ，能够使平方和最大，SVD就是这样的一个程序。</p>
<h4 id="主成分">主成分</h4>
<p>正交向量能够使平方和最大：</p>
<p><span class="math display">\[
(\mathbf{u}_1^\top\mathbf{Y})^\top(\mathbf{u}_1^\top\mathbf{Y})
\]</span></p>
<p><span class="math inline">\(\mathbf{u}_1^\top\mathbf{Y}\)</span> 指的就是第1PC。e用于获得PC的加权(weights) <span class="math inline">\(\mathbf{u}\)</span> 指的就是因子载荷(loadings)。使用旋转这种操作，它指的就是第1PC的旋转方向。</p>
<p>为了获得第2PC，我们可以重复上述操作，但是残差如下：</p>
<p><span class="math display">\[\mathbf{r} = \mathbf{Y} - \mathbf{u}_1^\top \mathbf{Yv}_1 \]</span></p>
<p>第2PC的向量含有以下性质：</p>
<p><span class="math display">\[ \mathbf{v}_2^\top \mathbf{v}_1=0\]</span></p>
<p>它能使 <span class="math inline">\((\mathbf{rv}_2)^\top \mathbf{rv}_2\)</span>最大，</p>
<p>当 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(N \times m\)</span> 时，我们可以重复地找到第3，第4，第5，等主成分。</p>
<h4 id="prcomp"><code>prcomp</code></h4>
<p>我们已经介绍了如何使用SVD来计算PC。介理，R中有一个专门的函数可以用于找到主成分，即<code>prcomp()</code>，在这个案例中，数据默认中心化的，这个函数的使用如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc &lt;- prcomp( t(Y) )</div></pre></td></tr></table></figure>
<p>计算出的结果与SVD相同，直到符号翻转（produces the same results as the SVD up to arbitrary sign flips，实在没理解这句话什么意思）</p>
<figure class="highlight plain"><figcaption><span>pca_svd, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd( Y - rowMeans(Y) )</div><div class="line">mypar(1,2)</div><div class="line">for(i in 1:nrow(Y) )&#123;</div><div class="line">  plot(pc$x[,i], s$d[i]*s$v[,i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911165120.jpeg">

</div>
<p>因子载荷可以通过下面方式计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$rotation</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pc$rotation</div><div class="line">           PC1        PC2</div><div class="line">[<span class="number">1</span>,] <span class="number">0.7072304</span>  <span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.7069831</span> -<span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>它就相当于 (up to a sign flip？这个不懂) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s$u</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; s$u</div><div class="line">           [,<span class="number">1</span>]       [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.7072304</span> -<span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">0.7069831</span>  <span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>解释的方差等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$sdev</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; pc$sdev</div><div class="line">[<span class="number">1</span>] <span class="number">1.2542672</span> <span class="number">0.2141882</span></div></pre></td></tr></table></figure>
<p>现在我们将<code>Y</code>转置一下，因为<code>prcomp()</code>函数与我们平时所用的高通量数据储存有点不太一样，平时我们的数据是列为样本，行为特征值，而<code>prcomp()</code>函数则是正好相反，它处理的数据列是特征值，行是样本名。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/20/DAL/DALS020_Distance_and_Dimension_Reduction1_SVD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/DAL/DALS020_Distance_and_Dimension_Reduction1_SVD/" itemprop="url">DALS020-距离与降维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T12:00:00+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,505
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第1小节，这一部分的主要内容涉及降维分析的一些原理，例如SVD，投影，旋转等，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/distance.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>距离(distance)的概念非常直接，例如，当我们把动物聚为亚群时，我们其实就是隐含地定义了一个距离，从而使我们可以说亚群内的动物彼此“接近”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909115530.png">

</div>
<p>我们使用的分析高通量数据的方法地都直接或间接地与距离有关。许多聚类方法和机器学习方法都需要使用特征值或预测因子来定义距离。例如热图是基因组学与高通量数据领域里使用最为广泛的工具，如果我们要生成热图，就需要明确计算距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130059.png">

</div>
<p>在上面的热图中，每个方格代表的数值储存在一个矩阵里，每具方格的行与列被聚类后（注：热图常用红色与绿色表示，但是对色盲人士来说，这两种颜色是最难分辨的颜色）用不同的颜色表示。在这一部分中，我们将学习必要的数学知识与计算技能来了解和创建热图。我们先来回顾一下数学上对距离的定义。</p>
<h2 id="欧氏距离euclidean-distance">欧氏距离(Euclidean Distance)</h2>
<p>现在我们在一个笛卡尔坐标系(Cartesian plane)中定义A点与B点的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>),pch=<span class="number">16</span>,cex=<span class="number">2</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,bty=<span class="string">"n"</span>,xlim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>),ylim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>))</div><div class="line">lines(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</div><div class="line">text(<span class="number">0</span>,<span class="number">.2</span>,expression(paste(<span class="string">'(A'</span>[x]*<span class="string">',A'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(<span class="number">1</span>,<span class="number">1.2</span>,expression(paste(<span class="string">'(B'</span>[x]*<span class="string">',B'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(-<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">"A"</span>,cex=<span class="number">2</span>)</div><div class="line">text(<span class="number">1.1</span>,<span class="number">1</span>,<span class="string">"B"</span>,cex=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130731.jpeg">

</div>
<p>其中，欧氏距离的定义如下所示： <span class="math display">\[
\sqrt{ (A_x-B_x)^2 + (A_y-B_y)^2}
\]</span></p>
<h2 id="高维数据的距离">高维数据的距离</h2>
<p>现在我们使用一个数据集，这个数据集中含有189个样本，22215个基因，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(devtools)</div><div class="line"><span class="comment"># install_github("genomicsclass/tissuesGeneExpression")</span></div><div class="line"></div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div></pre></td></tr></table></figure>
<p>这些数据代表了8个组织（每个组织中有多个样本）的RNA表达水平，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>   <span class="number">189</span></div><div class="line">&gt; table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们现在描述一下在这个数据集中，不同样本之间的距离。我们也许对在不同样本中表达相似的基因感兴趣。</p>
<p>为了定义这个距离，我们需要知道这些点是什么，因为我们计算数学上的距离需要这些点。由于这个数据集是高维数据集，这些点就无法直接放在笛卡尔坐标系中。相反，我们会把这个数据集放在更高维度的坐标系中。例如样本<span class="math inline">\(i\)</span>是由22215维空间的一个点定义的（这个空间可以写为<span class="math inline">\((Y_{1,i},\dots,Y_{22215,i})^\top\)</span>）。特征值<span class="math inline">\(g\)</span>是由一个189维空间的一个点定义的（这个空间可以写为<span class="math inline">\((Y_{g,1},\dots,Y_{g,189})^\top\)</span>）。</p>
<p>一旦我们定义好了这些点，那么欧氏距离就可以使用我们前面类似的方法进行计算，例如，两个样本<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>的距离为： <span class="math display">\[
\mbox{dist}(i,j) = \sqrt{ \sum_{g=1}^{22215} (Y_{g,i}-Y_{g,j })^2 }
\]</span> 两个特征值<span class="math inline">\(h\)</span>和<span class="math inline">\(g\)</span>的距离为： <span class="math display">\[
\mbox{dist}(h,g) = \sqrt{ \sum_{i=1}^{189} (Y_{h,i}-Y_{g,i})^2 }
\]</span></p>
<h3 id="矩阵代数与距离">矩阵代数与距离</h3>
<p>样本<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之间的距离可以写为： <span class="math display">\[
\mbox{dist}(i,j) = (\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j)
\]</span> 其中，<span class="math inline">\(\mbox{Y}_{i}\)</span>和<span class="math inline">\(\mbox{Y}_{j}\)</span>代表第<span class="math inline">\(i\)</span>列和第<span class="math inline">\(j\)</span>列。这种写法在实际计算中非常方便。</p>
<h3 id="案例">案例</h3>
<p>现在我们使用上面的矩阵代数来计算一下距离。现在我们计算样本1与样本2（它们都是肾脏组织）的距离，然后再过计算样本87的距离（结肠），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x &lt;- e[,<span class="number">1</span>]</div><div class="line">y &lt;- e[,<span class="number">2</span>]</div><div class="line">z &lt;- e[,<span class="number">87</span>]</div><div class="line">sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，肾脏组织之间距离比较近。另外一种计算距离更快的方式就是使用矩阵代数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqrt( crossprod(x-y) )</div><div class="line">sqrt( crossprod(x-z) )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt( crossprod(x-y) )</div><div class="line">        [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">85.8546</span></div><div class="line">&gt; sqrt( crossprod(x-z) )</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>现在我们一次计算出所有的距离，我们可以使用<code>dist()</code>函数，这个函数可以计算出每行之间的距离，现在我们感兴趣的是不同样本之间的相似性，因此我们需要使用<code>t()</code>来转换一下矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(e))</div><div class="line">class(d)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- dist(t(e))</div><div class="line">&gt; class(d)</div><div class="line">[<span class="number">1</span>] <span class="string">"dist"</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，计算结果<code>d</code>是一个<code>dist</code>类，为了得到它的具体数值，我们需要将其强行转换为矩阵，并使用索引操作，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>这里我们需要注意的是，我们对数据集<code>e</code>使用了函数<code>dist()</code>，这个函数计算的是基因之间所有两两矩离，它最终会形成一个<span class="math inline">\(22215\times 22215\)</span>的矩阵。</p>
<h2 id="练习">练习</h2>
<p>P322</p>
<h2 id="降维操作">降维操作</h2>
<p>相应的Rmarkdown见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/pca_motivation.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>可视化数据是分析高通量数据中最重要的步骤之一。正确的可视化方法可能会发现实验数据的问题，这些数据可以呈现标准分析的结果。我们已经展示了可视化数据的全局方法，但是由于数据的高维特性，使得发现列之间或行之间关系的图形变得复杂。例如，如果要比较189个样本之间的特性，我们必不得不创建17766个MA图。创建一个单独的散点图明显不合适，因为数据量太大。</p>
<p>我们将介绍其于降维的探索性数据分析的强大技巧。一般的想法就是将数据集降至较低维度的同时又保留重要的特性，例如样本之间的距离。如果我们能够将数据降低到2维，那么我们就能很容易地画出图形。降维的背后就是奇异值分解(Singular value decomposition, SVD)，这种思路也可以应用于其他情况。在介绍SVD背后的复杂数学原理之前，我们将会使用一个简单的案例来介绍一下它的思路。</p>
<h3 id="案例将2维数据降低至1维">案例：将2维数据降低至1维</h3>
<p>现在我们来看一个案例，这个案例是有关双胞胎身高的。我们来模拟生成100个二维数据点，它们表示每个人与其均值的偏离的标准差的数目，每对数据点表示一对又胞胎，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">plot(y[<span class="number">1</span>,], y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=c(-<span class="number">3</span>,<span class="number">3</span>), ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909151311.jpeg">

</div>
<p>为了辅助说明问题，我们可以将上面的模拟数据视为高通量基因表达数据，其中双胞胎的配对数据表示了N个样本，双胞胎的2个身高表示基因表达数据。我们是对任意2个之间的距离感兴趣。我们可以使用<code>dist()</code>函数来进行计算。例如，上图的2个橙色数据点的距离为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d=dist(t(y))</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d=dist(t(y))</div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">1.140897</span></div></pre></td></tr></table></figure>
<p>如果两维数据太复杂（这里只是假设），我们只想制备一维图，那怎么办呢？例如，我们能否将这些数据减化为一维矩阵，同时保留这些点与点之间的距离信息呢？</p>
<p>如果我们回顾再来看这张图，在任何一对数据点之间画一条线，那么这条线的长度就是这两点这之间的距离。这些线倾向于沿着对角线的方向分布。我们以前到过MA图，这种图就是将原始散点图的对角线“旋转”了一下，将原来的对角线旋转到与x轴平行的位置形成的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">z1 = (y[<span class="number">1</span>,]+y[<span class="number">2</span>,])/<span class="number">2</span> <span class="comment">#the sum</span></div><div class="line">z2 = (y[<span class="number">1</span>,]-y[<span class="number">2</span>,]) <span class="comment">#the difference</span></div><div class="line">z = rbind( z1, z2) <span class="comment">#matrix now same dimensions as y</span></div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized \</span></div><div class="line"><span class="string">height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece \</span></div><div class="line"><span class="string">in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909153046.jpeg">

</div>
<p>上图的左图就是原始的散点图，右图则是MA图。</p>
<p>在后面章节中，我们将会使用线性代数来表示这些数据的变换（也就是旋转）。这里我们可以通过将<code>y</code>的相乘来得到<code>z</code>，如下所示： <span class="math display">\[
A = \,
\begin{pmatrix}
1/2&amp;1/2\\
1&amp;-1\\
\end{pmatrix}
\implies 
z = A y
\]</span> 我们将两侧都乘以<span class="math inline">\(A^{-1}\)</span>，则得到z，如下所示： <span class="math display">\[
A^{-1} = \,
\begin{pmatrix}
1&amp;1/2\\
1&amp;-1/2\\
\end{pmatrix}
\implies 
y = A^{-1} z
\]</span></p>
<h3 id="旋转">旋转</h3>
<p>在上图相，相对于其它点之间的距离，两个橙色上炽之间的距离大致保持一致。所以的点其实都是如此。对上面转换进行简单的重新缩放，将会使前后的距离完全相同。我们要做的就是乘以一个标量，从而保留每个数据点的标准差。如果你认为<code>y</code>的列是一个独立随机变量，其标准差为<span class="math inline">\(\sigma\)</span>，那么我们要注意到<span class="math inline">\(M\)</span>与<span class="math inline">\(A\)</span>的标准差如下所示： <span class="math display">\[
\mbox{sd}[ Z_1 ] = \mbox{sd}[ (Y_1 + Y_2) / 2 ] = \frac{1}{\sqrt{2}} \sigma \mbox{ and } \mbox{sd}[ Z_2] = \mbox{sd}[ Y_1 - Y_2  ] = {\sqrt{2}} \sigma
\]</span> 这就说明，如果我们将上面的转换变为如下形式： <span class="math display">\[
A = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1&amp;1\\
1&amp;-1\\
\end{pmatrix}
\]</span> 那么<span class="math inline">\(Y\)</span>列的SD就会变得与<span class="math inline">\(Z\)</span>列的方差一样。此外，我们要注意到，<span class="math inline">\(A^{-1}A=I\)</span>。我们称这种特性为<code>正交</code>(orthogonal)，并且它保留了上述SD的特性。因此就保留了距离信息：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">A &lt;- <span class="number">1</span>/sqrt(<span class="number">2</span>)*matrix(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z &lt;- A%*%y</div><div class="line">d &lt;- dist(t(y))</div><div class="line">d2 &lt;- dist(t(z))</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d2)) <span class="comment">#as.numeric turns distnaces into long vector</span></div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154417.jpeg">

</div>
<p>我们称这种转换为<code>y</code>的旋转：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154529.jpeg">

</div>
<p>我们之所以优先使用这种转换，是因为我们注意到所有的点是沿着对角线进行分布的，我们将对角线进行转换后，对角线与x轴平行。所以这个旋转实际上就达到了我们最初的要求：我们只需要一个维度就可以保留点与点之间的距离。现在让我们删除了第二个维度<code>z</code>，并重新计算一下距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3 = dist(z[<span class="number">1</span>,]) <span class="comment">##distance computed using just first dimension</span></div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d3))</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909155706.jpeg">

</div>
<p>仅用一维数据进行的距离计算就很接近实际距离，并且降低了维度，将2维降低到了1维。转换后的数据的第1约就是第一主成分。这一思想促进了使用主成分分析(PCA)和奇异值分解(SVD)来实现更广泛的降维。</p>
<h3 id="关于与其他解释区别的重要说明">关于与其他解释区别的重要说明</h3>
<p>如果你在网上搜索PCA的描述，你会注意到网上的描述与我们这里描述在符号上有些出入。这主要是因为在PCA中，通常使用行来表示实验单元（就是样本）。因此，在我们这里的实验中，<span class="math inline">\(Y\)</span>通常会被转换为<span class="math inline">\(N \times 2\)</span>矩阵。在统计学中，这也是最为普遍的表示数据的方式：每行表示一个样本。然而，由于实际原因，在遗传学中，通常使用列表示样本。例如行表示基因，列表示样本。由于这个原因，在这本书中，我们会解释PCA和与之相应的数学计算会与常规的方式有所不同。因此，在网上找到的相关的许多PCA的解释都是先从样本的协方差矩阵开始的，它通常使用<span class="math inline">\(\mathbf{X}^\top\mathbf{X}\)</span>表示，并且每个单元格表示两个实验单元之间的协方差。然而，要做到这一点，我们需要使用<span class="math inline">\(\mbox{X}\)</span>的行表示实验单元。因此，在我们上面的符号中，在经过缩放后，你必须要使用<span class="math inline">\(\mathbf{Y}\mathbf{Y}^\top\)</span>来进行计算。总之，如果你想让我们的解释与其他有关的PCA内容相符，就必须对这本书中使用的矩阵进行转置。</p>
<h2 id="奇异值分解">奇异值分解</h2>
<p>相关的Rmarkdown参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/svd.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在前面的部分中，我们展示了降维分析，以及如何让我们使用一维数据来替代原来的二维数据，近似地表示点与点之间的距离。奇异值分解(SVD)是我们这种方法的推广。在这个案例中，SVD对原始数据进行了转换。这种转换具有一些非常有用的属性。</p>
<p>SVD计算的主要结果就是，我们可以写为一个<span class="math inline">\(m\times n\)</span>矩阵，对于矩阵<span class="math inline">\(\mbox{Y}\)</span>就写为：</p>
<p><span class="math display">\[
\mathbf{U}^\top\mathbf{Y} = \mathbf{DV}^\top
\]</span> 其中， * <span class="math inline">\(\mathbf{U}\)</span> 是一个 <span class="math inline">\(m \times p\)</span> 正交矩阵； * <span class="math inline">\(\mathbf{V}\)</span> 是一个 <span class="math inline">\(p \times p\)</span> 正交矩阵； * <span class="math inline">\(\mathbf{D}\)</span> 是一个 <span class="math inline">\(n \times p\)</span> 对角矩阵。</p>
<p>其中，<span class="math inline">\(p=\mbox{min}(m,n)\)</span>，<span class="math inline">\(\mathbf{U}^\top\)</span>对数据<span class="math inline">\(\mathbf{Y}\)</span>进行旋转，这一步非常有用，因为<span class="math inline">\(\mathbf{U}^\top \mathbf{Y}=\mathbf{VD}\)</span>列的变异（精确的平方和）会下降。因此<span class="math inline">\(\mathbf{U}\)</span>是正交辞职，我们可以将SVD写为如下形式： <span class="math display">\[
\mathbf{Y} = \mathbf{UDV}^\top
\]</span> 实际上这个公式更加普遍，我们也可以将转换写为如下形式： <span class="math display">\[
\mathbf{YV} = \mathbf{UD}
\]</span> <span class="math inline">\(Y\)</span>的这种转换也会生成一个矩阵，这个矩阵的列的乘方和是递减的。</p>
<p>将SVD应用到我们的案例中，就是如下结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y &lt;- t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">s &lt;- svd(y)</div></pre></td></tr></table></figure>
<p>我们可以马上就是看到使用了SVD后生成的转换后的矩阵非常类似于我们前面的案例中的结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div><div class="line">       [,<span class="number">1</span>]   [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.982</span> -<span class="number">1.017</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">1.017</span>  <span class="number">0.982</span></div></pre></td></tr></table></figure>
<p>当我们旋转后，绘制成的图形称为主成分(principal coimponent)：这里只绘制出了第一个主成分和第二个主成分。如果我们想要从SVD中获取主成分，只需要旋转后的<span class="math inline">\(\mathbf{U}^\top\mathbf{Y}\)</span> 即可：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PC1 = s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 = s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">plot(PC1,PC2,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173315.jpeg">

</div>
<h3 id="用途">用途</h3>
<p>使用SVD的用途并不十分明显，我们可以看一些案例。在这个案例中，我们将会极大地降低<span class="math inline">\(V\)</span>的组倒数，并且仍然能够构建<span class="math inline">\(Y\)</span>。</p>
<p>现在我们来对基因表达谱进行SVD的计算，我们可以只使用表达谱中的100个基因的子集，这样计算会快一点，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">ind &lt;- sample(nrow(e),<span class="number">500</span>)</div><div class="line">Y &lt;- t(apply(e[ind,],<span class="number">1</span>,scale)) <span class="comment">#standardize data for illustration</span></div></pre></td></tr></table></figure>
<p>使用<code>svd()</code>函数可以返回3个矩阵（D矩阵仅返回对角线元素），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(Y)</div><div class="line">U &lt;- s$u</div><div class="line">V &lt;- s$v</div><div class="line">D &lt;- diag(s$d) <span class="comment">##turn it into a matrix</span></div></pre></td></tr></table></figure>
<p>我们首选要注意到，我们可以重构<span class="math inline">\(y\)</span>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Yhat &lt;- U %*% D %*% t(V)</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>如果我们看一下<span class="math inline">\(\mathbf{UD}\)</span>的平方和，我们会看到最后几个非常接近于0（也许我们会有一些重复的列）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173946.jpeg">

</div>
<p>这意味着<span class="math inline">\(V\)</span>的最后一列对于<span class="math inline">\(Y\)</span>的重建非常小。为了说明这一点，我们可以考虑<span class="math inline">\(V\)</span>最后一项为0的这种极端情况。在这个案例中，<span class="math inline">\(V\)</span>的最后一列根本用不到。由于SVD的这种创建方式，<span class="math inline">\(V\)</span>的列对<span class="math inline">\(Y\)</span>的重建影响越来越小。我们通常认为这种描述为“解释了较少的变异”。这就意味着，对于一个大型矩阵，当你到达最后一列时，可能已经没有太多需要“解释”的内容了。例如，当我们把最后4列删除，看一下计算结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- ncol(U)-<span class="number">4</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>最大的残差基本上就等于0了，就意味着<code>Yhat</code>实际上是与<code>Y</code>一样，但是，我们至少需要4个维度来传输信息。</p>
<p>通过查看<span class="math inline">\(d\)</span>，我们可以看到，在这个特定的数据集中，我们能得到一个很好的近似值，它只保留了94列。在下面的图形中，我们可以看到每列能解释的变异程度是多少：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909174959.jpeg">

</div>
<p>还可以看一下累积曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plot(cumsum(s$d^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>,ylim=c(<span class="number">0</span>,\</div><div class="line"><span class="number">100</span>),type=<span class="string">"l"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175047.jpeg">

</div>
<p>虽然刚开始的时候，我们的数据是189维，但是我们可以使用95维来近似表示<span class="math inline">\(Y\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- <span class="number">95</span> <span class="comment">##out a possible 189</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">boxplot(resid,ylim=quantile(Y,c(<span class="number">0.01</span>,<span class="number">0.99</span>)),range=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175150.jpeg">

</div>
<p>因此， 我们只使用了一半的维度就保留了原始数据中的大部分的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var(as.vector(resid))/var(as.vector(Y))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; var(as.vector(resid))/var(as.vector(Y))</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>这个计算结果说明，我们使用了降维后的数据解释了原始95%的变异，我们需要注意的是，我们是通过<span class="math inline">\(D\)</span>来计算的这个比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>因此，<span class="math inline">\(D\)</span>中的元素可以告诉我们每个PC在解释变异方面所贡献的程度大小。</p>
<h3 id="高度相关数据">高度相关数据</h3>
<p>为了辅助理解SVD是如何工作的，我们使用两组高度相关的列来构建一个数据集，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">2</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- cbind(x,x)+e</div><div class="line">cor(Y)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; cor(Y)</div><div class="line">          x         x</div><div class="line">x <span class="number">1.0000000</span> <span class="number">0.9998873</span></div><div class="line">x <span class="number">0.9998873</span> <span class="number">1.0000000</span></div></pre></td></tr></table></figure>
<p>在这个案例中，第2列添加了很少的“信息”，因此所有的<code>Y[,1]-Y[,2]</code>都接近于0。使用<code>rowMeans(Y)</code>计算更加有效，这是因为<code>Y[,1]-rowMeans(Y)</code>和<code>Y[,2]-rowMeans(Y)</code>更接近于0。<code>rowMenas(Y)</code>最终生成的结果在<span class="math inline">\(U\)</span>的第1列中。SVD的计算结果表明，仅使用第1列就能解释大多数的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- svd(Y)$d</div><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999441</span></div></pre></td></tr></table></figure>
<p>在这个案例中，许多列的数据高度相关，我们可以进行更大程度的降维操作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">25</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- replicate(n,x)+e</div><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999065</span></div></pre></td></tr></table></figure>
<h2 id="练习-1">练习</h2>
<p>P338</p>
<h2 id="投影">投影</h2>
<p>原始Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/projections.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经详细地描述了降维的概念，以及SVD和主成分分析的内容，现在我们来谈一下它们背后的数学原理。我们先从投影(projection)开始讲起。投影是一个线性代数的概念，它能帮助我们理解许多关于高通量数据的许多数学操作。如果想要了解更多相关的知识，可以找本线性代数的书来看一下有关投影的内容。在这一部分里，我们会提供一个快速的回顾，然后提供一些数据分析的相关案例。</p>
<p>作为回顾，我们需要注意的是，投影就是点与其子空间之间的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910145026.png">

</div>
<p>在上图中，顶部的点指向空间中的一点。在上图的这个卡通图中，空间是二维的，但是我们可以更加抽象地思考一下。这个空间由笛卡尔平面表示，小人站的这条线是点的一个子空间。将点投影到这个子空间上所对应的位置，就是这个子空间上这个位置距离原点最近的点。几何学告诉我们，我们可以通过从点到子空间一条垂线（虚线）来找到子空间上的这点。小人站在这个子空间上，这个人从原点走到投影点的位置时，就是这个点投影到子空间后的坐标。</p>
<p>为了扩展投影的概念，我们可以使用标准矩阵线性符号来说明这个点， <span class="math inline">\(\vec{y} \in \mathbb{R}^N\)</span>是一个N维空间的点，<span class="math inline">\(L \subset \mathbb{R}^N\)</span>是一个更小的子空间。</p>
<h3 id="案例当n2">案例：当N=2</h3>
<p>先看一个案例，<span class="math inline">\(Y = \begin{pmatrix} 2 \\ 3\end{pmatrix}\)</span>，我们可以画出这个向量的图形：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar (<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">4</span>),c(<span class="number">0</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910151328.jpeg">

</div>
<p>我们可以马上定义一个坐标系统，将这个向量投影到空间中：<span class="math inline">\(\begin{pmatrix} 1\\ 0\end{pmatrix}\)</span> （x轴）和 <span class="math inline">\(\begin{pmatrix} 0\\ 1\end{pmatrix}\)</span> （y轴）。 <span class="math inline">\(Y\)</span> 向子空间的投影可以通过点2和3分别进行定义：</p>
<p><span class="math display">\[
\begin{align*}
Y &amp;= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&amp;=2  \begin{pmatrix} 1\\ 0\end{pmatrix} + 3 \begin{pmatrix} 0\\ 1\end{pmatrix} 
\end{align*}
\]</span> 我们可以说 <span class="math inline">\(2\)</span> 和<span class="math inline">\(3\)</span>是向量<span class="math inline">\(Y\)</span>的坐标，<span class="math inline">\(\begin{pmatrix} 1\\ 0\end{pmatrix} \mbox{and} \begin{pmatrix} 0\\1 \end{pmatrix}\)</span> 是它的基。</p>
<p>现在我们定义一个新的子空间。红线（后面我们会画出这个图形）是一个子集(subset)<span class="math inline">\(L\)</span>，它由满足 <span class="math inline">\(c \vec{v}\)</span> with <span class="math inline">\(\vec{v}=\begin{pmatrix} 2&amp; 1\end{pmatrix}^\top\)</span>的点构成。那么 <span class="math inline">\(\vec{y}\)</span> 在<span class="math inline">\(L\)</span>上的投影就是<span class="math inline">\(L\)</span>上最接近于 <span class="math inline">\(\vec{y}\)</span> 的点。因此我们需要找一个向量<span class="math inline">\(c\)</span>，它是位于 <span class="math inline">\(\vec{y}\)</span> 和<span class="math inline">\(c\vec{v}=(2c,c)\)</span>之间最小的距离。从线性代数的知识我们可知，这些点之间的距离正交于空间：</p>
<p><span class="math display">\[
(\vec{y}-\hat{c}\vec{v}) \cdot \vec{v} = 0
\]</span></p>
<p>上面公式也可以写为：</p>
<p><span class="math display">\[
\vec{y}\cdot\vec{v} - \hat{c}\vec{v}\cdot\vec{v} =  0
\]</span></p>
<p>即： <span class="math display">\[
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}
\]</span> <span class="math display">\[\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}\]</span></p>
<p>这里我们使用点号 <span class="math inline">\(\cdot\)</span> 来表示点积(dot product): <span class="math inline">\(\,\, \vec{x} \cdot \vec{y} = x_1 y_1+\dots x_n y_n\)</span>.</p>
<p>下面我们使用R来演示一下上面的案例：</p>
<figure class="highlight plain"><figcaption><span>projection, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(c(0,4),c(0,4),xlab=&quot;Dimension 1&quot;,ylab=&quot;Dimension 2&quot;,type=&quot;n&quot;)</div><div class="line">arrows(0,0,2,3,lwd=3)</div><div class="line">abline(0,0.5,col=&quot;red&quot;,lwd=3) #if x=2c and y=c then slope is 0.5 (y=0.5x)</div><div class="line">text(2,3,&quot; Y&quot;,pos=4,cex=3)</div><div class="line">y=c(2,3)</div><div class="line">x=c(2,1)</div><div class="line">cc = crossprod(x,y)/crossprod(x)</div><div class="line">segments(x[1]*cc,x[2]*cc,y[1],y[2],lty=2)</div><div class="line">text(x[1]*cc,x[2]*cc,expression(hat(Y)),pos=4,cex=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910153202.jpeg">

</div>
<p>我们需要注意的是，如果 <span class="math inline">\(\vec{v}\)</span> 满足 <span class="math inline">\(\vec{v}\cdot \vec{v}=1\)</span>, 那么<span class="math inline">\(\hat{c}\)</span> 就是 <span class="math inline">\(\vec{y} \cdot \vec{v}\)</span> ，空间 <span class="math inline">\(L\)</span>并没有发生改变，这处简化担任就是我们喜欢正交矩阵的一个原因。</p>
<h3 id="案例样本均值就是投影">案例：样本均值就是投影</h3>
<p>设 <span class="math inline">\(\vec{y} \in \mathbb{R}^N\)</span> ，<span class="math inline">\(L \subset \mathbb{R}^N\)</span> 被以下向量张成：</p>
<p><span class="math display">\[
\vec{v}=\begin{pmatrix} 1\\ \vdots \\  1\end{pmatrix};
L = \{ c \vec{v}; c \in \mathbb{R}\}
\]</span> 在这个空间里，向量的分量(components）都是相同的数目，因此我们可以把这个空间看作为常数：在投影中，每个维度都是相同的值。那么<span class="math inline">\(c\)</span>如何才能使得 <span class="math inline">\(c\vec{v}\)</span> 与 <span class="math inline">\(\vec{y}\)</span> 之间的距离最小呢？</p>
<p>当我们谈到这个问题时，我们会使用前面的二维图形。我们可以简单地抽象将<span class="math inline">\(\vec{y}\)</span>视为N维空间上的一个点，将<span class="math inline">\(L\)</span>视为一个更小数目的子空间，在这个案例中就是<span class="math inline">\(c\)</span>。</p>
<p>回到我们的问题，我们知道，投影就是：</p>
<p><span class="math display">\[\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}\]</span></p>
<p>在这个案例中它就是平均值： <span class="math display">\[
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}} = \frac{\sum_{i=1}^N Y_i}{\sum_{i=1}^N 1} = \bar{Y}
\]</span></p>
<p>在这个案例中，它也非常容易使用微积分进行计算：</p>
<p><span class="math display">\[
\frac{\partial}{\partial c}\sum_{i=1}^N (Y_i - c)^2 = 0 \implies 2 \sum_{i=1}^N (Y_i - \hat{c}) = 0 \implies
\]</span> <span class="math display">\[
N c = \sum_{i=1}^N Y_i \implies \hat{c}=\bar{Y
}
\]</span></p>
<h3 id="案例回归也是一种投影">案例：回归也是一种投影</h3>
<p>现在来看一下略微复杂的案例。简单线性回归也能用投影来解释。我们的数据 <span class="math inline">\(\mathbf{Y}\)</span>（这里我们不再使用<span class="math inline">\(\vec{y}\)</span>符号）是一个N维向量，我们使用一个线性方程<span class="math inline">\(\beta_0 + \beta_1 X_i\)</span>来预测<span class="math inline">\(Y_i\)</span> 。此时我要找到能够使<span class="math inline">\(Y\)</span>和由以下向量定义的空间的最小距离时的 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span> ，其中： <span class="math display">\[
\vec{v}_0=
\begin{pmatrix}
1\\
1\\
\vdots \\
1\\
\end{pmatrix} 
\mbox{ and }
\vec{v}_1=
\begin{pmatrix}
X_{1}\\
X_{2}\\
\vdots \\
X_{N}\\
\end{pmatrix} 
\]</span></p>
<p>我们的 <span class="math inline">\(N\times 2\)</span> 矩阵 <span class="math inline">\(\mathbf{X}\)</span> 是 <span class="math inline">\([ \vec{v}_0 \,\, \vec{v}_1]\)</span> ，<span class="math inline">\(L\)</span>中的任何点都可以被写为 <span class="math inline">\(X\vec{\beta}\)</span>.</p>
<p>正交投影的多维形式的方程为：</p>
<p><span class="math display">\[
X^\top (\vec{y}-X\vec{\beta}) = 0
\]</span></p>
<p>我们在之前看到过种形式：</p>
<p><span class="math display">\[
X^\top X \hat{\beta}=  X^\top \vec{y} 
\]</span></p>
<p><span class="math display">\[
\hat{\beta}= (X^\top X)^{-1}X^\top \vec{y}
\]</span></p>
<p>它向<span class="math inline">\(L\)</span>的投影就是：</p>
<p><span class="math display">\[
X (X^\top X)^{-1}X^\top \vec{y}
\]</span></p>
<h2 id="旋转-1">旋转</h2>
<p>相关的Rmarkdown参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/rotations.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>与投影相关的一个最常见的应用就是坐标旋转(coordinate rotations)。在数据分析中，简单的旋转可以很好地对数据进行可视化和解释。我们将会介绍旋转背后的数学原理，并且给出一些简单的数据分析案例。</p>
<p>前面我们使用了下面的例子： <span class="math display">\[
Y = \begin{pmatrix} 2 \\ 
3 
\end{pmatrix} 
= 
2  
\begin{pmatrix} 1\\
0 
\end{pmatrix} + 
3 
\begin{pmatrix} 0\\ 
1 
\end{pmatrix}
\]</span> 我们注意到，<span class="math inline">\(Y\)</span>的坐标是<span class="math inline">\((2,3)\)</span>，现在我们使用如下的代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">segments(<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">segments(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910165242.jpeg">

</div>
<p>但是，我们可以用其它的一些线性组合来表示点<span class="math inline">\((2,3)\)</span>： <span class="math display">\[
\begin{align*}
Y &amp;= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&amp;= 2.5 \begin{pmatrix} 1\\ 1\end{pmatrix} + -1 \begin{pmatrix} \phantom{-}0.5\\ -0.5\end{pmatrix} 
\end{align*}
\]</span> 新的坐标就是： <span class="math display">\[
Z = \begin{pmatrix} 2.5 \\ -1 \end{pmatrix}
\]</span> 从图形上我们可以看出来，这个坐标就是我们由新的基定义的空间的投影</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">abline(<span class="number">0</span>,-<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">y=c(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">x1=c(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">##new basis</span></div><div class="line">x2=c(<span class="number">0.5</span>,-<span class="number">0.5</span>)<span class="comment">##new basis</span></div><div class="line">c1 = crossprod(x1,y)/crossprod(x1)</div><div class="line">c2 = crossprod(x2,y)/crossprod(x2)</div><div class="line">segments(x1[<span class="number">1</span>]*c1,x1[<span class="number">2</span>]*c1,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">segments(x2[<span class="number">1</span>]*c2,x2[<span class="number">2</span>]*c2,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233102.jpeg">

</div>
<p>我们可以使用矩阵乘法在表示<span class="math inline">\((2,3)\)</span>的这两个坐标中进行转换： <span class="math display">\[
Y =   AZ\\
\]</span></p>
<p><span class="math display">\[
 A^{-1} Y =  Z\\
\]</span></p>
<p><span class="math display">\[
A= \begin{pmatrix} 1&amp; \phantom{-}0.5\\ 1 &amp; -0.5\end{pmatrix} \implies 
A^{-1}= \begin{pmatrix} 0.5&amp; 0.5 \\ 1 &amp;-1\end{pmatrix}
\]</span></p>
<p>其中，<span class="math inline">\(Z\)</span>和<span class="math inline">\(Y\)</span>表示了相同的信息，但是它们位于不同的坐标系中。</p>
<h3 id="案例双胞胎身高">案例：双胞胎身高</h3>
<p>我们先来看100个二维数据点<span class="math inline">\(Y\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n = <span class="number">100</span></div><div class="line">mypar()</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>),matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233353.jpeg">

</div>
<p>这里就使用了旋转：<span class="math inline">\(Z = A^{-1} Y\)</span>，图形如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = matrix(c(<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z = A%*%y</div><div class="line">mypar()</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlab=<span class="string">"Average"</span>,ylab=<span class="string">"Difference"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233448.jpeg">

</div>
<p>我们在这里进行的操作就是对数据进行旋转，从而使行新的坐标系<span class="math inline">\(Z\)</span>的第一维是平均身高（就是相当于x轴），崦第二维则是两个双胞胎身高的差值（y轴）。</p>
<p>我们已经使用了奇异值分解计算主成分。有时候将SVD视为应动力非常有用，例如 <span class="math inline">\(\mathbf{U}^\top \mathbf{Y}\)</span> 就会构建出一个新的坐标系 <span class="math inline">\(\mathbf{DV}^\top\)</span> ，在这个新的坐标系中，它们的维度按照维度能够解释变异的程序进行排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">222</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">109</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共882.4k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
