<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/10/BioTools/fgsea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/BioTools/fgsea/" itemprop="url">fgsea包做GSEA分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T12:00:00+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生信工具/" itemprop="url" rel="index">
                    <span itemprop="name">生信工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,259
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="gsea图">GSEA图</h2>
<p>这篇教程翻译自生信博客DAVE TANGE’S BLOG(https://davetang.org/muse/)上的一篇教程，参考资料中已经列出了地址。</p>
<p><code>fgsea</code>这个包用于做GSEA分析，先来看一下使用这个包做的图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911114456.png">

</div>
<p>现在简单解释一下这个图形：</p>
<p>x轴——排序后的基因列表<code>L</code>位置对应的坐标，也就是我们自己通过RNA-seq，芯片，qPCR等手段获得的基因表达值倍数变化，或p值排序，总之，这是一个有序列表。</p>
<p>垂直的黑色细胞——上图中类似条形码的图形，这是指的是某一个基因集<code>S</code>中基因对应于<code>L</code>基因中，的位置，在上图中，这个基因集是细胞周期(Cell Cycle)，明天看到<code>S</code>中的成员在<code>L</code>的左侧比较密集。</p>
<p>y轴——富集分布，从上面我们可以看到，细胞周期(Cell Cycle)这个基因集在左侧富集，也就是绿色曲线表示的位置。</p>
<h2 id="fgsea使用">fgsea使用</h2>
<h3 id="安装">安装</h3>
<p>先安装<code>fgsea</code>包，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"BiocManager"</span>)</div><div class="line">BiocManager::install(<span class="string">"fgsea"</span>)</div><div class="line"><span class="keyword">library</span>(fgsea)</div></pre></td></tr></table></figure>
<h3 id="数据">数据</h3>
<p><code>fgsea</code>包中内置的有数据集<code>examplePathways</code>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(fgsea)</div><div class="line"></div><div class="line">data(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># examplePathways是从'reactome.db'包中</span></div><div class="line"><span class="comment"># 提取的信息，并以列表的形式存了这些信息，</span></div><div class="line"><span class="comment"># 这些信息主要是小鼠的基因</span></div><div class="line">help(<span class="string">"examplePathways"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 这个数据集是一个列表</span></div><div class="line">class(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># 一共有1,457 "通路"</span></div><div class="line">length(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># 第1列含有Meiotic_Synapsis pathway的EntrezID</span></div><div class="line">examplePathways[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment"># exampleRanks储存的是排序信息</span></div><div class="line">data(exampleRanks)</div><div class="line"></div><div class="line"><span class="comment"># exampleRnak是一个数字型的向量</span></div><div class="line">class(exampleRanks)</div><div class="line"></div><div class="line"><span class="comment"># exampleRanks中的向量名称则是对称的Entrez ID</span></div><div class="line">head(exampleRanks)</div><div class="line">tail(unname(exampleRanks))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(fgsea)</div><div class="line">&gt; </div><div class="line">&gt; data(examplePathways)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># examplePathways是从'reactome.db'包中</span></div><div class="line"><span class="comment"># 提取的信息，并以列表的形式</span></div><div class="line">&gt; <span class="comment"># 储存了这些信息，这些信息主要是小鼠的基因</span></div><div class="line">&gt; help(<span class="string">"examplePathways"</span>)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 这个数据集是一个列表</span></div><div class="line">&gt; class(examplePathways)</div><div class="line">[<span class="number">1</span>] <span class="string">"list"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 一共有1,457 "通路"</span></div><div class="line">&gt; length(examplePathways)</div><div class="line">[<span class="number">1</span>] <span class="number">1457</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 第1列含有Meiotic_Synapsis pathway的EntrezID</span></div><div class="line">&gt; examplePathways[<span class="number">1</span>]</div><div class="line">$`1221633_Meiotic_Synapsis`</div><div class="line"> [<span class="number">1</span>] <span class="string">"12189"</span>     <span class="string">"13006"</span>     <span class="string">"15077"</span>     <span class="string">"15078"</span>     <span class="string">"15270"</span>     <span class="string">"15512"</span>    </div><div class="line"> [<span class="number">7</span>] <span class="string">"16905"</span>     <span class="string">"16906"</span>     <span class="string">"19357"</span>     <span class="string">"20842"</span>     <span class="string">"20843"</span>     <span class="string">"20957"</span>    </div><div class="line">[<span class="number">13</span>] <span class="string">"20962"</span>     <span class="string">"21749"</span>     <span class="string">"21750"</span>     <span class="string">"22196"</span>     <span class="string">"23856"</span>     <span class="string">"24061"</span>    </div><div class="line">[<span class="number">19</span>] <span class="string">"28113"</span>     <span class="string">"50878"</span>     <span class="string">"56739"</span>     <span class="string">"57321"</span>     <span class="string">"64009"</span>     <span class="string">"66654"</span>    </div><div class="line">[<span class="number">25</span>] <span class="string">"69386"</span>     <span class="string">"71846"</span>     <span class="string">"74075"</span>     <span class="string">"77053"</span>     <span class="string">"94244"</span>     <span class="string">"97114"</span>    </div><div class="line">[<span class="number">31</span>] <span class="string">"97122"</span>     <span class="string">"97908"</span>     <span class="string">"101185"</span>    <span class="string">"140557"</span>    <span class="string">"223697"</span>    <span class="string">"260423"</span>   </div><div class="line">[<span class="number">37</span>] <span class="string">"319148"</span>    <span class="string">"319149"</span>    <span class="string">"319150"</span>    <span class="string">"319151"</span>    <span class="string">"319152"</span>    <span class="string">"319153"</span>   </div><div class="line">[<span class="number">43</span>] <span class="string">"319154"</span>    <span class="string">"319155"</span>    <span class="string">"319156"</span>    <span class="string">"319157"</span>    <span class="string">"319158"</span>    <span class="string">"319159"</span>   </div><div class="line">[<span class="number">49</span>] <span class="string">"319160"</span>    <span class="string">"319161"</span>    <span class="string">"319565"</span>    <span class="string">"320332"</span>    <span class="string">"320558"</span>    <span class="string">"326619"</span>   </div><div class="line">[<span class="number">55</span>] <span class="string">"326620"</span>    <span class="string">"360198"</span>    <span class="string">"497652"</span>    <span class="string">"544973"</span>    <span class="string">"625328"</span>    <span class="string">"667250"</span>   </div><div class="line">[<span class="number">61</span>] <span class="string">"100041230"</span> <span class="string">"102641229"</span> <span class="string">"102641751"</span> <span class="string">"102642045"</span></div><div class="line"></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRanks储存的是排序信息</span></div><div class="line">&gt; data(exampleRanks)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRnak是一个数字型的向量</span></div><div class="line">&gt; class(exampleRanks)</div><div class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRanks中的向量名称则是对称的Entrez ID</span></div><div class="line">&gt; head(exampleRanks)</div><div class="line">   <span class="number">170942</span>    <span class="number">109711</span>     <span class="number">18124</span>     <span class="number">12775</span>     <span class="number">72148</span>     <span class="number">16010</span> </div><div class="line">-<span class="number">63.33703</span> -<span class="number">49.74779</span> -<span class="number">43.63878</span> -<span class="number">41.51889</span> -<span class="number">33.26039</span> -<span class="number">32.77626</span> </div><div class="line">&gt; tail(unname(exampleRanks))</div><div class="line">[<span class="number">1</span>] <span class="number">47.58235</span> <span class="number">49.87543</span> <span class="number">50.25179</span> <span class="number">50.86532</span> <span class="number">51.16110</span> <span class="number">53.28400</span></div></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<p>现在我们使用上面的数据进行GSEA分析，进行GSEA分析时，我们的通路文件（也就是GSEA官网中的GMT文件，对应的就是基因集<code>S</code>）储存在<code>pathways</code>参数中，用户自己的数据（排过序的数据）放在<code>stats</code>数据集中，剩下的参数不用管，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fgseaRes &lt;- fgsea(pathways = examplePathways, </div><div class="line">                  stats = exampleRanks,</div><div class="line">                  minSize=<span class="number">15</span>,</div><div class="line">                  maxSize=<span class="number">500</span>,</div><div class="line">                  nperm=<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>分析的结果fgseaRes是一个<code>data.table</code>格式的文件，使用<code>plotEnrichment</code>函数可以绘制出GSEA分析的结果，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">library(ggplot2)</div><div class="line"># 参考 https://github.com/Rdatatable/data.table/wiki</div><div class="line"># 来查看data.table相关的信息</div><div class="line">class(fgseaRes)</div><div class="line"></div><div class="line"># 查看p值小于0.01的通路的数目</div><div class="line">sum(fgseaRes[, padj &lt; 0.01])</div><div class="line"></div><div class="line"># 绘制出最显著的富集通路</div><div class="line">plotEnrichment(examplePathways[[head(fgseaRes[order(pval), ], 1)$pathway]],</div><div class="line">               exampleRanks) + </div><div class="line">               labs(title=head(fgseaRes[order(pval), ], 1)$pathway)</div></pre></td></tr></table></figure></p>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; class(fgseaRes)</div><div class="line">[<span class="number">1</span>] <span class="string">"data.table"</span> <span class="string">"data.frame"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 查看p值小于0.01的通路的数目</span></div><div class="line">&gt; sum(fgseaRes[, padj &lt; <span class="number">0.01</span>])</div><div class="line">[<span class="number">1</span>] <span class="number">78</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911122517.jpeg">

</div>
<p>可以画出具体的某条通路，如下所示；</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plotEnrichment(examplePathways[[<span class="string">"5991130_Programmed_Cell_Death"</span>]],</div><div class="line">               exampleRanks) + </div><div class="line">  labs(title=<span class="string">"Programmed Cell Death"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911125331.jpeg">

</div>
<p>还可以在一张图中绘制出前10个富集通路，以及后10个富集通路，一共20个，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">topPathwaysUp &lt;- fgseaRes[ES &gt; 0][head(order(pval), n=10), pathway]</div><div class="line">topPathwaysDown &lt;- fgseaRes[ES &lt; 0][head(order(pval), n=10), pathway]</div><div class="line">topPathways &lt;- c(topPathwaysUp, rev(topPathwaysDown))</div><div class="line">plotGseaTable(examplePathways[topPathways], exampleRanks, fgseaRes, </div><div class="line">              gseaParam = 0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911122626.jpeg">

</div>
<h3 id="reactome">Reactome</h3>
<p>也可以使用<a href="https://reactome.org/" target="_blank" rel="external">Reactome</a>通路来进行GSEA分析，此时需要安装<code>reactome.db</code>包，这个包很大，600多M，下载的时间很长，安装过程如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BiocManager::install("reactome.db")</span></div><div class="line"><span class="keyword">library</span>(reactome.db)</div><div class="line"></div><div class="line">my_pathways &lt;- reactomePathways(names(exampleRanks))</div><div class="line"> </div><div class="line"><span class="comment"># Reactome pathways have a median of 11 genes</span></div><div class="line">summary(sapply(my_pathways, length))</div><div class="line">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </div><div class="line">    <span class="number">1.0</span>     <span class="number">4.0</span>    <span class="number">11.0</span>    <span class="number">30.3</span>    <span class="number">30.0</span>  <span class="number">1140.0</span></div><div class="line"> </div><div class="line">fgsea_reactome &lt;- fgsea(pathways = my_pathways, </div><div class="line">                        stats = exampleRanks,</div><div class="line">                        minSize=<span class="number">15</span>,</div><div class="line">                        maxSize=<span class="number">500</span>,</div><div class="line">                        nperm=<span class="number">100000</span>)</div><div class="line"> </div><div class="line">head(fgsea_reactome[order(pval), ])</div><div class="line">sum(fgsea_reactome[, padj &lt; <span class="number">0.01</span>])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&gt; head(fgsea_reactome[order(pval), ])</div><div class="line">                    pathway         pval         padj</div><div class="line"><span class="number">1</span>:               Cell Cycle <span class="number">1.212856e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">2</span>:      Cell Cycle, Mitotic <span class="number">1.236552e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">3</span>: Neutrophil degranulation <span class="number">1.274974e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">4</span>: Signaling by Rho GTPases <span class="number">1.291339e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">5</span>:                  M Phase <span class="number">1.303509e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">6</span>:   Cell Cycle Checkpoints <span class="number">1.350749e-05</span> <span class="number">0.0002571089</span></div><div class="line">          ES      NES nMoreExtreme size</div><div class="line"><span class="number">1</span>: <span class="number">0.5324037</span> <span class="number">2.674889</span>            <span class="number">0</span>  <span class="number">414</span></div><div class="line"><span class="number">2</span>: <span class="number">0.5475346</span> <span class="number">2.719737</span>            <span class="number">0</span>  <span class="number">363</span></div><div class="line"><span class="number">3</span>: <span class="number">0.4258088</span> <span class="number">2.074081</span>            <span class="number">0</span>  <span class="number">296</span></div><div class="line"><span class="number">4</span>: <span class="number">0.4073481</span> <span class="number">1.966039</span>            <span class="number">0</span>  <span class="number">271</span></div><div class="line"><span class="number">5</span>: <span class="number">0.5022189</span> <span class="number">2.408762</span>            <span class="number">0</span>  <span class="number">255</span></div><div class="line"><span class="number">6</span>: <span class="number">0.6085986</span> <span class="number">2.836881</span>            <span class="number">0</span>  <span class="number">200</span></div><div class="line">                                  leadingEdge</div><div class="line"><span class="number">1</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line"><span class="number">2</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line"><span class="number">3</span>:    <span class="number">11676</span>,<span class="number">14190</span>,<span class="number">53381</span>,<span class="number">12306</span>,<span class="number">20430</span>,<span class="number">12505</span>,<span class="keyword">...</span></div><div class="line"><span class="number">4</span>: <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">20430</span>,<span class="number">104215</span>,<span class="number">233406</span>,<span class="number">107995</span>,<span class="keyword">...</span></div><div class="line"><span class="number">5</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="number">52276</span>,<span class="keyword">...</span></div><div class="line"><span class="number">6</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="number">12428</span>,<span class="keyword">...</span></div><div class="line">&gt; sum(fgsea_reactome[, padj &lt; <span class="number">0.01</span>])</div><div class="line">[<span class="number">1</span>] <span class="number">103</span></div></pre></td></tr></table></figure>
<h3 id="leading-edge">Leading edge</h3>
<p>在GSEA分析中，我们通常会提取那些构成高得分的核心基因。我们对高得分的核心基因的定义就是，基因集<code>S</code>中位于排序基因列表<code>L</code>位置中的得分最大处之前或之后的那些基因集（也就是GSEA结果中绿色曲线最高点的前面或后面）。</p>
<p>前面我们注意到，GSEA分析的结果中有1列被命名为<code>leadingEdge</code>。这一列包含了高得分的基因。我们使用Reactome通路的富集结果来提取这些基因，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># the most significant pathway</span></div><div class="line">fgsea_reactome[order(pval),][<span class="number">1</span>,]</div><div class="line"></div><div class="line"><span class="comment"># list of Entrez gene IDs that contributed to the enrichment score</span></div><div class="line">fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge</div><div class="line"></div><div class="line"><span class="comment"># how many genes are in the leading edge?</span></div><div class="line">length(fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge[[<span class="number">1</span>]])</div><div class="line"></div><div class="line"><span class="comment"># how many genes are in the Cell Cycle pathway?</span></div><div class="line">length(my_pathways[[<span class="string">'Cell Cycle'</span>]])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment"># the most significant pathway</span></div><div class="line">&gt; fgsea_reactome[order(pval),][<span class="number">1</span>,]</div><div class="line">      pathway         pval         padj        ES</div><div class="line"><span class="number">1</span>: Cell Cycle <span class="number">1.212856e-05</span> <span class="number">0.0002571089</span> <span class="number">0.5324037</span></div><div class="line">        NES nMoreExtreme size</div><div class="line"><span class="number">1</span>: <span class="number">2.674889</span>            <span class="number">0</span>  <span class="number">414</span></div><div class="line">                                leadingEdge</div><div class="line"><span class="number">1</span>: <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># list of Entrez gene IDs that contributed to the enrichment score</span></div><div class="line">&gt; fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge</div><div class="line">[[<span class="number">1</span>]]</div><div class="line">  [<span class="number">1</span>] <span class="string">"66336"</span>  <span class="string">"66977"</span>  <span class="string">"15366"</span>  <span class="string">"12442"</span>  <span class="string">"107995"</span></div><div class="line">  [<span class="number">6</span>] <span class="string">"66442"</span>  <span class="string">"12571"</span>  <span class="string">"12428"</span>  <span class="string">"52276"</span>  <span class="string">"54392"</span> </div><div class="line"> [<span class="number">11</span>] <span class="string">"66311"</span>  <span class="string">"215387"</span> <span class="string">"67629"</span>  <span class="string">"12649"</span>  <span class="string">"72415"</span> </div><div class="line"> [<span class="number">16</span>] <span class="string">"56150"</span>  <span class="string">"57441"</span>  <span class="string">"20877"</span>  <span class="string">"67121"</span>  <span class="string">"12615"</span> </div><div class="line"> [<span class="number">21</span>] <span class="string">"11799"</span>  <span class="string">"66468"</span>  <span class="string">"67849"</span>  <span class="string">"19053"</span>  <span class="string">"73804"</span> </div><div class="line"> [<span class="number">26</span>] <span class="string">"76044"</span>  <span class="string">"20878"</span>  <span class="string">"15270"</span>  <span class="string">"13555"</span>  <span class="string">"60411"</span> </div><div class="line"> [<span class="number">31</span>] <span class="string">"12580"</span>  <span class="string">"17219"</span>  <span class="string">"69270"</span>  <span class="string">"12575"</span>  <span class="string">"69263"</span> </div><div class="line"> [<span class="number">36</span>] <span class="string">"12448"</span>  <span class="string">"14211"</span>  <span class="string">"20873"</span>  <span class="string">"18005"</span>  <span class="string">"72119"</span> </div><div class="line"> [<span class="number">41</span>] <span class="string">"71988"</span>  <span class="string">"12189"</span>  <span class="string">"17215"</span>  <span class="string">"12534"</span>  <span class="string">"66156"</span> </div><div class="line"> [<span class="number">46</span>] <span class="string">"208628"</span> <span class="string">"237911"</span> <span class="string">"22390"</span>  <span class="string">"68240"</span>  <span class="string">"228421"</span></div><div class="line"> [<span class="number">51</span>] <span class="string">"68014"</span>  <span class="string">"269582"</span> <span class="string">"19348"</span>  <span class="string">"12236"</span>  <span class="string">"72151"</span> </div><div class="line"> [<span class="number">56</span>] <span class="string">"18817"</span>  <span class="string">"21781"</span>  <span class="string">"18968"</span>  <span class="string">"217653"</span> <span class="string">"66934"</span> </div><div class="line"> [<span class="number">61</span>] <span class="string">"272551"</span> <span class="string">"227613"</span> <span class="string">"67141"</span>  <span class="string">"67951"</span>  <span class="string">"68612"</span> </div><div class="line"> [<span class="number">66</span>] <span class="string">"68298"</span>  <span class="string">"108000"</span> <span class="string">"23834"</span>  <span class="string">"106344"</span> <span class="string">"56452"</span> </div><div class="line"> [<span class="number">71</span>] <span class="string">"242705"</span> <span class="string">"18141"</span>  <span class="string">"223921"</span> <span class="string">"26886"</span>  <span class="string">"13557"</span> </div><div class="line"> [<span class="number">76</span>] <span class="string">"26909"</span>  <span class="string">"72787"</span>  <span class="string">"268697"</span> <span class="string">"72155"</span>  <span class="string">"56371"</span> </div><div class="line"> [<span class="number">81</span>] <span class="string">"17535"</span>  <span class="string">"107823"</span> <span class="string">"12531"</span>  <span class="string">"327762"</span> <span class="string">"12567"</span> </div><div class="line"> [<span class="number">86</span>] <span class="string">"229841"</span> <span class="string">"67052"</span>  <span class="string">"16319"</span>  <span class="string">"66634"</span>  <span class="string">"171567"</span></div><div class="line"> [<span class="number">91</span>] <span class="string">"26931"</span>  <span class="string">"67203"</span>  <span class="string">"12235"</span>  <span class="string">"19891"</span>  <span class="string">"74470"</span> </div><div class="line"> [<span class="number">96</span>] <span class="string">"72083"</span>  <span class="string">"381318"</span> <span class="string">"66570"</span>  <span class="string">"17216"</span>  <span class="string">"76308"</span> </div><div class="line">[<span class="number">101</span>] <span class="string">"19687"</span>  <span class="string">"17218"</span>  <span class="string">"102920"</span> <span class="string">"29870"</span>  <span class="string">"18973"</span> </div><div class="line">[<span class="number">106</span>] <span class="string">"16881"</span>  <span class="string">"17463"</span>  <span class="string">"75786"</span>  <span class="string">"19645"</span>  <span class="string">"19075"</span> </div><div class="line">[<span class="number">111</span>] <span class="string">"26417"</span>  <span class="string">"69736"</span>  <span class="string">"19357"</span>  <span class="string">"76816"</span>  <span class="string">"70385"</span> </div><div class="line">[<span class="number">116</span>] <span class="string">"70645"</span>  <span class="string">"22628"</span>  <span class="string">"225182"</span> <span class="string">"22627"</span>  <span class="string">"52683"</span> </div><div class="line">[<span class="number">121</span>] <span class="string">"19076"</span>  <span class="string">"18972"</span>  <span class="string">"231863"</span> <span class="string">"26932"</span>  <span class="string">"12544"</span> </div><div class="line">[<span class="number">126</span>] <span class="string">"17997"</span>  <span class="string">"51788"</span>  <span class="string">"26440"</span>  <span class="string">"68549"</span>  <span class="string">"12445"</span> </div><div class="line">[<span class="number">131</span>] <span class="string">"19088"</span>  <span class="string">"269113"</span> <span class="string">"26444"</span>  <span class="string">"19324"</span>  <span class="string">"103733"</span></div><div class="line">[<span class="number">136</span>] <span class="string">"59001"</span>  <span class="string">"107976"</span> <span class="string">"19179"</span>  <span class="string">"12579"</span>  <span class="string">"232987"</span></div><div class="line">[<span class="number">141</span>] <span class="string">"17420"</span>  <span class="string">"228769"</span> <span class="string">"219072"</span> <span class="string">"26445"</span>  <span class="string">"105988"</span></div><div class="line">[<span class="number">146</span>] <span class="string">"69745"</span>  <span class="string">"18538"</span>  <span class="string">"69928"</span>  <span class="string">"11651"</span>  <span class="string">"235559"</span></div><div class="line">[<span class="number">151</span>] <span class="string">"68097"</span>  <span class="string">"57296"</span>  <span class="string">"63955"</span>  <span class="string">"14235"</span>  <span class="string">"19170"</span> </div><div class="line">[<span class="number">156</span>] <span class="string">"17246"</span>  <span class="string">"17220"</span>  <span class="string">"12144"</span>  <span class="string">"50793"</span>  <span class="string">"77605"</span> </div><div class="line">[<span class="number">161</span>] <span class="string">"18392"</span>  <span class="string">"236930"</span> <span class="string">"67151"</span>  <span class="string">"70024"</span>  <span class="string">"59126"</span> </div><div class="line">[<span class="number">166</span>] <span class="string">"66296"</span>  <span class="string">"16906"</span>  <span class="string">"109145"</span> <span class="string">"71819"</span>  <span class="string">"67733"</span> </div><div class="line">[<span class="number">171</span>] <span class="string">"50883"</span>  <span class="string">"12447"</span>  <span class="string">"12532"</span>  <span class="string">"14156"</span>  <span class="string">"26442"</span> </div><div class="line">[<span class="number">176</span>] <span class="string">"19177"</span>  <span class="string">"230376"</span> <span class="string">"245688"</span></div><div class="line"></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># how many genes are in the leading edge?</span></div><div class="line">&gt; length(fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge[[<span class="number">1</span>]])</div><div class="line">[<span class="number">1</span>] <span class="number">178</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># how many genes are in the Cell Cycle pathway?</span></div><div class="line">&gt; length(my_pathways[[<span class="string">'Cell Cycle'</span>]])</div><div class="line">[<span class="number">1</span>] <span class="number">414</span></div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>GSEA是于2005年首次提出来的，现在已经成了基因表达分析中的常规分析手段，它不同于GO分析，GO分析只关注差异基因，而GSEA分析则关注所有的基因。<code>fgsea</code>包可以使用预先排列好的基因一R中进行GSEA分析。p值的计算结果是基于置换检验(permutation test)，这种方法并不是十分精我，因为它忽略了基因之间的相关性，有可能会导致假阳性。但是，在这种方法在研究上调与上调基因方面还是很有用的。即使你计算出的GSEA结果中，p值大于0.05，但是是也可以参考leading edge基因集，为你的实验进行指导。</p>
<h2 id="案例分析">案例分析</h2>
<p>作者提供了用于生成类似于<strong>exampleRanks</strong>文件的R脚本，不过使用的GEO的数据，平时自己利用<code>fgsea</code>包进行GSEA分析时，生成就好，现在看一下如何将GEO的数据生成类似于****exampleRanks****文件的排序信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span>(<span class="string">"https://raw.githubusercontent.com/assaron/r-utils/master/R/exprs.R"</span>)</div><div class="line"><span class="keyword">library</span>(GEOquery)</div><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">gse14308 &lt;- getGEO(<span class="string">"GSE14308"</span>)[[<span class="number">1</span>]]</div><div class="line">pData(gse14308)$condition &lt;- sub(<span class="string">"-.*$"</span>, <span class="string">""</span>, gse14308$title)</div><div class="line">es &lt;- collapseBy(gse14308, fData(gse14308)$ENTREZ_GENE_ID, FUN=median)</div><div class="line">es &lt;- es[!grepl(<span class="string">"///"</span>, rownames(es)), ]</div><div class="line">es &lt;- es[rownames(es) != <span class="string">""</span>, ]</div><div class="line">exprs(es) &lt;- normalizeBetweenArrays(log2(exprs(es)+<span class="number">1</span>), method=<span class="string">"quantile"</span>)</div><div class="line">es.design &lt;- model.matrix(~<span class="number">0</span>+condition, data=pData(es))</div><div class="line">fit &lt;- lmFit(es, es.design)</div><div class="line">fit2 &lt;- contrasts.fit(fit, makeContrasts(conditionTh1-conditionNaive,</div><div class="line">                                         levels=es.design))</div><div class="line">fit2 &lt;- eBayes(fit2)</div><div class="line">de &lt;- data.table(topTable(fit2, adjust.method=<span class="string">"BH"</span>, number=<span class="number">12000</span>, sort.by = <span class="string">"B"</span>), keep.rownames = <span class="literal">T</span>)</div><div class="line">ranks &lt;- de[order(t), list(rn, t)]</div><div class="line">head(ranks)</div><div class="line">tail(ranks)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; head(ranks)</div><div class="line">       rn         t</div><div class="line"><span class="number">1</span>: <span class="number">109711</span> -<span class="number">50.99316</span></div><div class="line"><span class="number">2</span>:  <span class="number">18124</span> -<span class="number">44.40559</span></div><div class="line"><span class="number">3</span>:  <span class="number">12775</span> -<span class="number">43.22109</span></div><div class="line"><span class="number">4</span>:  <span class="number">72148</span> -<span class="number">33.74441</span></div><div class="line"><span class="number">5</span>:  <span class="number">16010</span> -<span class="number">33.34034</span></div><div class="line"><span class="number">6</span>:  <span class="number">16206</span> -<span class="number">30.67962</span></div><div class="line">&gt; tail(ranks)</div><div class="line">      rn        t</div><div class="line"><span class="number">1</span>: <span class="number">80901</span> <span class="number">47.55618</span></div><div class="line"><span class="number">2</span>: <span class="number">58801</span> <span class="number">48.53756</span></div><div class="line"><span class="number">3</span>: <span class="number">15937</span> <span class="number">49.88068</span></div><div class="line"><span class="number">4</span>: <span class="number">13730</span> <span class="number">50.17693</span></div><div class="line"><span class="number">5</span>: <span class="number">12772</span> <span class="number">50.32302</span></div><div class="line"><span class="number">6</span>: <span class="number">80876</span> <span class="number">51.72987</span></div></pre></td></tr></table></figure>
<p>现在绘制一下上述数据中6个上升与6个下降的基因热图：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(pheatmap)</div><div class="line"> </div><div class="line">my_group &lt;- data.frame(group = pData(es)$condition)</div><div class="line">row.names(my_group) &lt;- colnames(exprs(es))</div><div class="line"> </div><div class="line">pheatmap(</div><div class="line">  mat = es[c(head(de[order(t), <span class="number">1</span>])$rn, tail(de[order(t), <span class="number">1</span>])$rn),],</div><div class="line">  annotation_col = my_group,</div><div class="line">  cluster_rows = <span class="literal">FALSE</span>,</div><div class="line">  cellwidth=<span class="number">25</span>,</div><div class="line">  cellheight=<span class="number">15</span></div><div class="line">)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911133906.png">

</div>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/fgsea/inst/doc/fgsea-tutorial.html" target="_blank" rel="external">Using fgsea package</a></li>
<li><a href="https://www.r-bloggers.com/comparison-of-clusterprofiler-and-gsea-p/" target="_blank" rel="external">Comparison of clusterProfiler and GSEA-P</a></li>
<li><a href="https://davetang.org/muse/2018/01/10/using-fast-preranked-gene-set-enrichment-analysis-fgsea-package/" target="_blank" rel="external">Using the fast preranked gene set enrichment analysis (fgsea) package</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/10/DAL/DALS022_Basic_Machine_Learning01_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/DAL/DALS022_Basic_Machine_Learning01_/" itemprop="url">DALS022-机器学习01-聚类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T12:00:00+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  51
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第1小节，这一部分的主要内容涉及聚类，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/clustering_and_heatmaps.Rmd" target="_blank" rel="external">Github</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/09/DAL/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/09/DAL/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/" itemprop="url">DALS021-MDS与PCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-09T12:00:00+08:00">
                2019-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,847
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第2小节，这一部分的主要内容涉及MDS和PCA，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/highdim/mds.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="mds">MDS</h2>
<p>MDS的全称为multi-dimensional scaling，即多维数据缩放。在这 一部分中，我们会使用基因表达的数据来作为案例讲解一下。为了简化说明，我们仅考虑3个组织：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">colind &lt;- tissue%<span class="keyword">in</span>%c(<span class="string">"kidney"</span>,<span class="string">"colon"</span>,<span class="string">"liver"</span>)</div><div class="line">mat &lt;- e[,colind]</div><div class="line">group &lt;- factor(tissue[colind])</div><div class="line">dim(mat)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; dim(mat)</div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>    <span class="number">99</span></div></pre></td></tr></table></figure>
<p>现在我们要研究一下这个数据集，我们想知道，储存在<code>mat</code>列中的基因表达谱的数据在不同的组织间的相似性如何。由于数据很大，无法直接画出相应的多维点图。我们通常只能绘制出二维图形，如果我们要绘制出每两个样本之间的基因表达情况不现实。而MDS图形就是为了解决这个问题而提出来的。</p>
<h3 id="mds背后的数学原理">MDS背后的数学原理</h3>
<p>前面我们已经知道了SVD和矩阵代数，那么我们理解MDS就相对清楚了。为了说明MDS，我们先来看一下SVD分解，如下所示： <span class="math display">\[
\mathbf{Y} = \mathbf{UDV}^\top
\]</span> 我们假设 <span class="math inline">\(\mathbf{U^\top Y=DV^\top}\)</span> 的前两列的平方和剩余列的平方和。因此它们可以写为<span class="math inline">\(d_1+ d_2 \gg d_3 + \dots + d_n\)</span> 其中 <span class="math inline">\(d_i\)</span> 是<span class="math inline">\(\mathbf{D}\)</span> 是第i列（原文是i-th entry）。当出现这种情况时，我们就会得到如下公式：</p>
<p><span class="math display">\[
\mathbf{Y}\approx [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&amp;0\\
    0&amp;d_{2}\\
  \end{pmatrix}
  [\mathbf{V}_1 \mathbf{V}_2]^\top
\]</span></p>
<p>这就表明，第<span class="math inline">\(i\)</span>列近似等于： <span class="math display">\[
\mathbf{Y}_i \approx
[\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&amp;0\\
    0&amp;d_{2}\\
  \end{pmatrix}
  \begin{pmatrix}
    v_{i,1}\\
    v_{i,2}\\
     \end{pmatrix}
    =
    [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}
\]</span> 如果我们们定义下面的二维向量：</p>
<p><span class="math display">\[
\mathbf{Z}_i=\begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}
\]</span></p>
<p>那么： <span class="math display">\[
\begin{align*}
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) &amp;\approx \left\{ [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \right\}^\top \left\{[\mathbf{U}_1 \mathbf{U}_2]  (\mathbf{Z}_i-\mathbf{Z}_j)\right\}\\
&amp;= (\mathbf{Z}_i-\mathbf{Z}_j)^\top [\mathbf{U}_1 \mathbf{U}_2]^\top [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \\
&amp;=(\mathbf{Z}_i-\mathbf{Z}_j)^\top(\mathbf{Z}_i-\mathbf{Z}_j)\\
&amp;=(Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\end{align*}
\]</span> 上面的这个推导告诉我们，在样本<span class="math inline">\(i\)</span>和样本<span class="math inline">\(j\)</span>之最的距离近拟等于下面二维数据点的距离：</p>
<p><span class="math display">\[
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) \approx
 (Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\]</span></p>
<p>因为<span class="math inline">\(Z\)</span>是一个二维向量，因此我们可以通过绘制<span class="math inline">\(\mathbf{Z_{1}}\)</span>和<span class="math inline">\(\mathbf{Z_{2}}\)</span>来发展示这两个样本的距离。现在我们绘制出它们的距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(mat-rowMeans(mat))</div><div class="line">PC1 &lt;- s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 &lt;- s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC1,PC2,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090640.jpeg">

</div>
<p>从图片上我们可以看出，数据点按照相应的组织区分开来了。上面的这种分开的精确近似取决于前两个主成分解释变异的程度。像上面那样所示，我们可以绘制出每个主成分可以解释的变异程度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090819.jpeg">

</div>
<p>虽然前两个主成分解释了超过50%的变异，不过前面的图形还是没有展示出大量的信息。但是这种图已经足够用于进行可视化大量的数据了。此外，我们还可以注意到，我们能够绘制其它的主成分来研究这些数据点，例如我们绘制第3个和第4个主成分：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PC3 &lt;- s$d[<span class="number">3</span>]*s$v[,<span class="number">3</span>]</div><div class="line">PC4 &lt;- s$d[<span class="number">4</span>]*s$v[,<span class="number">4</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC3,PC4,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091057.jpeg">

</div>
<p>从上面图形中我们可以看到，第4个主成分能够将肾脏组织的样本强烈分开。在后面的部分中，我们会讲到批次效应(batch effects)会解释这种情况。</p>
<h3 id="cmdscale函数"><code>cmdscale()</code>函数</h3>
<p>我们在上面使用了<code>svd()</code>函数来进行计算，不过R中有一个专门的函数用于计算MDS，生成MDS图。这个函数就是<code>cmdscale()</code>函数，这个函数将距离对象作为参数，然后使用主成分分析来对这些距离进行近似计算。这个函数比使用<code>svd()</code>函数更高效（因为不可能实现完全的<code>svd()</code>函数计算，那样比较花时间）。此函数默认返回二维的数据，不过我们通过设定参数<code>k</code>（默认情况下，<code>k=2</code>）可以改变结果中的维度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(mat))</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar()</div><div class="line">plot(mds[,<span class="number">1</span>],mds[,<span class="number">2</span>],bg=as.numeric(group),pch=<span class="number">21</span>,</div><div class="line">xlab=<span class="string">"First dimension"</span>,ylab=<span class="string">"Second dimension"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091915.jpeg">

</div>
<p>再看另外一个：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">2</span>)&#123;</div><div class="line">plot(mds[,i],s$d[i]*s$v[,i],main=paste(<span class="string">"PC"</span>,i))</div><div class="line">b = ifelse( cor(mds[,i],s$v[,i]) &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</div><div class="line">abline(<span class="number">0</span>,b) <span class="comment">##b is 1 or -1 depending on the arbitrary sign "flip"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911092010.jpeg">

</div>
<h3 id="任意符号">任意符号</h3>
<p>SVD并非是唯一的，只要我们用<code>-1</code>乘以<span class="math inline">\(\mathbf{U}\)</span>的样本列，我们就能使用<code>-1</code>乘以<span class="math inline">\(\mathbf{V}\)</span>的任意列，通过下面的转换我们就能看出来（这一段不懂）： <span class="math display">\[
\mathbf{-1UD(-1)V}^\top = \mathbf{UDV}^\top
\]</span></p>
<h3 id="扣除平均值">扣除平均值</h3>
<p>在所有的计算中，当我们计算SVD时，都会扣除行(row)的均值。如果我们要试图计算两列之间的近似距离，那么在<span class="math inline">\(\mathbf{Y}_{i}\)</span>和<span class="math inline">\(\mathbf{Y}_{j}\)</span>之间的距离就与<span class="math inline">\(\mathbf{Y}_i - \mathbf{\mu}\)</span>和<span class="math inline">\(\mathbf{Y}_j - \mathbf{\mu}\)</span>之间的距离相同，因为当我们过计算时，中间的<span class="math inline">\(\mu\)</span>就会被消去： <span class="math display">\[
\left\{ ( \mathbf{Y}_i- \mathbf{\mu} ) - ( \mathbf{Y}_j - \mathbf{\mu} ) \right\}^\top \left\{ (\mathbf{Y}_i- \mathbf{\mu}) - (\mathbf{Y}_j - \mathbf{\mu} ) \right\} = \left\{  \mathbf{Y}_i-  \mathbf{Y}_j  \right\}^\top \left\{ \mathbf{Y}_i - \mathbf{Y}_j  \right\}
\]</span> 因为扣除行均值可以降低总的变异，它可以使得SVD的结果近更为逼近。</p>
<h2 id="练习">练习</h2>
<p>P357</p>
<h2 id="pca">PCA</h2>
<p>PCA的相关资料可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/PCA.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经提到了PCA，这里继续深入一步，讲一下PCA背后的数学原理。</p>
<h3 id="案例双胞胎身高">案例：双胞胎身高</h3>
<p>我们先使用模拟数据的案例展示一个旋转，这个旋转与PCA有着很大的有关系：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">Y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(Y[<span class="number">1</span>,], Y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=thelim, ylim=thelim)</div><div class="line">points(Y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], Y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911094030.jpeg">

</div>
<p>这里我们专门来解释一下什么是什么成分（principla components）。</p>
<p>我们使用 <span class="math inline">\(\mathbf{Y}\)</span> 这个 <span class="math inline">\(2 \times N\)</span> 矩阵来表示我们的数据。这个类似于我们检测了两组基因的信息，每列表示1个样本。现在我们的任何就是，找到一个 <span class="math inline">\(2 \times 1\)</span> 向量 <span class="math inline">\(\mathbf{u}_1\)</span> ，使其满足 <span class="math inline">\(\mathbf{u}_1^\top \mathbf{v}_1 = 1\)</span>，它能使 <span class="math inline">\((\mathbf{u}_1^\top\mathbf{Y})^\top (\mathbf{u}_1^\top\mathbf{Y})\)</span> 最大。这个过程可以被视为每个样本，或<span class="math inline">\(\mathbf{Y}\)</span>向子空间 <span class="math inline">\(\mathbf{u}_1\)</span> 的投影。因此，我们需要将坐标系进行置换，使新的坐标系能够显示出最大变异。</p>
<p>我先试一下 <span class="math inline">\(\mathbf{u}=(1,0)^\top\)</span>。这个投影公仅能够给出双胞胎1的身高（橘黄色）。图片标题中显示的是平方和。</p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1, fig.align</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(t(Y), xlim=thelim, ylim=thelim,</div><div class="line">     main=paste(&quot;Sum of squares :&quot;,round(crossprod(Y[1,]),1)))</div><div class="line">abline(h=0)</div><div class="line">apply(Y,2,function(y) segments(y[1],0,y[1],y[2],lty=2))</div><div class="line">points(Y[1,],rep(0,ncol(Y)),col=2,pch=16,cex=0.75)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911160126.jpeg">

</div>
<p>我们能否找到一个方向，使得坐标系旋转后，能够表示更高的变异？例如</p>
<p><span class="math inline">\(\mathbf{u} =\begin{pmatrix}1\\-1\end{pmatrix}\)</span> 这个怎么样？它不满足 <span class="math inline">\(\mathbf{u}^\top\mathbf{u}= 1\)</span> ，因此我们可以使用另外一个向量，即 <span class="math inline">\(\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\-1/\sqrt{2}\end{pmatrix}\)</span></p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1_either, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">u &lt;- matrix(c(1,-1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar(1,1)</div><div class="line">plot(t(Y),</div><div class="line">     main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),xlim=thelim,ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,-1,col=2)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i],Z[2,i],Y[1,i],Y[2,i],lty=2)</div><div class="line">points(t(Z), col=2, pch=16, cex=0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161254.jpeg">

</div>
<p>这个图形与双胞胎的差异有关，我们知道这个差异很少的。通常平方和我们可以确实这一点，最后我们试一下这个向量：</p>
<p><span class="math display">\[
\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\1/\sqrt{2}\end{pmatrix}
\]</span></p>
<figure class="highlight plain"><figcaption><span>PC1, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">u &lt;- matrix(c(1,1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar()</div><div class="line">plot(t(Y), main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),</div><div class="line">     xlim=thelim, ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,1,col=2)</div><div class="line">points(u%*%w, col=2, pch=16, cex=1)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i], Z[2,i], Y[1,i], Y[2,i], lty=2)</div><div class="line">points(t(Z),col=2,pch=16,cex=0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161447.jpeg">

</div>
<p>这个图形与重新缩放(re-scaled)后的平均高度有关，它有着最大的平方和。这是一个数学计算程序，它能够计算出一个 <span class="math inline">\(\mathbf{v}\)</span> ，能够使平方和最大，SVD就是这样的一个程序。</p>
<h4 id="主成分">主成分</h4>
<p>正交向量能够使平方和最大：</p>
<p><span class="math display">\[
(\mathbf{u}_1^\top\mathbf{Y})^\top(\mathbf{u}_1^\top\mathbf{Y})
\]</span></p>
<p><span class="math inline">\(\mathbf{u}_1^\top\mathbf{Y}\)</span> 指的就是第1PC。e用于获得PC的加权(weights) <span class="math inline">\(\mathbf{u}\)</span> 指的就是因子载荷(loadings)。使用旋转这种操作，它指的就是第1PC的旋转方向。</p>
<p>为了获得第2PC，我们可以重复上述操作，但是残差如下：</p>
<p><span class="math display">\[\mathbf{r} = \mathbf{Y} - \mathbf{u}_1^\top \mathbf{Yv}_1 \]</span></p>
<p>第2PC的向量含有以下性质：</p>
<p><span class="math display">\[ \mathbf{v}_2^\top \mathbf{v}_1=0\]</span></p>
<p>它能使 <span class="math inline">\((\mathbf{rv}_2)^\top \mathbf{rv}_2\)</span>最大，</p>
<p>当 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(N \times m\)</span> 时，我们可以重复地找到第3，第4，第5，等主成分。</p>
<h4 id="prcomp"><code>prcomp</code></h4>
<p>我们已经介绍了如何使用SVD来计算PC。介理，R中有一个专门的函数可以用于找到主成分，即<code>prcomp()</code>，在这个案例中，数据默认中心化的，这个函数的使用如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc &lt;- prcomp( t(Y) )</div></pre></td></tr></table></figure>
<p>计算出的结果与SVD相同，直到符号翻转（produces the same results as the SVD up to arbitrary sign flips，实在没理解这句话什么意思）</p>
<figure class="highlight plain"><figcaption><span>pca_svd, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd( Y - rowMeans(Y) )</div><div class="line">mypar(1,2)</div><div class="line">for(i in 1:nrow(Y) )&#123;</div><div class="line">  plot(pc$x[,i], s$d[i]*s$v[,i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911165120.jpeg">

</div>
<p>因子载荷可以通过下面方式计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$rotation</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pc$rotation</div><div class="line">           PC1        PC2</div><div class="line">[<span class="number">1</span>,] <span class="number">0.7072304</span>  <span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.7069831</span> -<span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>它就相当于 (up to a sign flip？这个不懂) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s$u</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; s$u</div><div class="line">           [,<span class="number">1</span>]       [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.7072304</span> -<span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">0.7069831</span>  <span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>解释的方差等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$sdev</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; pc$sdev</div><div class="line">[<span class="number">1</span>] <span class="number">1.2542672</span> <span class="number">0.2141882</span></div></pre></td></tr></table></figure>
<p>现在我们将<code>Y</code>转置一下，因为<code>prcomp()</code>函数与我们平时所用的高通量数据储存有点不太一样，平时我们的数据是列为样本，行为特征值，而<code>prcomp()</code>函数则是正好相反，它处理的数据列是特征值，行是样本名。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/08/DAL/DALS020_Distance_and_Dimension_Reduction1_SVD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/08/DAL/DALS020_Distance_and_Dimension_Reduction1_SVD/" itemprop="url">DALS020-距离与降维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-08T12:00:00+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,505
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第1小节，这一部分的主要内容涉及降维分析的一些原理，例如SVD，投影，旋转等，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/distance.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>距离(distance)的概念非常直接，例如，当我们把动物聚为亚群时，我们其实就是隐含地定义了一个距离，从而使我们可以说亚群内的动物彼此“接近”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909115530.png">

</div>
<p>我们使用的分析高通量数据的方法地都直接或间接地与距离有关。许多聚类方法和机器学习方法都需要使用特征值或预测因子来定义距离。例如热图是基因组学与高通量数据领域里使用最为广泛的工具，如果我们要生成热图，就需要明确计算距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130059.png">

</div>
<p>在上面的热图中，每个方格代表的数值储存在一个矩阵里，每具方格的行与列被聚类后（注：热图常用红色与绿色表示，但是对色盲人士来说，这两种颜色是最难分辨的颜色）用不同的颜色表示。在这一部分中，我们将学习必要的数学知识与计算技能来了解和创建热图。我们先来回顾一下数学上对距离的定义。</p>
<h2 id="欧氏距离euclidean-distance">欧氏距离(Euclidean Distance)</h2>
<p>现在我们在一个笛卡尔坐标系(Cartesian plane)中定义A点与B点的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>),pch=<span class="number">16</span>,cex=<span class="number">2</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,bty=<span class="string">"n"</span>,xlim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>),ylim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>))</div><div class="line">lines(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</div><div class="line">text(<span class="number">0</span>,<span class="number">.2</span>,expression(paste(<span class="string">'(A'</span>[x]*<span class="string">',A'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(<span class="number">1</span>,<span class="number">1.2</span>,expression(paste(<span class="string">'(B'</span>[x]*<span class="string">',B'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(-<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">"A"</span>,cex=<span class="number">2</span>)</div><div class="line">text(<span class="number">1.1</span>,<span class="number">1</span>,<span class="string">"B"</span>,cex=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130731.jpeg">

</div>
<p>其中，欧氏距离的定义如下所示： <span class="math display">\[
\sqrt{ (A_x-B_x)^2 + (A_y-B_y)^2}
\]</span></p>
<h2 id="高维数据的距离">高维数据的距离</h2>
<p>现在我们使用一个数据集，这个数据集中含有189个样本，22215个基因，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(devtools)</div><div class="line"><span class="comment"># install_github("genomicsclass/tissuesGeneExpression")</span></div><div class="line"></div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div></pre></td></tr></table></figure>
<p>这些数据代表了8个组织（每个组织中有多个样本）的RNA表达水平，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>   <span class="number">189</span></div><div class="line">&gt; table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们现在描述一下在这个数据集中，不同样本之间的距离。我们也许对在不同样本中表达相似的基因感兴趣。</p>
<p>为了定义这个距离，我们需要知道这些点是什么，因为我们计算数学上的距离需要这些点。由于这个数据集是高维数据集，这些点就无法直接放在笛卡尔坐标系中。相反，我们会把这个数据集放在更高维度的坐标系中。例如样本<span class="math inline">\(i\)</span>是由22215维空间的一个点定义的（这个空间可以写为<span class="math inline">\((Y_{1,i},\dots,Y_{22215,i})^\top\)</span>）。特征值<span class="math inline">\(g\)</span>是由一个189维空间的一个点定义的（这个空间可以写为<span class="math inline">\((Y_{g,1},\dots,Y_{g,189})^\top\)</span>）。</p>
<p>一旦我们定义好了这些点，那么欧氏距离就可以使用我们前面类似的方法进行计算，例如，两个样本<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>的距离为： <span class="math display">\[
\mbox{dist}(i,j) = \sqrt{ \sum_{g=1}^{22215} (Y_{g,i}-Y_{g,j })^2 }
\]</span> 两个特征值<span class="math inline">\(h\)</span>和<span class="math inline">\(g\)</span>的距离为： <span class="math display">\[
\mbox{dist}(h,g) = \sqrt{ \sum_{i=1}^{189} (Y_{h,i}-Y_{g,i})^2 }
\]</span></p>
<h3 id="矩阵代数与距离">矩阵代数与距离</h3>
<p>样本<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之间的距离可以写为： <span class="math display">\[
\mbox{dist}(i,j) = (\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j)
\]</span> 其中，<span class="math inline">\(\mbox{Y}_{i}\)</span>和<span class="math inline">\(\mbox{Y}_{j}\)</span>代表第<span class="math inline">\(i\)</span>列和第<span class="math inline">\(j\)</span>列。这种写法在实际计算中非常方便。</p>
<h3 id="案例">案例</h3>
<p>现在我们使用上面的矩阵代数来计算一下距离。现在我们计算样本1与样本2（它们都是肾脏组织）的距离，然后再过计算样本87的距离（结肠），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x &lt;- e[,<span class="number">1</span>]</div><div class="line">y &lt;- e[,<span class="number">2</span>]</div><div class="line">z &lt;- e[,<span class="number">87</span>]</div><div class="line">sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，肾脏组织之间距离比较近。另外一种计算距离更快的方式就是使用矩阵代数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqrt( crossprod(x-y) )</div><div class="line">sqrt( crossprod(x-z) )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt( crossprod(x-y) )</div><div class="line">        [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">85.8546</span></div><div class="line">&gt; sqrt( crossprod(x-z) )</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>现在我们一次计算出所有的距离，我们可以使用<code>dist()</code>函数，这个函数可以计算出每行之间的距离，现在我们感兴趣的是不同样本之间的相似性，因此我们需要使用<code>t()</code>来转换一下矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(e))</div><div class="line">class(d)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- dist(t(e))</div><div class="line">&gt; class(d)</div><div class="line">[<span class="number">1</span>] <span class="string">"dist"</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，计算结果<code>d</code>是一个<code>dist</code>类，为了得到它的具体数值，我们需要将其强行转换为矩阵，并使用索引操作，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>这里我们需要注意的是，我们对数据集<code>e</code>使用了函数<code>dist()</code>，这个函数计算的是基因之间所有两两矩离，它最终会形成一个<span class="math inline">\(22215\times 22215\)</span>的矩阵。</p>
<h2 id="练习">练习</h2>
<p>P322</p>
<h2 id="降维操作">降维操作</h2>
<p>相应的Rmarkdown见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/pca_motivation.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>可视化数据是分析高通量数据中最重要的步骤之一。正确的可视化方法可能会发现实验数据的问题，这些数据可以呈现标准分析的结果。我们已经展示了可视化数据的全局方法，但是由于数据的高维特性，使得发现列之间或行之间关系的图形变得复杂。例如，如果要比较189个样本之间的特性，我们必不得不创建17766个MA图。创建一个单独的散点图明显不合适，因为数据量太大。</p>
<p>我们将介绍其于降维的探索性数据分析的强大技巧。一般的想法就是将数据集降至较低维度的同时又保留重要的特性，例如样本之间的距离。如果我们能够将数据降低到2维，那么我们就能很容易地画出图形。降维的背后就是奇异值分解(Singular value decomposition, SVD)，这种思路也可以应用于其他情况。在介绍SVD背后的复杂数学原理之前，我们将会使用一个简单的案例来介绍一下它的思路。</p>
<h3 id="案例将2维数据降低至1维">案例：将2维数据降低至1维</h3>
<p>现在我们来看一个案例，这个案例是有关双胞胎身高的。我们来模拟生成100个二维数据点，它们表示每个人与其均值的偏离的标准差的数目，每对数据点表示一对又胞胎，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">plot(y[<span class="number">1</span>,], y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=c(-<span class="number">3</span>,<span class="number">3</span>), ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909151311.jpeg">

</div>
<p>为了辅助说明问题，我们可以将上面的模拟数据视为高通量基因表达数据，其中双胞胎的配对数据表示了N个样本，双胞胎的2个身高表示基因表达数据。我们是对任意2个之间的距离感兴趣。我们可以使用<code>dist()</code>函数来进行计算。例如，上图的2个橙色数据点的距离为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d=dist(t(y))</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d=dist(t(y))</div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">1.140897</span></div></pre></td></tr></table></figure>
<p>如果两维数据太复杂（这里只是假设），我们只想制备一维图，那怎么办呢？例如，我们能否将这些数据减化为一维矩阵，同时保留这些点与点之间的距离信息呢？</p>
<p>如果我们回顾再来看这张图，在任何一对数据点之间画一条线，那么这条线的长度就是这两点这之间的距离。这些线倾向于沿着对角线的方向分布。我们以前到过MA图，这种图就是将原始散点图的对角线“旋转”了一下，将原来的对角线旋转到与x轴平行的位置形成的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">z1 = (y[<span class="number">1</span>,]+y[<span class="number">2</span>,])/<span class="number">2</span> <span class="comment">#the sum</span></div><div class="line">z2 = (y[<span class="number">1</span>,]-y[<span class="number">2</span>,]) <span class="comment">#the difference</span></div><div class="line">z = rbind( z1, z2) <span class="comment">#matrix now same dimensions as y</span></div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized \</span></div><div class="line"><span class="string">height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece \</span></div><div class="line"><span class="string">in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909153046.jpeg">

</div>
<p>上图的左图就是原始的散点图，右图则是MA图。</p>
<p>在后面章节中，我们将会使用线性代数来表示这些数据的变换（也就是旋转）。这里我们可以通过将<code>y</code>的相乘来得到<code>z</code>，如下所示： <span class="math display">\[
A = \,
\begin{pmatrix}
1/2&amp;1/2\\
1&amp;-1\\
\end{pmatrix}
\implies 
z = A y
\]</span> 我们将两侧都乘以<span class="math inline">\(A^{-1}\)</span>，则得到z，如下所示： <span class="math display">\[
A^{-1} = \,
\begin{pmatrix}
1&amp;1/2\\
1&amp;-1/2\\
\end{pmatrix}
\implies 
y = A^{-1} z
\]</span></p>
<h3 id="旋转">旋转</h3>
<p>在上图相，相对于其它点之间的距离，两个橙色上炽之间的距离大致保持一致。所以的点其实都是如此。对上面转换进行简单的重新缩放，将会使前后的距离完全相同。我们要做的就是乘以一个标量，从而保留每个数据点的标准差。如果你认为<code>y</code>的列是一个独立随机变量，其标准差为<span class="math inline">\(\sigma\)</span>，那么我们要注意到<span class="math inline">\(M\)</span>与<span class="math inline">\(A\)</span>的标准差如下所示： <span class="math display">\[
\mbox{sd}[ Z_1 ] = \mbox{sd}[ (Y_1 + Y_2) / 2 ] = \frac{1}{\sqrt{2}} \sigma \mbox{ and } \mbox{sd}[ Z_2] = \mbox{sd}[ Y_1 - Y_2  ] = {\sqrt{2}} \sigma
\]</span> 这就说明，如果我们将上面的转换变为如下形式： <span class="math display">\[
A = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1&amp;1\\
1&amp;-1\\
\end{pmatrix}
\]</span> 那么<span class="math inline">\(Y\)</span>列的SD就会变得与<span class="math inline">\(Z\)</span>列的方差一样。此外，我们要注意到，<span class="math inline">\(A^{-1}A=I\)</span>。我们称这种特性为<code>正交</code>(orthogonal)，并且它保留了上述SD的特性。因此就保留了距离信息：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">A &lt;- <span class="number">1</span>/sqrt(<span class="number">2</span>)*matrix(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z &lt;- A%*%y</div><div class="line">d &lt;- dist(t(y))</div><div class="line">d2 &lt;- dist(t(z))</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d2)) <span class="comment">#as.numeric turns distnaces into long vector</span></div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154417.jpeg">

</div>
<p>我们称这种转换为<code>y</code>的旋转：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154529.jpeg">

</div>
<p>我们之所以优先使用这种转换，是因为我们注意到所有的点是沿着对角线进行分布的，我们将对角线进行转换后，对角线与x轴平行。所以这个旋转实际上就达到了我们最初的要求：我们只需要一个维度就可以保留点与点之间的距离。现在让我们删除了第二个维度<code>z</code>，并重新计算一下距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3 = dist(z[<span class="number">1</span>,]) <span class="comment">##distance computed using just first dimension</span></div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d3))</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909155706.jpeg">

</div>
<p>仅用一维数据进行的距离计算就很接近实际距离，并且降低了维度，将2维降低到了1维。转换后的数据的第1约就是第一主成分。这一思想促进了使用主成分分析(PCA)和奇异值分解(SVD)来实现更广泛的降维。</p>
<h3 id="关于与其他解释区别的重要说明">关于与其他解释区别的重要说明</h3>
<p>如果你在网上搜索PCA的描述，你会注意到网上的描述与我们这里描述在符号上有些出入。这主要是因为在PCA中，通常使用行来表示实验单元（就是样本）。因此，在我们这里的实验中，<span class="math inline">\(Y\)</span>通常会被转换为<span class="math inline">\(N \times 2\)</span>矩阵。在统计学中，这也是最为普遍的表示数据的方式：每行表示一个样本。然而，由于实际原因，在遗传学中，通常使用列表示样本。例如行表示基因，列表示样本。由于这个原因，在这本书中，我们会解释PCA和与之相应的数学计算会与常规的方式有所不同。因此，在网上找到的相关的许多PCA的解释都是先从样本的协方差矩阵开始的，它通常使用<span class="math inline">\(\mathbf{X}^\top\mathbf{X}\)</span>表示，并且每个单元格表示两个实验单元之间的协方差。然而，要做到这一点，我们需要使用<span class="math inline">\(\mbox{X}\)</span>的行表示实验单元。因此，在我们上面的符号中，在经过缩放后，你必须要使用<span class="math inline">\(\mathbf{Y}\mathbf{Y}^\top\)</span>来进行计算。总之，如果你想让我们的解释与其他有关的PCA内容相符，就必须对这本书中使用的矩阵进行转置。</p>
<h2 id="奇异值分解">奇异值分解</h2>
<p>相关的Rmarkdown参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/svd.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在前面的部分中，我们展示了降维分析，以及如何让我们使用一维数据来替代原来的二维数据，近似地表示点与点之间的距离。奇异值分解(SVD)是我们这种方法的推广。在这个案例中，SVD对原始数据进行了转换。这种转换具有一些非常有用的属性。</p>
<p>SVD计算的主要结果就是，我们可以写为一个<span class="math inline">\(m\times n\)</span>矩阵，对于矩阵<span class="math inline">\(\mbox{Y}\)</span>就写为：</p>
<p><span class="math display">\[
\mathbf{U}^\top\mathbf{Y} = \mathbf{DV}^\top
\]</span> 其中， * <span class="math inline">\(\mathbf{U}\)</span> 是一个 <span class="math inline">\(m \times p\)</span> 正交矩阵； * <span class="math inline">\(\mathbf{V}\)</span> 是一个 <span class="math inline">\(p \times p\)</span> 正交矩阵； * <span class="math inline">\(\mathbf{D}\)</span> 是一个 <span class="math inline">\(n \times p\)</span> 对角矩阵。</p>
<p>其中，<span class="math inline">\(p=\mbox{min}(m,n)\)</span>，<span class="math inline">\(\mathbf{U}^\top\)</span>对数据<span class="math inline">\(\mathbf{Y}\)</span>进行旋转，这一步非常有用，因为<span class="math inline">\(\mathbf{U}^\top \mathbf{Y}=\mathbf{VD}\)</span>列的变异（精确的平方和）会下降。因此<span class="math inline">\(\mathbf{U}\)</span>是正交辞职，我们可以将SVD写为如下形式： <span class="math display">\[
\mathbf{Y} = \mathbf{UDV}^\top
\]</span> 实际上这个公式更加普遍，我们也可以将转换写为如下形式： <span class="math display">\[
\mathbf{YV} = \mathbf{UD}
\]</span> <span class="math inline">\(Y\)</span>的这种转换也会生成一个矩阵，这个矩阵的列的乘方和是递减的。</p>
<p>将SVD应用到我们的案例中，就是如下结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y &lt;- t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">s &lt;- svd(y)</div></pre></td></tr></table></figure>
<p>我们可以马上就是看到使用了SVD后生成的转换后的矩阵非常类似于我们前面的案例中的结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div><div class="line">       [,<span class="number">1</span>]   [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.982</span> -<span class="number">1.017</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">1.017</span>  <span class="number">0.982</span></div></pre></td></tr></table></figure>
<p>当我们旋转后，绘制成的图形称为主成分(principal coimponent)：这里只绘制出了第一个主成分和第二个主成分。如果我们想要从SVD中获取主成分，只需要旋转后的<span class="math inline">\(\mathbf{U}^\top\mathbf{Y}\)</span> 即可：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PC1 = s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 = s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">plot(PC1,PC2,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173315.jpeg">

</div>
<h3 id="用途">用途</h3>
<p>使用SVD的用途并不十分明显，我们可以看一些案例。在这个案例中，我们将会极大地降低<span class="math inline">\(V\)</span>的组倒数，并且仍然能够构建<span class="math inline">\(Y\)</span>。</p>
<p>现在我们来对基因表达谱进行SVD的计算，我们可以只使用表达谱中的100个基因的子集，这样计算会快一点，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">ind &lt;- sample(nrow(e),<span class="number">500</span>)</div><div class="line">Y &lt;- t(apply(e[ind,],<span class="number">1</span>,scale)) <span class="comment">#standardize data for illustration</span></div></pre></td></tr></table></figure>
<p>使用<code>svd()</code>函数可以返回3个矩阵（D矩阵仅返回对角线元素），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(Y)</div><div class="line">U &lt;- s$u</div><div class="line">V &lt;- s$v</div><div class="line">D &lt;- diag(s$d) <span class="comment">##turn it into a matrix</span></div></pre></td></tr></table></figure>
<p>我们首选要注意到，我们可以重构<span class="math inline">\(y\)</span>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Yhat &lt;- U %*% D %*% t(V)</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>如果我们看一下<span class="math inline">\(\mathbf{UD}\)</span>的平方和，我们会看到最后几个非常接近于0（也许我们会有一些重复的列）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173946.jpeg">

</div>
<p>这意味着<span class="math inline">\(V\)</span>的最后一列对于<span class="math inline">\(Y\)</span>的重建非常小。为了说明这一点，我们可以考虑<span class="math inline">\(V\)</span>最后一项为0的这种极端情况。在这个案例中，<span class="math inline">\(V\)</span>的最后一列根本用不到。由于SVD的这种创建方式，<span class="math inline">\(V\)</span>的列对<span class="math inline">\(Y\)</span>的重建影响越来越小。我们通常认为这种描述为“解释了较少的变异”。这就意味着，对于一个大型矩阵，当你到达最后一列时，可能已经没有太多需要“解释”的内容了。例如，当我们把最后4列删除，看一下计算结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- ncol(U)-<span class="number">4</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>最大的残差基本上就等于0了，就意味着<code>Yhat</code>实际上是与<code>Y</code>一样，但是，我们至少需要4个维度来传输信息。</p>
<p>通过查看<span class="math inline">\(d\)</span>，我们可以看到，在这个特定的数据集中，我们能得到一个很好的近似值，它只保留了94列。在下面的图形中，我们可以看到每列能解释的变异程度是多少：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909174959.jpeg">

</div>
<p>还可以看一下累积曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plot(cumsum(s$d^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>,ylim=c(<span class="number">0</span>,\</div><div class="line"><span class="number">100</span>),type=<span class="string">"l"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175047.jpeg">

</div>
<p>虽然刚开始的时候，我们的数据是189维，但是我们可以使用95维来近似表示<span class="math inline">\(Y\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- <span class="number">95</span> <span class="comment">##out a possible 189</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">boxplot(resid,ylim=quantile(Y,c(<span class="number">0.01</span>,<span class="number">0.99</span>)),range=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175150.jpeg">

</div>
<p>因此， 我们只使用了一半的维度就保留了原始数据中的大部分的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var(as.vector(resid))/var(as.vector(Y))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; var(as.vector(resid))/var(as.vector(Y))</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>这个计算结果说明，我们使用了降维后的数据解释了原始95%的变异，我们需要注意的是，我们是通过<span class="math inline">\(D\)</span>来计算的这个比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>因此，<span class="math inline">\(D\)</span>中的元素可以告诉我们每个PC在解释变异方面所贡献的程度大小。</p>
<h3 id="高度相关数据">高度相关数据</h3>
<p>为了辅助理解SVD是如何工作的，我们使用两组高度相关的列来构建一个数据集，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">2</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- cbind(x,x)+e</div><div class="line">cor(Y)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; cor(Y)</div><div class="line">          x         x</div><div class="line">x <span class="number">1.0000000</span> <span class="number">0.9998873</span></div><div class="line">x <span class="number">0.9998873</span> <span class="number">1.0000000</span></div></pre></td></tr></table></figure>
<p>在这个案例中，第2列添加了很少的“信息”，因此所有的<code>Y[,1]-Y[,2]</code>都接近于0。使用<code>rowMeans(Y)</code>计算更加有效，这是因为<code>Y[,1]-rowMeans(Y)</code>和<code>Y[,2]-rowMeans(Y)</code>更接近于0。<code>rowMenas(Y)</code>最终生成的结果在<span class="math inline">\(U\)</span>的第1列中。SVD的计算结果表明，仅使用第1列就能解释大多数的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- svd(Y)$d</div><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999441</span></div></pre></td></tr></table></figure>
<p>在这个案例中，许多列的数据高度相关，我们可以进行更大程度的降维操作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">25</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- replicate(n,x)+e</div><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999065</span></div></pre></td></tr></table></figure>
<h2 id="练习-1">练习</h2>
<p>P338</p>
<h2 id="投影">投影</h2>
<p>原始Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/projections.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经详细地描述了降维的概念，以及SVD和主成分分析的内容，现在我们来谈一下它们背后的数学原理。我们先从投影(projection)开始讲起。投影是一个线性代数的概念，它能帮助我们理解许多关于高通量数据的许多数学操作。如果想要了解更多相关的知识，可以找本线性代数的书来看一下有关投影的内容。在这一部分里，我们会提供一个快速的回顾，然后提供一些数据分析的相关案例。</p>
<p>作为回顾，我们需要注意的是，投影就是点与其子空间之间的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910145026.png">

</div>
<p>在上图中，顶部的点指向空间中的一点。在上图的这个卡通图中，空间是二维的，但是我们可以更加抽象地思考一下。这个空间由笛卡尔平面表示，小人站的这条线是点的一个子空间。将点投影到这个子空间上所对应的位置，就是这个子空间上这个位置距离原点最近的点。几何学告诉我们，我们可以通过从点到子空间一条垂线（虚线）来找到子空间上的这点。小人站在这个子空间上，这个人从原点走到投影点的位置时，就是这个点投影到子空间后的坐标。</p>
<p>为了扩展投影的概念，我们可以使用标准矩阵线性符号来说明这个点， <span class="math inline">\(\vec{y} \in \mathbb{R}^N\)</span>是一个N维空间的点，<span class="math inline">\(L \subset \mathbb{R}^N\)</span>是一个更小的子空间。</p>
<h3 id="案例当n2">案例：当N=2</h3>
<p>先看一个案例，<span class="math inline">\(Y = \begin{pmatrix} 2 \\ 3\end{pmatrix}\)</span>，我们可以画出这个向量的图形：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar (<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">4</span>),c(<span class="number">0</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910151328.jpeg">

</div>
<p>我们可以马上定义一个坐标系统，将这个向量投影到空间中：<span class="math inline">\(\begin{pmatrix} 1\\ 0\end{pmatrix}\)</span> （x轴）和 <span class="math inline">\(\begin{pmatrix} 0\\ 1\end{pmatrix}\)</span> （y轴）。 <span class="math inline">\(Y\)</span> 向子空间的投影可以通过点2和3分别进行定义：</p>
<p><span class="math display">\[
\begin{align*}
Y &amp;= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&amp;=2  \begin{pmatrix} 1\\ 0\end{pmatrix} + 3 \begin{pmatrix} 0\\ 1\end{pmatrix} 
\end{align*}
\]</span> 我们可以说 <span class="math inline">\(2\)</span> 和<span class="math inline">\(3\)</span>是向量<span class="math inline">\(Y\)</span>的坐标，<span class="math inline">\(\begin{pmatrix} 1\\ 0\end{pmatrix} \mbox{and} \begin{pmatrix} 0\\1 \end{pmatrix}\)</span> 是它的基。</p>
<p>现在我们定义一个新的子空间。红线（后面我们会画出这个图形）是一个子集(subset)<span class="math inline">\(L\)</span>，它由满足 <span class="math inline">\(c \vec{v}\)</span> with <span class="math inline">\(\vec{v}=\begin{pmatrix} 2&amp; 1\end{pmatrix}^\top\)</span>的点构成。那么 <span class="math inline">\(\vec{y}\)</span> 在<span class="math inline">\(L\)</span>上的投影就是<span class="math inline">\(L\)</span>上最接近于 <span class="math inline">\(\vec{y}\)</span> 的点。因此我们需要找一个向量<span class="math inline">\(c\)</span>，它是位于 <span class="math inline">\(\vec{y}\)</span> 和<span class="math inline">\(c\vec{v}=(2c,c)\)</span>之间最小的距离。从线性代数的知识我们可知，这些点之间的距离正交于空间：</p>
<p><span class="math display">\[
(\vec{y}-\hat{c}\vec{v}) \cdot \vec{v} = 0
\]</span></p>
<p>上面公式也可以写为：</p>
<p><span class="math display">\[
\vec{y}\cdot\vec{v} - \hat{c}\vec{v}\cdot\vec{v} =  0
\]</span></p>
<p>即： <span class="math display">\[
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}
\]</span> <span class="math display">\[\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}\]</span></p>
<p>这里我们使用点号 <span class="math inline">\(\cdot\)</span> 来表示点积(dot product): <span class="math inline">\(\,\, \vec{x} \cdot \vec{y} = x_1 y_1+\dots x_n y_n\)</span>.</p>
<p>下面我们使用R来演示一下上面的案例：</p>
<figure class="highlight plain"><figcaption><span>projection, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(c(0,4),c(0,4),xlab=&quot;Dimension 1&quot;,ylab=&quot;Dimension 2&quot;,type=&quot;n&quot;)</div><div class="line">arrows(0,0,2,3,lwd=3)</div><div class="line">abline(0,0.5,col=&quot;red&quot;,lwd=3) #if x=2c and y=c then slope is 0.5 (y=0.5x)</div><div class="line">text(2,3,&quot; Y&quot;,pos=4,cex=3)</div><div class="line">y=c(2,3)</div><div class="line">x=c(2,1)</div><div class="line">cc = crossprod(x,y)/crossprod(x)</div><div class="line">segments(x[1]*cc,x[2]*cc,y[1],y[2],lty=2)</div><div class="line">text(x[1]*cc,x[2]*cc,expression(hat(Y)),pos=4,cex=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910153202.jpeg">

</div>
<p>我们需要注意的是，如果 <span class="math inline">\(\vec{v}\)</span> 满足 <span class="math inline">\(\vec{v}\cdot \vec{v}=1\)</span>, 那么<span class="math inline">\(\hat{c}\)</span> 就是 <span class="math inline">\(\vec{y} \cdot \vec{v}\)</span> ，空间 <span class="math inline">\(L\)</span>并没有发生改变，这处简化担任就是我们喜欢正交矩阵的一个原因。</p>
<h3 id="案例样本均值就是投影">案例：样本均值就是投影</h3>
<p>设 <span class="math inline">\(\vec{y} \in \mathbb{R}^N\)</span> ，<span class="math inline">\(L \subset \mathbb{R}^N\)</span> 被以下向量张成：</p>
<p><span class="math display">\[
\vec{v}=\begin{pmatrix} 1\\ \vdots \\  1\end{pmatrix};
L = \{ c \vec{v}; c \in \mathbb{R}\}
\]</span> 在这个空间里，向量的分量(components）都是相同的数目，因此我们可以把这个空间看作为常数：在投影中，每个维度都是相同的值。那么<span class="math inline">\(c\)</span>如何才能使得 <span class="math inline">\(c\vec{v}\)</span> 与 <span class="math inline">\(\vec{y}\)</span> 之间的距离最小呢？</p>
<p>当我们谈到这个问题时，我们会使用前面的二维图形。我们可以简单地抽象将<span class="math inline">\(\vec{y}\)</span>视为N维空间上的一个点，将<span class="math inline">\(L\)</span>视为一个更小数目的子空间，在这个案例中就是<span class="math inline">\(c\)</span>。</p>
<p>回到我们的问题，我们知道，投影就是：</p>
<p><span class="math display">\[\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}\]</span></p>
<p>在这个案例中它就是平均值： <span class="math display">\[
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}} = \frac{\sum_{i=1}^N Y_i}{\sum_{i=1}^N 1} = \bar{Y}
\]</span></p>
<p>在这个案例中，它也非常容易使用微积分进行计算：</p>
<p><span class="math display">\[
\frac{\partial}{\partial c}\sum_{i=1}^N (Y_i - c)^2 = 0 \implies 2 \sum_{i=1}^N (Y_i - \hat{c}) = 0 \implies
\]</span> <span class="math display">\[
N c = \sum_{i=1}^N Y_i \implies \hat{c}=\bar{Y
}
\]</span></p>
<h3 id="案例回归也是一种投影">案例：回归也是一种投影</h3>
<p>现在来看一下略微复杂的案例。简单线性回归也能用投影来解释。我们的数据 <span class="math inline">\(\mathbf{Y}\)</span>（这里我们不再使用<span class="math inline">\(\vec{y}\)</span>符号）是一个N维向量，我们使用一个线性方程<span class="math inline">\(\beta_0 + \beta_1 X_i\)</span>来预测<span class="math inline">\(Y_i\)</span> 。此时我要找到能够使<span class="math inline">\(Y\)</span>和由以下向量定义的空间的最小距离时的 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span> ，其中： <span class="math display">\[
\vec{v}_0=
\begin{pmatrix}
1\\
1\\
\vdots \\
1\\
\end{pmatrix} 
\mbox{ and }
\vec{v}_1=
\begin{pmatrix}
X_{1}\\
X_{2}\\
\vdots \\
X_{N}\\
\end{pmatrix} 
\]</span></p>
<p>我们的 <span class="math inline">\(N\times 2\)</span> 矩阵 <span class="math inline">\(\mathbf{X}\)</span> 是 <span class="math inline">\([ \vec{v}_0 \,\, \vec{v}_1]\)</span> ，<span class="math inline">\(L\)</span>中的任何点都可以被写为 <span class="math inline">\(X\vec{\beta}\)</span>.</p>
<p>正交投影的多维形式的方程为：</p>
<p><span class="math display">\[
X^\top (\vec{y}-X\vec{\beta}) = 0
\]</span></p>
<p>我们在之前看到过种形式：</p>
<p><span class="math display">\[
X^\top X \hat{\beta}=  X^\top \vec{y} 
\]</span></p>
<p><span class="math display">\[
\hat{\beta}= (X^\top X)^{-1}X^\top \vec{y}
\]</span></p>
<p>它向<span class="math inline">\(L\)</span>的投影就是：</p>
<p><span class="math display">\[
X (X^\top X)^{-1}X^\top \vec{y}
\]</span></p>
<h2 id="旋转-1">旋转</h2>
<p>相关的Rmarkdown参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/rotations.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>与投影相关的一个最常见的应用就是坐标旋转(coordinate rotations)。在数据分析中，简单的旋转可以很好地对数据进行可视化和解释。我们将会介绍旋转背后的数学原理，并且给出一些简单的数据分析案例。</p>
<p>前面我们使用了下面的例子： <span class="math display">\[
Y = \begin{pmatrix} 2 \\ 
3 
\end{pmatrix} 
= 
2  
\begin{pmatrix} 1\\
0 
\end{pmatrix} + 
3 
\begin{pmatrix} 0\\ 
1 
\end{pmatrix}
\]</span> 我们注意到，<span class="math inline">\(Y\)</span>的坐标是<span class="math inline">\((2,3)\)</span>，现在我们使用如下的代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">segments(<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">segments(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910165242.jpeg">

</div>
<p>但是，我们可以用其它的一些线性组合来表示点<span class="math inline">\((2,3)\)</span>： <span class="math display">\[
\begin{align*}
Y &amp;= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&amp;= 2.5 \begin{pmatrix} 1\\ 1\end{pmatrix} + -1 \begin{pmatrix} \phantom{-}0.5\\ -0.5\end{pmatrix} 
\end{align*}
\]</span> 新的坐标就是： <span class="math display">\[
Z = \begin{pmatrix} 2.5 \\ -1 \end{pmatrix}
\]</span> 从图形上我们可以看出来，这个坐标就是我们由新的基定义的空间的投影</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">abline(<span class="number">0</span>,-<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">y=c(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">x1=c(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">##new basis</span></div><div class="line">x2=c(<span class="number">0.5</span>,-<span class="number">0.5</span>)<span class="comment">##new basis</span></div><div class="line">c1 = crossprod(x1,y)/crossprod(x1)</div><div class="line">c2 = crossprod(x2,y)/crossprod(x2)</div><div class="line">segments(x1[<span class="number">1</span>]*c1,x1[<span class="number">2</span>]*c1,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">segments(x2[<span class="number">1</span>]*c2,x2[<span class="number">2</span>]*c2,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233102.jpeg">

</div>
<p>我们可以使用矩阵乘法在表示<span class="math inline">\((2,3)\)</span>的这两个坐标中进行转换： <span class="math display">\[
Y =   AZ\\
\]</span></p>
<p><span class="math display">\[
 A^{-1} Y =  Z\\
\]</span></p>
<p><span class="math display">\[
A= \begin{pmatrix} 1&amp; \phantom{-}0.5\\ 1 &amp; -0.5\end{pmatrix} \implies 
A^{-1}= \begin{pmatrix} 0.5&amp; 0.5 \\ 1 &amp;-1\end{pmatrix}
\]</span></p>
<p>其中，<span class="math inline">\(Z\)</span>和<span class="math inline">\(Y\)</span>表示了相同的信息，但是它们位于不同的坐标系中。</p>
<h3 id="案例双胞胎身高">案例：双胞胎身高</h3>
<p>我们先来看100个二维数据点<span class="math inline">\(Y\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n = <span class="number">100</span></div><div class="line">mypar()</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>),matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233353.jpeg">

</div>
<p>这里就使用了旋转：<span class="math inline">\(Z = A^{-1} Y\)</span>，图形如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = matrix(c(<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z = A%*%y</div><div class="line">mypar()</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlab=<span class="string">"Average"</span>,ylab=<span class="string">"Difference"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233448.jpeg">

</div>
<p>我们在这里进行的操作就是对数据进行旋转，从而使行新的坐标系<span class="math inline">\(Z\)</span>的第一维是平均身高（就是相当于x轴），崦第二维则是两个双胞胎身高的差值（y轴）。</p>
<p>我们已经使用了奇异值分解计算主成分。有时候将SVD视为应动力非常有用，例如 <span class="math inline">\(\mathbf{U}^\top \mathbf{Y}\)</span> 就会构建出一个新的坐标系 <span class="math inline">\(\mathbf{DV}^\top\)</span> ，在这个新的坐标系中，它们的维度按照维度能够解释变异的程序进行排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/07/Experiment/HIPC介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Experiment/HIPC介绍/" itemprop="url">HIPC介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T12:00:00+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物实验笔记/" itemprop="url" rel="index">
                    <span itemprop="name">生物实验笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  803
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>最近在看GSEA有关的内容，GSEA官网里涉及到一个基因集，即<code>C7 collection: Immunologic signatures</code>，这是一个与免疫相关的基因集，根据官网的介绍，这个基因集是由BROAD实验室与丹娜法伯癌症研究院（Dana-Farber Cancer Institute）的Haining Lab和人类免疫学项目联合合会(HIPC)合作的一部分，当时还发了一篇Immunity，文献信息如下：</p>
<p>Godec J, Tan Y, Liberzon A, Tamayo P, Bhattacharya S, Butte A, Mesirov JP, Haining WN, Compendium of Immune Signatures Identifies Conserved and Species-Specific Biology in Response to Inflammation, 2016, Immunity 44(1), 194-206.</p>
<p>以下内容是HIPC官网的一些资料。</p>
<h2 id="hipc简介">HIPC简介</h2>
<p>HIPC英文全称是Human Immunology Project Consortium，即人类免疫学项目研究联合会，成立于2010年，后又于2015年重组，即由原来的NIAID的过敏所（注：NIAID的全称为National Institute of Allergy and Infectious Diseases，即<strong>国家过敏与感染性疾病研究院</strong>），免疫所和移植所进行合并，统一作为NIAID的构成部分，集中研究人类免疫学。</p>
<p>注：上面一段话是我按原文翻译后理解的，不一定准确，为了避免歧义我，这里贴出原文：</p>
<blockquote>
<p>The Human Immunology Project Consortium (HIPC) program was established in 2010, and renewed in 2015, by the NIAID Division of Allergy, Immunology, and Transplantation as part of the overall NIAID focus on human immunology.</p>
</blockquote>
<p>通过HIPC计划，研究者们使用各种现代分析工具分析人类多个免疫学方面的数据，其中包括多重转录(multiplex transcriptional)，细胞因子，蛋白质谱；白细胞亚型的多参数表型(multiparameter phenotyping of leukocyte subsets)；评估白细胞功能状态以及开发多种算法。</p>
<p>HIPC项目旨在建立一个集中的研究中心，以及一个广泛的，中心化的数据库，从而让更多的研究者们使用。HIPC项目产生的信息将会有助于研究者们广泛地理解人类免疫系统方方面面，包括免疫系统的调控，发现免疫系统组分与其它生物系统的新型关系，从而确定新的免疫介质与通路，以及构建不同种群疫苗案安全性的预测因子，从而确保对不同疫苗配方的快速评估，确立接种方案等。该知识库还将会构建起免疫系统介导的人类疾病的研究基础，这些人类免疫性疾病包括过敏，哮喘，移植排斥和自身免疫性疾病以及各种炎症性疾病。</p>
<h2 id="hipc的任务">HIPC的任务</h2>
<h3 id="目标">目标</h3>
<ol style="list-style-type: decimal">
<li>定义稳定和活化的人类免疫系统的表达谱/标签/足迹(Define profiles/signatures/fingerprints of steady-state and activated human immune system)</li>
<li>创建一个中心化的知识库或资源：</li>
</ol>
<ul>
<li>有利于研究人类免疫系统；</li>
<li>针对人类疾病开发新的疗法。</li>
</ul>
<h3 id="研究">研究</h3>
<ol style="list-style-type: decimal">
<li>感染导致的稳态异常(Perturbations of the steady-state by infection)；</li>
<li>疫苗；</li>
<li>佐剂研究(Adjuvant administration )</li>
</ol>
<h3 id="方法">方法</h3>
<ol style="list-style-type: decimal">
<li>定义人类转录组/蛋白质谱；</li>
<li>多重分析(multiplex assays)；</li>
<li>多参数表型，系统生物学；</li>
<li>质谱。</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>https://www.immuneprofiling.org/hipc/page/showPage?pg=sci-about</li>
<li>http://software.broadinstitute.org/gsea/msigdb/collection_details.jsp#C7</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/24/DAL/DALS019_StatisticalModels2_Beyes_Hierarchical/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/24/DAL/DALS019_StatisticalModels2_Beyes_Hierarchical/" itemprop="url">DALS019-统计模型2-贝叶斯分布与层次分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-24T12:00:00+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,055
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第7章统计模型的第2小节，这一部分的主要内容涉及贝叶斯统计的一些原理。相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/modeling/bayes.Rmd" target="_blank" rel="external">Github</a>，另外，如果想补充一些贝叶斯的相关知识，可以参考这本书《统计学关我什么事：生活中的极简统计学》，这是一本有关贝叶斯统计的科普书，公式不多。</p>
<h2 id="贝叶斯统计">贝叶斯统计</h2>
<p>高通量数据的一个明显特点就是，虽然我们最终会报道一些特定的基因，但是我们还会观察到许多相关的结果。例如，我们检测会数千个基因或者是代表了蛋白结合位点的数千个峰图，或者是一些CpGs的甲基化水平。但是，我们这里使用的多数统计推断方法都是独立地处理每个特征值，并且几乎忽略了来自其它特征的数据。在这一部分里，我们将会了解到，如何通过对特征值的联合建模来进行统计。这里方法中使用最为广泛的就是层次模型(hierachical models)，我们会在后面的贝叶斯统计中进行解释。</p>
<h3 id="贝叶斯定理">贝叶斯定理</h3>
<p>先来看一个案例，如果我们有一种检测手段来检测囊性纤维化(cystic fibrosis)。假设这个检测手段的精确程度为99%，我们可以使用下面的公式来表示： <span class="math display">\[
\mbox{Prob}(+ \mid D=1)=0.99, \mbox{Prob}(- \mid D=0)=0.99
\]</span> 其中，<span class="math inline">\(+\)</span>表示阳性结果，<span class="math inline">\(D\)</span>表示检测的结果，其中<span class="math inline">\(1\)</span>表示得病，，<span class="math inline">\(0\)</span>表示不得病。</p>
<p>现在我们随机选择一个人进行检测，结果如果是阳性，那么这个人患病的概率是多大？也就是说要计算<span class="math inline">\(\mbox{Prb}(D=1|+)\)</span>的结果。囊性纤维化的发病率是每1/3900，也就是说，<span class="math inline">\(\mbox{Prob}(D=1|+)=0.0025\)</span>，为了计算出这个人患病的概率，我们就会使用到贝叶斯定理，贝叶斯定理公式如下所示： <span class="math display">\[
\mbox{Pr}(A \mid B)  =  \frac{\mbox{Pr}(B \mid A)\mbox{Pr}(A)}{\mbox{Pr}(B)}
\]</span> 这个公式就可以应用到我们的案例中，如下所示： <span class="math display">\[
\begin{align*}
\mbox{Prob}(D=1 \mid +) &amp; =  \frac{ P(+ \mid D=1) \cdot P(D=1)} {\mbox{Prob}(+)} \\
&amp; =  \frac{\mbox{Prob}(+ \mid D=1)\cdot P(D=1)} {\mbox{Prob}(+ \mid D=1) \cdot P(D=1) + \mbox{Prob}(+ \mid D=0) \mbox{Prob}( D=0)} 
\end{align*}
\]</span> 换成实际数字，则如下所示： <span class="math display">\[
\frac{0.99 \cdot 0.00025}{0.99 \cdot 0.00025 + 0.01 \cdot (.99975)}  =  0.02
\]</span> 也就是说，虽然这种检测手段有99%的精度，但是一个人的检测结果如果是阳性，那么这个人得病的概率只有0.02。这似乎有点反直觉。其原因就是，我们必须要考虑，当我们随机选择一个人时，这个人患上这种疾病时非常罕见的可能性。为了说明这一个，我们随便使用Monte Carlo模拟来计算一下。</p>
<h3 id="模拟">模拟</h3>
<p>下面的模拟旨在帮助你能够以可视化的形式来理解贝叶斯定理。我们首选从一个总体中随机选择1500人，其中患病的概率是5%，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">3</span>)</div><div class="line">prev &lt;- <span class="number">1</span>/<span class="number">20</span></div><div class="line"><span class="comment">##Later, we are arranging 1000 people in 80 rows and 20 columns</span></div><div class="line">M &lt;- <span class="number">50</span> ; N &lt;- <span class="number">30</span></div><div class="line"><span class="comment">##do they have the disease?</span></div><div class="line">d&lt;-rbinom(N*M,<span class="number">1</span>,p=prev)</div></pre></td></tr></table></figure>
<p>现在进行一项检测，这个检测的准确率是90%，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">accuracy &lt;- <span class="number">0.9</span></div><div class="line">test &lt;- rep(<span class="literal">NA</span>,N*M)</div><div class="line"><span class="comment">##do controls test positive?</span></div><div class="line">test[d==<span class="number">1</span>] &lt;- rbinom(sum(d==<span class="number">1</span>), <span class="number">1</span>, p=accuracy)</div><div class="line"><span class="comment">##do cases test positive?</span></div><div class="line">test[d==<span class="number">0</span>] &lt;- rbinom(sum(d==<span class="number">0</span>), <span class="number">1</span>, p=<span class="number">1</span>-accuracy)</div></pre></td></tr></table></figure>
<p>由于没有患病的人数要远远超过患病的人数，即使存在着极低的假阳性率，那么在检测为阳性的结果中，不患病人的也要多于患病的人，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">cols &lt;- c(<span class="string">"grey"</span>,<span class="string">"red"</span>)</div><div class="line">people &lt;- expand.grid(<span class="number">1</span>:M,N:<span class="number">1</span>)</div><div class="line">allcols &lt;- cols[d+<span class="number">1</span>] <span class="comment">##Cases will be red</span></div><div class="line">positivecols &lt;- allcols</div><div class="line">positivecols[test==<span class="number">0</span>] &lt;- <span class="literal">NA</span> <span class="comment">##remove non-positives</span></div><div class="line">negativecols &lt;- allcols</div><div class="line">negativecols[test==<span class="number">1</span>] &lt;- <span class="literal">NA</span> <span class="comment">##remove non-positives</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">layout(matrix(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>),<span class="number">2</span>,<span class="number">2</span>),width=c(<span class="number">0.35</span>,<span class="number">0.65</span>))</div><div class="line"><span class="comment">###plot of all people</span></div><div class="line">plot(people,col=allcols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste0(<span class="string">"Population: "</span>,round(mean(d)*<span class="number">100</span>),<span class="string">"% are red"</span>))</div><div class="line">plot(people,col=positivecols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste(<span class="string">"Tested Positive:"</span>,round(mean(d[test==<span class="number">1</span>])*<span class="number">100</span>),<span class="string">"% are red"</span>))</div><div class="line">plot(people,col=negativecols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste(<span class="string">"Tested Negative:"</span>,round(mean(d[test==<span class="number">0</span>])*<span class="number">100</span>,<span class="number">1</span>),<span class="string">"% are red"</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908153222.jpeg">

</div>
<p>现在解释一下上面的图：</p>
<p>顶图：红点表示患者。每个人接受检测的话，有90%的可能性结果是准确的。即<span class="math inline">\(\mbox{Pr}(D=1)\)</span>；</p>
<p>下左图：检测结果为阳性（无论结果对不对，这里面含有真阳性与假阳性）的人，即<span class="math inline">\(\mbox{Pr}(D=1|+)\)</span></p>
<p>下右图：检测结果为阴性的人，即<span class="math inline">\(\mbox{Pr}(D=0|+)\)</span></p>
<h3 id="贝叶斯的实际运用">贝叶斯的实际运用</h3>
<p>José Iglesias是一名职业棒球运行员，在2013年4月份，他开始了职业生成，他表表现得很好，成绩如下所示：</p>
<table>
<thead>
<tr class="header">
<th>Month</th>
<th>At Bats</th>
<th>H</th>
<th>AVG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>April</td>
<td>20</td>
<td>9</td>
<td>.450</td>
</tr>
</tbody>
</table>
<p>平均击球率(battingaverage, AVG)统计是一种检测成功的方式。粗略地说，这个指标是告诉我们击球时的成功情况。<code>AVG=0.450</code>就表明，这个运动员在他击球的时间内（对应上面的<code>At Bats</code>）成功了45%，这是一个非常高的水平。为什么水平高呢，因为自1941年Ted Williams的<code>AVG=0.400</code>以来，还没有人能超过这个水平。为了说明层次模型的强大功能，我们将会在后面对Jose的数据进行预测。</p>
<p>在本书的前面部分到此为止，我们所到到的统计学技术可以被称为频率学派技术(frequentist techniques)，使用这种知识做出的结论就是能计算出一个置信区间。我们可以把击打(hitting)这个事件看作是一个二元结果，其成功的概论为<span class="math inline">\(p\)</span>。因此，如果成功率是0.450的话，那么击球次数是20次时，标准误为： <span class="math display">\[
\sqrt{\frac{.450 (1-.450)}{20}}=.111
\]</span> 也就是说，我们计算出的置信区间为<code>.450-.222</code> to <code>.450+.222</code>或<code>.228</code> to <code>.672</code>。</p>
<p>使用这种手段进行预测存在着两个问题。第一，实际用处不大。第二，成功率在0.450之间波动，也就是说这个人打破了Ted William的纪录。如果你自己关注棒球运动的话，打破Ted William纪录这种描述似乎是有问题，这是因为你隐含地使用了一个层次模型，这个模型会影响后面几年棒球的信息。在这里，我们对这种直觉进行量化。</p>
<p>首选，我们来研究一下前三个赛季里所有超过500次击打(at bats)的运动员的击球率的分布情况：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">tmpfile &lt;- tempfile()</div><div class="line">tmpdir &lt;- tempdir()</div><div class="line">download.file(<span class="string">"http://seanlahman.com/files/database/lahman-csv_2014-02-14.zip"</span>,tmpfile)</div><div class="line"><span class="comment">##this shows us files</span></div><div class="line">filenames &lt;- unzip(tmpfile,list=<span class="literal">TRUE</span>)</div><div class="line">players &lt;- read.csv(unzip(tmpfile,files=<span class="string">"Batting.csv"</span>,exdir=tmpdir),as.is=<span class="literal">TRUE</span>)</div><div class="line">unlink(tmpdir)</div><div class="line">file.remove(tmpfile)</div><div class="line"></div><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line"><span class="keyword">for</span>(y <span class="keyword">in</span> <span class="number">2010</span>:<span class="number">2012</span>)&#123;</div><div class="line">  dat &lt;- filter(players,yearID==y) %&gt;% mutate(AVG=H/AB) %&gt;% filter(AB&gt;<span class="number">500</span>)</div><div class="line">  hist(dat$AVG*<span class="number">1000</span>,xlab=<span class="string">"AVG"</span>,freq=<span class="literal">FALSE</span>,main=y,xlim=c(<span class="number">200</span>,<span class="number">360</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908211314.jpeg">

</div>
<p>我们注意到，普通运行员的AVG为0.275，总体运动员的标准差为0.027。所以，我们看到，0.45这个数字与它们假设偏离非常大，因为这个数字离平均值的差距超过了6个标准差。Jose的这个数字是由于运气，还是说他确实是过去50年来最好的运动员？或者是这两者的结合？但是，他有多幸运，以及运动天赋有多高？如果我们确信他是由于运气出现的这个数字，我们应该把他送到相信他确实是0.45这个水平的球队里，并且有可能高估了他的潜力。</p>
<h3 id="层次模型"><strong>层次模型</strong></h3>
<p>层次模型为我们提供了如何观察到0.45的这个数字的数学描述。首先，我们会随机选择一个内在能力为<span class="math inline">\(\theta\)</span>运动员，然后，我们看到成功概率为<span class="math inline">\(\theta\)</span>的20个随机结果（这一段不太懂，原文为：The hierarchical model provides a mathematical description of how we came to see the observation of .450. First, we pick a player at random with an intrinsic ability summarized by, for example, <span class="math inline">\(\theta\)</span>, then we see 20 random outcomes with success probability <span class="math inline">\(\theta\)</span>.），其中： <span class="math display">\[
\begin{align*}
\theta &amp;\sim N(\mu, \tau^2) \mbox{ describes randomness in picking a player}\\
Y \mid \theta &amp;\sim N(\theta, \sigma^2) \mbox{ describes randomness in the performance of this particular player}
\end{align*}
\]</span> 我们要注意2个层次（这就是为什么要称为层次分析的原因）：</p>
<ol style="list-style-type: decimal">
<li>运动员与运动员之间的变异；</li>
<li>击球时，运气因素导致的变异。</li>
</ol>
<p>在贝叶斯框架中，第一个水平称为先验分布(prior distribution)，第二个水平称为采样分布(sampling distribution)。</p>
<p>现在我们使用贝叶斯模型来计算Jose的数据。假设我们想预测构成他真实击球平均水平<span class="math inline">\(\theta\)</span>的内在能力的话。使用层次模型就按下面的方法表示： <span class="math display">\[
\begin{align*}
\theta &amp;\sim N(.275, .027^2) \\
Y \mid \theta &amp;\sim N(\theta, .111^2) 
\end{align*}
\]</span> 我们现在就可以计算出一个后验分布(posterior distribution)来描述我们对<span class="math inline">\(\theta\)</span>的预测。这里我们可以使用贝叶斯规则的连续计算方法推导后验概率，后验概率是对给定观测数据参数<span class="math inline">\(\theta\)</span>的分布： <span class="math display">\[
\begin{align*}
f_{ \theta \mid Y} (\theta\mid Y) &amp;=
\frac{f_{Y\mid \theta}(Y\mid \theta) f_{\theta}(\theta)
}{f_Y(Y)}\\
&amp;= \frac{f_{Y\mid \theta}(Y\mid \theta) f_{\theta}(\theta)}
{\int_{\theta}f_{Y\mid \theta}(Y\mid \theta)f_{\theta}(\theta)}
\end{align*}
\]</span> 我们主要是对能够使后验概率<span class="math inline">\(f_{\theta\mid Y}(\theta\mid Y)\)</span>的值最大的<span class="math inline">\(\theta\)</span>感兴趣。在我们的案例中，我们可以看出后验概率服从正态分布，我们能计算出均值<span class="math inline">\(\mbox{E}(\theta\mid y)\)</span>，方差<span class="math inline">\(\mbox{var}(\theta\mid y)\)</span>，尤其，我们可以计算出这个分布的均值服从以下分布： <span class="math display">\[
\begin{align*}
\mbox{E}(\theta\mid y) &amp;= B \mu + (1-B) Y\\
&amp;= \mu + (1-B)(Y-\mu)\\
B &amp;= \frac{\sigma^2}{\sigma^2+\tau^2}
\end{align*}
\]</span> 这是一个总体均值<span class="math inline">\(\mu\)</span>和观测数据<span class="math inline">\(Y\)</span>的加权均值。其权重取决于总体<span class="math inline">\(\tau\)</span>的SD和我们观测数据<span class="math inline">\(\sigma\)</span>的SD。这个加权均值有时候也会被称为<code>shrinking</code>，因为它缩小(shrink)了对先验均值的估计，在Joes Iglesias的数据中，结果如下所示： <span class="math display">\[
\begin{align*}
\mbox{E}(\theta \mid Y=.450) &amp;= B \times .275 + (1 - B) \times .450 \\
&amp;= .275 + (1 - B)(.450 - .275) \\
B &amp;=\frac{.111^2}{.111^2 + .027^2} = 0.944\\
\mbox{E}(\theta \mid Y=450) &amp;\approx .285
\end{align*}
\]</span> 方差如下所示： <span class="math display">\[
\mbox{var}(\theta\mid y) = \frac{1}{1/\sigma^2+1/\tau^2}
= \frac{1}{1/.111^2 + 1/.027^2} = 0.00069
\]</span> 标准差因此是0.026。我们开始时，使用了传统频率学派的思路计算出的95%置信区间忽略了来自于其他运动员的数据，因此会单纯地认为Joes的数据是0.0450 ± 0.220。我们随后使用了贝叶斯方法，整合了来源于其他运动员的数据，以及前几年的数据，计算出了后验概率。这种计算思路实际上就是经验贝叶斯方法，因此我们使用了数据先构建了先验知识。从后验结果中我们可以知道，通过报告一个以均值为中心的区间来报告所谓的95%的可信区间，其发生的概率为95%，在这个案例中，其结果是0.285 ± 0.052。原文：From the posterior we can report what is called a 95% credible interval by reporting a region, centered at the mean, with a 95% chance of occurring. In our case, this turns out to be: 0.285 ± 0.052.</p>
<p>贝叶斯可信区间表明，如果其他的球队发现了0.45这个数字，我们应该考虑到Joses可能转会到其他球队，因为我们预测到了Jose的水平高于平均不水平。有意思的是，Red Sox在7月份的时候将Jose转会到了Detroit Tigers队。这里是Jose在接下来的5个月内的击球率：</p>
<table>
<thead>
<tr class="header">
<th>Month</th>
<th>At Bat</th>
<th>Hits</th>
<th>AVG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>April</td>
<td>20</td>
<td>9</td>
<td>.450</td>
</tr>
<tr class="even">
<td>May</td>
<td>26</td>
<td>11</td>
<td>.423</td>
</tr>
<tr class="odd">
<td>June</td>
<td>86</td>
<td>34</td>
<td>.395</td>
</tr>
<tr class="even">
<td>July</td>
<td>83</td>
<td>17</td>
<td>.205</td>
</tr>
<tr class="odd">
<td>August</td>
<td>85</td>
<td>25</td>
<td>.294</td>
</tr>
<tr class="even">
<td>September</td>
<td>50</td>
<td>10</td>
<td>.200</td>
</tr>
<tr class="odd">
<td>Total w/o April</td>
<td>330</td>
<td>97</td>
<td>.293</td>
</tr>
</tbody>
</table>
<p>虽然这两个区间都包括了最终的击球平均值，但是贝叶斯可信区间提供了更精确的预测，尤其是，这种方法预测到Jose在本赛季的剩余时间里表现不佳。</p>
<h2 id="练习">练习</h2>
<p>P308</p>
<h2 id="层次模型-1">层次模型</h2>
<p>有关层次模型的内容可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/modeling/hierarchical_models.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在这一部分里，我们会使用数据理论来描述在高通量数据分析中常用的方法。常规的思路就是构建一个两层的层次模型。一层用于描述样本/实验单元之间的变异，另外一层用于描述特征值之间的变异。这种分析方法类似于我们前面讲的棒球案例，即第一层用于描述不同运动员之间的变异，第二层用于描述一个运动员成功的随机性。我们这里𢪮的所有模型与方法都考虑了第一个变异水平，例如构建t检验的醋。第二个水平允许我们通过从所有的特征值里“借用(borrow)”信息用于对特征值进行统计推断，从而提供检验效能。</p>
<p>现在我们来看一个在基因表达数据中使用最为广泛的统计学方法。这个统计学方就是由<code>limma</code>Bioconductor包提供的。这个方法已经被用于改造分析RNAseq数据，例如edgeR<a href="https://www.ncbi.nlm.nih.gov/pubmed/19910308" target="_blank" rel="external">《edgeR: a Bioconductor package for differential expression analysis of digital gene expression data.》</a>和DESeq2<a href="https://www.ncbi.nlm.nih.gov/pubmed/25516281" target="_blank" rel="external">《Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2》</a>。这两个包提供了t检验的替代方案，它们通过对方差进行建模从而极大地改善了统计功效。然而在棒球案例中，我们是对均值进行了建模，这是与那两种方法建模的不同之处。对方差建模需要更深的数学知识，但是思路是一样的。我们以一个案例来说明一下这种方法。</p>
<p>下图是一个火山图，它显示了使用t检验来分析数据的结果，显示了效应大小(effect size)和p值，其中使用了6个重复样本（对照组3个，干预组3个），其中有16个基因是人为设定的差异基因。只有这16个基因的备选假设为真，在火山图上它们标记为蓝色，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(SpikeInSubset) <span class="comment">##Available from Bioconductor</span></div><div class="line">data(rma95)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">fac &lt;- factor(rep(<span class="number">1</span>:<span class="number">2</span>,each=<span class="number">3</span>))</div><div class="line">tt &lt;- rowttests(exprs(rma95),fac)</div><div class="line">smallp &lt;- with(tt, p.value &lt; <span class="number">.01</span>)</div><div class="line">spike &lt;- rownames(rma95) %<span class="keyword">in</span>% colnames(pData(rma95))</div><div class="line">cols &lt;- ifelse(spike,<span class="string">"dodgerblue"</span>,ifelse(smallp,<span class="string">"red"</span>,<span class="string">"black"</span>))</div><div class="line">with(tt, plot(-dm, -log10(p.value), cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">xlim=c(-<span class="number">1</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">4.5</span>),</div><div class="line">xlab=<span class="string">"difference in means"</span>,</div><div class="line">col=cols))</div><div class="line">abline(h=<span class="number">2</span>,v=c(-<span class="number">.2</span>,<span class="number">.2</span>), lty=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908225643.jpeg">

</div>
<p>上图是使用t检验计算了两组样本的差异基因，其中Spiked-in基因使用蓝色。剩下的基因中，p小于的用红色标明。</p>
<p>在上面的火山图中，我们将y轴的截止值(cut-off)设为了4.5，但是有一个蓝点的p值小于<span class="math inline">\(10^{-6}\)</span>。但是，从这张图中我们会发现2点怪异之处。第一，按照5% FDR的标准，只有一个阳性结果是显著的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum( p.adjust(tt$p.value,method = <span class="string">"BH"</span>)[spike] &lt; <span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum( p.adjust(tt$p.value,method = <span class="string">"BH"</span>)[spike] &lt; <span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这个结果与每组3个样本的低统计效能有关。第二，如果我们忽略掉统计推断，仅仅是基于t检验统计量的大小简单地对这些基因进行排序，那么我们会在任何大于1的排序列表中得到很多假阳性结果。例如，按照t检验统计量进行排序，位列前10名的基因中，有6个都是假阳性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table( top50=rank(tt$p.value)&lt;= <span class="number">10</span>, spike) <span class="comment">#t-stat and p-val rank is the same</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table( top50=rank(tt$p.value)&lt;= <span class="number">10</span>, spike) <span class="comment">#t-stat and p-val rank is the same</span></div><div class="line">       spike</div><div class="line">top50   <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line">  <span class="literal">FALSE</span> <span class="number">12604</span>    <span class="number">12</span></div><div class="line">  <span class="literal">TRUE</span>      <span class="number">6</span>     <span class="number">4</span></div></pre></td></tr></table></figure>
<p>在火山图中，我们注意到，大多数基因的效能大小都非常小，这说明，估计的标准误非常小，我们可以通过画图的手段来看一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tt$s &lt;- apply(exprs(rma95), <span class="number">1</span>, <span class="keyword">function</span>(row)</div><div class="line">  sqrt(<span class="number">.5</span> * (var(row[<span class="number">1</span>:<span class="number">3</span>]) + var(row[<span class="number">4</span>:<span class="number">6</span>]) ) ) )</div><div class="line">with(tt, plot(s, -log10(p.value), cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">              log=<span class="string">"x"</span>,xlab=<span class="string">"estimate of standard deviation"</span>,</div><div class="line">              col=cols))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908230650.jpeg">

</div>
<p>在这里我们就可以看到层次模型的用处了。如果我们假设这些变异的分布在所有基因中，然后我们通过分布来“调整”那些“太小”估计值，就可以改善我们的计算结果。在本书的前面部分中，我们提到F分布与观测到的方差分布近似，即： <span class="math display">\[
s^2 \sim s_0^2 F_{d,d_0}
\]</span> 因为我们有数千个数据点，我们实际上可以检验一下这个假设，并且估计出参数<span class="math inline">\(s_{0}\)</span>和<span class="math inline">\(d_{0}\)</span>。这种估计方法指的就是经验贝叶斯统计，因为我们使用现有的数据（经验）就可以构建先验分布（贝叶斯方法）。</p>
<p>现在我们将前面的棒球案例应用到标准误的估计中。像以前一样，我们已经有了每个基因的观测值<span class="math inline">\(s_{g}\)</span>，这是一个采样分布，用它来作为先验分布。我们因此可以计算出方差<span class="math inline">\(\sigma_{g}^2\)</span>的后来又做分布，并且获得一个后验均值，细节可以参考文献<a href="https://www.ncbi.nlm.nih.gov/pubmed/16646809" target="_blank" rel="external">《Linear models and empirical bayes methods for assessing differential expression in microarray experiments.》</a>，均值如下所示： <span class="math display">\[
\mathrm{E}\left[\sigma_{g}^{2} | s_{g}\right]=\frac{d_{0} s_{0}^{2}+d s_{g}^{2}}{d_{0}+d}
\]</span> 与棒球案例一样，后验均值会降低我们观测到的方差<span class="math inline">\(s_{g}^2\)</span>偏向于全局方差<span class="math inline">\(s_{0}^2\)</span>，其权重取决于样本大小，以及含有自由度<span class="math inline">\(d\)</span>的样本数目，在这个案例中，就是取决于通过<span class="math inline">\(d_{0}\)</span>的先验分布形状。（原文：AAs in the baseball example, the posterior mean <em>shrinks</em> the observed variance <span class="math inline">\(s_g^2\)</span> towards the global variance <span class="math inline">\(s_0^2\)</span> and the weights depend on the sample size through the degrees of freedom <span class="math inline">\(d\)</span> and, in this case, the shape of the prior distribution through <span class="math inline">\(d_0\)</span>. ）</p>
<p>在上面的图形中，我们可以看到40个基因的方差估计是如何缩小(shrink)的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">fit &lt;- lmFit(rma95, model.matrix(~ fac))</div><div class="line">ebfit &lt;- ebayes(fit)</div><div class="line">n &lt;- <span class="number">40</span></div><div class="line">qs &lt;- seq(from=<span class="number">0</span>,to=<span class="number">.2</span>,length=n)</div><div class="line">idx &lt;- sapply(seq_len(n),<span class="keyword">function</span>(i) which(as.integer(cut(tt$s^<span class="number">2</span>,qs)) == i)[<span class="number">1</span>])</div><div class="line">idx &lt;- idx[!is.na(idx)]</div><div class="line">par(mar=c(<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">plot(<span class="number">1</span>,<span class="number">1</span>,xlim=c(<span class="number">0</span>,<span class="number">.21</span>),ylim=c(<span class="number">0</span>,<span class="number">1</span>),type=<span class="string">"n"</span>,</div><div class="line">     xlab=<span class="string">"variance estimates"</span>,ylab=<span class="string">""</span>,yaxt=<span class="string">"n"</span>)</div><div class="line">axis(<span class="number">2</span>,at=c(<span class="number">.1</span>,<span class="number">.9</span>),c(<span class="string">"before"</span>,<span class="string">"after"</span>),las=<span class="number">2</span>)</div><div class="line">segments((tt$s^<span class="number">2</span>)[idx],rep(<span class="number">.1</span>,n),</div><div class="line">         ebfit$s2.post[idx],rep(<span class="number">.9</span>,n))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908232355.jpeg">

</div>
<p>上图显示的就是估计值如何向先验期望缩小的，40个基因包括了我们选择值的整个范围。</p>
<p>这种调整的一个重要方面就是使那些样本标准差接近于0的基因的样本偏差不再接近于0（向<span class="math inline">\(s_{0}\)</span>收缩）。我们现在就创建一个t检验的统计模型，用于替代使用这个后验均值或“收缩“(shrunken)后的方差估计值。我们称这种t检验模型为适度t检验（moderated t-test）。当我们使用适应t检验后从火山图上就能明显地看到其改进之处：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">fit &lt;- lmFit(rma95, model.matrix(~ fac))</div><div class="line">ebfit &lt;- ebayes(fit)</div><div class="line">limmares &lt;- data.frame(dm=coef(fit)[,<span class="string">"fac2"</span>], p.value=ebfit$p.value[,<span class="string">"fac2"</span>])</div><div class="line">with(limmares, plot(dm, -log10(p.value),cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">                    col=cols,xlab=<span class="string">"difference in means"</span>,</div><div class="line">                    xlim=c(-<span class="number">1</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">5</span>)))</div><div class="line">abline(h=<span class="number">2</span>,v=c(-<span class="number">.2</span>,<span class="number">.2</span>), lty=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908233029.jpeg">

</div>
<p>这个火山图显示的就是使用适度t检验比较两组的差异基因结果。Spiked-in基因用蓝色进行了标注。剩下的基因中，p值小于的用红色标注。</p>
<p>现在我们来看一下排列前10的基因中假阳性的数目，这个数目就降为了2，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table( top50=rank(limmares$p.value)&lt;= <span class="number">10</span>, spike)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table( top50=rank(limmares$p.value)&lt;= <span class="number">10</span>, spike)</div><div class="line">       spike</div><div class="line">top50   <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line">  <span class="literal">FALSE</span> <span class="number">12608</span>     <span class="number">8</span></div><div class="line">  <span class="literal">TRUE</span>      <span class="number">2</span>     <span class="number">8</span></div></pre></td></tr></table></figure>
<h2 id="练习-1">练习</h2>
<p>P315</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/23/DAL/DALS018_StatisticalModels1_binomal_Possion_MLE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/DAL/DALS018_StatisticalModels1_binomal_Possion_MLE/" itemprop="url">DALS018-统计模型1-二项分布与泊松分布，MLE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T12:00:00+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,870
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第7章统计模型的第1小节，这一部分的主要内容涉及高维数据统计的一些原理，例如二项分布，泊松分布，最大似然估计等。</p>
<p>相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/modeling/modeling.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>当我们在文献中看到p值的时候，它意味着使用某种概率分布来对零假设进行量化。很多时候我们很容易地就能找到使用哪种分布。例如，在女士品茶这个案例中，我们就能使用简单的概率计睡来确定零分布。文献中的大多数p值都是基于线性模型的样本均值或最小二乘估计来进行计算的，并利用CLT近似地救出它们的零分布。</p>
<p>CLT有着理论支持，它能保证这种近似是正确的。但是，我们无法一直使用这种近似法，例如当我们的样本太少时。以前面部分中，我们提到了，当总体数据近似服从正态分布时，样本的平均近似服从t分布。但是这种假设没有理论上的支持。在这一部分里，我们就会对这种情况进行建模。在研究身高时，我们从经验中就知道，这是一个非常好的模型。</p>
<p>但是，这并不意味着我们收集的每个数据集都服从正态分布。我们常见的一些例子，例如掷硬币，中彩票的人数，美国的收入。正态分布不是建模过程中的唯一参数分布。在这一部分里，我们会描述一些最广泛使用的参数分布以及它们在生命科学研究中的作用。我们还会介绍贝叶斯统计相关的知识，以及给出使用分层模型的使用案例。</p>
<h2 id="二项分布">二项分布</h2>
<p>在<span class="math inline">\(N\)</span>次实验中，成功<span class="math inline">\(S=k\)</span>次的概率，公式如下所示： <span class="math display">\[
\mbox{Pr}(S=k) = {N \choose k}p^k (1-p)^{N-k}
\]</span> 其中<span class="math inline">\(p\)</span>是成功的概率，二项分布的一个最有名案例就是掷硬币，当我们掷<span class="math inline">\(N\)</span>次硬币，有<span class="math inline">\(S\)</span>次是正面朝上的概率，在这个案例中，<span class="math inline">\(p=0.5\)</span>。</p>
<p><span class="math inline">\(S/N\)</span>是独立随机变量的均值，因此CLT告诉我们，当<span class="math inline">\(N\)</span>足够大时，<span class="math inline">\(S\)</span>近似地服从正态分布。这种分布在生命科学研究中应用很广，最近，此分布在NGS检测variant callers和表型(genotyper)应用很广，它的一个特殊分布则是泊松分布(poisson distribution)（二顶分布的极限是泊松分布）。</p>
<h2 id="泊松分布">泊松分布</h2>
<p>由于买彩票的结果只有两个，中彩票与不中彩票，因此，那些赢得彩票的人数从理论上服从二项分布（我们是假设每个人只能买一张彩票）的。试验次数<span class="math inline">\(N\)</span>是买彩票的人数，这个数字通常非常大。但是，赢得彩票的的人数通常是0到3之间，这就表明，赢得彩票的人数是不服从正态分布的。那么，为什么CLT在这种情况下不成立呢？从数学上可以对此进行解释，但是直觉又告诉我们，如果成功的总和是如此接近，并且大于1，这种分布就不可能是正态分布，这里我们进行一个快速的模拟：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p=<span class="number">10</span>^-<span class="number">7</span> <span class="comment">##1 in 10,000,0000 chances of winning</span></div><div class="line">N=<span class="number">5</span>*<span class="number">10</span>^<span class="number">6</span> <span class="comment">##5,000,000 tickets bought</span></div><div class="line">winners=rbinom(<span class="number">1000</span>,N,p) <span class="comment">##1000 is the number of different lotto draws</span></div><div class="line">tab=table(winners)</div><div class="line">plot(tab)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190905223653.jpeg">

</div>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; prop.table(tab)</div><div class="line">winners</div><div class="line">    <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span> </div><div class="line"><span class="number">0.617</span> <span class="number">0.294</span> <span class="number">0.080</span> <span class="number">0.009</span></div></pre></td></tr></table></figure>
<p>达种情况下，<span class="math inline">\(N\)</span>会非常大，<span class="math inline">\(p\)</span>会非常小，因此我们可以计算出<span class="math inline">\(N \times p\)</span>（此时我们之为<span class="math inline">\(\lambda\)</span>）的值，例如位于0到10之间，而<span class="math inline">\(S\)</span>此时就服从泊松分布，其简单的公式如下所示： <span class="math display">\[
\mbox{Pr}(S=k)=\frac{\lambda^k \exp{-\lambda}}{k!}
\]</span></p>
<p>RNA-seq分析中常常用到泊松分布。因为我们对数千个分子进行采样，并且多数基因仅仅代表了所有基因中一小部分，因此在RNA-seq分析中使用泊松分布比较合适。</p>
<p>我们知道了泊松分布后，它对我们有什么作用？其中一个方面就是这种分布可以为我们提供实际分析过程中关于统计属性的总结信息。例如我们只从患者组和对照组中各取一个样本进行RNA-seq实验并研究基因的倍数变化。此时，在零假设成立的前提下（也就是这两个样本没有差异），利用泊松分布，我们可以计算出，统计学上的统计变异取决于基因的总丰度。我们可以从数学上来展示一下这个过程，下面是模拟这个过程：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">N=<span class="number">10000</span><span class="comment">##number of genes</span></div><div class="line">lambdas=<span class="number">2</span>^seq(<span class="number">1</span>,<span class="number">16</span>,len=N) <span class="comment">##these are the true abundances of genes</span></div><div class="line">y=rpois(N,lambdas)<span class="comment">##note that the null hypothesis is true for all genes</span></div><div class="line">x=rpois(N,lambdas)</div><div class="line">ind=which(y&gt;<span class="number">0</span> &amp; x&gt;<span class="number">0</span>)<span class="comment">##make sure no 0s due to ratio and log</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">splot(log2(lambdas),log2(y/x),subset=ind)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906202636.jpeg">

</div>
<p>对于低较的<code>lambda</code>的值，存在着更多的变异，如果我们计算出了大于2倍或更高倍数的基因，那些对于低丰度的基因来说，假阳性率也会变大。</p>
<h3 id="ngs与poisson分布">NGS与Poisson分布</h3>
<p>在这一部分里，我们还是要使用公共数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BiocManager::install("parathyroidSE")</span></div><div class="line"><span class="keyword">library</span>(parathyroidSE) <span class="comment">##available from Bioconductor</span></div><div class="line">data(parathyroidGenesSE)</div><div class="line">se &lt;- parathyroidGenesSE</div></pre></td></tr></table></figure>
<p>上述的这个数据包含在<code>SummarizedExperiment</code>对象中，在此不再赘述，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; class(parathyroidGenesSE)</div><div class="line">[<span class="number">1</span>] <span class="string">"RangedSummarizedExperiment"</span></div><div class="line">attr(,<span class="string">"package"</span>)</div><div class="line">[<span class="number">1</span>] <span class="string">"SummarizedExperiment"</span></div></pre></td></tr></table></figure>
<p>我们只需要知道它包含一个数据矩阵，其中每一行都是基因组特征（可以理解为基因），每列都是一个样本。我们可以使用<code>assay()</code>函数提取这个矩阵。对于这个数据集，数据矩阵中每个单元格的数值对应了一个特定样本的一个特定基因的reads数。因此，我们可以绘制出前面类似的图形，从而表明利用实验数据构建的模型的预测行为，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x &lt;- assay(se)[,<span class="number">23</span>]</div><div class="line">y &lt;- assay(se)[,<span class="number">24</span>]</div><div class="line">ind=which(y&gt;<span class="number">0</span> &amp; x&gt;<span class="number">0</span>)<span class="comment">##make sure no 0s due to ratio and log</span></div><div class="line">splot((log2(x)+log2(y))/<span class="number">2</span>,log(x/y),subset=ind)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906203804.jpeg">

</div>
<p>如果我们计算出4个个体的标准差，它要比利用泊松模型预测的要高得多。假设大多数基因在不同的个体之间的表达不同，那么，如果泊松模型适用于此情况，那么此图中应该存在着线性关系：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(matrixStats)</div><div class="line">vars=rowVars(assay(se)[,c(<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">21</span>)]) <span class="comment">##we now these four are 4</span></div><div class="line">means=rowMeans(assay(se)[,c(<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">21</span>)]) <span class="comment">##different individulsa</span></div><div class="line">splot(means,vars,log=<span class="string">"xy"</span>,subset=which(means&gt;<span class="number">0</span>&amp;vars&gt;<span class="number">0</span>)) <span class="comment">##plot a subset of data</span></div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="number">2</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906204226.jpeg">

</div>
<p>上面图中的变异包括生物变异，但是泊松分布则无法对此进行建模。此时，我们需要另外一种分布，即负二项分布（negative binomial distribution)，这种分布整合了服从泊松分布的采样变异(sampling variability)和生物变异(biological variability)，它更适合对这种情况进行建模。负二项分布有两个参数，在处理计数数据(count data)方面有更大的灵活性。有关RNA-seq与负二项分布的内容可以参考这篇文献<a href="https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106" target="_blank" rel="external">《Differential expression analysis for sequence count data》</a>。而泊松分布只是负二项分布的一个特例。</p>
<h2 id="最大似然估计">最大似然估计</h2>
<p>为了说明最大似然估计(Maximum Likelihood Estimation, MLE)的概念，我们使用一个相对简单的数据集来进行演示，这个数据集包含HMCV（人巨细胞病毒，human cytomegalovirus）基因组的回文位置(palindrome location)信息。我们从HMCV基因组每4kb个间隔中读取回文序列的数目，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">datadir=<span class="string">"http://www.biostat.jhsph.edu/bstcourse/bio751/data"</span></div><div class="line">x=read.csv(file.path(datadir,<span class="string">"hcmv.csv"</span>))[,<span class="number">2</span>]</div><div class="line">breaks=seq(<span class="number">0</span>,<span class="number">4000</span>*round(max(x)/<span class="number">4000</span>),<span class="number">4000</span>)</div><div class="line">tmp=cut(x,breaks)</div><div class="line">counts=table(tmp)</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(counts)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906232857.jpeg">

</div>
<p>上图中的计数数据似乎服从泊松分布，但是，<span class="math inline">\(\lambda\)</span>是多少呢？常见的估计<span class="math inline">\(\lambda\)</span>的方法是最大似然估计(maximum likelihoood estimation)。最了找到最大的MLE，我们要注意这些数据是独立的，我们所观察到这些数据的概率可以用以下公式来表示： <span class="math display">\[
\Pr(X_1=k_1,\dots,X_n=k_n;\lambda) = \prod_{i=1}^n \lambda^{k_i} / k_i! \exp ( -\lambda)
\]</span> 当下面这个公式取最大值时候，MLE就等于<span class="math inline">\(\lambda\)</span>： <span class="math display">\[
\mbox{L}(\lambda; X_1=k_1,\dots,X_n=k_1)=\exp\left\{\sum_{i=1}^n \log \Pr(X_i=k_i;\lambda)\right\}
\]</span> 在实际计算过程中我们通常使用log转换后似然值(log-likehood)。下面我们使用一些代码来计算一下任意的<span class="math inline">\(\lambda\)</span>下的log-likehood，并且我们使用函数<code>optimized()</code>来计睡一下能够值得这个函数值最大的时候的<span class="math inline">\(\lambda\)</span>，最后我们绘制出log-likehood的曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">l&lt;-<span class="keyword">function</span>(lambda) sum(dpois(counts,lambda,log=<span class="literal">TRUE</span>))</div><div class="line">lambdas&lt;-seq(<span class="number">3</span>,<span class="number">7</span>,len=<span class="number">100</span>)</div><div class="line">ls &lt;- exp(sapply(lambdas,l))</div><div class="line">plot(lambdas,ls,type=<span class="string">"l"</span>)</div><div class="line">mle=optimize(l,c(<span class="number">0</span>,<span class="number">10</span>),maximum=<span class="literal">TRUE</span>)</div><div class="line">abline(v=mle$maximum)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907145959.jpeg">

</div>
<p>如果进行一些微积分计算，就会发现计算MLE其实非常简单，就是计算其均值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print( c(mle$maximum, mean(counts) ) )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print( c(mle$maximum, mean(counts) ) )</div><div class="line">[<span class="number">1</span>] <span class="number">5.157894</span> <span class="number">5.157895</span></div></pre></td></tr></table></figure>
<p>我们会注意到，观察到的计数数据与通过泊松分布预测的计算数据非常吻合：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">theoretical&lt;-qpois((seq(<span class="number">0</span>,<span class="number">99</span>)+<span class="number">0.5</span>)/<span class="number">100</span>,mean(counts))</div><div class="line">qqplot(theoretical,counts)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907155849.jpeg">

</div>
<p>因此，我们可以使用泊松分布来计算回文数据，其中<span class="math inline">\(\lambda = 5.16\)</span>。</p>
<h2 id="正连续值的分布">正连续值的分布</h2>
<p>不同的基因在生物学重复中的变化不同。在后面我们会介绍次聚类模型(hierarchical model)，这是在分析基因组学数学中最有影响力的统计学方法之一。该方法以能够极大地改善了分析差异基因的初级方法。它是通过模拟基因变异的分布来进行建模的。在这里我们会介绍这种方法的参数模型。</p>
<p>我们想模拟一下基因特异性标准误(gene-specific standard erros)。这些分布是正态分布吗？这里我们需要记住，我们现在模拟的是总体的标准误，因此CLT在此种情况下并不适用，即使我们我们拥有数几千个基因。</p>
<p>下面就是案例，在这个案例中，我们会使用一个实验数据，这个数据中包含了小鼠基因表达的技术重复和生物学重复，我们会计算出技术重复和生物学重复的基因特异性样本标准误：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(Biobase) <span class="comment">##available from Bioconductor</span></div><div class="line"><span class="comment"># install_github("genomicsclass/maPooling")</span></div><div class="line"><span class="keyword">library</span>(maPooling) <span class="comment">##available from course github repo</span></div><div class="line">data(maPooling)</div><div class="line">pd=pData(maPooling)</div><div class="line"><span class="comment">##determin which samples are bio reps and which are tech reps</span></div><div class="line">strain=factor(as.numeric(grepl(<span class="string">"b"</span>,rownames(pd))))</div><div class="line">pooled=which(rowSums(pd)==<span class="number">12</span> &amp; strain==<span class="number">1</span>)</div><div class="line">techreps=exprs(maPooling[,pooled])</div><div class="line">individuals=which(rowSums(pd)==<span class="number">1</span> &amp; strain==<span class="number">1</span>)</div><div class="line"><span class="comment">##remove replicates</span></div><div class="line">individuals=individuals[-grep(<span class="string">"tr"</span>,names(individuals))]</div><div class="line">bioreps=exprs(maPooling)[,individuals]</div><div class="line"><span class="comment">###now compute the gene specific standard deviations</span></div><div class="line"><span class="keyword">library</span>(matrixStats)</div><div class="line">techsds=rowSds(techreps)</div><div class="line">biosds=rowSds(bioreps)</div></pre></td></tr></table></figure>
<p>下面提研究样本的标准差(sample standard deviation)：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###now plot</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">shist(biosds,unit=<span class="number">0.1</span>,col=<span class="number">1</span>,xlim=c(<span class="number">0</span>,<span class="number">1.5</span>))</div><div class="line">shist(techsds,unit=<span class="number">0.1</span>,col=<span class="number">2</span>,add=<span class="literal">TRUE</span>)</div><div class="line">legend(<span class="string">"topright"</span>,c(<span class="string">"Biological"</span>,<span class="string">"Technical"</span>), col=c(<span class="number">1</span>,<span class="number">2</span>),lty=c(<span class="number">1</span>,<span class="number">1</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907172043.jpeg">

</div>
<p>从上面的图形中我们可以发现，生物学变异(biological variability)远远大于技术变异(technical variability)。这就为我们提供了一个证据，即基因确实具有基因特异性生物学变异。如果我们想要模拟这种变异，我们首先要注意到，这些变异不服从正态分布，因为上面的曲线明显出现了拖尾现象。此外，由于SD为正数，因此上面的分布也存在着一定的限制。现在我们使用qq图来看一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qqnorm(biosds)</div><div class="line">qqline(biosds)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907172353.jpeg">

</div>
<p>一些参数分布可以处理这些情况（例如严格正向右拖尾分布，strictly positive and heavy right tails）。其中比较典型的分布就是gamma分布与F分布，gamma分布的密度函数为： <span class="math display">\[
f(x;\alpha,\beta)=\frac{\beta^\alpha x^{\alpha-1}\exp{-\beta x}}{\Gamma(\alpha)}
\]</span> 这个分布有2个参数，分别是<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>，它们间接控制了曲线的位置(location)与缩放(scale)。它们也控制着曲线的形状，有关这些分布的知识可以参考<a href="https://www.stat.berkeley.edu/~rice/Book3ed/index.html" target="_blank" rel="external">《Mathematical Statistics and Data Analysis》</a>这本书。</p>
<p>gamma分布的两个特例是卡方分布与指数分布，我们前面了解到了可以使用卡方分布来计算二联表。对于卡方分布来说，我们的参数是<span class="math inline">\(\alpha=\nu/2\)</span>，<span class="math inline">\(\beta=2\)</span>，其中<span class="math inline">\(\nu\)</span>表示自由度。对于指数分布来说，<span class="math inline">\(\alpha=1\)</span>，<span class="math inline">\(\beta=\lambda\)</span>。</p>
<p>F分布在ANOVA中使用，它也是一个正向分布，并且存在着严格的右拖尾曲线，它的2个参数影响其曲线形状，，F分布的密度函数为： <span class="math display">\[
f(x,d_1,d_2)=\frac{1}{B\left( \frac{d_1}{2},\frac{d_2}{2}\right)}
  \left(\frac{d_1}{d_2}\right)^{\frac{d_1}{2}}  
  x^{\frac{d_1}{2}-1}\left(1+\frac{d1}{d2}x\right)^{-\frac{d_1+d_2}{2}}
\]</span> 这个函数中含有<span class="math inline">\(B\)</span>函数（即<span class="math inline">\(\beta\)</span>函数），还有2个自由度，即<span class="math inline">\(d_{1}\)</span>和<span class="math inline">\(d_{2}\)</span>。</p>
<h3 id="模拟变异">模拟变异</h3>
<p>在后面部分中，我们会介绍用于改善变异估计的层级模型(hierarchical model)。在这些案例中，从数学上很方便地能模拟出<span class="math inline">\(\sigma^2\)</span>的分布，关于层级模型的内容可以参考<a href="https://www.ncbi.nlm.nih.gov/pubmed/16646809" target="_blank" rel="external">《Linear models and empirical bayes methods for assessing differential expression in microarray experiments.》</a>这篇文献，此文献指出，对基因的标准差进行采样服从校正后的F统计： <span class="math display">\[
s^2 \sim s_0^2 F_{d,d_0}
\]</span> 其中<span class="math inline">\(d\)</span>表示了计算中<span class="math inline">\(s^2\)</span>的自由度。例如，当我们比较两组样本时，每组3个样本，那么自由度就是4（文中后面提到了<code>This leaves two free parameters to adjust to the data</code>，直译就是<code>剩下的2个自由参数用于调整数据</code>，不太理解）。这里的<span class="math inline">\(d\)</span>用于控制位置(location)，<span class="math inline">\(s_{0}\)</span>用于控制缩放(scale)。下面的代码是F分布的一些案例，我们绘制出了相应的图形，并且标注上了样本的方差：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">sds=seq(<span class="number">0</span>,<span class="number">2</span>,len=<span class="number">100</span>)</div><div class="line"><span class="keyword">for</span>(d <span class="keyword">in</span> c(<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>))&#123;</div><div class="line">  <span class="keyword">for</span>(s0 <span class="keyword">in</span> c(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>))&#123;</div><div class="line">    tmp=hist(biosds,main=paste(<span class="string">"s_0 ="</span>,s0,<span class="string">"d ="</span>,d),xlab=<span class="string">"sd"</span>,ylab=<span class="string">"density"</span>,freq = <span class="literal">FALSE</span>,nc=<span class="number">100</span>,xlim=c(<span class="number">0</span>,<span class="number">1</span>))</div><div class="line">    dd=df(sds^<span class="number">2</span>/s0^<span class="number">2</span>,<span class="number">11</span>,d)</div><div class="line">    <span class="comment">##multiply by normalizing constant to assure same range on plot</span></div><div class="line">    k=sum(tmp$density)/sum(dd)</div><div class="line">    lines(sds,dd*k,type=<span class="string">"l"</span>,col=<span class="number">2</span>,lwd=<span class="number">2</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907184007.jpeg">

</div>
<p>从上面的图形我们要找到哪个图形的<span class="math inline">\(s_{0}\)</span>与<span class="math inline">\(d\)</span>最能拟合我们的数据？这是一个比较麻烦的过程，因为MLE并不会计算这个特殊的分布（具体可以参考Wmyth(2004)）。Bioconductor上的<code>limma</code>包提供的估计这些参数的函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">estimates=fitFDist(biosds^<span class="number">2</span>,<span class="number">11</span>)</div><div class="line">theoretical&lt;- sqrt(qf((seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span>, <span class="number">11</span>, estimates$df2)*estimates$scale)</div><div class="line">observed &lt;- biosds</div></pre></td></tr></table></figure>
<p>拟合模型确实提供了一个合理的估计，从qq图和直方图就能看出来：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">qqplot(theoretical,observed)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">tmp=hist(biosds,main=paste(<span class="string">"s_0 ="</span>, signif(estimates[[<span class="number">1</span>]],<span class="number">2</span>), <span class="string">"d ="</span>, signif(estimates[[<span class="number">2</span>]],<span class="number">2</span>)), xlab=<span class="string">"sd"</span>, ylab=<span class="string">"density"</span>, freq=<span class="literal">FALSE</span>, nc=<span class="number">100</span>, xlim=c(<span class="number">0</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">9</span>))</div><div class="line">dd=df(sds^<span class="number">2</span>/estimates$scale,<span class="number">11</span>,estimates$df2)</div><div class="line">k=sum(tmp$density)/sum(dd) <span class="comment">##a normalizing constant to assure same area in plot</span></div><div class="line">lines(sds, dd*k, type=<span class="string">"l"</span>, col=<span class="number">2</span>, lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907184617.jpeg">

</div>
<h2 id="练习">练习</h2>
<p>P297</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/22/DAL/DALS017_InferenceForHighDimensionalData2_Principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/DAL/DALS017_InferenceForHighDimensionalData2_Principle/" itemprop="url">DALS017-高维数据推断2-统计原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:00:00+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,658
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第6章线性模型的第2小节，这一部分的主要内容涉及高维数据统计的一些原理，相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/advinference/multiple_testing.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="高维数据的p值">高维数据的p值</h2>
<p>在前面我们了解了，当我们在分析高维数据时，p值就不再是一个很好的统计指标了。这是因为，我们同一次检测了许多特征值(feature)。这种检测手段被称为多重比较( multiple comparison)，或多重检测(multiple testing)，或多重性问题(multiplicity)。在此情况下，p值就不再适用。另外，当我们同时检测多个假设问题时，仅仅基于一个小p值的阈值，例如0.01，这就很容易导假阳性。针对这种情况，我们需要定义一个新的术语来研究高通量数据。</p>
<p>为了处理多重比较的问题，我们广泛使用的方法就是定义一个程序(procedure，也可以说是一种算法，也可以翻译为<code>校正</code>等等，总之，表达的是一个意思)，然后用它来估计或控制(control)计算过程中的错误率(rate error)。我们这里所说的<code>控制(control)</code>的意思是说，我们会采用这个程序来保证错误率(error rate)低于某个提前设定的值。通过参数或截止值(cutoff)来进行设定的这个程序通常比较灵活，它会让我们能够控制特异性(specificity)和灵敏度(sensitivity)，这种程序的一个典型功能如下所示：</p>
<ul>
<li>计算每个基因的p值；</li>
<li>计算出p值小于<span class="math inline">\(\alpha\)</span>的所有显著性基因。</li>
</ul>
<p>这里需要注意的是，当我们改变<span class="math inline">\(\alpha\)</span>值时，会调整相应的特异性(specificity)和灵敏度(sensitivity)。</p>
<p>接着我们来定义错误率(error rate)，它会让我们对统计过程进行估计和控制。</p>
<h2 id="错误率">错误率</h2>
<p>在这一部分中，我们会了解到I类错误与II类错误，这两类错误分别代表假阳性(false positives)与假阴性(false negatives)。通常，特异性(specificity)与I类错误有关，灵敏性(sensitivity)与II类错误有关。</p>
<p>在一次高通量实验里，我们会犯第I类错误和第II类错误。我们参考了Benjamini-Hochberg的论文，做了以下表格，总结了这些错误，如下所示：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Called significant（真）</th>
<th>Not called significant（假）</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Null True</td>
<td><span class="math inline">\(V\)</span></td>
<td><span class="math inline">\(m_0-V\)</span></td>
<td><span class="math inline">\(m_0\)</span></td>
</tr>
<tr class="even">
<td>Alternative True</td>
<td><span class="math inline">\(S\)</span></td>
<td><span class="math inline">\(m_1-S\)</span></td>
<td><span class="math inline">\(m_1\)</span></td>
</tr>
<tr class="odd">
<td>True</td>
<td><span class="math inline">\(R\)</span></td>
<td><span class="math inline">\(m-R\)</span></td>
<td><span class="math inline">\(m\)</span></td>
</tr>
</tbody>
</table>
<p>为了说明这个表格中的内容，我们来打个比方，假设我们检测了10000个基因，这就意味着我们需要做检测的次数为<span class="math inline">\(m=10000\)</span>。</p>
<p>那些零假设是真的基因数目（多数是我们不感兴趣的基因，零假设为真，也就是说这些基因在对照和实验组中都没有显著性差异）为<span class="math inline">\(m_{0}\)</span>，那些零假设为假的基因数目为<span class="math inline">\(m_{1}\)</span>，零假设为假，也就是说，替代假设(alternative hypothesis)为真（不一定严谨，反正就是说零假设为假）。通常来说，我们感兴趣的是尽可能地检测到那些替代假设为真的基因（真阳性），避免检测到那些零假设为真的基因（假阳性）。对于多数高通量实验来说，我们会假设<span class="math inline">\(m_{0}\)</span>远大于<span class="math inline">\(m_{1}\)</span>（这句话我的理解就是，在一次高通量实验中，没差异基因的数目<span class="math inline">\(m_{0}\)</span>要大于有差异基因的数目<span class="math inline">\(m_{1}\)</span>）。</p>
<p>例如我们检测了10000个基因，对其中约有100个基因感兴趣。这也就是说，<span class="math inline">\(m_1 \leq 100\)</span> 并且 <span class="math inline">\(m_0 \geq 19,900\)</span>。</p>
<p>在这一章中，我们指的特征值(feature)就是我们的检测值。在遗传学中，这些特征值可以是基因(genes)，转录本(transcripts)，结合位点(binding sites)，CpG岛和SNPs。</p>
<p>在上面的那个表格中，<span class="math inline">\(R\)</span>表示的是经过检测后，有显著性差异的特征值的数目总和，而<span class="math inline">\(m-R\)</span>则表示不显著的基因数目。表格中剩下的部分表示的是一些实际上未知的重要的量。</p>
<ul>
<li><span class="math inline">\(V\)</span>表示I类错误或假阳性。更具体地来说就是，<span class="math inline">\(V\)</span>表示了那些零假设为真的特征值的数目。</li>
<li><span class="math inline">\(S\)</span>表示的是真阳性的数目。具体地来说就是，<span class="math inline">\(S\)</span>表示替代假设为真的特征值的数目。</li>
</ul>
<p><span class="math inline">\(m_{1}-S\)</span>表示了II类错误或假阴性，<span class="math inline">\(m_{0}-V\)</span>表示真阴性。</p>
<p>这里需要牢记的是，当我们只做一次检测时，p就仅仅是当<span class="math inline">\(V=1\)</span>，<span class="math inline">\(m=m_{0}=1\)</span>时的概率。功效(power)就是当<span class="math inline">\(S=1\)</span>，<span class="math inline">\(m=m_{1}=1\)</span>时的概率。在这种非常简单的案例里，我们并不制作上面类似的表格，但是我们会说明一下，如何定义表格中的术语，从而帮助我们处理高维数据。</p>
<h2 id="数据案例">数据案例</h2>
<p>现在看一个案例。在这个案例中我们会使用小鼠数据进行Monte Carlo模拟，从而模拟一种情况，在这种情况里，我们会检测10000种对小鼠体重无影响的减肥饲料(fad diets)。这就是说，在零假设下，这些饲料对小鼠体重没影响为真，也就是说<span class="math inline">\(m=m_{0}=10000\)</span>，并且<span class="math inline">\(m_{1}=0\)</span>，现在我们先进行一个样本数目为12的计算，并且我们认为p值小于<span class="math inline">\(\alpha=0.05\)</span>显著，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">population = unlist( read.csv(<span class="string">"femaleControlsPopulation.csv"</span>) )</div><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">N &lt;- <span class="number">12</span></div><div class="line">m &lt;- <span class="number">10000</span></div><div class="line">pvals &lt;- replicate(m,&#123;</div><div class="line">  control = sample(population,N)</div><div class="line">  treatment = sample(population,N)</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div><div class="line">sum(pvals &lt; <span class="number">0.05</span>) <span class="comment">##This is R</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>) <span class="comment">##This is R</span></div><div class="line">[<span class="number">1</span>] <span class="number">462</span></div></pre></td></tr></table></figure>
<p>从结果我们可以看出，这个假阳性（462个）还是比较高的，这是要在多数分析中是要避免的。</p>
<p>下面我们来看一个更加复杂的代码，这段代码会进行人为设定10%的饮食有效，平均效应(average effect size)为<span class="math inline">\(\Delta=3\)</span>盎司（约85克）。仔细研究这段代码可以帮助我们理解上面的那个表格，现在我们先来定义这样的数据，其中10%有效：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">N &lt;- <span class="number">12</span></div><div class="line">m &lt;- <span class="number">10000</span></div><div class="line">p0 &lt;- <span class="number">0.90</span> <span class="comment">##10% of diets work, 90% don't</span></div><div class="line">m0 &lt;- m*p0</div><div class="line">m1 &lt;- m-m0</div><div class="line">nullHypothesis &lt;- c( rep(<span class="literal">TRUE</span>,m0), rep(<span class="literal">FALSE</span>,m1))</div><div class="line">delta &lt;- <span class="number">3</span></div></pre></td></tr></table></figure>
<p>现在我们做10000次模拟统计，每次都采用t检验，并记录下来：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">calls &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,N)</div><div class="line">  treatment &lt;- sample(population,N)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  ifelse( t.test(treatment,control)$p.value &lt; alpha,</div><div class="line">          <span class="string">"Called Significant"</span>,</div><div class="line">          <span class="string">"Not Called Significant"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>由于我们知道哪些是数据是有差异的（毕竟是自己人为生成的，保存在了<code>nullHypothesis</code>中)，我们现在计算一下上面的表格，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">null_hypothesis &lt;- factor( nullHypothesis, levels=c(<span class="string">"TRUE"</span>,<span class="string">"FALSE"</span>))</div><div class="line">table(null_hypothesis,calls)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; null_hypothesis &lt;- factor( nullHypothesis, levels=c(<span class="string">"TRUE"</span>,<span class="string">"FALSE"</span>))</div><div class="line">&gt; table(null_hypothesis,calls)</div><div class="line">               calls</div><div class="line">null_hypothesis Called Significant Not Called Significant</div><div class="line">          <span class="literal">TRUE</span>                 <span class="number">421</span>                   <span class="number">8579</span></div><div class="line">          <span class="literal">FALSE</span>                <span class="number">520</span>                    <span class="number">480</span></div></pre></td></tr></table></figure>
<p>结果中的第1列就是<span class="math inline">\(V\)</span>与<span class="math inline">\(S\)</span>，需要注意的是，<span class="math inline">\(V\)</span>与<span class="math inline">\(S\)</span>是随机变量，如果我们再次运行这段代码以，这些值就会改变，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">B &lt;- <span class="number">10</span> <span class="comment">##number of simulations</span></div><div class="line">VandS &lt;- replicate(B,&#123;</div><div class="line">  calls &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">    control &lt;- sample(population,N)</div><div class="line">    treatment &lt;- sample(population,N)</div><div class="line">    <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">    t.test(treatment,control)$p.val &lt; alpha</div><div class="line">  &#125;)</div><div class="line">  cat(<span class="string">"V ="</span>,sum(nullHypothesis &amp; calls), <span class="string">"S ="</span>,sum(!nullHypothesis &amp; calls),<span class="string">"\n"</span>)</div><div class="line">  c(sum(nullHypothesis &amp; calls),sum(!nullHypothesis &amp; calls))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">V = <span class="number">410</span> S = <span class="number">564</span> </div><div class="line">V = <span class="number">400</span> S = <span class="number">552</span> </div><div class="line">V = <span class="number">366</span> S = <span class="number">546</span> </div><div class="line">V = <span class="number">382</span> S = <span class="number">553</span> </div><div class="line">V = <span class="number">372</span> S = <span class="number">505</span> </div><div class="line">V = <span class="number">382</span> S = <span class="number">530</span> </div><div class="line">V = <span class="number">381</span> S = <span class="number">539</span> </div><div class="line">V = <span class="number">396</span> S = <span class="number">554</span> </div><div class="line">V = <span class="number">380</span> S = <span class="number">550</span> </div><div class="line">V = <span class="number">405</span> S = <span class="number">569</span></div></pre></td></tr></table></figure>
<p>针对这种情况，我们就定义了错误率(error rate)。例如，我们可以估计<span class="math inline">\(V\)</span>大于0的概率。它可以解释为，在10000次检验中，我们出现I类错误的概率。在上述模拟数据中，<span class="math inline">\(V\)</span>在每次模拟中都大于1，因此我们怀疑这个概率实际上就是1（这里的1就是“V大于0”这个事件的概率，换句话讲，就是，在这个检验中，必然会出现假阳性）。</p>
<p>当<span class="math inline">\(m=1\)</span>时，这个概率就等于p值。当我们进行多重检验模拟时，我们称之为多重比较谬误(Family Wide Error Rate,FWER)，它与我们广泛使用的一个检验方法有关，即Bonferroni校正( Bonferroni Correction)。</p>
<h2 id="bonferroni校正">Bonferroni校正</h2>
<p>现在我们了解一下FWER是如何运用的，在实际的分析中，我们会选择一个程序(procedure)来保证FWER小于某个提前设定好的阈值，例如0.05，通常情况下，就使用<span class="math inline">\(\alpha\)</span>来表示。</p>
<p>现在我们来描述一个这样的程序：拒绝所有p值小于0.01的假设。</p>
<p>为了说明这个目的，我们假设所有的检验都是独立的（在10000个饲料检验的实验里，这个假设是成立的；但是在一些遗传学实验里，这个假设有可能不成立，因为某些基因会共同发挥作用）。每次检验得到的p值我们用<span class="math inline">\(p_1,\dots,p_{10000}\)</span>表示。这些独立的随机变量如下所示： <span class="math display">\[
\begin{align*}
\mbox{Pr}(\mbox{at least one rejection}) &amp;= 1 -\mbox{Pr}(\mbox{no rejections}) \\
&amp;= 1 - \prod_{i=1}^{10000} \mbox{Pr}(p_i&gt;0.01) \\
&amp;= 1-0.99^{10000} \approx 1
\end{align*}
\]</span> 如果我们要模拟这个过程，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">B&lt;-<span class="number">10000</span></div><div class="line">minpval &lt;- replicate(B, min(runif(<span class="number">10000</span>,<span class="number">0</span>,<span class="number">1</span>))&lt;<span class="number">0.01</span>)</div><div class="line">mean(minpval&gt;=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(minpval&gt;=<span class="number">1</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div></pre></td></tr></table></figure>
<p>因此，我们计算出来的FWER是1，这并非我们想要的结果。如果我们想要它低于<span class="math inline">\(\alpha=0.05\)</span>，那么我们的统计就是失败的。</p>
<p>我们如何做才能使得一个错误出现的概率低于<span class="math inline">\(\alpha\)</span>呢，我们可以使用上面的公式推导一下，通过选择更严格的截止值(cutoff），之前的是0.01，从而将我们的错误降低至至少5%的水平，如下所示： <span class="math display">\[
\mbox{Pr}(\mbox{at least one rejection}) =  1-(1-k)^{10000}
\]</span> 解这个方程，我们就得到了 <span class="math inline">\(1-(1-k)^{10000}=0.01 \implies k = 1-0.99^{1/10000} \approx 1e-6\)</span></p>
<p>这就是我们给出的一个程序案例。这实际上就是Sikdak过程。尤其是，当我们定义一个说明，例如<code>拒绝所有p值小于 0.000005的零假设</code>。然后，我们知道了p值是一个随机变量，我们会使用统计理论来计算，如果我们遵循这个程序，平均会犯多少错误。更确切地讲就是，我们可以计算出这些错误的边界，也就是说，这些错误小于某些预定值的比例。</p>
<p>Sidak校正的一个问题是，这个校正假设所有的检验都是独立的。因此当这个假设时成立的，它只能控制FWER。百Bonferroini校正则更为通用，因为即使每个检测不独立，它也能控制FWER。。与Sidak校正一样，我们首先来看一下： <span class="math display">\[
FWER = \mbox{Pr}(V&gt;0) \leq \mbox{Pr}(V&gt;0 \mid \mbox{all nulls are true})
\]</span></p>
<p>现在使用前面表格的那种表示方法为： <span class="math display">\[
\mbox{Pr}(V&gt;0) \leq \mbox{Pr}(V&gt;0 \mid m_1=0)
\]</span> Bonferoni校正会设定<span class="math inline">\(k=\alpha/m\)</span>，因此可以写为如下形式： <span class="math display">\[
\begin{align*}
\mbox{Pr}(V&gt;0 \,\mid \, m_1=0) &amp;= \mbox{Pr}\left( \min_i \{p_i\} \leq \frac{\alpha}{m} \mid m_1=0 \right)\\
 &amp;\leq \sum_{i=1}^m \mbox{Pr}\left(p_i \leq \frac{\alpha}{m} \right)\\
 &amp;= m \frac{\alpha}{m}=\alpha
\end{align*}
\]</span> 将FWER控制在0.05水平是一种非常保守的方法，现在我们使用前面计算的p值来计算一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">pvals &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,N)</div><div class="line">  treatment &lt;- sample(population,N)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>只需要关于p值是否小于0.05/10000即可，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">2</span></div></pre></td></tr></table></figure>
<p>当使用了Bonferroni校正后，即使我们进行了10000次饮食实验，却只有发现2个假阳性的结果，Bonferroni是一种非常严格的校正。</p>
<h2 id="错误发现率fdr">错误发现率(FDR)</h2>
<p>在许多情况下，要求FWER是0.05没多大意义，因为它太严格了。例如，我们常见的做法就是先进行初步的小型实验来确定小数候选基因。这种做法被称为之发现驱动的实验或项目。我们也许会寻找一个未知的致病基因，而不仅仅是对候选基因进行采用更多的样本进行后续研究。如果我们开发一个程序，例如一个10个基因列表，从中发现1到2个为重要的基因，这个实验就算非常成功。小样本实验，实现<span class="math inline">\(FWER\leq0.05\)</span>的唯一途径就是使用一个空的基因列表。在前面我们已经看到，虽然只有1000种包含有效，但是最终我们只得到2个饮食有效这样一个结果，如果把样本数目降低到6，这个结果有可能就是0，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">pvals &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,<span class="number">6</span>)</div><div class="line">  treatment &lt;- sample(population,<span class="number">6</span>)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div><div class="line">sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>由于我们要求<span class="math inline">\(FWER\leq 0.05\)</span>，因此我们实际上就是0功效（灵敏度）。在许多方法中，这种情况称为特异性(specificity)过强(over-kill)。替代FWER的另外一种方法就是FDR，即错误发现率(false discover rate)。FDR背后的思想就是集中关注Q值，即 <span class="math inline">\(Q \equiv V/R\)</span>，当<span class="math inline">\(R=0,V=0\)</span>时，<span class="math inline">\(Q=0\)</span>。其中，当<span class="math inline">\(R=0\)</span>（没有显著性）就表明，<span class="math inline">\(V=0\)</span>（没有假阳性）。因此<span class="math inline">\(Q\)</span>是一个随机变量，它的范围是0到1，通过计算Q的平均值，我们可以定义一个比值(rate)，它所表示的是意思是，在显著的基因里，假阳性的基因占的比例。为了更好地理解这个概含，我们计算Q的程序要求调用所有的p值都小于0.05。</p>
<h2 id="向量化代码">向量化代码</h2>
<p>在R中可以使用<code>sapply()</code>系列函数来加快运行速度，前面已经看到了这个函数的使用方法，现在使用传统的代码来看一下Q值的计算方法，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(genefilter) <span class="comment">##rowttests is here</span></div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line"><span class="comment">##Define groups to be used with rowttests</span></div><div class="line">g &lt;- factor( c(rep(<span class="number">0</span>,N),rep(<span class="number">1</span>,N)) )</div><div class="line">B &lt;- <span class="number">1000</span> <span class="comment">##number of simulations</span></div><div class="line">Qs &lt;- replicate(B,&#123;</div><div class="line">  <span class="comment">##matrix with control data (rows are tests, columns are mice)</span></div><div class="line">  controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  <span class="comment">##matrix with control data (rows are tests, columns are mice)</span></div><div class="line">  treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  <span class="comment">##add effect to 10% of them</span></div><div class="line">  treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">  <span class="comment">##combine to form one matrix</span></div><div class="line">  dat &lt;- cbind(controls,treatments)</div><div class="line">  calls &lt;- rowttests(dat,g)$p.value &lt; alpha</div><div class="line">  R=sum(calls)</div><div class="line">  Q=ifelse(R&gt;<span class="number">0</span>,sum(nullHypothesis &amp; calls)/R,<span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span>(Q)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; head(Qs)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4513274</span> <span class="number">0.4063786</span> <span class="number">0.4568627</span> <span class="number">0.4490414</span> <span class="number">0.4468314</span> <span class="number">0.4315569</span></div><div class="line">&gt; tail(Qs)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4390756</span> <span class="number">0.4718657</span> <span class="number">0.4395373</span> <span class="number">0.4425711</span> <span class="number">0.4536391</span> <span class="number">0.4284284</span></div></pre></td></tr></table></figure>
<h2 id="控制fdr">控制FDR</h2>
<p>上述代码使用Monte Carlo模拟计算了1000次10000个样本的实验，并保存了Q值，现在看一下Q值的直方图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(Qs) <span class="comment">##Q is a random variable, this is its distribution</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831135218.jpeg">

</div>
<p>FDR就是Q值的平均值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FDR=mean(Qs)</div><div class="line">print(FDR)</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(FDR)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4463354</span></div></pre></td></tr></table></figure>
<p>这里的计算结果表明，FDR值比较高。这是因为对于90%的统计检验而言，零假设是真。这就暗示了，由于p值是cutoff值为0.05，100个检验中，大概有4到5个是假阳性。再加上我们没有考虑到替代所设为真时的所有情况，因此FDR值就比较高。那么我们如何控制它呢，如果我们想要更低的FDR值，比如5%怎么办？</p>
<p>为了用图形说明FDR为什么这么高，我们来绘制p值的直方图。我们使用一个较大的<code>m</code>值从直方图中获取更多的数据。再绘制一条水平线，表示当NULL为真时，从<span class="math inline">\(m_{0}\)</span>个案例（指的基因或其它检测值，<span class="math inline">\(m_{0}\)</span>就是没有统计学差异的基因）中到的阳性结果的均匀分布，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">dat &lt;- cbind(controls,treatments)</div><div class="line">pvals &lt;- rowttests(dat,g)$p.value</div><div class="line">h &lt;- hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.05</span>))</div><div class="line">polygon(c(<span class="number">0</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,h$counts[<span class="number">1</span>],h$counts[<span class="number">1</span>]),col=<span class="string">"grey"</span>)</div><div class="line">abline(h=m0/<span class="number">20</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831140759.jpeg">

</div>
<p>第1个柱子（灰色）表示提p值小于0.05的基因的数目，从水平线可知，大概有一半p值小于0.05的基因是假阳性，这与前面提到的FDR=0.5是一致的。我们来看一下当柱子的宽度为0.01时FDR的值会更低，但同时我们的显著性差异数目也会降低。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">h &lt;- hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.01</span>))</div><div class="line">polygon(c(<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0.01</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,h$counts[<span class="number">1</span>],h$counts[<span class="number">1</span>]),col=<span class="string">"grey"</span>)</div><div class="line">abline(h=m0/<span class="number">100</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831142643.jpeg">

</div>
<p>当柱子的宽度变为0.01时，我们可以看到一个更小的p值cutoff，并且检测到到特征值的数目也会下降（降低了灵敏性sensitivity)，但是，FDR也会降低（提高了特异性specificity）。我们如何设定这个cutoff呢？其中一个方法就是设定一个FDR水平<span class="math inline">\(\alpha\)</span>，然后设置控制错误率的程序即可：<span class="math inline">\(FDR \leq \alpha\)</span>。</p>
<h2 id="benjamini-hochberg">Benjamini-Hochberg</h2>
<p>对于任意给定的<span class="math inline">\(\alpha\)</span>，Benjamini-Hochberg方法都非常适用，这种方法可以让使用者地每个检验的p值进行校正，也能很好地定义一个程序。</p>
<p>Benjamini-Hochberg方法的原理是，先按照升序对p值进行排列，即<span class="math inline">\(p_{(1)},\dots,p_{(m)}\)</span>，然后定义一个<span class="math inline">\(k\)</span>用来表示最大的秩<span class="math inline">\(i\)</span>，它所对应的p值为： <span class="math display">\[
p_{(i)} \leq \frac{i}{m}\alpha
\]</span> 这个程序会拒绝那些p值小于或等于<span class="math inline">\(p_{(k)}\)</span>的检验。现在看一个案例，如何选择<span class="math inline">\(k\)</span>来计算p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">i = seq(along=pvals)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(i,sort(pvals))</div><div class="line">abline(<span class="number">0</span>,i/m*alpha)</div><div class="line"><span class="comment">##close-up</span></div><div class="line">plot(i[<span class="number">1</span>:<span class="number">15</span>],sort(pvals)[<span class="number">1</span>:<span class="number">15</span>],main=<span class="string">"Close-up"</span>)</div><div class="line">abline(<span class="number">0</span>,i/m*alpha)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831145524.jpeg">

</div>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">k &lt;- max( which( sort(pvals) &lt; i/m*alpha) )</div><div class="line">cutoff &lt;- sort(pvals)[k]</div><div class="line">cat(<span class="string">"k ="</span>,k,<span class="string">"p-value cutoff="</span>,cutoff)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"k ="</span>,k,<span class="string">"p-value cutoff="</span>,cutoff)</div><div class="line">k = <span class="number">11</span> p-value cutoff= <span class="number">3.763357e-05</span></div></pre></td></tr></table></figure>
<p>我们可以从数学上证明到这个程序可以将FDR控制在5%以下，具体的算法可以参考Benjamini-Hochberg在1995年的论文。这种新的程序计算的结果就是将原来得到的2个有统计学差异的数值提高到了11个。如果我们将FDR的值设为50%，那么这个数字会提高到1063。FWER无法提供这种灵活性，因为只要检测值的数量增加，都会造成FWER的值为1。</p>
<p>这里我们需要注意的是，在R中，已经有了计算FDR的函数，前面的那些复杂代码只是为了说明这种算法，在R中我们可以使用下面的代码进行计算，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fdr &lt;- p.adjust(pvals, method=<span class="string">"fdr"</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(pvals,fdr,log=<span class="string">"xy"</span>)</div><div class="line">abline(h=alpha,v=cutoff) <span class="comment">##cutoff was computed above</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831151618.jpeg">

</div>
<p>我们也可以使用Monte Carlo模拟来确认一下FDR的值实际上小于0.05，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">B &lt;- <span class="number">1000</span> <span class="comment">##number of simulations. We should increase for more precision</span></div><div class="line">res &lt;- replicate(B,&#123;</div><div class="line">  controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">  dat &lt;- cbind(controls,treatments)</div><div class="line">  pvals &lt;- rowttests(dat,g)$p.value</div><div class="line">  <span class="comment">##then the FDR</span></div><div class="line">  calls &lt;- p.adjust(pvals,method=<span class="string">"fdr"</span>) &lt; alpha</div><div class="line">  R=sum(calls)</div><div class="line">  Q=ifelse(R&gt;<span class="number">0</span>,sum(nullHypothesis &amp; calls)/R,<span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span>(c(R,Q))</div><div class="line">&#125;)</div><div class="line">Qs &lt;- res[<span class="number">2</span>,]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(Qs) <span class="comment">##Q is a random variable, this is its distribution</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831180342.jpeg">

</div>
<p>上述是Q值的直方图（假阳性除以显著性特征值的数目），现在看一下FDR值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FDR=mean(Qs)</div><div class="line">print(FDR)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; FDR=mean(Qs)</div><div class="line">&gt; print(FDR)</div><div class="line">[<span class="number">1</span>] <span class="number">0.03813818</span></div></pre></td></tr></table></figure>
<p>这个FDR的值小于0.05，这个结果是符合预期的，因为我们需要保守一点，从而确保任何值的<span class="math inline">\(m_{0}\)</span>的FDR都小于0.05，例如当每个假设检验都是零的极端情况，例如<span class="math inline">\(m=m_{0}\)</span>。如果你重新模拟上述情况，你会发现FDR会增加。</p>
<p>我们需要注意下面的值：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Rs &lt;- res[<span class="number">1</span>,]</div><div class="line">&gt; mean(Rs==<span class="number">0</span>)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">0.7</span></div></pre></td></tr></table></figure>
<p>在模拟中，这个比例是0.7%，我们没有调用任何有显著性差异的基因。</p>
<p>在R中，<code>p.adjust()</code>函数可以选择一些算法来控制FDR，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; p.adjust.methods</div><div class="line">[<span class="number">1</span>] <span class="string">"holm"</span>       <span class="string">"hochberg"</span>   <span class="string">"hommel"</span>     <span class="string">"bonferroni"</span> <span class="string">"BH"</span>         <span class="string">"BY"</span>         <span class="string">"fdr"</span>        <span class="string">"none"</span></div></pre></td></tr></table></figure>
<p>上面的这些方法不仅仅是估计错误率的不同方法，并且它们的估计值也不同，也就是说FWER与FDR不同。</p>
<h2 id="直接fdr与q值">直接FDR与q值</h2>
<p>这里我们先回顾一下由John D.Storey在J. R. Statist. Soc. B(2002)中提到的结果。Storey与Benjamini-Hochberg方法的不同之处在于，前者不再提前设定<span class="math inline">\(\alpha\)</span>水平。因为在一些高通量实验中，我们感兴趣的仅仅是找到一个基因列表用于验证这些基因，我们会事先考虑将那些p值小于0.01的基因都进行验证。我们人随后会考虑估计的错误率。通常使用这些方法，我们会确保我们的<span class="math inline">\(R&gt;0\)</span>。在上述定义的FDR里，当<span class="math inline">\(R=V=0\)</span>时，我们指定<span class="math inline">\(Q=0\)</span>，因此我们可以计算FDR如下所示： <span class="math display">\[
\mbox{FDR} = E\left( \frac{V}{R} \mid R&gt;0\right) \mbox{Pr}(R&gt;0)
\]</span> 在Storey提出的方法里，我们需要构建一个非空列表，也就是说<span class="math inline">\(R&gt;0\)</span>，那么我们计算阳性FDR(positive FDR)的公式如下所示： <span class="math display">\[
\mbox{pFDR} = E\left( \frac{V}{R} \mid R&gt;0\right)
\]</span> 第二点不同之处在于，Benjamini和Hochberg的程度是在最差的情况下进行控制，最差的情况是指零假设都为真（<span class="math inline">\(m=m_{0}\)</span>的情况），Storey的方法则是让我们从数据中估计<span class="math inline">\(m_{0}\)</span>。因为在高通量实验中，我们已经获得了如此多的数据，使Storey的算法成为了可能。这种算法的大致思路就是，挑选一个相对高值的p值cut-off，将它称为<span class="math inline">\(\lambda\)</span>，并且假设那些p值大于<span class="math inline">\(\Lambda\)</span>的检验在多数情况下其零假设是成立的，因此我们可以计算出估计值<span class="math inline">\(\pi_0 = m_0/m\)</span>为： <span class="math display">\[
\hat{\pi}_0 = \frac{\#\left\{p_i &gt; \lambda \right\} }{ (1-\lambda) m }
\]</span> 还有其它比这种算法更复杂的算法，但是它们的思路都是一样的，例如当我们设定<span class="math inline">\(\lambda=0.1\)</span>时，我们计算一下p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.05</span>),freq=<span class="literal">FALSE</span>)</div><div class="line">lambda = <span class="number">0.1</span></div><div class="line">pi0=sum(pvals&gt; lambda) /((<span class="number">1</span>-lambda)*m)</div><div class="line">abline(h= pi0)</div><div class="line">print(pi0) <span class="comment">##this is close to the trye pi0=0.9</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190901144305.jpeg">

</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(pi0) ##this is close to the trye pi0=0.9</div><div class="line">[1] 0.9311111</div></pre></td></tr></table></figure>
<p>根据这个估计，我们可以改变一下Benjamini-Hochberg程序，例如选择一个<span class="math inline">\(k\)</span>作为最大值（<span class="math inline">\(k\)</span>这里是最大的<span class="math inline">\(i\)</span>），因此就有如下公式： <span class="math display">\[
\hat{\pi}_0 p_{(i)} \leq \frac{i}{m}\alpha
\]</span> 我们还有一种方法可以计算校正后的p值，即对每个检验计算q值(q-value)，如果一个特征计算的p值为<span class="math inline">\(p\)</span>，那么q值就是一系列含有最小p值为<span class="math inline">\(p\)</span>的特征值的估计pFDR。</p>
<p>除此之外，我们还有一种方法可以计算校正后的p值，即对每个检验计算q值(<code>q-value</code>)，如果一个特征最终计算的p值为<span class="math inline">\(p\)</span>，那么q值就是一系列含有尽可能最小与<span class="math inline">\(p\)</span>相等的p值的特征值的估计pFDR（原文是：However, instead of doing this, we compute a q-value for each test. If a feature resulted in a p-value of <span class="math inline">\(p\)</span>, the q-value is the estimated pFDR for a list of all the features with a p-value at least as small as <span class="math inline">\(p\)</span>.）。</p>
<p>上面这段我也不理解，后来查中文资料，根据Benjamini-Hochberg的算法，q值的定义如下所示：</p>
<p>对于m个独立的假设检验，它们对就的p值为：<span class="math inline">\(p_{i},i=1,2,\cdots,m\)</span></p>
<ol style="list-style-type: decimal">
<li>按照升序的方法对这些p值进行排序，得到：</li>
</ol>
<p><span class="math display">\[
p_{(1)} \leq p_{(1)} \cdots \leq p_{(m)}
\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>对于给定的统计学检验水平<span class="math inline">\(\alpha in(0,1]\)</span>，找到最大的<span class="math inline">\(k\)</span>，使得：</li>
</ol>
<p><span class="math display">\[
p_{(k)} \leq \frac{a*k}{m}
\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>对于排序靠前的<span class="math inline">\(k\)</span>个假设检验，认为它们是真阳性，看下面的案例：</li>
</ol>
<p>现在我们做了6个基因的检验，它们的p值如下所示：</p>
<table>
<thead>
<tr class="header">
<th>Gene</th>
<th>p-value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>G1</td>
<td>p1=0.053</td>
</tr>
<tr class="even">
<td>G2</td>
<td>p2=0.001</td>
</tr>
<tr class="odd">
<td>G3</td>
<td>p3=0.045</td>
</tr>
<tr class="even">
<td>G4</td>
<td>p4=0.03</td>
</tr>
<tr class="odd">
<td>G5</td>
<td>p5=0.02</td>
</tr>
<tr class="even">
<td>G6</td>
<td>p6=0.01</td>
</tr>
</tbody>
</table>
<p>现在取检测水平<span class="math inline">\(\alpha=0.05\)</span>，先把p值按从小到大的升序排列：</p>
<table>
<thead>
<tr class="header">
<th>Gene</th>
<th>p-value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>G2</td>
<td>p2=0.001</td>
</tr>
<tr class="even">
<td>G6</td>
<td>p6=0.01</td>
</tr>
<tr class="odd">
<td>G5</td>
<td>p5=0.02</td>
</tr>
<tr class="even">
<td>G4</td>
<td>p4=0.03</td>
</tr>
<tr class="odd">
<td>G3</td>
<td>p3=0.045</td>
</tr>
<tr class="even">
<td>G1</td>
<td>p1=0.053</td>
</tr>
</tbody>
</table>
<p>取检测水平<span class="math inline">\(\alpha=0.05\)</span>，现在我们找到一个值<span class="math inline">\(k\)</span>，这个<span class="math inline">\(k\)</span>满足以下公式： <span class="math display">\[
p_{(k)} \leq \frac{a*k}{m}
\]</span> 当<span class="math inline">\(k=1\)</span>时，<span class="math inline">\(p_{(1)}=0.001 &lt; 0.05*1/6=0.008333333\)</span></p>
<p>当<span class="math inline">\(k=2\)</span>时，<span class="math inline">\(p_{(2)}=0.01&lt;0.05*2/6=0.01666667\)</span></p>
<p>当<span class="math inline">\(k=3\)</span>时，<span class="math inline">\(p_{(3)}=0.02&lt;0.05*3/6=0.025\)</span></p>
<p>当<span class="math inline">\(k=4\)</span>时，<span class="math inline">\(p_{(4)}=0.03&lt;0.05*4/6=0.03333333\)</span></p>
<p>当<span class="math inline">\(k=5\)</span>时，<span class="math inline">\(p_{(5)}=0.045&gt;0.05*5/6=0.04166667\)</span></p>
<p>当<span class="math inline">\(k=6\)</span>时，<span class="math inline">\(p_{(6)}=0.053&gt;0.05*6/6=0.05\)</span></p>
<p>从上面的计算过程可以知道，这个<span class="math inline">\(k\)</span>等于4，也就是说，在FDR&lt;0.05的情况下，G2，G6，G5，G4有差异。</p>
<p>到这里，只是说明了，G2，G6，G5，G4是有差异的，但是q值还没有算出来，继续计算：</p>
<p>前面我们已经把原始的p值按照从小到大的顺序排列好了，也就是<code>[1] 0.001 0.010 0.020 0.030 0.045 0.053</code>，其中最大的p值是<code>0.053</code>，它校正后还是这个值，也就是说这个值是校正后的最大p值，次大的p值是<code>0.045</code>，这个值需要校正，它排序是第5，那么校正的公式就是所有p值的数目（一共是6个p值）除以秩（这里是5），再乘以p值大小，也就是<code>0.045*6/5=0.054</code>，但是，这个值已经大于原来最大的p值（0.053）了，因此这个把它校正后的值也作为0.053，再看倒数第3个值，即0.03的校正p值，即<code>0.03*6/4=0.045</code>，它小于0.053，因此它校正后可以是0.045，现在依次校正剩下的值：</p>
<p><code>0.02*6/3=0.04</code>，<code>0.01*6/2=0.03</code>，<code>0.001*6/1=0.006</code>，也就是说校正后的p值（就是q值），按从小到大的顺序排列就是：<code>0.006，0.03，0.04，0.045，0.053，0.053</code>，从结果中我们可以发现，前4个是有差异的，它们都小于0.05，也就是说G2，G6，G5，G4有差异。</p>
<p>其实公式就是： <span class="math display">\[
q^{(i)}=p_{(k)}^{(i)} * \frac{\text {Total Gene } N u m b e r}{\operatorname{rank}\left(p^{(i)}\right)}=p_{(k)}^{(i)} * \frac{m}{k}
\]</span> 以上是BH法进行q值计算的过程，R中可以使用<code>p.adjust()</code>函数计算q值，所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">p1 &lt;- <span class="number">0.053</span></div><div class="line">p2 &lt;- <span class="number">0.001</span></div><div class="line">p3 &lt;- <span class="number">0.045</span></div><div class="line">p4 &lt;- <span class="number">0.03</span></div><div class="line">p5 &lt;- <span class="number">0.02</span></div><div class="line">p6 &lt;- <span class="number">0.01</span></div><div class="line"></div><div class="line">p0 &lt;- c(p1,p2,p3,p4,p5,p6)</div><div class="line">p.adjust(p0,method = <span class="string">"BH"</span>)</div><div class="line">p.adjust(sort(p0),method = <span class="string">"BH"</span>)</div><div class="line">p.adjust(sort(p0),method = <span class="string">"fdr"</span>)</div><div class="line">sort(p.adjust(p0,method = <span class="string">"BH"</span>))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; p.adjust(p0,method = <span class="string">"BH"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.053</span> <span class="number">0.006</span> <span class="number">0.053</span> <span class="number">0.045</span> <span class="number">0.040</span> <span class="number">0.030</span></div><div class="line">&gt; p.adjust(sort(p0),method = <span class="string">"BH"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div><div class="line">&gt; p.adjust(sort(p0),method = <span class="string">"fdr"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div><div class="line">&gt; sort(p.adjust(p0,method = <span class="string">"BH"</span>))</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div></pre></td></tr></table></figure>
<p>从上面的计算结果看来：</p>
<ol style="list-style-type: decimal">
<li><code>method=&quot;BH&quot;</code>等于<code>method=&quot;fdr&quot;</code>，结果没有区别；</li>
<li>在使用<code>p.adjust()</code>函数计算q值时，不用对原始数据进行排序，如果想要结果按从小到大的序列排列，那么就排序原始值，或计算后的值均可。</li>
</ol>
<p>回到原文。</p>
<p>在R中，<code>qvalue</code>包中的<code>qvalue()</code>函数可以用来计算q值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(qvalue)</div><div class="line">res &lt;- qvalue(pvals)</div><div class="line">qvals &lt;- res$qvalues</div><div class="line">plot(pvals,qvals)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902153110.jpeg">

</div>
<p>估计一下<span class="math inline">\(\hat{\pi_{0}}\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; res$pi0</div><div class="line">[<span class="number">1</span>] <span class="number">0.8813727</span></div></pre></td></tr></table></figure>
<h2 id="练习">练习</h2>
<p>P274</p>
<h2 id="基础探索数据分析">基础探索数据分析</h2>
<p>与低通量数据相比，高通量数据的一个被低估的优点就是它很容易展现数据。例如当我们有了海量的高通量数据后，我们很容易发现那些在少量数据时并不明显的问题。研究这些数据的一个强有力工具就是探索性数据分析(EDA,exploratory data analysis)。这一部分我们就来了解这方面的内容，可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/advinference/eda_for_highthroughput.Rmd" target="_blank" rel="external">Github上的原文</a>。</p>
<h3 id="火山图">火山图</h3>
<p>我们使用前面数据做的t检验结果来看一下火山图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line"><span class="keyword">library</span>(GSE5859Subset)</div><div class="line">data(GSE5859Subset)</div><div class="line">g &lt;- factor(sampleInfo$group)</div><div class="line">results &lt;- rowttests(geneExpression,g)</div><div class="line">pvals &lt;- results$p.value</div></pre></td></tr></table></figure>
<p>我们还可以从一个数据集中生成一些p值，这些数据集中的零假设为真，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m &lt;- nrow(geneExpression)</div><div class="line">n &lt;- ncol(geneExpression)</div><div class="line">randomData &lt;- matrix(rnorm(n*m),m,n)</div><div class="line">nullpvals &lt;- rowttests(randomData,g)$p.value</div></pre></td></tr></table></figure>
<p>我们前面提到过，当我们报告效应大小(effect size)时，如果仅仅计算p值则会造成一些错误。我们可以通过画一个火山图来展示高通量数据的统计结果。火山图背后的思想是，它能展示出所有的特征值（这里指的是基因表达谱）。火山图的y轴是<code>-log(base 10) p-value</code>，x轴是效应大小(effect size)。当我们经过<code>-log(base 10)</code>转换后，那些有着极显著差异的特征值就会出现在火山图的上方。这里使用log转换是因为，我们可用log转换可以更好地区分一些非常小的数据，例如区分<code>0.01</code>和<span class="math inline">\(10^6\)</span>，此时我们来绘制一个火山图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plot(results$dm,-log10(results$p.value),</div><div class="line">xlab=<span class="string">"Effect size"</span>,ylab=<span class="string">"- log (base 10) p-values"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902194350.jpeg">

</div>
<h3 id="p值直方图">p值直方图</h3>
<p>另外一种看整体数据的思路就是绘制p值的直方图。当我们的数据完全无效时，那么p值的直方图是服从均匀分布的，而我们的数据有效时，我们可以发现较小的p值频率较高，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">hist(nullpvals,ylim=c(<span class="number">0</span>,<span class="number">1400</span>))</div><div class="line">hist(pvals,ylim=c(<span class="number">0</span>,<span class="number">1400</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902194645.jpeg">

</div>
<p>左侧的p值是无效数据产生的p值，它服从均匀分布，右侧的p值则是则是我们基因表达谱的数据。</p>
<p>当我们预期大多数假设都是无效时，我们就不会看到服从均匀分布的p值，它也许是一些异常属性的指标，例如相关的样本。如果我们对结果时行置换检验，并计算出p值后，如果样本是独立的，那么我们应该会看到均匀分布，但是，我们的数据却看不到这个结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">permg &lt;- sample(g)</div><div class="line">permresults &lt;- rowttests(geneExpression,permg)</div><div class="line">hist(permresults$p.value)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902195138.jpeg">

</div>
<p>在后面部分中，我们会了解到这个数据集中的每个检验并不是独立的，因此这里用于检验的假设（我们使用的是t检验，而t检验的前提就是样本独立）是不正确的。</p>
<h3 id="箱线图与直方图">箱线图与直方图</h3>
<p>高通量数据实验中，我们会检测每个实验单元的数千个特征值，我们前面也提到了，使用箱线图可以辅助我们来判断这些数据的质量。例如，如果一个样本的分布完全不同于剩余的样本，那么我们就可以认为，这个样本存在着一定问题。虽然一个完全的完全的变化可能是由于真正的生物学差异引起的，但是多数情况下，这就是技术因素造成的。这里我们使用Bioconductor中的基因表达数据，为了模拟出一组异常的数据，我们会对其中的一个样本进行log2转换，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#BiocManager::install("Biobase")</span></div><div class="line"><span class="comment">#devtools::install_github("genomicsclass/GSE5859")</span></div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">load(<span class="string">"GSE5859.rda"</span>)</div><div class="line">data(GSE5859)</div><div class="line">ge &lt;- exprs(e) <span class="comment">##ge for gene expression</span></div><div class="line">ge[,<span class="number">49</span>] &lt;- ge[,<span class="number">49</span>]/log2(exp(<span class="number">1</span>)) <span class="comment">##immitate error</span></div><div class="line"></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">boxplot(ge,range=<span class="number">0</span>,names=<span class="number">1</span>:ncol(e),col=ifelse(<span class="number">1</span>:ncol(ge)==<span class="number">49</span>,<span class="number">1</span>,<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>运行过重中发现，<code>GSE5859</code>这个包无法安装，因此可以去官网下载原始文件，直接加载到RStudio中，另外在加载<code>data(GSE5859)</code>时会出错，不用管，运行就行，图形如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202117.jpeg">

</div>
<p>从上图我们可以看到，样本数据大，很难看清楚中间的箱子形状，但是我们很容易发现有一个样本异常，除此之外，我们可以用另外一种方式来展示一下数据，这个数据不画箱子，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qs &lt;- t(apply(ge,<span class="number">2</span>,quantile,prob=c(<span class="number">0.05</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.75</span>,<span class="number">0.95</span>)))</div><div class="line">matplot(qs,type=<span class="string">"l"</span>,lty=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202322.jpeg">

</div>
<p>这种图形可以称为<code>kaboxplot</code>，因为这是由Karl Broman首次使用的，它绘制的是0.05，0.25，0.5，0.75和0.95分位数的图形。</p>
<p>我们也可以绘制直方图。因为我们的数据很多，因此可以使用很窄的间隔(bin)与柱子，然后将这些柱子进行平滑处理，最终绘制成平滑直方图(smooth histogram)。我们重新再校正这些平滑曲线的高度，那么在<span class="math inline">\(x_{0}\)</span>处的高度与基本单元构成的面积内，它们的点的数目就都比较接近，如下所示：</p>
<p>元区域内的点的数目就与这个基本单元的面积接近积，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">shist(ge,unit=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202859.jpeg">

</div>
<h3 id="ma图">MA图</h3>
<p>散点图(scatterplot)与相关性(correlation)不是检测重复性问题的最佳工具。检测重复性更好的工作就是检测两次之间的差值，如果重复性好，那么这些差值应该是一样的。因此，一种更好的绘图工具就是将散点图旋转一下，这个散点图的y轴上差值，x轴是平均值。这种图最初被叫做Bland-Altman图，但在遗传学中它经常被称为MA图。MA的名称来源于图形的内容，M表示减(minus)，表示两值之差（有的时候是log值之差），A表示平均(Average)，现在绘制一下MA图</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x &lt;- ge[,<span class="number">1</span>]</div><div class="line">y &lt;- ge[,<span class="number">2</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y)</div><div class="line">plot((x+y)/<span class="number">2</span>,x-y)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902215832.jpeg">

</div>
<p>左图是常规的相关图，右图是MA图，需要注意的是，当我们把左图进行旋转后，这些数据的差异的SD就非常直观了：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sd(y-x)</div><div class="line">[<span class="number">1</span>] <span class="number">0.2025465</span></div></pre></td></tr></table></figure>
<p>左图的散点图显示这两个样本的相关性很强，但是显示的信息有限。</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://www.jianshu.com/p/d86823ecd3ac" target="_blank" rel="external">如何理解与计算FDR？（第二版）</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/20/DAL/DALS016_InferenceForHighDimensionalData1_Basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/DAL/DALS016_InferenceForHighDimensionalData1_Basic/" itemprop="url">DALS016-高维数据推断1-背景介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T12:00:00+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,781
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第6章线性高维数据推断(Inference For High Dimensional Data)的第1小节，这一部分的主要内容涉及高通量数据的介绍，统计学的一些注意事项，相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/advinference/intro_to_highthroughput_data.Rmd" target="_blank" rel="external">Github</a>。</p>
<h3 id="高通量技术">高通量技术</h3>
<p>高通量技术已经将基础生物学和生物学从数据贫乏型学科尾成了数据密集型学科。一个典型的例子就是那些对基因表达有兴趣的研究领域。基因表达是这样一个过程，将生命蓝图DNA复制到RNA，而RNA是蛋白质合成的模板，是构成生命的基石。在20世纪90年代，对基因表达数据的分析相当于在一张纸上画了几个点，或从标准曲线上提取了几个数字。随着微阵列等高通量技术的发展，这几个数据就突然变成了筛选成千上万的数字。最近，RNA测序技术又进一步增加了数据的复杂性。生物学家们从使用他们的肉眼或简单的方法来分析结果到每个样本有数千（现在则是数百万个）个数据的分析。在这一篇中，我们佬双重点关注高通量数量的统计推断。具体来说就是，我们会使用统计检验来检测不同组之间的差异，以及使用有意义的方法来量化不确定性问题。我们还公介绍探索性数据分析方法，这些方法会结合高通量数据进行使用。在后面的章节中，我们会研究聚类，机器学习，因子分析和多层级建模(multi-level)。</p>
<p>由于现在有大量可用的公共数据集，我们会使用这些公共数据集来作为我们的学习案例。尽量使用的是公共数据，但是当你学习了这些方法后，在使用了高通量数据技术的其它领域也会派上用场。这些高通量技术包括微阵列，NGS，fRMI与蛋白质谱等。</p>
<h3 id="数据包">数据包</h3>
<p>我们这里使用的数据文件已经在作者的Github上分享了，因此使用<code>devtools</code>包就可以直接下载，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(devtools)</div><div class="line">install_github(<span class="string">"genomicsclass/GSE5859Subset"</span>)</div></pre></td></tr></table></figure>
<h3 id="张表">3张表</h3>
<p>我们用来做为案例学习的这些数据多数都是使用高通量技术生成的。这些技术会检测数千个特征值(feature)。这些特征值可以是基因，可以是基因组的单碱基位置，基因区域，以及图像的像素密度（芯片数据）。每个特定的检测产品被都会被相应地一组特定的功能所定义（我的理解就是，某公司的特定产品，例如检测miRNA的芯片，它的检测结果就是一些表达值，而这些表达值代表了哪些miRNA，就还需要另外一个miRNA名称的数据文件），例如特定基因表达的微阵列数据被一组其检测的基因所定义。一个特定的研究通常会使用一种产品对几个实验单元进行检验，例如几个人的样本。最常见的就是人，不过实验产单元也可以是其它的东西，例如肿瘤组织的一部分。按照实验术语，我们通常称实验单元为样本，这个样本与前面讲的随机样本不是一个东西，后者是统计学术语。</p>
<p>因此，一个高能被实验通常由3张表定义：一个是高通量数据的检测值，第二与第三表是关于列与行的信息。由于这些数据集通常是由一系列的实验单元，以及一些固定的特征构成，因此，高通量数据可以储存为<span class="math inline">\(n \times m\)</span>的形式，其中<span class="math inline">\(n\)</span>表示实验单元（样本），而<span class="math inline">\(m\)</span>表示特征值（通常就是基因），现在 我们来看一个案例：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(GSE5859Subset)</div><div class="line">data(GSE5859Subset) <span class="comment">##this loads the three tables</span></div><div class="line">dim(geneExpression)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; dim(geneExpression)</div><div class="line">[<span class="number">1</span>] <span class="number">8793</span>   <span class="number">24</span></div></pre></td></tr></table></figure>
<p>这个数据是RNA表达谱数据，它检测了24个人（实验单元）的8793个基因。对于大多数的统计分析来说，我们还需要实验样本的一些信息。例如，在这个案例中，最初收集的数据是用于比较不同种族群体的基因表达情况。但是，我们已经创建了这个数据集的一个子集用于说明样本的信息情况，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dim(sampleInfo)</div><div class="line">head(sampleInfo)</div><div class="line">sampleInfo$group</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; dim(sampleInfo)</div><div class="line">[<span class="number">1</span>] <span class="number">24</span>  <span class="number">4</span></div><div class="line">&gt; head(sampleInfo)</div><div class="line">    ethnicity       date         filename group</div><div class="line"><span class="number">107</span>       ASN <span class="number">2005</span>-<span class="number">06</span>-<span class="number">23</span> GSM136508.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">122</span>       ASN <span class="number">2005</span>-<span class="number">06</span>-<span class="number">27</span> GSM136530.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">113</span>       ASN <span class="number">2005</span>-<span class="number">06</span>-<span class="number">27</span> GSM136517.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">163</span>       ASN <span class="number">2005</span>-<span class="number">10</span>-<span class="number">28</span> GSM136576.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">153</span>       ASN <span class="number">2005</span>-<span class="number">10</span>-<span class="number">07</span> GSM136566.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">161</span>       ASN <span class="number">2005</span>-<span class="number">10</span>-<span class="number">07</span> GSM136574.CEL.gz     <span class="number">1</span></div><div class="line">&gt; sampleInfo$group</div><div class="line"> [<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>关于样本信息中的一列是文件名，它可以让我们把这个表的行与表达谱的列连接起来，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match(sampleInfo$filename,colnames(geneExpression))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; match(sampleInfo$filename,colnames(geneExpression))</div><div class="line"> [<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span></div></pre></td></tr></table></figure>
<p>最后，我们还有一张描述特征值的表格，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dim(geneAnnotation)</div><div class="line">head(geneAnnotation)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; dim(geneAnnotation)</div><div class="line">[<span class="number">1</span>] <span class="number">8793</span>    <span class="number">4</span></div><div class="line">&gt; head(geneAnnotation)</div><div class="line">     PROBEID  CHR     CHRLOC SYMBOL</div><div class="line"><span class="number">1</span>  1007_s_at chr6   <span class="number">30852327</span>   DDR1</div><div class="line"><span class="number">30</span>   1053_at chr7  -<span class="number">73645832</span>   RFC2</div><div class="line"><span class="number">31</span>    117_at chr1  <span class="number">161494036</span>  HSPA6</div><div class="line"><span class="number">32</span>    121_at chr2 -<span class="number">113973574</span>   PAX8</div><div class="line"><span class="number">33</span> 1255_g_at chr6   <span class="number">42123144</span> GUCA1A</div><div class="line"><span class="number">34</span>   1294_at chr3  -<span class="number">49842638</span>   UBA7</div></pre></td></tr></table></figure>
<p>从上面的信息知道，<code>geneAnnotation</code>这个文件里含有ID，这个表的行可以与表达谱的行连接起来，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">head(match(geneAnnotation$PROBEID,rownames(geneExpression)))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; head(match(geneAnnotation$PROBEID,rownames(geneExpression)))</div><div class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div></pre></td></tr></table></figure>
<h2 id="实际应用">实际应用</h2>
<p>现在假设我们已经拥有了一批高通量数据，这个数据是检测了两组中一些人的基因表达情况。现在我们的问题是：在这两组人中，哪些基因的表达均值存在差异？如果是一个基因，计算起来很简单，我们手工计算就行，但是，高通常数量通常都是几千个基因，显然手工算不太现实，但是寻找差异基因的方法跟前面我们提到的统计推断原理一样。例如，我们可以使用t检验或其它检验来寻找差异基因。</p>
<h3 id="随机变量的p值">随机变量的p值</h3>
<p>这里我们要强调的一个概念就是，p值是一个随机变量。为了能说明这一点，我们来看一个案例。在这个案例中，我们会使用CLT近似的原来生成大量的样本，并通过t检验来计算其p值。然后我们的p值被定义为，正态分布的随机变量的绝对值大于观察到的t检验r值的概率，被称为<span class="math inline">\(Z\)</span>（书中原话是：Then our p-value is defined as the probability that a normally distributed random variable is larger, in absolute value, than the observed t-test, call it Z.），因此，双尾检验的p值公式如下所示： <span class="math display">\[
p = 2 \{ 1 - \Phi(\mid Z \mid)\}
\]</span> 在R中则为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>*(<span class="number">1</span>-pnorm(Z))</div></pre></td></tr></table></figure>
<p>因为<span class="math inline">\(Z\)</span>是一个随机变量，并且<span class="math inline">\(\Phi\)</span>是一个确定的函数，<span class="math inline">\(p\)</span>因此也是一个随机变量。我们现在使用Monte Carlo模拟来显示一下<span class="math inline">\(p\)</span>值的变化，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line"></div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/femaleControlsPopulation.csv"</span>)</div><div class="line">population &lt;- read.csv(filename)</div><div class="line">population &lt;- unlist(population) <span class="comment"># turn it into a numeric</span></div><div class="line">N &lt;- <span class="number">12</span></div><div class="line">B &lt;- <span class="number">10000</span></div><div class="line">pvals &lt;- replicate(B,&#123;</div><div class="line">  control = sample(population,N)</div><div class="line">  treatment = sample(population,N)</div><div class="line">  t.test(treatment,control)$p.val</div><div class="line">&#125;)</div><div class="line">hist(pvals)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190828112405.jpeg">

</div>
<p>从直方图中我们可以看到，p值属于均匀分布。事实上，我们可以从理论上证明，当零假设为真是，情况确实如此。当我们使用CLT时，我们的零假设<span class="math inline">\(H_{0}\)</span>意味着我们的检验统计量Z服从均值为0，SD为1的正态分布，因此： <span class="math display">\[
p_a = \mbox{Pr}(Z &lt; a \mid H_0) = \Phi(a)
\]</span> 这也说明： <span class="math display">\[
\begin{align*}
\mbox{Pr}(p &lt; p_a) &amp;= \mbox{Pr}[ \Phi^{-1}(p) &lt; \Phi^{-1}(p_a) ] \\
  &amp; = \mbox{Pr}(Z &lt; a) = p_a
\end{align*}
\]</span> 这其实就是均匀分布(uniform distribution)的定义。</p>
<h3 id="千次检验">千次检验</h3>
<p>在上面的案例中，我们有两组数据，分别用0和1表示，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(GSE5859Subset)</div><div class="line">data(GSE5859Subset)</div><div class="line">g &lt;- sampleInfo$group</div><div class="line">g</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(GSE5859Subset)</div><div class="line">&gt; data(GSE5859Subset)</div><div class="line">&gt; g &lt;- sampleInfo$group</div><div class="line">&gt; g</div><div class="line"> [<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>如果我们对某个特定的基因感兴趣，例如第25行的那个基因，那么我们就可以简单地使用t检验就行，为了计算p值，我们需要先看一下这个基因数据是否服从t分布，因此我们可以使用qq图来绘制，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">e &lt;- geneExpression[<span class="number">25</span>,]</div><div class="line">e</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">qqnorm(e[g==<span class="number">1</span>])</div><div class="line">qqline(e[g==<span class="number">1</span>])</div><div class="line">qqnorm(e[g==<span class="number">0</span>])</div><div class="line">qqline(e[g==<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; e</div><div class="line">GSM136508.CEL.gz GSM136530.CEL.gz GSM136517.CEL.gz GSM136576.CEL.gz GSM136566.CEL.gz GSM136574.CEL.gz GSM136575.CEL.gz </div><div class="line">        <span class="number">10.34172</span>         <span class="number">10.64662</span>         <span class="number">10.69198</span>         <span class="number">10.96155</span>         <span class="number">10.24889</span>         <span class="number">10.74414</span>         <span class="number">10.22206</span> </div><div class="line">GSM136569.CEL.gz GSM136568.CEL.gz GSM136559.CEL.gz GSM136565.CEL.gz GSM136573.CEL.gz GSM136523.CEL.gz GSM136509.CEL.gz </div><div class="line">        <span class="number">10.49094</span>         <span class="number">10.57574</span>         <span class="number">10.47758</span>         <span class="number">10.43493</span>         <span class="number">10.46440</span>         <span class="number">10.58358</span>         <span class="number">10.39607</span> </div><div class="line">GSM136727.CEL.gz GSM136510.CEL.gz GSM136515.CEL.gz GSM136522.CEL.gz GSM136507.CEL.gz GSM136524.CEL.gz GSM136514.CEL.gz </div><div class="line">        <span class="number">10.75837</span>         <span class="number">10.37383</span>         <span class="number">10.57540</span>         <span class="number">10.51203</span>         <span class="number">10.39952</span>         <span class="number">10.70539</span>         <span class="number">10.77077</span> </div><div class="line">GSM136563.CEL.gz GSM136564.CEL.gz GSM136572.CEL.gz </div><div class="line">        <span class="number">10.38333</span>         <span class="number">10.31405</span>         <span class="number">10.25655</span></div></pre></td></tr></table></figure></p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190828180606.jpeg">

</div>
<p>qq显示，这个数据比较接近于正态分布，但是t检验发现，这个基因在两组之间并无差异，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.test(e[g==<span class="number">1</span>],e[g==<span class="number">0</span>])$p.value</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; t.test(e[g==<span class="number">1</span>],e[g==<span class="number">0</span>])$p.value</div><div class="line">[<span class="number">1</span>] <span class="number">0.779303</span></div></pre></td></tr></table></figure>
<p>上面是只计算1个基因的情况，如果要计算所有的基因，那么就需要对每个基因进行t检验，我们来构建一个函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myttest &lt;- <span class="keyword">function</span>(x) t.test(x[g==<span class="number">1</span>],x[g==<span class="number">0</span>],var.equal=<span class="literal">TRUE</span>)$p.value</div><div class="line">pvals &lt;- apply(geneExpression,<span class="number">1</span>,myttest)</div><div class="line">head(pvals)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; head(pvals)</div><div class="line"> 1007_s_at    1053_at     117_at     121_at  1255_g_at    1294_at </div><div class="line"><span class="number">0.04553344</span> <span class="number">0.03370683</span> <span class="number">0.13604026</span> <span class="number">0.59413846</span> <span class="number">0.96849102</span> <span class="number">0.08489586</span></div></pre></td></tr></table></figure>
<p>现在我们来看一下，p值小于0.05的基因有多少个，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(pvals&lt;<span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals&lt;<span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1383</span></div></pre></td></tr></table></figure>
<p>也就是说，有1383个基因有差异。</p>
<p>但是，正如我们随后即将详细描述的那样，对于这个结果，我们要谨慎对待。因为这个结果是我们经过8000多次比较后得到的结果（数据集里一共有个8793基因）。如果我们对一批随机数据执行相同的计算过程，在零假设成立的前提下，我们也能计算出一批p值，并且这批p值小于0.05的数目为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">m &lt;- nrow(geneExpression)</div><div class="line">n &lt;- ncol(geneExpression)</div><div class="line">randomData &lt;- matrix(rnorm(n*m),m,n)</div><div class="line">nullpvals &lt;- apply(randomData,<span class="number">1</span>,myttest)</div><div class="line">sum(nullpvals&lt;<span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(nullpvals&lt;<span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">419</span></div></pre></td></tr></table></figure>
<p>随后，我们会解释一下这个数值是怎么一回事，实际上，这个数字大概就是8192*0.05的结果（大约为409.6），后面会详细介绍这个原理。</p>
<h3 id="加快t检验的计算">加快t检验的计算</h3>
<p>在我们开始之前，我们需要知道，前面我们构建了一个做t检验的函数，虽然它能计算出相应的p值，但是这种方法比较低效。我们还有其它更快的方法实现这一目的，在Bioconductor项目中就有这样的函数，此时我们要用到<code>rafalib</code>包中的<code>install_bioc()</code>函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install_bioc(<span class="string">"genefilter"</span>)</div></pre></td></tr></table></figure>
<p>现在我们使用<code>rowttests()</code>函数来计算一下p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">results &lt;- rowttests(geneExpression,factor(g))</div><div class="line">max(abs(pvals-results$p))</div><div class="line">sum(results$p&lt;<span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(pvals-results$p))</div><div class="line">[<span class="number">1</span>] <span class="number">6.528111e-14</span></div><div class="line">&gt; sum(results$p&lt;<span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1383</span></div></pre></td></tr></table></figure>
<h2 id="p值计算练习">p值计算练习</h2>
<p>为了更好地理解p值是一个随机变量，现在我们再来看一些案例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line"><span class="keyword">library</span>(downloader)</div><div class="line">url = <span class="string">"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extda\</span></div><div class="line"><span class="string">ta/femaleControlsPopulation.csv"</span></div><div class="line">filename = <span class="string">"femaleControlsPopulation.csv"</span></div><div class="line"><span class="keyword">if</span> (!file.exists(filename)) download(url,destfile=filename)</div><div class="line">population = read.csv(filename)</div><div class="line"></div><div class="line">pvals &lt;- replicate(<span class="number">1000</span>,&#123;</div><div class="line">  control = sample(population,<span class="number">12</span>)</div><div class="line">  treatment = sample(population,<span class="number">12</span>)</div><div class="line">  t.test(treatment,control)$p.val&#125;)</div><div class="line">head(pvals)</div><div class="line">hist(pvals)</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; head(pvals)</div><div class="line">[<span class="number">1</span>] <span class="number">0.76454370</span> <span class="number">0.60237592</span> <span class="number">0.49679830</span> <span class="number">0.23518016</span> <span class="number">0.20882028</span> <span class="number">0.06812489</span></div></pre></td></tr></table></figure></p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190828191526.jpeg">

</div>
<p>现在回答以下几个问题：</p>
<p><strong>问题一</strong>：小于0.05的p值所占的比例是多少？</p>
<p>答：4.1%，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">4.1</span></div></pre></td></tr></table></figure>
<p><strong>问题二</strong>：小于0.01的p值所占的比例是多少？</p>
<p>答：0.8%，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.01</span>)/length(pvals)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">0.8</span></div></pre></td></tr></table></figure>
<p><strong>问题三</strong>：假设你正在测试20种饮食对小鼠体重影响的效应。对于20种饮食中的每一种，我们都使用10只对照小鼠和10只实验小鼠。在零假设成立时，也就是说饮食对小鼠的体重没有影响，另外，小鼠的体重是服从正态分布的（均值为30g，SD为2g）。我们对其中的一项进行Monte Carlo模拟：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cases = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">controls = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">t.test(cases,controls)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; cases = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">&gt; controls = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">&gt; t.test(cases,controls)</div><div class="line"></div><div class="line">	Welch Two Sample t-test</div><div class="line"></div><div class="line">data:  cases and controls</div><div class="line">t = <span class="number">0.16473</span>, df = <span class="number">17.934</span>, p-value = <span class="number">0.871</span></div><div class="line">alternative hypothesis: true difference <span class="keyword">in</span> means is not equal to <span class="number">0</span></div><div class="line"><span class="number">95</span> percent confidence interval:</div><div class="line"> -<span class="number">1.708669</span>  <span class="number">1.999327</span></div><div class="line">sample estimates:</div><div class="line">mean of x mean of y </div><div class="line"> <span class="number">30.23172</span>  <span class="number">30.08639</span></div></pre></td></tr></table></figure>
<p>问题：现在进行Monte Carlo模拟，模拟所有20种包含的实验结果，如果我们将种子设置为<code>set.seed(100)</code>，那么有多少值低于0.05？</p>
<p>答案是：5%，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">100</span>)</div><div class="line">pvals &lt;- replicate(<span class="number">20</span>,&#123;</div><div class="line">  cases = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">  controls = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">  t.test(cases,controls)$p.val&#125;)</div><div class="line">sum(pvals&lt;<span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals&lt;<span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">5</span></div></pre></td></tr></table></figure>
<p><strong>问题四</strong>：现在我们通过模拟数据了解了p值的分布情况，也就是说了解了小于0.05的p值的比例。在问题三中，我们一次运行了20种饮食的实验。现在我们运行1000次实验，并且每次保存下那些p值小于0.05的数目。</p>
<p>操作如下：</p>
<p>随机种子数设为100，即<code>set.seed(100)</code>，运行问题三中的代码1000次，并保存p值小于0.05的次数，计算一下这些数字的平均值，这就是我们拒绝零假设为真时的次数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">100</span>)</div><div class="line">pvals &lt;- replicate(<span class="number">1000</span>,&#123;</div><div class="line">  cases = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">  controls = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">  t.test(cases,controls)$p.val&#125;)</div><div class="line">sum(pvals&lt;<span class="number">0.05</span>)</div><div class="line">sum(pvals&lt;<span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals&lt;<span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">40</span></div><div class="line">&gt; sum(pvals&lt;<span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">4</span></div></pre></td></tr></table></figure>
<p><strong>问题五</strong>：这说明，就平均数而言，即使所有的饮食对小鼠的体重都没有影响，我们还能得到一些小于0.05的p值。使用相同的模拟数据来做1000次计算，我们能得到多少假阳性的比例？</p>
<p>答：大概是5%。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/20/DAL/DALS014_Linear_Models04ANOVA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/DAL/DALS014_Linear_Models04ANOVA/" itemprop="url">DALS014-Linear Models线性模型04方差分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T12:00:00+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,532
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第5章线性模型的第4小节，这一部分的主要内容涉及ANOVA，有关方差分析的笔记R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/linear/interactions_and_contrasts.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="anova简介">ANOVA简介</h2>
<p>现在考虑一种情况，如果我们想知道push与pull的差值在整体上，不同的组中是否有区别。换句话讲，我们并不想比较任意两组有差异，我们就想知道，在所有的有腿中，代表了push和pull差值的3个交互作用导致的push和pull差异是否比正常的差异大（即不考虑交互作用的情况）。</p>
<p>通过方差分析(analysis of variance，ANOVA)就可以解决这个问题。ANOVA的本质在于比较不同复杂模型的残差平方和是被哪些因素降低的（我的理解就是，总的残差平方和都是分布在哪些变量上面，哪些变量分到的最多，哪些变量的效应就最强）。含有8个系数的模型比含有5个系数的模型要复杂的多，在5个系数的模型中，我们是假设push和pull在所有组之间的差异是相等的。最简单的模型只使用一个系数，一个截矩。在某些假设下，我们还可以执行推断，确定与我们观察到的一样大的改进概率(Under certain assumptions we can also perform inference that determines the probability of improvements as large as what we observed)。</p>
<p>下面的ANOVA计算的结果（接前文案例）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; anova(fitX)</div><div class="line">Analysis of Variance Table</div><div class="line"></div><div class="line">Response: friction</div><div class="line">           Df Sum Sq Mean Sq  <span class="literal">F</span> value    Pr(&gt;<span class="literal">F</span>)    </div><div class="line">type        <span class="number">1</span> <span class="number">42.783</span>  <span class="number">42.783</span> <span class="number">1179.713</span> &lt; <span class="number">2.2e-16</span> ***</div><div class="line">leg         <span class="number">3</span>  <span class="number">2.921</span>   <span class="number">0.974</span>   <span class="number">26.847</span> <span class="number">2.972e-15</span> ***</div><div class="line">type:leg    <span class="number">3</span>  <span class="number">2.098</span>   <span class="number">0.699</span>   <span class="number">19.282</span> <span class="number">2.256e-11</span> ***</div><div class="line">Residuals <span class="number">274</span>  <span class="number">9.937</span>   <span class="number">0.036</span>                       </div><div class="line">---</div><div class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></div></pre></td></tr></table></figure>
<p>结果的第一行中有一个<code>type</code>变量（表示pull或push），它对应的Sum值为42.783，这就表示，这一单一的系数减少了42.783的平方和。我们看一下总的平方和，其实就是线性模型的截矩，也可以是<code>anova(fitX)</code>的第2列的和，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">result &lt;- anova(fitX)</div><div class="line">sum(result$`Sum Sq`)</div><div class="line">mu0 &lt;- mean(spider$friction)</div><div class="line">(initial.ss &lt;- sum((spider$friction - mu0)^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; result &lt;- anova(fitX)</div><div class="line">&gt; sum(result$`Sum Sq`)</div><div class="line">[<span class="number">1</span>] <span class="number">57.73858</span></div><div class="line">&gt; mu0 &lt;- mean(spider$friction)</div><div class="line">&gt; (initial.ss &lt;- sum((spider$friction - mu0)^<span class="number">2</span>))</div><div class="line">[<span class="number">1</span>] <span class="number">57.73858</span></div></pre></td></tr></table></figure>
<p>需要注意是的是，这个平方和的计算公式最初就是来源于样本方差的计算公式，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">N &lt;- nrow(spider)</div><div class="line">(N - <span class="number">1</span>) * var(spider$friction)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; N &lt;- nrow(spider)</div><div class="line">&gt; (N - <span class="number">1</span>) * var(spider$friction)</div><div class="line">[<span class="number">1</span>] <span class="number">57.73858</span></div></pre></td></tr></table></figure>
<p>现在来看一下，前面的42.783是如何得到的。我们需要计算仅包含类型信息模型的残差平方和。我们可以通过计算残差，残差的平方，并将它们加起来就能实现，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s &lt;- split(spider$friction, spider$type)</div><div class="line">after.type.ss &lt;- sum( sapply(s, <span class="keyword">function</span>(x) &#123;</div><div class="line">residual &lt;- x - mean(x)</div><div class="line">sum(residual^<span class="number">2</span>)</div><div class="line">&#125;) )</div><div class="line">(type.ss &lt;- initial.ss - after.type.ss)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; s &lt;- split(spider$friction, spider$type)</div><div class="line">&gt; after.type.ss &lt;- sum( sapply(s, <span class="keyword">function</span>(x) &#123;</div><div class="line">+   residual &lt;- x - mean(x)</div><div class="line">+   sum(residual^<span class="number">2</span>)</div><div class="line">+ &#125;) )</div><div class="line">&gt; (type.ss &lt;- initial.ss - after.type.ss)</div><div class="line">[<span class="number">1</span>] <span class="number">42.78307</span></div></pre></td></tr></table></figure>
<p>这个降低的程度(就是上面的42.78307)就相当于模型<code>~type</code>和<code>~1</code>拟合值差值的平方和，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(sapply(s, length) * (sapply(s, mean) - mu0)^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(sapply(s, length) * (sapply(s, mean) - mu0)^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">42.78307</span></div></pre></td></tr></table></figure>
<p>线性模型中的各个项的顺序以及ANOVA表格中的顺序很重要：每行表示的是：当添加了一个新的系数后，残差平方和较未添加这个系数之前减少的量。</p>
<p>在ANOVA表（这个表其实就是ANOAVA计算后的结果）还标明了自由度。当引入了<code>type</code>这一项时，它对应的<code>Df</code>就是1，<code>leg</code>变量引入了3个项（即legL2，legL3和legL4），它对应的<code>Df</code>就是3（这一段不太理解）。ANOVA还有一列是<code>F value</code>。F值表示的是包含感兴趣的项（感兴趣的项平方和除以相应自由度）除以残差（ANOVA表中的最后一行除以自自由度），以第一行为例 说明一下就是<code>(42.783/1)/(9.937/274)=1179.686</code>。</p>
<p>书中给出的公式为：</p>
<p><span class="math display">\[
r_i = Y_i - \hat{Y}_i
\]</span> <span class="math display">\[
\mbox{Mean Sq Residuals} = \frac{1}{N - p} \sum_{i=1}^N r_i^2
\]</span></p>
<p>其中<code>p</code>表示模型中系数的总数（在这个模型中，包括截矩在内的系数总数是8）。</p>
<p>在零假设成立的前提下（零假设就是添加系数的真值为0），我们会得到每行F值分布的理论结果。这种近似所需的假设类似于t分布近似的假设，例如我们在使用CLT时需要大量的样本，或者是总体的数据服从正态分布。</p>
<p>现在我们来解释一下p值，看最后一行，即<code>type:leg</code>，内容是<code>type:leg    3  2.098   0.699   19.282 2.256e-11 ***</code>，<code>type:leg</code>表示的是3个交互作用系数。在零假设下，这3个附加项的真实值为0，例如，<span class="math inline">\(\beta_{push,L2}=0\)</span>，<span class="math inline">\(\beta_{push,L3}=0\)</span>，<span class="math inline">\(\beta_{push,L4}=0\)</span>，然后我们就计算出ANOVA表的这一行观察到的这么大的F值的概率。这里需要记住，我们只关注大的F值，因为我们有一个平方和的比，因此F值只能是正数（原文：Remember that we are only concerned with large values here, because we have a ratio of sum of squares, the F-value can only be positive. ）。<code>type:leg</code>这一行中的p值可以这么解释：在零假设下，我们认为push和pull的差值在所有组之间是没有差异的，p值表示了，在这个零假设成立时，我们观察到的如此大的方差的可能性。从计算结果中我们可以看到，我们的p值非常小，我们就可以拒绝零假设，即可以认为，push和pull的差值在不同组之间是不同的。</p>
<p>另外，ANOVA中的F值与F分布有关，F分布有2个以参数，一个是分子的自由度（分子是研究对象的自由度，例如前面提到的交互作用），一个是分母的自由度（残差）。从结果可以看到，交互作用系数的自由度是3，残差的自由度是274。</p>
<h2 id="anova模型的另外表示">ANOVA模型的另外表示</h2>
<p>现在来看一下ANOVA模型的另外表示方法，在这种方式里，我们假设每一对type与leg都有自己的均值（这样，对于每一条腿来说，push与pull的效应就不会相同）。这种表述方式在某种程度上来说更加简单，但是，我们不能像前面那样构建ANOVA表，因为这种方式无法区分交互作用系数。</p>
<p>首先我们会先构建一个因子变量，这个因子变量表示的是<code>type</code>与<code>leg</code>的组合，在公式中含有<code>~0</code>，它表示，我们不在线性模型中包含截矩，其中我们通过<code>rafalib</code>包中的<code>imagemat()</code>函数绘制了组变量的矩阵示意图，这个示意图也有8项，它针对每一个type和leg组合进行了拟合，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##earlier, we defined the 'group' column:</span></div><div class="line">spider$group &lt;- factor(paste0(spider$leg, spider$type))</div><div class="line">X &lt;- model.matrix(~ <span class="number">0</span> + group, data=spider)</div><div class="line">colnames(X)</div><div class="line">head(X)</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">imagemat(X, main=<span class="string">"Model matrix for linear model with group variable"</span>)</div><div class="line">fitG &lt;- lm(friction ~ <span class="number">0</span> + group, data=spider)</div><div class="line">summary(fitG)</div><div class="line">coefs &lt;- coef(fitG)</div><div class="line">coefs</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&gt; colnames(X)</div><div class="line">[<span class="number">1</span>] <span class="string">"groupL1pull"</span> <span class="string">"groupL1push"</span> <span class="string">"groupL2pull"</span> <span class="string">"groupL2push"</span> <span class="string">"groupL3pull"</span></div><div class="line">[<span class="number">6</span>] <span class="string">"groupL3push"</span> <span class="string">"groupL4pull"</span> <span class="string">"groupL4push"</span></div><div class="line">&gt; head(X)</div><div class="line">  groupL1pull groupL1push groupL2pull groupL2push groupL3pull groupL3push</div><div class="line"><span class="number">1</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">5</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">6</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line">  groupL4pull groupL4push</div><div class="line"><span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">4</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">5</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line"><span class="number">6</span>           <span class="number">0</span>           <span class="number">0</span></div><div class="line">&gt; <span class="keyword">library</span>(rafalib)</div><div class="line">&gt; imagemat(X, main=<span class="string">"Model matrix for linear model with group variable"</span>)</div><div class="line">&gt; fitG &lt;- lm(friction ~ <span class="number">0</span> + group, data=spider)</div><div class="line">&gt; summary(fitG)</div><div class="line"></div><div class="line">Call:</div><div class="line">lm(formula = friction ~ <span class="number">0</span> + group, data = spider)</div><div class="line"></div><div class="line">Residuals:</div><div class="line">     Min       1Q   Median       3Q      Max </div><div class="line">-<span class="number">0.46385</span> -<span class="number">0.10735</span> -<span class="number">0.01111</span>  <span class="number">0.07848</span>  <span class="number">0.76853</span> </div><div class="line"></div><div class="line">Coefficients:</div><div class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </div><div class="line">groupL1pull  <span class="number">0.92147</span>    <span class="number">0.03266</span>   <span class="number">28.21</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">groupL1push  <span class="number">0.40735</span>    <span class="number">0.03266</span>   <span class="number">12.47</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">groupL2pull  <span class="number">1.14533</span>    <span class="number">0.04917</span>   <span class="number">23.29</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">groupL2push  <span class="number">0.52733</span>    <span class="number">0.04917</span>   <span class="number">10.72</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">groupL3pull  <span class="number">1.27385</span>    <span class="number">0.02641</span>   <span class="number">48.24</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">groupL3push  <span class="number">0.37596</span>    <span class="number">0.02641</span>   <span class="number">14.24</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">groupL4pull  <span class="number">1.40075</span>    <span class="number">0.03011</span>   <span class="number">46.52</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">groupL4push  <span class="number">0.49075</span>    <span class="number">0.03011</span>   <span class="number">16.30</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">---</div><div class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></div><div class="line"></div><div class="line">Residual standard error: <span class="number">0.1904</span> on <span class="number">274</span> degrees of freedom</div><div class="line">Multiple R-squared:   <span class="number">0.96</span>,	Adjusted R-squared:  <span class="number">0.9588</span> </div><div class="line"><span class="literal">F</span>-statistic:   <span class="number">821</span> on <span class="number">8</span> and <span class="number">274</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></div><div class="line"></div><div class="line">&gt; coefs &lt;- coef(fitG)</div><div class="line">&gt; coefs</div><div class="line">groupL1pull groupL1push groupL2pull groupL2push groupL3pull groupL3push groupL4pull </div><div class="line">  <span class="number">0.9214706</span>   <span class="number">0.4073529</span>   <span class="number">1.1453333</span>   <span class="number">0.5273333</span>   <span class="number">1.2738462</span>   <span class="number">0.3759615</span>   <span class="number">1.4007500</span> </div><div class="line">groupL4push </div><div class="line">  <span class="number">0.4907500</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190824171912.jpeg">

</div>
<h2 id="计算估计系数">计算估计系数</h2>
<p>现在我们绘制出上面计算结果的示意图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">stripchart(split(spider$friction, spider$group), </div><div class="line">           vertical=<span class="literal">TRUE</span>, pch=<span class="number">1</span>, method=<span class="string">"jitter"</span>, las=<span class="number">2</span>, xlim=c(<span class="number">0</span>,<span class="number">11</span>), ylim=c(<span class="number">0</span>,<span class="number">2</span>))</div><div class="line">cols &lt;- brewer.pal(<span class="number">8</span>,<span class="string">"Dark2"</span>)</div><div class="line">abline(h=<span class="number">0</span>)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">8</span>) &#123;</div><div class="line">  arrows(i+a,<span class="number">0</span>,i+a,coefs[i],lwd=<span class="number">3</span>,col=cols[i],length=lgth)</div><div class="line">&#125;</div><div class="line">legend(<span class="string">"right"</span>,names(coefs),fill=cols,cex=<span class="number">.75</span>,bg=<span class="string">"white"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190824172337.jpeg">

</div>
<h2 id="使用contrast包进行简单比较">使用contrast包进行简单比较</h2>
<p>虽然无法使用这个公式来进行ANOVA分析，但是可以使用<code>contrast()</code>函数对每组的估计系数进行比较，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">groupL2push.vs.pull &lt;- contrast(fitG,</div><div class="line">                                list(group = <span class="string">"L2push"</span>),</div><div class="line">                                list(group = <span class="string">"L2pull"</span>))</div><div class="line">groupL2push.vs.pull</div><div class="line">coefs[<span class="number">4</span>] - coefs[<span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; groupL2push.vs.pull</div><div class="line">lm model parameter contrast</div><div class="line"></div><div class="line">  Contrast      S.E.      Lower      Upper     t  df Pr(&gt;|t|)</div><div class="line"><span class="number">1</span>   -<span class="number">0.618</span> <span class="number">0.0695372</span> -<span class="number">0.7548951</span> -<span class="number">0.4811049</span> -<span class="number">8.89</span> <span class="number">274</span>        <span class="number">0</span></div><div class="line">&gt; coefs[<span class="number">4</span>] - coefs[<span class="number">3</span>]</div><div class="line">groupL2push </div><div class="line">     -<span class="number">0.618</span></div></pre></td></tr></table></figure>
<h2 id="无截矩时差值的差异">无截矩时差值的差异</h2>
<p>我们还可以进行push和pull在各级之间的两两(pair-wise)比较。例如，现在我们想比较L3与L2的push和pull的差值，如下所示：</p>
<p><span class="math display">\[
(\mbox{L3push} - \mbox{L3pull}) - (\mbox{L2push} - \mbox{L2pull})
\]</span> <span class="math display">\[
= \mbox{L3 push} + \mbox{L2pull} - \mbox{L3pull} - \mbox{L2push}
\]</span></p>
<p>其过程如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C &lt;- matrix(c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1</span>)</div><div class="line">groupL3vsL2interaction &lt;- glht(fitG, linfct=C)</div><div class="line">summary(groupL3vsL2interaction)</div><div class="line">names(coefs)</div><div class="line">(coefs[<span class="number">6</span>] - coefs[<span class="number">5</span>]) - (coefs[<span class="number">4</span>] - coefs[<span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; C &lt;- matrix(c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1</span>)</div><div class="line">&gt; groupL3vsL2interaction &lt;- glht(fitG, linfct=C)</div><div class="line">&gt; summary(groupL3vsL2interaction)</div><div class="line"></div><div class="line">	 Simultaneous Tests <span class="keyword">for</span> General Linear Hypotheses</div><div class="line"></div><div class="line">Fit: lm(formula = friction ~ <span class="number">0</span> + group, data = spider)</div><div class="line"></div><div class="line">Linear Hypotheses:</div><div class="line">       Estimate Std. Error t value Pr(&gt;|t|)    </div><div class="line"><span class="number">1</span> == <span class="number">0</span> -<span class="number">0.27988</span>    <span class="number">0.07893</span>  -<span class="number">3.546</span>  <span class="number">0.00046</span> ***</div><div class="line">---</div><div class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></div><div class="line">(Adjusted p values reported -- single-step method)</div><div class="line"></div><div class="line">&gt; names(coefs)</div><div class="line">[<span class="number">1</span>] <span class="string">"groupL1pull"</span> <span class="string">"groupL1push"</span> <span class="string">"groupL2pull"</span> <span class="string">"groupL2push"</span> <span class="string">"groupL3pull"</span></div><div class="line">[<span class="number">6</span>] <span class="string">"groupL3push"</span> <span class="string">"groupL4pull"</span> <span class="string">"groupL4push"</span></div><div class="line">&gt; (coefs[<span class="number">6</span>] - coefs[<span class="number">5</span>]) - (coefs[<span class="number">4</span>] - coefs[<span class="number">3</span>])</div><div class="line">groupL3push </div><div class="line"> -<span class="number">0.2798846</span></div></pre></td></tr></table></figure>
<h2 id="练习">练习</h2>
<p>P230</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">217</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">107</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共864.3k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
