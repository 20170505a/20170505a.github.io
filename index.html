<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/10/BioTools/fgsea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/BioTools/fgsea/" itemprop="url">fgsea包做GSEA分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T12:00:00+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生信工具/" itemprop="url" rel="index">
                    <span itemprop="name">生信工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,259
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="gsea图">GSEA图</h2>
<p>这篇教程翻译自生信博客DAVE TANGE’S BLOG(https://davetang.org/muse/)上的一篇教程，参考资料中已经列出了地址。</p>
<p><code>fgsea</code>这个包用于做GSEA分析，先来看一下使用这个包做的图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911114456.png">

</div>
<p>现在简单解释一下这个图形：</p>
<p>x轴——排序后的基因列表<code>L</code>位置对应的坐标，也就是我们自己通过RNA-seq，芯片，qPCR等手段获得的基因表达值倍数变化，或p值排序，总之，这是一个有序列表。</p>
<p>垂直的黑色细胞——上图中类似条形码的图形，这是指的是某一个基因集<code>S</code>中基因对应于<code>L</code>基因中，的位置，在上图中，这个基因集是细胞周期(Cell Cycle)，明天看到<code>S</code>中的成员在<code>L</code>的左侧比较密集。</p>
<p>y轴——富集分布，从上面我们可以看到，细胞周期(Cell Cycle)这个基因集在左侧富集，也就是绿色曲线表示的位置。</p>
<h2 id="fgsea使用">fgsea使用</h2>
<h3 id="安装">安装</h3>
<p>先安装<code>fgsea</code>包，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">install.packages(<span class="string">"BiocManager"</span>)</div><div class="line">BiocManager::install(<span class="string">"fgsea"</span>)</div><div class="line"><span class="keyword">library</span>(fgsea)</div></pre></td></tr></table></figure>
<h3 id="数据">数据</h3>
<p><code>fgsea</code>包中内置的有数据集<code>examplePathways</code>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(fgsea)</div><div class="line"></div><div class="line">data(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># examplePathways是从'reactome.db'包中</span></div><div class="line"><span class="comment"># 提取的信息，并以列表的形式存了这些信息，</span></div><div class="line"><span class="comment"># 这些信息主要是小鼠的基因</span></div><div class="line">help(<span class="string">"examplePathways"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 这个数据集是一个列表</span></div><div class="line">class(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># 一共有1,457 "通路"</span></div><div class="line">length(examplePathways)</div><div class="line"></div><div class="line"><span class="comment"># 第1列含有Meiotic_Synapsis pathway的EntrezID</span></div><div class="line">examplePathways[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment"># exampleRanks储存的是排序信息</span></div><div class="line">data(exampleRanks)</div><div class="line"></div><div class="line"><span class="comment"># exampleRnak是一个数字型的向量</span></div><div class="line">class(exampleRanks)</div><div class="line"></div><div class="line"><span class="comment"># exampleRanks中的向量名称则是对称的Entrez ID</span></div><div class="line">head(exampleRanks)</div><div class="line">tail(unname(exampleRanks))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(fgsea)</div><div class="line">&gt; </div><div class="line">&gt; data(examplePathways)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># examplePathways是从'reactome.db'包中</span></div><div class="line"><span class="comment"># 提取的信息，并以列表的形式</span></div><div class="line">&gt; <span class="comment"># 储存了这些信息，这些信息主要是小鼠的基因</span></div><div class="line">&gt; help(<span class="string">"examplePathways"</span>)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 这个数据集是一个列表</span></div><div class="line">&gt; class(examplePathways)</div><div class="line">[<span class="number">1</span>] <span class="string">"list"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 一共有1,457 "通路"</span></div><div class="line">&gt; length(examplePathways)</div><div class="line">[<span class="number">1</span>] <span class="number">1457</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 第1列含有Meiotic_Synapsis pathway的EntrezID</span></div><div class="line">&gt; examplePathways[<span class="number">1</span>]</div><div class="line">$`1221633_Meiotic_Synapsis`</div><div class="line"> [<span class="number">1</span>] <span class="string">"12189"</span>     <span class="string">"13006"</span>     <span class="string">"15077"</span>     <span class="string">"15078"</span>     <span class="string">"15270"</span>     <span class="string">"15512"</span>    </div><div class="line"> [<span class="number">7</span>] <span class="string">"16905"</span>     <span class="string">"16906"</span>     <span class="string">"19357"</span>     <span class="string">"20842"</span>     <span class="string">"20843"</span>     <span class="string">"20957"</span>    </div><div class="line">[<span class="number">13</span>] <span class="string">"20962"</span>     <span class="string">"21749"</span>     <span class="string">"21750"</span>     <span class="string">"22196"</span>     <span class="string">"23856"</span>     <span class="string">"24061"</span>    </div><div class="line">[<span class="number">19</span>] <span class="string">"28113"</span>     <span class="string">"50878"</span>     <span class="string">"56739"</span>     <span class="string">"57321"</span>     <span class="string">"64009"</span>     <span class="string">"66654"</span>    </div><div class="line">[<span class="number">25</span>] <span class="string">"69386"</span>     <span class="string">"71846"</span>     <span class="string">"74075"</span>     <span class="string">"77053"</span>     <span class="string">"94244"</span>     <span class="string">"97114"</span>    </div><div class="line">[<span class="number">31</span>] <span class="string">"97122"</span>     <span class="string">"97908"</span>     <span class="string">"101185"</span>    <span class="string">"140557"</span>    <span class="string">"223697"</span>    <span class="string">"260423"</span>   </div><div class="line">[<span class="number">37</span>] <span class="string">"319148"</span>    <span class="string">"319149"</span>    <span class="string">"319150"</span>    <span class="string">"319151"</span>    <span class="string">"319152"</span>    <span class="string">"319153"</span>   </div><div class="line">[<span class="number">43</span>] <span class="string">"319154"</span>    <span class="string">"319155"</span>    <span class="string">"319156"</span>    <span class="string">"319157"</span>    <span class="string">"319158"</span>    <span class="string">"319159"</span>   </div><div class="line">[<span class="number">49</span>] <span class="string">"319160"</span>    <span class="string">"319161"</span>    <span class="string">"319565"</span>    <span class="string">"320332"</span>    <span class="string">"320558"</span>    <span class="string">"326619"</span>   </div><div class="line">[<span class="number">55</span>] <span class="string">"326620"</span>    <span class="string">"360198"</span>    <span class="string">"497652"</span>    <span class="string">"544973"</span>    <span class="string">"625328"</span>    <span class="string">"667250"</span>   </div><div class="line">[<span class="number">61</span>] <span class="string">"100041230"</span> <span class="string">"102641229"</span> <span class="string">"102641751"</span> <span class="string">"102642045"</span></div><div class="line"></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRanks储存的是排序信息</span></div><div class="line">&gt; data(exampleRanks)</div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRnak是一个数字型的向量</span></div><div class="line">&gt; class(exampleRanks)</div><div class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># exampleRanks中的向量名称则是对称的Entrez ID</span></div><div class="line">&gt; head(exampleRanks)</div><div class="line">   <span class="number">170942</span>    <span class="number">109711</span>     <span class="number">18124</span>     <span class="number">12775</span>     <span class="number">72148</span>     <span class="number">16010</span> </div><div class="line">-<span class="number">63.33703</span> -<span class="number">49.74779</span> -<span class="number">43.63878</span> -<span class="number">41.51889</span> -<span class="number">33.26039</span> -<span class="number">32.77626</span> </div><div class="line">&gt; tail(unname(exampleRanks))</div><div class="line">[<span class="number">1</span>] <span class="number">47.58235</span> <span class="number">49.87543</span> <span class="number">50.25179</span> <span class="number">50.86532</span> <span class="number">51.16110</span> <span class="number">53.28400</span></div></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<p>现在我们使用上面的数据进行GSEA分析，进行GSEA分析时，我们的通路文件（也就是GSEA官网中的GMT文件，对应的就是基因集<code>S</code>）储存在<code>pathways</code>参数中，用户自己的数据（排过序的数据）放在<code>stats</code>数据集中，剩下的参数不用管，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fgseaRes &lt;- fgsea(pathways = examplePathways, </div><div class="line">                  stats = exampleRanks,</div><div class="line">                  minSize=<span class="number">15</span>,</div><div class="line">                  maxSize=<span class="number">500</span>,</div><div class="line">                  nperm=<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<p>分析的结果fgseaRes是一个<code>data.table</code>格式的文件，使用<code>plotEnrichment</code>函数可以绘制出GSEA分析的结果，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">library(ggplot2)</div><div class="line"># 参考 https://github.com/Rdatatable/data.table/wiki</div><div class="line"># 来查看data.table相关的信息</div><div class="line">class(fgseaRes)</div><div class="line"></div><div class="line"># 查看p值小于0.01的通路的数目</div><div class="line">sum(fgseaRes[, padj &lt; 0.01])</div><div class="line"></div><div class="line"># 绘制出最显著的富集通路</div><div class="line">plotEnrichment(examplePathways[[head(fgseaRes[order(pval), ], 1)$pathway]],</div><div class="line">               exampleRanks) + </div><div class="line">               labs(title=head(fgseaRes[order(pval), ], 1)$pathway)</div></pre></td></tr></table></figure></p>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; class(fgseaRes)</div><div class="line">[<span class="number">1</span>] <span class="string">"data.table"</span> <span class="string">"data.frame"</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># 查看p值小于0.01的通路的数目</span></div><div class="line">&gt; sum(fgseaRes[, padj &lt; <span class="number">0.01</span>])</div><div class="line">[<span class="number">1</span>] <span class="number">78</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911122517.jpeg">

</div>
<p>可以画出具体的某条通路，如下所示；</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plotEnrichment(examplePathways[[<span class="string">"5991130_Programmed_Cell_Death"</span>]],</div><div class="line">               exampleRanks) + </div><div class="line">  labs(title=<span class="string">"Programmed Cell Death"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911125331.jpeg">

</div>
<p>还可以在一张图中绘制出前10个富集通路，以及后10个富集通路，一共20个，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">topPathwaysUp &lt;- fgseaRes[ES &gt; 0][head(order(pval), n=10), pathway]</div><div class="line">topPathwaysDown &lt;- fgseaRes[ES &lt; 0][head(order(pval), n=10), pathway]</div><div class="line">topPathways &lt;- c(topPathwaysUp, rev(topPathwaysDown))</div><div class="line">plotGseaTable(examplePathways[topPathways], exampleRanks, fgseaRes, </div><div class="line">              gseaParam = 0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911122626.jpeg">

</div>
<h3 id="reactome">Reactome</h3>
<p>也可以使用<a href="https://reactome.org/" target="_blank" rel="external">Reactome</a>通路来进行GSEA分析，此时需要安装<code>reactome.db</code>包，这个包很大，600多M，下载的时间很长，安装过程如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BiocManager::install("reactome.db")</span></div><div class="line"><span class="keyword">library</span>(reactome.db)</div><div class="line"></div><div class="line">my_pathways &lt;- reactomePathways(names(exampleRanks))</div><div class="line"> </div><div class="line"><span class="comment"># Reactome pathways have a median of 11 genes</span></div><div class="line">summary(sapply(my_pathways, length))</div><div class="line">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </div><div class="line">    <span class="number">1.0</span>     <span class="number">4.0</span>    <span class="number">11.0</span>    <span class="number">30.3</span>    <span class="number">30.0</span>  <span class="number">1140.0</span></div><div class="line"> </div><div class="line">fgsea_reactome &lt;- fgsea(pathways = my_pathways, </div><div class="line">                        stats = exampleRanks,</div><div class="line">                        minSize=<span class="number">15</span>,</div><div class="line">                        maxSize=<span class="number">500</span>,</div><div class="line">                        nperm=<span class="number">100000</span>)</div><div class="line"> </div><div class="line">head(fgsea_reactome[order(pval), ])</div><div class="line">sum(fgsea_reactome[, padj &lt; <span class="number">0.01</span>])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&gt; head(fgsea_reactome[order(pval), ])</div><div class="line">                    pathway         pval         padj</div><div class="line"><span class="number">1</span>:               Cell Cycle <span class="number">1.212856e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">2</span>:      Cell Cycle, Mitotic <span class="number">1.236552e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">3</span>: Neutrophil degranulation <span class="number">1.274974e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">4</span>: Signaling by Rho GTPases <span class="number">1.291339e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">5</span>:                  M Phase <span class="number">1.303509e-05</span> <span class="number">0.0002571089</span></div><div class="line"><span class="number">6</span>:   Cell Cycle Checkpoints <span class="number">1.350749e-05</span> <span class="number">0.0002571089</span></div><div class="line">          ES      NES nMoreExtreme size</div><div class="line"><span class="number">1</span>: <span class="number">0.5324037</span> <span class="number">2.674889</span>            <span class="number">0</span>  <span class="number">414</span></div><div class="line"><span class="number">2</span>: <span class="number">0.5475346</span> <span class="number">2.719737</span>            <span class="number">0</span>  <span class="number">363</span></div><div class="line"><span class="number">3</span>: <span class="number">0.4258088</span> <span class="number">2.074081</span>            <span class="number">0</span>  <span class="number">296</span></div><div class="line"><span class="number">4</span>: <span class="number">0.4073481</span> <span class="number">1.966039</span>            <span class="number">0</span>  <span class="number">271</span></div><div class="line"><span class="number">5</span>: <span class="number">0.5022189</span> <span class="number">2.408762</span>            <span class="number">0</span>  <span class="number">255</span></div><div class="line"><span class="number">6</span>: <span class="number">0.6085986</span> <span class="number">2.836881</span>            <span class="number">0</span>  <span class="number">200</span></div><div class="line">                                  leadingEdge</div><div class="line"><span class="number">1</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line"><span class="number">2</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line"><span class="number">3</span>:    <span class="number">11676</span>,<span class="number">14190</span>,<span class="number">53381</span>,<span class="number">12306</span>,<span class="number">20430</span>,<span class="number">12505</span>,<span class="keyword">...</span></div><div class="line"><span class="number">4</span>: <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">20430</span>,<span class="number">104215</span>,<span class="number">233406</span>,<span class="number">107995</span>,<span class="keyword">...</span></div><div class="line"><span class="number">5</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="number">52276</span>,<span class="keyword">...</span></div><div class="line"><span class="number">6</span>:   <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="number">12428</span>,<span class="keyword">...</span></div><div class="line">&gt; sum(fgsea_reactome[, padj &lt; <span class="number">0.01</span>])</div><div class="line">[<span class="number">1</span>] <span class="number">103</span></div></pre></td></tr></table></figure>
<h3 id="leading-edge">Leading edge</h3>
<p>在GSEA分析中，我们通常会提取那些构成高得分的核心基因。我们对高得分的核心基因的定义就是，基因集<code>S</code>中位于排序基因列表<code>L</code>位置中的得分最大处之前或之后的那些基因集（也就是GSEA结果中绿色曲线最高点的前面或后面）。</p>
<p>前面我们注意到，GSEA分析的结果中有1列被命名为<code>leadingEdge</code>。这一列包含了高得分的基因。我们使用Reactome通路的富集结果来提取这些基因，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># the most significant pathway</span></div><div class="line">fgsea_reactome[order(pval),][<span class="number">1</span>,]</div><div class="line"></div><div class="line"><span class="comment"># list of Entrez gene IDs that contributed to the enrichment score</span></div><div class="line">fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge</div><div class="line"></div><div class="line"><span class="comment"># how many genes are in the leading edge?</span></div><div class="line">length(fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge[[<span class="number">1</span>]])</div><div class="line"></div><div class="line"><span class="comment"># how many genes are in the Cell Cycle pathway?</span></div><div class="line">length(my_pathways[[<span class="string">'Cell Cycle'</span>]])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment"># the most significant pathway</span></div><div class="line">&gt; fgsea_reactome[order(pval),][<span class="number">1</span>,]</div><div class="line">      pathway         pval         padj        ES</div><div class="line"><span class="number">1</span>: Cell Cycle <span class="number">1.212856e-05</span> <span class="number">0.0002571089</span> <span class="number">0.5324037</span></div><div class="line">        NES nMoreExtreme size</div><div class="line"><span class="number">1</span>: <span class="number">2.674889</span>            <span class="number">0</span>  <span class="number">414</span></div><div class="line">                                leadingEdge</div><div class="line"><span class="number">1</span>: <span class="number">66336</span>,<span class="number">66977</span>,<span class="number">15366</span>,<span class="number">12442</span>,<span class="number">107995</span>,<span class="number">66442</span>,<span class="keyword">...</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># list of Entrez gene IDs that contributed to the enrichment score</span></div><div class="line">&gt; fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge</div><div class="line">[[<span class="number">1</span>]]</div><div class="line">  [<span class="number">1</span>] <span class="string">"66336"</span>  <span class="string">"66977"</span>  <span class="string">"15366"</span>  <span class="string">"12442"</span>  <span class="string">"107995"</span></div><div class="line">  [<span class="number">6</span>] <span class="string">"66442"</span>  <span class="string">"12571"</span>  <span class="string">"12428"</span>  <span class="string">"52276"</span>  <span class="string">"54392"</span> </div><div class="line"> [<span class="number">11</span>] <span class="string">"66311"</span>  <span class="string">"215387"</span> <span class="string">"67629"</span>  <span class="string">"12649"</span>  <span class="string">"72415"</span> </div><div class="line"> [<span class="number">16</span>] <span class="string">"56150"</span>  <span class="string">"57441"</span>  <span class="string">"20877"</span>  <span class="string">"67121"</span>  <span class="string">"12615"</span> </div><div class="line"> [<span class="number">21</span>] <span class="string">"11799"</span>  <span class="string">"66468"</span>  <span class="string">"67849"</span>  <span class="string">"19053"</span>  <span class="string">"73804"</span> </div><div class="line"> [<span class="number">26</span>] <span class="string">"76044"</span>  <span class="string">"20878"</span>  <span class="string">"15270"</span>  <span class="string">"13555"</span>  <span class="string">"60411"</span> </div><div class="line"> [<span class="number">31</span>] <span class="string">"12580"</span>  <span class="string">"17219"</span>  <span class="string">"69270"</span>  <span class="string">"12575"</span>  <span class="string">"69263"</span> </div><div class="line"> [<span class="number">36</span>] <span class="string">"12448"</span>  <span class="string">"14211"</span>  <span class="string">"20873"</span>  <span class="string">"18005"</span>  <span class="string">"72119"</span> </div><div class="line"> [<span class="number">41</span>] <span class="string">"71988"</span>  <span class="string">"12189"</span>  <span class="string">"17215"</span>  <span class="string">"12534"</span>  <span class="string">"66156"</span> </div><div class="line"> [<span class="number">46</span>] <span class="string">"208628"</span> <span class="string">"237911"</span> <span class="string">"22390"</span>  <span class="string">"68240"</span>  <span class="string">"228421"</span></div><div class="line"> [<span class="number">51</span>] <span class="string">"68014"</span>  <span class="string">"269582"</span> <span class="string">"19348"</span>  <span class="string">"12236"</span>  <span class="string">"72151"</span> </div><div class="line"> [<span class="number">56</span>] <span class="string">"18817"</span>  <span class="string">"21781"</span>  <span class="string">"18968"</span>  <span class="string">"217653"</span> <span class="string">"66934"</span> </div><div class="line"> [<span class="number">61</span>] <span class="string">"272551"</span> <span class="string">"227613"</span> <span class="string">"67141"</span>  <span class="string">"67951"</span>  <span class="string">"68612"</span> </div><div class="line"> [<span class="number">66</span>] <span class="string">"68298"</span>  <span class="string">"108000"</span> <span class="string">"23834"</span>  <span class="string">"106344"</span> <span class="string">"56452"</span> </div><div class="line"> [<span class="number">71</span>] <span class="string">"242705"</span> <span class="string">"18141"</span>  <span class="string">"223921"</span> <span class="string">"26886"</span>  <span class="string">"13557"</span> </div><div class="line"> [<span class="number">76</span>] <span class="string">"26909"</span>  <span class="string">"72787"</span>  <span class="string">"268697"</span> <span class="string">"72155"</span>  <span class="string">"56371"</span> </div><div class="line"> [<span class="number">81</span>] <span class="string">"17535"</span>  <span class="string">"107823"</span> <span class="string">"12531"</span>  <span class="string">"327762"</span> <span class="string">"12567"</span> </div><div class="line"> [<span class="number">86</span>] <span class="string">"229841"</span> <span class="string">"67052"</span>  <span class="string">"16319"</span>  <span class="string">"66634"</span>  <span class="string">"171567"</span></div><div class="line"> [<span class="number">91</span>] <span class="string">"26931"</span>  <span class="string">"67203"</span>  <span class="string">"12235"</span>  <span class="string">"19891"</span>  <span class="string">"74470"</span> </div><div class="line"> [<span class="number">96</span>] <span class="string">"72083"</span>  <span class="string">"381318"</span> <span class="string">"66570"</span>  <span class="string">"17216"</span>  <span class="string">"76308"</span> </div><div class="line">[<span class="number">101</span>] <span class="string">"19687"</span>  <span class="string">"17218"</span>  <span class="string">"102920"</span> <span class="string">"29870"</span>  <span class="string">"18973"</span> </div><div class="line">[<span class="number">106</span>] <span class="string">"16881"</span>  <span class="string">"17463"</span>  <span class="string">"75786"</span>  <span class="string">"19645"</span>  <span class="string">"19075"</span> </div><div class="line">[<span class="number">111</span>] <span class="string">"26417"</span>  <span class="string">"69736"</span>  <span class="string">"19357"</span>  <span class="string">"76816"</span>  <span class="string">"70385"</span> </div><div class="line">[<span class="number">116</span>] <span class="string">"70645"</span>  <span class="string">"22628"</span>  <span class="string">"225182"</span> <span class="string">"22627"</span>  <span class="string">"52683"</span> </div><div class="line">[<span class="number">121</span>] <span class="string">"19076"</span>  <span class="string">"18972"</span>  <span class="string">"231863"</span> <span class="string">"26932"</span>  <span class="string">"12544"</span> </div><div class="line">[<span class="number">126</span>] <span class="string">"17997"</span>  <span class="string">"51788"</span>  <span class="string">"26440"</span>  <span class="string">"68549"</span>  <span class="string">"12445"</span> </div><div class="line">[<span class="number">131</span>] <span class="string">"19088"</span>  <span class="string">"269113"</span> <span class="string">"26444"</span>  <span class="string">"19324"</span>  <span class="string">"103733"</span></div><div class="line">[<span class="number">136</span>] <span class="string">"59001"</span>  <span class="string">"107976"</span> <span class="string">"19179"</span>  <span class="string">"12579"</span>  <span class="string">"232987"</span></div><div class="line">[<span class="number">141</span>] <span class="string">"17420"</span>  <span class="string">"228769"</span> <span class="string">"219072"</span> <span class="string">"26445"</span>  <span class="string">"105988"</span></div><div class="line">[<span class="number">146</span>] <span class="string">"69745"</span>  <span class="string">"18538"</span>  <span class="string">"69928"</span>  <span class="string">"11651"</span>  <span class="string">"235559"</span></div><div class="line">[<span class="number">151</span>] <span class="string">"68097"</span>  <span class="string">"57296"</span>  <span class="string">"63955"</span>  <span class="string">"14235"</span>  <span class="string">"19170"</span> </div><div class="line">[<span class="number">156</span>] <span class="string">"17246"</span>  <span class="string">"17220"</span>  <span class="string">"12144"</span>  <span class="string">"50793"</span>  <span class="string">"77605"</span> </div><div class="line">[<span class="number">161</span>] <span class="string">"18392"</span>  <span class="string">"236930"</span> <span class="string">"67151"</span>  <span class="string">"70024"</span>  <span class="string">"59126"</span> </div><div class="line">[<span class="number">166</span>] <span class="string">"66296"</span>  <span class="string">"16906"</span>  <span class="string">"109145"</span> <span class="string">"71819"</span>  <span class="string">"67733"</span> </div><div class="line">[<span class="number">171</span>] <span class="string">"50883"</span>  <span class="string">"12447"</span>  <span class="string">"12532"</span>  <span class="string">"14156"</span>  <span class="string">"26442"</span> </div><div class="line">[<span class="number">176</span>] <span class="string">"19177"</span>  <span class="string">"230376"</span> <span class="string">"245688"</span></div><div class="line"></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># how many genes are in the leading edge?</span></div><div class="line">&gt; length(fgsea_reactome[order(pval),][<span class="number">1</span>,]$leadingEdge[[<span class="number">1</span>]])</div><div class="line">[<span class="number">1</span>] <span class="number">178</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="comment"># how many genes are in the Cell Cycle pathway?</span></div><div class="line">&gt; length(my_pathways[[<span class="string">'Cell Cycle'</span>]])</div><div class="line">[<span class="number">1</span>] <span class="number">414</span></div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>GSEA是于2005年首次提出来的，现在已经成了基因表达分析中的常规分析手段，它不同于GO分析，GO分析只关注差异基因，而GSEA分析则关注所有的基因。<code>fgsea</code>包可以使用预先排列好的基因一R中进行GSEA分析。p值的计算结果是基于置换检验(permutation test)，这种方法并不是十分精我，因为它忽略了基因之间的相关性，有可能会导致假阳性。但是，在这种方法在研究上调与上调基因方面还是很有用的。即使你计算出的GSEA结果中，p值大于0.05，但是是也可以参考leading edge基因集，为你的实验进行指导。</p>
<h2 id="案例分析">案例分析</h2>
<p>作者提供了用于生成类似于<strong>exampleRanks</strong>文件的R脚本，不过使用的GEO的数据，平时自己利用<code>fgsea</code>包进行GSEA分析时，生成就好，现在看一下如何将GEO的数据生成类似于****exampleRanks****文件的排序信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span>(<span class="string">"https://raw.githubusercontent.com/assaron/r-utils/master/R/exprs.R"</span>)</div><div class="line"><span class="keyword">library</span>(GEOquery)</div><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">gse14308 &lt;- getGEO(<span class="string">"GSE14308"</span>)[[<span class="number">1</span>]]</div><div class="line">pData(gse14308)$condition &lt;- sub(<span class="string">"-.*$"</span>, <span class="string">""</span>, gse14308$title)</div><div class="line">es &lt;- collapseBy(gse14308, fData(gse14308)$ENTREZ_GENE_ID, FUN=median)</div><div class="line">es &lt;- es[!grepl(<span class="string">"///"</span>, rownames(es)), ]</div><div class="line">es &lt;- es[rownames(es) != <span class="string">""</span>, ]</div><div class="line">exprs(es) &lt;- normalizeBetweenArrays(log2(exprs(es)+<span class="number">1</span>), method=<span class="string">"quantile"</span>)</div><div class="line">es.design &lt;- model.matrix(~<span class="number">0</span>+condition, data=pData(es))</div><div class="line">fit &lt;- lmFit(es, es.design)</div><div class="line">fit2 &lt;- contrasts.fit(fit, makeContrasts(conditionTh1-conditionNaive,</div><div class="line">                                         levels=es.design))</div><div class="line">fit2 &lt;- eBayes(fit2)</div><div class="line">de &lt;- data.table(topTable(fit2, adjust.method=<span class="string">"BH"</span>, number=<span class="number">12000</span>, sort.by = <span class="string">"B"</span>), keep.rownames = <span class="literal">T</span>)</div><div class="line">ranks &lt;- de[order(t), list(rn, t)]</div><div class="line">head(ranks)</div><div class="line">tail(ranks)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; head(ranks)</div><div class="line">       rn         t</div><div class="line"><span class="number">1</span>: <span class="number">109711</span> -<span class="number">50.99316</span></div><div class="line"><span class="number">2</span>:  <span class="number">18124</span> -<span class="number">44.40559</span></div><div class="line"><span class="number">3</span>:  <span class="number">12775</span> -<span class="number">43.22109</span></div><div class="line"><span class="number">4</span>:  <span class="number">72148</span> -<span class="number">33.74441</span></div><div class="line"><span class="number">5</span>:  <span class="number">16010</span> -<span class="number">33.34034</span></div><div class="line"><span class="number">6</span>:  <span class="number">16206</span> -<span class="number">30.67962</span></div><div class="line">&gt; tail(ranks)</div><div class="line">      rn        t</div><div class="line"><span class="number">1</span>: <span class="number">80901</span> <span class="number">47.55618</span></div><div class="line"><span class="number">2</span>: <span class="number">58801</span> <span class="number">48.53756</span></div><div class="line"><span class="number">3</span>: <span class="number">15937</span> <span class="number">49.88068</span></div><div class="line"><span class="number">4</span>: <span class="number">13730</span> <span class="number">50.17693</span></div><div class="line"><span class="number">5</span>: <span class="number">12772</span> <span class="number">50.32302</span></div><div class="line"><span class="number">6</span>: <span class="number">80876</span> <span class="number">51.72987</span></div></pre></td></tr></table></figure>
<p>现在绘制一下上述数据中6个上升与6个下降的基因热图：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(pheatmap)</div><div class="line"> </div><div class="line">my_group &lt;- data.frame(group = pData(es)$condition)</div><div class="line">row.names(my_group) &lt;- colnames(exprs(es))</div><div class="line"> </div><div class="line">pheatmap(</div><div class="line">  mat = es[c(head(de[order(t), <span class="number">1</span>])$rn, tail(de[order(t), <span class="number">1</span>])$rn),],</div><div class="line">  annotation_col = my_group,</div><div class="line">  cluster_rows = <span class="literal">FALSE</span>,</div><div class="line">  cellwidth=<span class="number">25</span>,</div><div class="line">  cellheight=<span class="number">15</span></div><div class="line">)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911133906.png">

</div>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://bioconductor.org/packages/release/bioc/vignettes/fgsea/inst/doc/fgsea-tutorial.html" target="_blank" rel="external">Using fgsea package</a></li>
<li><a href="https://www.r-bloggers.com/comparison-of-clusterprofiler-and-gsea-p/" target="_blank" rel="external">Comparison of clusterProfiler and GSEA-P</a></li>
<li><a href="https://davetang.org/muse/2018/01/10/using-fast-preranked-gene-set-enrichment-analysis-fgsea-package/" target="_blank" rel="external">Using the fast preranked gene set enrichment analysis (fgsea) package</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/09/07/Experiment/HIPC介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Experiment/HIPC介绍/" itemprop="url">HIPC介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T12:00:00+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物实验笔记/" itemprop="url" rel="index">
                    <span itemprop="name">生物实验笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  803
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>最近在看GSEA有关的内容，GSEA官网里涉及到一个基因集，即<code>C7 collection: Immunologic signatures</code>，这是一个与免疫相关的基因集，根据官网的介绍，这个基因集是由BROAD实验室与丹娜法伯癌症研究院（Dana-Farber Cancer Institute）的Haining Lab和人类免疫学项目联合合会(HIPC)合作的一部分，当时还发了一篇Immunity，文献信息如下：</p>
<p>Godec J, Tan Y, Liberzon A, Tamayo P, Bhattacharya S, Butte A, Mesirov JP, Haining WN, Compendium of Immune Signatures Identifies Conserved and Species-Specific Biology in Response to Inflammation, 2016, Immunity 44(1), 194-206.</p>
<p>以下内容是HIPC官网的一些资料。</p>
<h2 id="hipc简介">HIPC简介</h2>
<p>HIPC英文全称是Human Immunology Project Consortium，即人类免疫学项目研究联合会，成立于2010年，后又于2015年重组，即由原来的NIAID的过敏所（注：NIAID的全称为National Institute of Allergy and Infectious Diseases，即<strong>国家过敏与感染性疾病研究院</strong>），免疫所和移植所进行合并，统一作为NIAID的构成部分，集中研究人类免疫学。</p>
<p>注：上面一段话是我按原文翻译后理解的，不一定准确，为了避免歧义我，这里贴出原文：</p>
<blockquote>
<p>The Human Immunology Project Consortium (HIPC) program was established in 2010, and renewed in 2015, by the NIAID Division of Allergy, Immunology, and Transplantation as part of the overall NIAID focus on human immunology.</p>
</blockquote>
<p>通过HIPC计划，研究者们使用各种现代分析工具分析人类多个免疫学方面的数据，其中包括多重转录(multiplex transcriptional)，细胞因子，蛋白质谱；白细胞亚型的多参数表型(multiparameter phenotyping of leukocyte subsets)；评估白细胞功能状态以及开发多种算法。</p>
<p>HIPC项目旨在建立一个集中的研究中心，以及一个广泛的，中心化的数据库，从而让更多的研究者们使用。HIPC项目产生的信息将会有助于研究者们广泛地理解人类免疫系统方方面面，包括免疫系统的调控，发现免疫系统组分与其它生物系统的新型关系，从而确定新的免疫介质与通路，以及构建不同种群疫苗案安全性的预测因子，从而确保对不同疫苗配方的快速评估，确立接种方案等。该知识库还将会构建起免疫系统介导的人类疾病的研究基础，这些人类免疫性疾病包括过敏，哮喘，移植排斥和自身免疫性疾病以及各种炎症性疾病。</p>
<h2 id="hipc的任务">HIPC的任务</h2>
<h3 id="目标">目标</h3>
<ol style="list-style-type: decimal">
<li>定义稳定和活化的人类免疫系统的表达谱/标签/足迹(Define profiles/signatures/fingerprints of steady-state and activated human immune system)</li>
<li>创建一个中心化的知识库或资源：</li>
</ol>
<ul>
<li>有利于研究人类免疫系统；</li>
<li>针对人类疾病开发新的疗法。</li>
</ul>
<h3 id="研究">研究</h3>
<ol style="list-style-type: decimal">
<li>感染导致的稳态异常(Perturbations of the steady-state by infection)；</li>
<li>疫苗；</li>
<li>佐剂研究(Adjuvant administration )</li>
</ol>
<h3 id="方法">方法</h3>
<ol style="list-style-type: decimal">
<li>定义人类转录组/蛋白质谱；</li>
<li>多重分析(multiplex assays)；</li>
<li>多参数表型，系统生物学；</li>
<li>质谱。</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>https://www.immuneprofiling.org/hipc/page/showPage?pg=sci-about</li>
<li>http://software.broadinstitute.org/gsea/msigdb/collection_details.jsp#C7</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/25/DAL/DALS025_Batch_Effect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/DAL/DALS025_Batch_Effect/" itemprop="url">DALS025-批次效应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T12:00:00+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  57
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第10章机器学习的第1小节，这一部分的主要内容涉及批次效应(Batch Effects)，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/confounding.Rmd" target="_blank" rel="external">Github</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/24/DAL/DALS024_Basic_Machine_Learning03_Class_Prediction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/24/DAL/DALS024_Basic_Machine_Learning03_Class_Prediction/" itemprop="url">DALS024-机器学习03-分类预测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-24T12:00:00+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,035
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第3小节，这一部分的主要内容涉及类预测(Class Prediction)，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/machine_learning.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在这一部分中我们主要介绍分类预测(class prediction)。实际上，许多人将分类预测称为机器学习，有的时候我们会交替使用这两个术语。我们会对这个庞杂的主题做一个非常简单的介绍，重点关注一些具体的案例。</p>
<p>我们这里使用的案例来源于统计学的经典书籍，即Trevor Hastie, Robert Tibshirani and Jerome Friedman的《<em>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</em>》。与回归中的推断类似，机器学习(ML)也是研究结果 <span class="math inline">\(Y\)</span> 和协变量 <span class="math inline">\(X\)</span> 之间的关系。在ML中，我们将 <span class="math inline">\(X\)</span> 称为预测因子或特征值，ML和推断之间的主要区别在于，在ML中，我们主要研究使用 <span class="math inline">\(X\)</span> 来预测 <span class="math inline">\(Y\)</span> 。关于统计模型，我在常规的推断中，我们主要用来估计和解释模型参数，但在ML中，统计模型只是我们达到目的的手段，即预测 <span class="math inline">\(Y\)</span> 。</p>
<p>这里我们介绍理解ML的主要概念，以及两个具体的算法：回归(regression)和k近似算法(kNN,k nearest neighbors)。我们需要知道，绐中学习有几十种流行的算法，我们这里不一一列举。</p>
<p>在前面部分里，我们介绍了非常简单的单一预测因子案例。但是，大多数与这种案例相关的案例往往不止一个预测因子。为了说明这个问题，我们现在再介绍一个案例，其中 <span class="math inline">\(X\)</span> 是一个二维数据，<span class="math inline">\(Y\)</span> 是一个二分类结果。这个案例来源于Hastie, Tibshirani 和 Friedman的书中，在这个案例中， <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 并不线性关系。在下面的图形中，使用不 的颜色表示了实际的 <span class="math inline">\(f(x_1,x_2)=E(Y \mid X_1=x_1,X_2=x_2)\)</span> 值。下面的代码用于生成一个相对复杂的条件概率函数。我们随后会使用测试数据集与训练数据集。在下图中，我们使用红色来表示 <span class="math inline">\(f(x_1,x_2)\)</span>中接近于1的数据，使用蓝色表示接近于0的数据，中间过渡态使用黄色表示，如下所示：</p>
<figure class="highlight plain"><figcaption><span>conditional_prob, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(RColorBrewer)</div><div class="line">hmcol &lt;- colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(100)</div><div class="line">mycols=c(hmcol[1],hmcol[100])</div><div class="line">set.seed(1)</div><div class="line">##create covariates and outcomes</div><div class="line">##outcomes are alwasy 50 0s and 50 1s</div><div class="line">s2=0.15</div><div class="line">##pick means to create a non linear conditional expectation</div><div class="line">library(MASS)</div><div class="line">M0 &lt;- mvrnorm(10,c(1,0),s2*diag(2)) ##generate 10 means</div><div class="line">M1 &lt;- rbind(mvrnorm(3,c(1,1),s2*diag(2)),</div><div class="line">            mvrnorm(3,c(0,1),s2*diag(2)),</div><div class="line">            mvrnorm(4,c(0,0),s2*diag(2)))</div><div class="line">###funciton to generate random pairs</div><div class="line">s&lt;- sqrt(1/5)</div><div class="line">N=200</div><div class="line">makeX &lt;- function(M,n=N,sigma=s*diag(2))&#123;</div><div class="line">  z &lt;- sample(1:10,n,replace=TRUE) ##pick n at random from above 10</div><div class="line">  m &lt;- M[z,] ##these are the n vectors (2 components)</div><div class="line">  return(t(apply(m,1,function(mu) mvrnorm(1,mu,sigma)))) ##the final values</div><div class="line">&#125;</div><div class="line">###create the training set and the test set</div><div class="line">x0 &lt;- makeX(M0)##the final values for y=0 (green)</div><div class="line">testx0 &lt;- makeX(M0)</div><div class="line">x1 &lt;- makeX(M1)</div><div class="line">testx1 &lt;-makeX(M1)</div><div class="line">x &lt;- rbind(x0,x1) ##one matrix with everything</div><div class="line">test &lt;- rbind(testx0,testx1)</div><div class="line">y &lt;- c(rep(0,N),rep(1,N)) #the outcomes</div><div class="line">ytest &lt;- c(rep(0,N),rep(1,N))</div><div class="line">cols &lt;- mycols[c(rep(1,N),rep(2,N))]</div><div class="line">colstest &lt;- cols</div><div class="line">##Create a grid so we can predict all of X,Y</div><div class="line">GS &lt;- 150 ##grid size is GS x GS</div><div class="line">XLIM &lt;- c(min(c(x[,1],test[,1])),max(c(x[,1],test[,1])))</div><div class="line">tmpx &lt;- seq(XLIM[1],XLIM[2],len=GS)</div><div class="line">YLIM &lt;- c(min(c(x[,2],test[,2])),max(c(x[,2],test[,2])))</div><div class="line">tmpy &lt;- seq(YLIM[1],YLIM[2],len=GS)</div><div class="line">newx &lt;- expand.grid(tmpx,tmpy) #grid used to show color contour of predictions</div><div class="line">###Bayes rule: best possible answer</div><div class="line">p &lt;- function(x)&#123; ##probability of Y given X</div><div class="line">  p0 &lt;- mean(dnorm(x[1],M0[,1],s)*dnorm(x[2],M0[,2],s))</div><div class="line">  p1 &lt;- mean(dnorm(x[1],M1[,1],s)*dnorm(x[2],M1[,2],s))</div><div class="line">  p1/(p0+p1)</div><div class="line">&#125;</div><div class="line">###Create the bayesrule prediction</div><div class="line">bayesrule &lt;- apply(newx,1,p)</div><div class="line">colshat &lt;- bayesrule</div><div class="line">colshat &lt;- hmcol[floor(bayesrule*100)+1]</div><div class="line">mypar()</div><div class="line">plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912170040.jpeg">

</div>
<p>如果我们将那些 <span class="math inline">\(E(Y \mid X=x)&gt;0.5\)</span> 的点用红色表示，剩下的点用蓝色表示，我们就能看到一条明显的分界线，它将0与1的区域分开了，如下所示：</p>
<figure class="highlight plain"><figcaption><span>bayes_rule,fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">colshat[bayesrule&gt;=0.5] &lt;- mycols[2]</div><div class="line">colshat[bayesrule&lt;0.5] &lt;- mycols[1]</div><div class="line">plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div><div class="line">contour(tmpx,tmpy,matrix(round(bayesrule),GS,GS),levels=c(1,2),</div><div class="line">        add=TRUE,drawlabels=FALSE)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912170527.jpeg">

</div>
<p>通过上面的图形我们并没有看到“真相”(truth)。大多数的ML方法涉及估计的 <span class="math inline">\(f(x)\)</span> 。通常第一步就是将一个样本作为参数，也就是训练集(training set)，用它来估计 <span class="math inline">\(f(x)\)</span> 。我们将回顾一下两种具体的ML技术。首先，我们需要回顾一下我们用评估这些方法性能的主要概念。</p>
<h3 id="训练集">训练集</h3>
<p>在第一张图中，我们创建了一个训练集和一个测试集，现在我们画出来，如下所示：</p>
<figure class="highlight plain"><figcaption><span>test_train, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#x, test, cols, and coltest were created in code that was not shown</div><div class="line">#x is training x1 and x2, test is test x1 and x2</div><div class="line">#cols (0=blue, 1=red) are training observations</div><div class="line">#coltests are test observations</div><div class="line">mypar(1,2)</div><div class="line">plot(x,pch=21,bg=cols,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">plot(test,pch=21,bg=colstest,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912171217.jpeg">

</div>
<p>从上面我们可以看到，训练集（左侧）与测试集（右侧）有着相似的全局属性，因为它们是用相同的随机谈量生成的（蓝色点都趋向分布于右下角），但是它们的构建的过程还是不同的。原因在于，我们创建测试集和训练集的原因是通过测试与用于拟合模型或训练算法的数据不同的数据来检测过度训练。 我们将在下面看到它的重要性。</p>
<h4 id="利用回归进行预测">利用回归进行预测</h4>
<p>关于ML问题的第一个简单方法就是拟合一个双变量线性回归模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##x and y were created in the code (not shown) for the first plot</div><div class="line">#y is outcome for the training set</div><div class="line">X1 &lt;- x[,1] ##these are the covariates</div><div class="line">X2 &lt;- x[,2] </div><div class="line">fit1 &lt;- lm(y~X1+X2)</div></pre></td></tr></table></figure>
<p>一旦我们有了这些拟合的数据，我们就能使用 <span class="math inline">\(\hat{f}(x_1,x_2)=\hat{\beta}_0 + \hat{\beta}_1x_1 +\hat{\beta}_2 x_2\)</span> 来估计 <span class="math inline">\(f(x_1,x_2)\)</span> 。为了提供一个实际的预测结果，我们仅仅预测当 <span class="math inline">\(\hat{f}(x_1,x_2)&gt;0.5\)</span> 时结果为1（这一段不懂）。我们现在检测一个在训练集与测试集中的错误率，并绘制出边界区域，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">##prediction on train</div><div class="line">yhat &lt;- predict(fit1)</div><div class="line">yhat &lt;- as.numeric(yhat&gt;0.5)</div><div class="line">cat(&quot;Linear regression prediction error in train:&quot;,1-mean(yhat==y),&quot;\n&quot;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Linear regression prediction error <span class="keyword">in</span> train: <span class="number">0.295</span></div></pre></td></tr></table></figure>
<p>我们使用<code>predict()</code>函数就能很快地从任意数据集中来获得预测值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yhat &lt;- predict(fit1,newdata=data.frame(X1=newx[,1],X2=newx[,2]))</div></pre></td></tr></table></figure>
<p>现在我们生成图片，用于展示我们预测的1和0在图片上的分布，以及边界。我们还可以使用<code>predict()</code>函数从我们的测试集中生成预测数据。需要注意的是，我们无法在测试集中拟合模型：</p>
<figure class="highlight plain"><figcaption><span>regression_prediction, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">colshat &lt;- yhat</div><div class="line">colshat[yhat&gt;=0.5] &lt;- mycols[2]</div><div class="line">colshat[yhat&lt;0.5] &lt;- mycols[1]</div><div class="line">m &lt;- -fit1$coef[2]/fit1$coef[3] #boundary slope</div><div class="line">b &lt;- (0.5 - fit1$coef[1])/fit1$coef[3] #boundary intercept</div><div class="line">##prediction on test</div><div class="line">yhat &lt;- predict(fit1,newdata=data.frame(X1=test[,1],X2=test[,2]))</div><div class="line">yhat &lt;- as.numeric(yhat&gt;0.5)</div><div class="line">cat(&quot;Linear regression prediction error in test:&quot;,1-mean(yhat==ytest),&quot;\n&quot;)</div><div class="line">plot(test,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">abline(b,m)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div><div class="line">##test was created in the code (not shown) for the first plot</div><div class="line">points(test,bg=cols,pch=21)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912173537.jpeg">

</div>
<p>在上图中，我们使用 <span class="math inline">\(X_{1}\)</span>和 <span class="math inline">\(X_{2}\)</span> 作为预测因子估计了1的概率，预测的结果将高于0.5的数据标注成了红色，低于0.5的标注为了蓝色。</p>
<p>从计算结果来年地，训练集与测试集的错误率非常相似。因此我们可以相信似乎没有过度训练。这并不奇怪，因为我们使用了2参数模型来拟合400个数据点。不过需要注意的是，边界是一个直线。因为我们为这些数据拟合了一个平面，所以这里没有其它选择。线性回归方法过于僵化。这种僵化会让它稳定，并且避免过度训练。，但是线性回归也不能适合对 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(X\)</span> 之间的非线性关系进行拟合。我们之前在平滑部分中看到了这些东西。下一个ML技术将会达到我们之间平滑处理的那种效果。</p>
<h4 id="knn">kNN</h4>
<p>kNN的全称是K-nearest neighbors，即<code>k最近邻</code>，这种算法类似于微区间平滑处理，但是kNN更适合于多维数据。总的来说，只要给定我们想要估计的任意点 <span class="math inline">\(x\)</span> ，我们会寻找k个最近的点，然后取这些点的平均值。这就会估计 <span class="math inline">\(f(x_1,x_2)\)</span> , 跟微区间平滑处理生成一个条曲线类似。我们现在通过 <span class="math inline">\(k\)</span> 来控制灵活性。这时我们比较一下 <span class="math inline">\(k=1\)</span> 和 <span class="math inline">\(k=100\)</span> 时的计算结果：</p>
<figure class="highlight plain"><figcaption><span>message</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">mypar(2,2)</div><div class="line">for(k in c(1,100))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=k)</div><div class="line">  cat(&quot;KNN prediction error in train:&quot;,1-mean((as.numeric(yhat)-1)==y),&quot;\n&quot;)</div><div class="line">  ##make plot</div><div class="line">  yhat &lt;- knn(x,test,y,k=k)</div><div class="line">  cat(&quot;KNN prediction error in test:&quot;,1-mean((as.numeric(yhat)-1)==ytest),&quot;\n&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">&gt; <span class="keyword">for</span>(k <span class="keyword">in</span> c(<span class="number">1</span>,<span class="number">100</span>))&#123;</div><div class="line">+   <span class="comment">##predict on train</span></div><div class="line">+   yhat &lt;- knn(x,x,y,k=k)</div><div class="line">+   cat(<span class="string">"KNN prediction error in train:"</span>,<span class="number">1</span>-mean((as.numeric(yhat)-<span class="number">1</span>)==y),<span class="string">"\n"</span>)</div><div class="line">+   <span class="comment">##make plot</span></div><div class="line">+   yhat &lt;- knn(x,test,y,k=k)</div><div class="line">+   cat(<span class="string">"KNN prediction error in test:"</span>,<span class="number">1</span>-mean((as.numeric(yhat)-<span class="number">1</span>)==ytest),<span class="string">"\n"</span>)</div><div class="line">+ &#125;</div><div class="line">KNN prediction error <span class="keyword">in</span> train: <span class="number">0</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> test: <span class="number">0.375</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> train: <span class="number">0.2425</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> test: <span class="number">0.2825</span></div></pre></td></tr></table></figure>
<p>为了说明，当我们设定 <span class="math inline">\(k=1\)</span>时，训练集中没有错误，以及 <span class="math inline">\(k=100\)</span> 时错误升高的原因，我们用图片直观地展示一下上面的结果，如下所示：</p>
<figure class="highlight plain"><figcaption><span>knn, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">mypar(2,2)</div><div class="line">for(k in c(1,100))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=k)</div><div class="line">  ##make plot</div><div class="line">  yhat &lt;- knn(x,newx,y,k=k)</div><div class="line">  colshat &lt;- mycols[as.numeric(yhat)]</div><div class="line">  plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">  points(newx,col=colshat,cex=0.35,pch=16)</div><div class="line">  contour(tmpx,tmpy,matrix(as.numeric(yhat),GS,GS),levels=c(1,2),</div><div class="line">          add=TRUE,drawlabels=FALSE)</div><div class="line">  points(x,bg=cols,pch=21)</div><div class="line">  title(paste(&quot;Train: KNN (&quot;,k,&quot;)&quot;,sep=&quot;&quot;))</div><div class="line">  </div><div class="line">  plot(test,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">  points(newx,col=colshat,cex=0.35,pch=16)</div><div class="line">  contour(tmpx,tmpy,matrix(as.numeric(yhat),GS,GS),levels=c(1,2),</div><div class="line">          add=TRUE,drawlabels=FALSE)</div><div class="line">  points(test,bg=cols,pch=21)</div><div class="line">  title(paste(&quot;Test: KNN (&quot;,k,&quot;)&quot;,sep=&quot;&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912174226.jpeg">

</div>
<p>从图上我们可以发现，当 <span class="math inline">\(k=1\)</span> 时，在训练集中并没有出现错误，因为每个点都是它最接近的点，这个就是它自身。但是，我们可以看到一些蓝色的岛（由几个点构成的区域）在红色区域中，一旦我们将数据集移向测试集，就会出现一些错误。当 <span class="math inline">\(k=100\)</span> 时，我们没有这个问题（也就是说红蓝区域分得很开），我们可以看到，错误率比线性回归有着明显的降低。我们还看到，我们估计的 <span class="math inline">\(f(x_1,x_2)\)</span> 比较接近于真实情况。</p>
<h4 id="贝叶斯规则">贝叶斯规则</h4>
<p>在这一部分里，我们会比较了不同 <span class="math inline">\(k\)</span> 值下的训练集与测试集。我们还会比较当我们知道 <span class="math inline">\(\mbox{E}(Y \mid X_1=x1,X_2=x_2)\)</span> 时的错误率，这也就是所谓的贝叶斯规则(Bayes Rule)。</p>
<p>我们先来计算一下错误率，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">###Bayes Rule</div><div class="line">yhat &lt;- apply(test,1,p)</div><div class="line">cat(&quot;Bayes rule prediction error in train&quot;,1-mean(round(yhat)==y),&quot;\n&quot;)</div><div class="line">bayes.error=1-mean(round(yhat)==y)</div><div class="line">train.error &lt;- rep(0,16)</div><div class="line">test.error &lt;- rep(0,16)</div><div class="line">for(k in seq(along=train.error))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=2^(k/2))</div><div class="line">  train.error[k] &lt;- 1-mean((as.numeric(yhat)-1)==y)</div><div class="line">  ##prediction on test    </div><div class="line">  yhat &lt;- knn(x,test,y,k=2^(k/2))</div><div class="line">  test.error[k] &lt;- 1-mean((as.numeric(yhat)-1)==y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后绘制出不同 <span class="math inline">\(k\)</span> 值下的错误率。我们还以一条水平线来展示贝叶斯规则错误率，如下所示</p>
<figure class="highlight plain"><figcaption><span>bayes_rule2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ks &lt;- 2^(seq(along=train.error)/2)</div><div class="line">mypar()</div><div class="line">plot(ks,train.error,type=&quot;n&quot;,xlab=&quot;K&quot;,ylab=&quot;Prediction Error&quot;,log=&quot;x&quot;,</div><div class="line">     ylim=range(c(test.error,train.error)))</div><div class="line">lines(ks,train.error,type=&quot;b&quot;,col=4,lty=2,lwd=2)</div><div class="line">lines(ks,test.error,type=&quot;b&quot;,col=5,lty=3,lwd=2)</div><div class="line">abline(h=bayes.error,col=6)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;Train&quot;,&quot;Test&quot;,&quot;Bayes&quot;),col=c(4,5,6),lty=c(2,3,1),box.lwd=0)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913013135.jpeg">

</div>
<p>在上图中，粉色是训练集的错误率，绿色的是测试集的错误率。黄色是贝叶斯规则的错误率。</p>
<p>我们要知道，错误率是一个随机变量，它有着标准差。在下面的部分里，我们会提到交叉验证，这种方法有助于降低一些变异（这里我自己的理解就是错误率的变异）。然而即使将这些变异降低，从图中我们就可以看出来，当 <span class="math inline">\(k\)</span> 低于20时就会出现过拟合(over-fitting)，当 <span class="math inline">\(k\)</span> 超过100时就会出现低拟合(under-fitting)。</p>
<h2 id="交叉验证">交叉验证</h2>
<p>这里我们描述一下交叉验证(cross-validation)，交叉验证是机器学习中有关方法评估的一个基础工具，它能在一项预测或机器学习任务中进行参数选择。假设我们有一组许多特征值的观测值，并且每个观测值都与一个标签关联。我们将这个集合称为我们的训练集。我们的任务就是通过从训练数据中学习模式来预测任何新样本的标签。对于一个具体的例子来说，例如我们会将每个基因看作是一个特征值，然后我们再来计算一组没有标签的数据（测试数据集），看一下这组数据是新样本中的哪些组织类型。</p>
<p>如果我们选择了一个可调参数的机器学习算法，那么我们必须要有一个策略来这个参数选择一个最佳值。我们可以尝试着先计算一批数据，例如可以把一些已知样本的数据当作训练集，然后算法会计算出这些值产生的错误数据，然后我们会选择在我们的训练集中表现最好的值。</p>
<p>现在我们使用前面提到过的组织基要因表达数据集来看一下，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">library(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div></pre></td></tr></table></figure>
<p>为了说明我们这么做的目的，我们把那些样本数目较少的组织剔除掉，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">table(tissue)</div><div class="line">ind &lt;- which(tissue != &quot;placenta&quot;)</div><div class="line">y &lt;- tissue[ind]</div><div class="line">X &lt;- t( e[,ind] )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; table(tissue)</div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们把<code>placenta(胎盘)</code>这个组织去掉了，现在我们使用kNN法来进行归类，先使用 <span class="math inline">\(k=5\)</span> 这个参数试一下。当我们把这个参数用于训练集和测试集时，我们在预测训练集中的组织时，平均误差是多少呢？</p>
<p>计算过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">pred &lt;- knn(train =  X, test = X, cl=y, k=5)</div><div class="line">mean(y != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当我们使用 <span class="math inline">\(k=5\)</span> 这个参数时，没有发现错误，如果是 <span class="math inline">\(k=1\)</span> 呢？如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pred &lt;- knn(train=X, test=X, cl=y, k=1)</div><div class="line">mean(y != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当我们试图通过对观测值进行分类用于训练(train)模型时，这一过程可能有误导性。事实时，对于kNN法来说，使用 <span class="math inline">\(k=1\)</span> 这个参数时，总是能在训练集中得到0个分类错误，因为我们使用的是数据本身。了解算法是否可靠的方法就让它对未见过的样本进行预测。类似地，如果我们想知道可调参数的最佳值是什么，我们查看不同的参数值在那些不在训练集中的样本上表现如何。</p>
<p>交叉验证是机器学习中广泛使用的一种方法，它解决了训练集和测试集的问题，同时它仍然可以使用所有的数据用于检测预测的准确性。它通过将所有的数据分散成一定数据的折叠(fold)（注：这里有关交叉验证的问题，可以参考以前的文章<a href="http://rvdsd.top/2018/07/05/StatQuest/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B022-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/">《StatQuest学习笔记22——交叉验证》</a>）。如果我们有 <span class="math inline">\(N\)</span> 个折叠，那么算法的第一步就是使用 <span class="math inline">\((N-1)\)</span> 个折叠来训练算法，并且剩下一个折叠用于测试算法的准确性。然后重复 <span class="math inline">\(N\)</span> 次，直到所有的折叠都在测试集中一样被使用。如果我们有M个参数需要进行尝试，那么我们需要在外部循环中完成这个过程，因为我们需要总共拟合 <span class="math inline">\(N \times M\)</span>次。</p>
<p>在R中，我们使用<code>caret</code>包中的<code>createFolds()</code>函数来实现这个过程,在下面的案例中，我们使用5个折叠来计算我们的基因表达数据，这个数字与组织的数目比较接近。此外，<code>createFold()</code>函数中有个参数<code>k</code>，这里不要与kNN算法中的<code>k</code>混淆，它们只是相同的字符，具体意义不一样，它们完全不相关。<code>createFolds()</code>会寻问用户要创建多少个折叠，也就是上文提到的 <span class="math inline">\(N\)</span> 。而<code>knn()</code>中的参数<code>k</code>则是说明在一个新的样本中，使用多少个最接近的观测值。现在我们创建10个折叠，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">library(caret)</div><div class="line">set.seed(1)</div><div class="line">idx &lt;- createFolds(y, k=10)</div><div class="line">sapply(idx, length)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; sapply(idx, length)</div><div class="line">Fold01 Fold02 Fold03 Fold04 Fold05 Fold06 Fold07 Fold08 Fold09 Fold10 </div><div class="line">    <span class="number">18</span>     <span class="number">19</span>     <span class="number">17</span>     <span class="number">17</span>     <span class="number">18</span>     <span class="number">20</span>     <span class="number">19</span>     <span class="number">19</span>     <span class="number">20</span>     <span class="number">16</span></div></pre></td></tr></table></figure>
<p>折叠会以数字索引列表的形式返回，因此数据的第一个折叠是：</p>
<p>The folds are returned as a list of numeric indices. The first fold of data is therefore:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y[idx[[1]]] ##the labels</div><div class="line">head( X[idx[[1]], 1:3] ) ##the genes (only showing the first 3 genes...)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; y[idx[[<span class="number">1</span>]]] <span class="comment">##the labels</span></div><div class="line"> [<span class="number">1</span>] <span class="string">"kidney"</span>      <span class="string">"kidney"</span>      <span class="string">"hippocampus"</span> <span class="string">"hippocampus"</span> <span class="string">"hippocampus"</span> <span class="string">"cerebellum"</span> </div><div class="line"> [<span class="number">7</span>] <span class="string">"cerebellum"</span>  <span class="string">"cerebellum"</span>  <span class="string">"colon"</span>       <span class="string">"colon"</span>       <span class="string">"colon"</span>       <span class="string">"colon"</span>      </div><div class="line">[<span class="number">13</span>] <span class="string">"kidney"</span>      <span class="string">"kidney"</span>      <span class="string">"endometrium"</span> <span class="string">"endometrium"</span> <span class="string">"liver"</span>       <span class="string">"liver"</span>      </div><div class="line">&gt; head( X[idx[[<span class="number">1</span>]], <span class="number">1</span>:<span class="number">3</span>] ) <span class="comment">##the genes (only showing the first 3 genes...)</span></div><div class="line">                1007_s_at  1053_at   117_at</div><div class="line">GSM12075.CEL.gz  <span class="number">9.966782</span> <span class="number">6.060069</span> <span class="number">7.644452</span></div><div class="line">GSM12098.CEL.gz  <span class="number">9.945652</span> <span class="number">5.927861</span> <span class="number">7.847192</span></div><div class="line">GSM21214.cel.gz <span class="number">10.955428</span> <span class="number">5.776781</span> <span class="number">7.493743</span></div><div class="line">GSM21218.cel.gz <span class="number">10.757734</span> <span class="number">5.984170</span> <span class="number">8.525524</span></div><div class="line">GSM21230.cel.gz <span class="number">11.496114</span> <span class="number">5.760156</span> <span class="number">7.787561</span></div><div class="line">GSM87086.cel.gz  <span class="number">9.798633</span> <span class="number">5.862426</span> <span class="number">7.279199</span></div></pre></td></tr></table></figure>
<p>我们可以看到，事实上组织在10个折叠中表现非常平均：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sapply(idx, function(i) table(y[i]))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; sapply(idx, <span class="keyword">function</span>(i) table(y[i]))</div><div class="line">            Fold01 Fold02 Fold03 Fold04 Fold05 Fold06 Fold07 Fold08 Fold09 Fold10</div><div class="line">cerebellum       <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span></div><div class="line">colon            <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">3</span></div><div class="line">endometrium      <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span></div><div class="line">hippocampus      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span></div><div class="line">kidney           <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span></div><div class="line">liver            <span class="number">2</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span>      <span class="number">2</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span></div></pre></td></tr></table></figure>
<p>因为不同组织的表达谱不一样，因此使用所有的基因来预测组织非常容易。为了说明这种算法的原理，我们这里只使用二维数据来进行预测，现在我们使用<code>cmdscale()</code>函数进行降低处理：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">Xsmall &lt;- cmdscale(dist(X))</div><div class="line">plot(Xsmall,col=as.fumeric(y))</div><div class="line">legend(<span class="string">"topleft"</span>,levels(factor(y)),fill=seq_along(levels(factor(y))))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913180841.jpeg">

</div>
<p>现在我们在单个折叠上试一下kNN法。我们使用<code>Xsmall</code>中的样本（不用第1个样本），用<code>knn()</code>函数计算一下。我们使用<code>-idx[[1]]</code>移除第1个样本，这样将剩下来的样本当作测试集。参数<code>cl</code>用于指定真分类（true classificaiton）或者是训练集的标签（这里指的是组织）。现在我们使用5个观测值来为我们的kNN算法指定分类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pred &lt;- knn(train=Xsmall[ -idx[[1]] , ], test=Xsmall[ idx[[1]], ], cl=y[ -idx[[1]] ], k=5)</div><div class="line">table(true=y[ idx[[1]] ], pred)</div><div class="line">mean(y[ idx[[1]] ] != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=y[ idx[[<span class="number">1</span>]] ], pred)</div><div class="line">             pred</div><div class="line">true          cerebellum colon endometrium hippocampus kidney liver</div><div class="line">  cerebellum           <span class="number">2</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  colon                <span class="number">0</span>     <span class="number">4</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  endometrium          <span class="number">0</span>     <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span></div><div class="line">  hippocampus          <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">2</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  kidney               <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">4</span>     <span class="number">0</span></div><div class="line">  liver                <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">0</span>     <span class="number">2</span></div><div class="line">&gt; mean(y[ idx[[<span class="number">1</span>]] ] != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0.1666667</span></div></pre></td></tr></table></figure>
<p>现在我们出现了一些分类错误，我们计算一下剩余折叠，看一下情况怎么样？</p>
<p>Now we have some misclassifications. How well do we do for the rest of the folds?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (i in 1:10) &#123;</div><div class="line">  pred &lt;- knn(train=Xsmall[ -idx[[i]] , ], test=Xsmall[ idx[[i]], ], cl=y[ -idx[[i]] ], k=5)</div><div class="line">  print(paste0(i,&quot;) error rate: &quot;, round(mean(y[ idx[[i]] ] != pred),3)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>) &#123;</div><div class="line">+   pred &lt;- knn(train=Xsmall[ -idx[[i]] , ], test=Xsmall[ idx[[i]], ], cl=y[ -idx[[i]] ], k=<span class="number">5</span>)</div><div class="line">+   print(paste0(i,<span class="string">") error rate: "</span>, round(mean(y[ idx[[i]] ] != pred),<span class="number">3</span>)))</div><div class="line">+ &#125;</div><div class="line">[<span class="number">1</span>] <span class="string">"1) error rate: 0.111"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"2) error rate: 0.105"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"3) error rate: 0.118"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"4) error rate: 0.118"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"5) error rate: 0.278"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"6) error rate: 0.1"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"7) error rate: 0.105"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"8) error rate: 0.158"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"9) error rate: 0.15"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"10) error rate: 0.312"</span></div></pre></td></tr></table></figure>
<p>所以，我们会看到每个折叠都会发生一些变化，其错误率徘徊在0.1-0.3之间。但是，<span class="math inline">\(k=5\)</span> 是最佳的参数吗？为了研究 <span class="math inline">\(k\)</span> 的最佳数值，我们需要创建一个外部循环，我们会在其中尝试不同的 <span class="math inline">\(k\)</span> 值，然后计算出所有折叠的平均测试集误差。我们将会尝试从1到12的每个 <span class="math inline">\(k\)</span> 值。不过这里我们不使用<code>for</code>循环，我们将使用<code>sapply</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">set.seed(1)</div><div class="line">ks &lt;- 1:12</div><div class="line">res &lt;- sapply(ks, function(k) &#123;</div><div class="line">  ##try out each version of k from 1 to 12</div><div class="line">  res.k &lt;- sapply(seq_along(idx), function(i) &#123;</div><div class="line">    ##loop over each of the 10 cross-validation folds</div><div class="line">    ##predict the held-out samples using k nearest neighbors</div><div class="line">    pred &lt;- knn(train=Xsmall[ -idx[[i]], ],</div><div class="line">                test=Xsmall[ idx[[i]], ],</div><div class="line">                cl=y[ -idx[[i]] ], k = k)</div><div class="line">    ##the ratio of misclassified samples</div><div class="line">    mean(y[ idx[[i]] ] != pred)</div><div class="line">  &#125;)</div><div class="line">  ##average over the 10 folds</div><div class="line">  mean(res.k)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>对于每个 <span class="math inline">\(k\)</span> 值，我们都有一个来自于交叉验证的关联测试集错误率，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; res</div><div class="line"> [<span class="number">1</span>] <span class="number">0.1978212</span> <span class="number">0.1703423</span> <span class="number">0.1882933</span> <span class="number">0.1750989</span> <span class="number">0.1613291</span> <span class="number">0.1500791</span> <span class="number">0.1552670</span> <span class="number">0.1884813</span></div><div class="line"> [<span class="number">9</span>] <span class="number">0.1822020</span> <span class="number">0.1763197</span> <span class="number">0.1761318</span> <span class="number">0.1813197</span></div></pre></td></tr></table></figure>
<p>我们可以绘制出每个 <span class="math inline">\(k\)</span> 值下的错误率图，它可以帮助我们查看哪个区域中的错误率最小，如下所示：</p>
<figure class="highlight plain"><figcaption><span>misclassification_error, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(ks, res, type=&quot;o&quot;,ylab=&quot;misclassification error&quot;)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913184146.jpeg">

</div>
<p>我们要记住一点就是，训练集是一个随机变量，因为我们生成折叠的程序涉随机数的生成，因此，在产生“最好”的 <span class="math inline">\(k\)</span> 值时，这个 <span class="math inline">\(k\)</span> 值的产生过程也是一个随机变量。如果我们有新的训练集，并且如果我们再创建折叠，那么我们有可能会得到一个新的优化的 <span class="math inline">\(k\)</span> 值。</p>
<p>最后，为了说明基因表达数据能够很好的预测组织类型，我们使用5维数据，而非是2维数据来展示这个过程，毕竟5维数据的信息量更丰富，如下所示：</p>
<figure class="highlight plain"><figcaption><span>misclassification_error2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Xsmall &lt;- cmdscale(dist(X),k=5)</div><div class="line">set.seed(1)</div><div class="line">ks &lt;- 1:12</div><div class="line">res &lt;- sapply(ks, function(k) &#123;</div><div class="line">  res.k &lt;- sapply(seq_along(idx), function(i) &#123;</div><div class="line">    pred &lt;- knn(train=Xsmall[ -idx[[i]], ],</div><div class="line">                test=Xsmall[ idx[[i]], ],</div><div class="line">                cl=y[ -idx[[i]] ], k = k)</div><div class="line">    mean(y[ idx[[i]] ] != pred)</div><div class="line">  &#125;)</div><div class="line">  mean(res.k)</div><div class="line">&#125;)</div><div class="line">plot(ks, res, type=&quot;o&quot;,ylim=c(0,0.20),ylab=&quot;misclassification error&quot;)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913184233.jpeg">

</div>
<p>上图显示的是，使用5维数据后，错误分配与 <span class="math inline">\(k\)</span> 值变化的关系。</p>
<p>重要提示：我们使用<code>cmdscale()</code>函数来计算整个数据集，用于创建一个较小的数据集来说明kNN的计算过程。然而在真正的机器学习应用中，这样的处理会低估小样本测试数据集的错误，但是，使用未标记的完全数据集进行降维会改善这种情况。一个种更安全的做法就是为每个折叠分别转换数据（这句不懂， 我个人的猜测就是，对每个折叠进行计算，把几个折叠中的每一个都当作测试集，而不是将几个折叠放一块当作测试集），方法就是仅用训练集来计算旋转和降维，并将其应用于测试集。</p>
<p>最后一段实在没读懂，这里放原文：</p>
<blockquote>
<p>However, in a real machine learning application, this may result in an underestimation of test set error for small sample sizes, where dimension reduction using the unlabeled full dataset gives a boost in performance. A safer choice would have been to transform the data separately for each fold, by calculating a rotation and dimension reduction using the training set only and applying this to the test set.</p>
</blockquote>
<h2 id="练习">练习</h2>
<p>P407</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/23/DAL/DALS023_Basic_Machine_Learning02_Loess/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/DAL/DALS023_Basic_Machine_Learning02_Loess/" itemprop="url">DALS023-机器学习02-条件概率与Loess拟合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T12:00:00+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,248
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第2小节，这一部分的主要内容涉及条件概率与Loess回归，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/tree/master/ml/conditional_expectation.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="条件概率与期望">条件概率与期望</h2>
<p>预测问题的结果可以分为两类，分别为分类结果(categorical outcomes)和连续型结果(continuous outcomes)。但是，许多算法都可以应用于这两种情况，这是因为条件概率(conditional probabilities)和条件期望(conditional expectations)之间有着一定联系。</p>
<p>对于分类数据，例如二分类结果，如果我们知道给在一组预测因子<span class="math inline">\(X=(X_1,\dots,X_p)^\top\)</span>下预测的概率<span class="math inline">\(Y\)</span>可能是<span class="math inline">\(k\)</span>个结果中的任意一个，这种情况用方程表示就是： <span class="math display">\[
f_k(x) = \mbox{Pr}(Y=k \mid X=x)
\]</span> 我们就可以优化我们的预测结果。尤其是，对于任意的 <span class="math inline">\(x\)</span> ，我们可能预测出最大概率 <span class="math inline">\(f_k(x)\)</span> 时的 <span class="math inline">\(k\)</span> 。</p>
<p>为了简化我们的描述，我们只考虑二分类变量。我们可以认为 <span class="math inline">\(\mbox{Pr}(Y=1 \mid X=x)\)</span> 是当 <span class="math inline">\(X=x\)</span> 时，第1层的某结果在总体中的比例。考虑到期望是所有 <span class="math inline">\(Y\)</span> 值的均值，在这个案例中，期望的概率就等于：<span class="math inline">\(f(x) \equiv \mbox{E}(Y \mid X=x)=\mbox{Pr}(Y=1 \mid X=x)\)</span>。因此，我们在后面的描述中，就会使用期望，因为这种表示更加普遍。</p>
<p>通常来说，期望值是有着比较受欢迎的数学属性，因为它能够缩小预测值 <span class="math inline">\(\hat{Y}\)</span> 和 <span class="math inline">\(Y\)</span> 之间的距离： <span class="math display">\[
\mbox{E}\{ (\hat{Y} - Y)^2  \mid  X=x \}
\]</span></p>
<h4 id="预测中的回归问题">预测中的回归问题</h4>
<p>我们在前面使用了父子的身高数据来介绍了回归，这里我们使用机器学习来解释一下这个数据分析过程。在我们前面的那个案例中，我们试图通常父母的身高<span class="math inline">\(X\)</span>来预测儿子的身高<span class="math inline">\(Y\)</span>。这里我们只有一个预测值(predictor)。现在如果我们被问到随机选择一个儿子，这个儿子的身高是多少，我们也许会使用平均值来回答，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">data(<span class="string">"father.son"</span>)</div><div class="line">x=round(father.son$fheight) <span class="comment">##round to nearest inch</span></div><div class="line">y=round(father.son$sheight)</div><div class="line">hist(y,breaks=seq(min(y),max(y)))</div><div class="line">abline(v=mean(y),col=<span class="string">"red"</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911232411.jpeg">

</div>
<p>在这个案例中，我们也可以使用<span class="math inline">\(Y\)</span>的分布近似服从正态分布来进行预测，那么也就是说，当我们回答平均值的时候，回答对的概率最大。</p>
<p>现在我们再来考虑一些情况，当我们有了更多的信息后，如何进行预测。例如，我们被告之，这个随机选择的这个儿子的父亲身高是71英寸（高于均值1.25个SD）。那么我们如何预测？</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y,xlab=<span class="string">"Father's height in inches"</span>,ylab=<span class="string">"Son's height in inches"</span>,main=paste(<span class="string">"correlation ="</span>,signif(cor(x,y),<span class="number">2</span>)))</div><div class="line">abline(v=c(-<span class="number">0.35</span>,<span class="number">0.35</span>)+<span class="number">71</span>,col=<span class="string">"red"</span>)</div><div class="line">hist(y[x==<span class="number">71</span>],xlab=<span class="string">"Heights"</span>,nc=<span class="number">8</span>,main=<span class="string">""</span>,xlim=range(y))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911232626.jpeg">

</div>
<p>上图的左侧是儿子身高的散点图，其中红色围起来的部分是给定父亲身高是71英寸这个数据后，对应的儿子的身高。条件分布：儿子的身高数据分布就是被父亲71英寸这个数据限定了。</p>
<p>有了父亲身高是71英寸这个数据后，那么我们来猜儿子的身高时，最好的回答还是期望值(expectation)，但是，我们的数据层(strata)已经发生了改变，也就是说，我们来猜测儿子身高<span class="math inline">\(Y\)</span>时，要考虑到限制因素，即<span class="math inline">\(Y=71\)</span>。因此，我们可以在这个条件之上，再来计算均值，这个均值就是条件期望(conditional expectation)，因此我们对于任意<span class="math inline">\(x\)</span>值来预测时，公式如下所示： <span class="math display">\[
f(x) = E(Y \mid X=x)
\]</span></p>
<p>通过微积分我们可以发现，这个结果更加接近于二元正态分布，我们可以换成下面的表示形式： <span class="math display">\[
f(x) = \mu_Y + \rho \frac{\sigma_Y}{\sigma_X} (X-\mu_X)
\]</span></p>
<p>如果我们使用样本的数据来估计这5个参数，那么我们就会得到回归线：</p>
<figure class="highlight plain"><figcaption><span>regression, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mypar(1,2)</div><div class="line">plot(x,y,xlab=&quot;Father&apos;s height in inches&quot;,ylab=&quot;Son&apos;s height in inches&quot;,</div><div class="line">     main=paste(&quot;correlation =&quot;,signif(cor(x,y),2)))</div><div class="line">abline(v=c(-0.35,0.35)+71,col=&quot;red&quot;)</div><div class="line">fit &lt;- lm(y~x)</div><div class="line">abline(fit,col=1)</div><div class="line">hist(y[x==71],xlab=&quot;Heights&quot;,nc=8,main=&quot;&quot;,xlim=range(y))</div><div class="line">abline(v = fit$coef[1] + fit$coef[2]*71, col=1)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911234623.jpeg">

</div>
<p>在这个特殊的案例中，回归线提供了对 <span class="math inline">\(Y\)</span> 更优化的预测函数，但是通常情况下这种情况并不真实，因为在典型的机器学习问题中，优化后的 <span class="math inline">\(f(x)\)</span> 很少是一条直线。</p>
<h2 id="练习">练习</h2>
<p>P379</p>
<h2 id="平滑">平滑</h2>
<p>相关的Rmarkdown文档见作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/smoothing.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在所有的数据分析中，平滑(Smoothing)是一个非常强大的工具。当数据的分布的形状未知时，我们可以假定这些数据是平滑(smooth)的，我们就能够估计 <span class="math inline">\(f(x)\)</span> 。平滑的主要思路就是将那些有着类似期望的数据归类，然后计算这些归类后的平均值，或者是对其进行简单的参数模型拟合。我们使用基因表达数据来介绍两个平滑工具。</p>
<p>下面的数据是源于相同RNA样本的基因表达数据。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##Following three packages are available from Bioconductor</span></div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="comment"># BiocManager::install("SpikeIn")</span></div><div class="line"><span class="keyword">library</span>(SpikeIn)</div><div class="line"><span class="comment"># BiocManager::install("hgu95acdf")</span></div><div class="line"><span class="keyword">library</span>(hgu95acdf)</div><div class="line">data(SpikeIn95)</div></pre></td></tr></table></figure>
<p>我们可以使用MA图 (<span class="math inline">\(Y\)</span> = log ratios and <span class="math inline">\(X\)</span> = averages) 来比较这两个重复样本的质量，我们可能通过一种方式对这些数据进行采样，这些采样方式要能平衡 <span class="math inline">\(X\)</span> 中不同层的数据点的数目，如下所示：</p>
<figure class="highlight plain"><figcaption><span>echo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">##Example with two columns</div><div class="line">i=10;j=9</div><div class="line">##remove the spiked in genes and take random sample</div><div class="line">library(GEOquery)</div><div class="line">siNames&lt;-colnames(pData(SpikeIn95))</div><div class="line">ind &lt;- which(!probeNames(SpikeIn95)%in%siNames)</div><div class="line">pms &lt;- pm(SpikeIn95)[ ind ,c(i,j)]</div><div class="line">##pick a representative sample for A and order A</div><div class="line">Y=log2(pms[,1])-log2(pms[,2])</div><div class="line">X=(log2(pms[,1])+log2(pms[,2]))/2</div><div class="line">set.seed(4)</div><div class="line">ind &lt;- tapply(seq(along=X),round(X*5),function(i)</div><div class="line">  if(length(i)&gt;20) return(sample(i,20)) else return(NULL))</div><div class="line">ind &lt;- unlist(ind)</div><div class="line">X &lt;- X[ind]</div><div class="line">Y &lt;- Y[ind]</div><div class="line">o &lt;-order(X)</div><div class="line">X &lt;- X[o]</div><div class="line">Y &lt;- Y[o]</div></pre></td></tr></table></figure>
<p>采样结束后，我们来绘制散点图，如下所示：</p>
<figure class="highlight plain"><figcaption><span>MAplot, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">plot(X,Y)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912000435.jpeg">

</div>
<p>在上面的MA图中我们可以看到 <span class="math inline">\(Y\)</span> 取决于 <span class="math inline">\(X\)</span>。这种取决关系存在着偏差，因为我们发现，它们在重复性方面有着偏差，这就意味着，如果不考虑 <span class="math inline">\(X\)</span>， 那么 <span class="math inline">\(Y\)</span> 的均值就是0。现在我们想预测 <span class="math inline">\(f(x)=\mbox{E}(Y \mid X=x)\)</span> ，以便于移除假这种偏差。线性回归无法捕捉到表示上图曲线 <span class="math inline">\(f(x)\)</span> 的曲率(curvature)，如下所示：</p>
<figure class="highlight plain"><figcaption><span>MAplot_with_regression_line, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">plot(X,Y)</div><div class="line">fit &lt;- lm(Y~X)</div><div class="line">points(X,Y,pch=21,bg=ifelse(Y&gt;fit$fitted,1,3))</div><div class="line">abline(fit,col=2,lwd=4,lty=2)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912000854.jpeg">

</div>
<h2 id="微区间平滑bin-smoothing">微区间平滑(Bin Smoothing)</h2>
<p>对于上述的数据，我们无法使用直线进行拟合，此时我们就要使用平滑处理的思想，也就是说把这些点分散到不同的组里，计算这些不同组的均值，这就是所谓的<code>微区间平滑</code>处理（我没有找到bin smoothing相应的中文翻译，这里说的<code>微区间平滑</code>是我自己造的词）。这种处理的通常思路就是，我们假定这些数据点分为很多微区间(bin)，这样拟合的曲线是足够”平滑“的，那么在这个微区间中的这个曲线就会近似于常数(approximately constant)。如果我们假设这个曲线是常数(constant)的，那么所有位于某个微区间(bin)中的 <span class="math inline">\(Y\)</span> 就有了相同的期望值。例如，在下面的图形中，如果我们将微区间的宽度设为1，我们标记出了在8.6和12.1处的微区间。我们还显示了，在这两个区间中拟合的 <span class="math inline">\(Y\)</span> 的均值，如下所示：</p>
<figure class="highlight plain"><figcaption><span>binsmoother, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">centers &lt;- seq(min(X),max(X),0.1)</div><div class="line">plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">windowSize &lt;- .5</div><div class="line">i &lt;- 25</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-mean(Y)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">lines(c(min(X[ind]),max(X[ind])),c(fit,fit),col=2,lty=2,lwd=4)</div><div class="line">i &lt;- 60</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-mean(Y[ind])</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">lines(c(min(X[ind]),max(X[ind])),c(fit,fit),col=2,lty=2,lwd=4)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001103.jpeg">

</div>
<p>我们通过计算每一个点附近的小区间，我们就能对构成的曲线的函数 $f(x) $ 进行估计。下图显示了这个计算过程，即我们从最小的 <span class="math inline">\(x\)</span> 值扩展到最大值过程中的这个估计值，同时我们还展示了最小值与最大值之间的10个值，一共是10张图片，如下所示：</p>
<figure class="highlight plain"><figcaption><span>bin_smoothing_demo, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">windowSize&lt;-0.5</div><div class="line">smooth&lt;-rep(NA,length(centers))</div><div class="line">mypar (4,3)</div><div class="line">for(i in seq(along=centers))&#123;</div><div class="line">  center&lt;-centers[i]</div><div class="line">  ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">  smooth[i]&lt;-mean(Y[ind])</div><div class="line">  if(i%%round(length(centers)/12)==1)&#123; ##we show 12</div><div class="line">    plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">    points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">    lines(c(min(X[ind]),max(X[ind])),c(smooth[i],smooth[i]),col=2,lwd=2)</div><div class="line">    lines(centers[1:i],smooth[1:i],col=&quot;black&quot;)</div><div class="line">    points(centers[i],smooth[i],col=&quot;black&quot;,pch=16,cex=1.5)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001146.jpeg">

</div>
<p>最终的结果就如下所示：</p>
<figure class="highlight plain"><figcaption><span>bin_smooth_final, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(centers,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001229.jpeg">

</div>
<p>在R中有许多函数可以进行平滑处理(bin smoothers)，例如<code>ksmooth</code>。但是在实际计算过程中，我们更偏向使用一些稍微复杂的模型来对数据进行拟合。在最后一个案例，也就是最后一张图，这个曲线就不怎么平滑，有一些粗糙。我们后面会介绍<code>loess</code>方法会改善这一点。</p>
<h2 id="loess">Loess</h2>
<p>Loess的全称是Local weighted regression，即局部权重回归，它在原理上类似于微区间平滑处理。但Loess与微区间平滑处理的主要区别就在于，在微区间中我是使用直线，还是抛物线进行拟合。Loess计算会增大微区间的数目，但这会使我们的估计更稳定。下图展示了两个微区间的拟合曲线，这两个区间比较宽，使用宽区间主要是因为拟合曲线提供了更多的灵活性，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">centers &lt;- seq(min(X),max(X),0.1)</div><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">windowSize &lt;- 1.25</div><div class="line">i &lt;- 25</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-lm(Y~X,subset=ind)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lty=2,lwd=3)</div><div class="line">i &lt;- 60</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-lm(Y~X,subset=ind)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lty=2,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912124609.jpeg" alt="当我们">
<p class="caption">当我们</p>
</div>
<p>现在我们展示一下通过12步处理来对这些数据进行loess拟合，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess_demo, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">mypar (4,3)</div><div class="line">windowSize&lt;-1.25</div><div class="line">smooth&lt;-rep(NA,length(centers))</div><div class="line">for(i in seq(along=centers))&#123;</div><div class="line">  center&lt;-centers[i]</div><div class="line">  ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">  fit&lt;-lm(Y~X,subset=ind)</div><div class="line">  smooth[i]&lt;-fit$coef[1]+fit$coef[2]*center</div><div class="line">  if(i%%round(length(centers)/12)==1)&#123; ##we show 12</div><div class="line">    plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">    points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">    a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">    lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lwd=2)</div><div class="line">    </div><div class="line">    lines(centers[1:i],smooth[1:i],col=&quot;black&quot;)</div><div class="line">    points(centers[i],smooth[i],col=&quot;black&quot;,pch=16,cex=1.5)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912124842.jpeg">

</div>
<p>最终的结果就是生成一条更加平滑的拟合曲线用于估计我们的局部参数，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess_final, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(centers,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912125359.jpeg">

</div>
<p>R中的函数<code>loess()</code>可以进行上述的分析，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fit &lt;- loess(Y~X, degree=1, span=1/3)</div><div class="line">newx &lt;- seq(min(X),max(X),len=100) </div><div class="line">smooth &lt;- predict(fit,newdata=data.frame(X=newx))</div><div class="line">mypar ()</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(newx,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912125636.jpeg">

</div>
<p><code>loess()</code>函数与其它的曲线平滑处理函数(bin smoother)还有三点重要的区别：</p>
<p>第一，<code>loess()</code>函数会保持局部拟合中的点数不变，而非保持区间的数目不变。局部拟合中的点数是通过<code>span</code>参数决定的，这是一个比值。例如，如果 <code>N</code> 是数据点的数目，那么 <code>span = 0.5</code> 则表示针对一个确定的 <code>x</code> ， <code>loess()</code>将会使用 <code>0.5*N</code> 个最接近的点对 <code>x</code> 进行拟合。</p>
<p>第二，使用参数模型来对 <span class="math inline">\(f(x)\)</span> 进行拟合时，<code>loess()</code>会使用加权最小平方和来进行计算，那些权重比较大的点就是那些更接近 <code>x</code> 的点。</p>
<p>第三，<code>loess()</code>函数会选择更稳健(robustly)的局部模型来进行拟合。这是一种迭代算法，其中在一次迭代中拟合了模型之后，对于那些检测到的异常值就会在下一次迭代中降低其权重。如果要想使用这个参数，可以设定<code>family = &quot;symmetric&quot;</code>。</p>
<h2 id="练习-1">练习</h2>
<p>P389</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/22/DAL/DALS022_Basic_Machine_Learning01_ Cluster_heatmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/DAL/DALS022_Basic_Machine_Learning01_ Cluster_heatmap/" itemprop="url">DALS022-机器学习01-聚类与热图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:00:00+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,120
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第1小节，这一部分的主要内容涉及聚类与热图，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/clustering_and_heatmaps.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>机器学习是一个非常广泛的主题和高度活跃的研究领域。 在生命科学中，涉及到“精准医学”的大部分内容都是与机器学习在生物医学数据方面的处理有关。 常规的思路就是从检测的指标中预测或发现一些信息。例如，我们能够从基因表达谱中发现新的癌症吗？我们能通过一系列的基因型来预测药物反应吗？在这一部分中，我们主要介绍两个机器学习的方法，即聚类(clustering)和类预测(class prediction)。</p>
<h2 id="聚类">聚类</h2>
<p>我们还使用前面的组织基因表达的数据来深圳一下聚类的概念和思路：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div></pre></td></tr></table></figure>
<p>为了说明聚类在生命科学方面的应用，我们先假设我们并不知道上面的几个样本是不同的组织，我们通过聚类来看一下它们的表达谱情况，第一步就是计算不同的样本之间的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist( t(e) )</div></pre></td></tr></table></figure>
<h3 id="层次聚类">层次聚类</h3>
<p>当我们计算了每对样本之间的距离后，我们需要使用聚类算法将它们聚成不同的组。层次聚类算是众多聚类算法中的一个。每个样本首先会被当作一组(group)，然后不断地通过聚类算法迭代，将两个相似的组结合起来，一直到所有的样本都聚为一组。对于样本之间的距离我们已经了解了，但是，不同组之间的距离我们并不了解。关于组与组之间的距离计算方法有很多种，这些方法的核心都是通过计算组与组之间的成员的距离实现的。具体的可以查看<code>hclust()</code>函数的帮助文档。</p>
<p>我们通过<code>hclust()</code>函数来对不同组之间的距离进行层次聚类分析。这个函数会返回一个<code>hclust</code>对象，它描述的我们通过上述算法进行的组划分(grouping)。随后使用<code>plot()</code>函数绘制出树状图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">hc &lt;- hclust(d)</div><div class="line">hc</div><div class="line">plot(hc,labels=tissue,cex=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(rafalib)</div><div class="line">&gt; mypar()</div><div class="line">&gt; hc &lt;- hclust(d)</div><div class="line">&gt; hc</div><div class="line"></div><div class="line">Call:</div><div class="line">hclust(d = d)</div><div class="line"></div><div class="line">Cluster method   : complete </div><div class="line">Distance         : euclidean </div><div class="line">Number of objects: <span class="number">189</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215025.jpeg">

</div>
<p>使用这种算法能否发现不同组织的簇(clusters)？在上面的这个图形里，我们不太容易发现这些不同的组织，因此我们需要使用<code>myclust()</code>函数来给它们加上颜色，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">myplclust(hc, labels=tissue, lab.col=as.fumeric(tissue), cex=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215224.jpeg">

</div>
<p>从图形上我们可以看出来，似乎聚类算法能够发现这些不同的组织。但是，层次聚类并没有定义特定的簇，而是定义了上在树状图。从树状图上我们可以描述任意两组之间的距离。为了定义一些簇，我们需要将把树在某些距离上”切开“，所有的样本在这个距离以下分成不同的组。我们可以绘制出一条水平线，我们就使用120这个距离来切，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myplclust(hc, labels=tissue, lab.col=as.fumeric(tissue),cex=<span class="number">0.5</span>)</div><div class="line">abline(h=<span class="number">120</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215559.jpeg">

</div>
<p>当我们在高度为120上对树进行切割时，我们可以看一下这个线能够把线以下的样本分为几组，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hclusters &lt;- cutree(hc, h=<span class="number">120</span>)</div><div class="line">table(true=tissue, cluster=hclusters)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=tissue, cluster=hclusters)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span>  <span class="number">0</span> <span class="number">12</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">9</span> <span class="number">18</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>从上面可以看出来，分为了8组，另外通过<code>cutreee()</code>函数，我们可以直接指定返回几组簇，这个函数会自动返回结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hclusters &lt;- cutree(hc, k=<span class="number">8</span>)</div><div class="line">table(true=tissue, cluster=hclusters)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; hclusters &lt;- cutree(hc, k=<span class="number">8</span>)</div><div class="line">&gt; table(true=tissue, cluster=hclusters)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span> <span class="number">12</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney      <span class="number">37</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">6</span></div></pre></td></tr></table></figure>
<p>从上面两组计算方法我们可以看出来，除了个别情况外（例如endometrium和kidney），其余的簇中，基本上每簇代表一个组织。在某些情况下，一个组织有可能存在于两个簇中，这是因为选择的簇太多了。在聚类分析中，关于如何选择簇的个数也是一个很活跃的研究领域。</p>
<h3 id="k-means">K-means</h3>
<p>我们还可以使用<code>kmeans()</code>函数来进行k-means聚类。现在我们来演示一下如何使用这个函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">km &lt;- kmeans(t(e[<span class="number">1</span>:<span class="number">2</span>,]), centers=<span class="number">7</span>)</div><div class="line">names(km)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(e[<span class="number">1</span>,], e[<span class="number">2</span>,], col=as.fumeric(tissue), pch=<span class="number">16</span>)</div><div class="line">plot(e[<span class="number">1</span>,], e[<span class="number">2</span>,], col=km$cluster, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; set.seed(<span class="number">1</span>)</div><div class="line">&gt; km &lt;- kmeans(t(e[<span class="number">1</span>:<span class="number">2</span>,]), centers=<span class="number">7</span>)</div><div class="line">&gt; names(km)</div><div class="line">[<span class="number">1</span>] <span class="string">"cluster"</span>      <span class="string">"centers"</span>      <span class="string">"totss"</span>        <span class="string">"withinss"</span>     <span class="string">"tot.withinss"</span></div><div class="line">[<span class="number">6</span>] <span class="string">"betweenss"</span>    <span class="string">"size"</span>         <span class="string">"iter"</span>         <span class="string">"ifault"</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911220200.jpeg">

</div>
<p>上图我们使用的是不同组织的前2个基因表达情况，其中颜色表示不同的组织。在在图中，颜色表示通过<code>kmeans()</code>函数计算的聚类结果。从下面的这个列表中我们就可以看到，这个聚类效果并不好：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(true=tissue,cluster=km$cluster)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line">&gt; table(true=tissue,cluster=km$cluster)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">0</span> <span class="number">23</span></div><div class="line">  colon        <span class="number">2</span> <span class="number">11</span>  <span class="number">2</span> <span class="number">15</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">8</span></div><div class="line">  hippocampus <span class="number">19</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">7</span>  <span class="number">8</span> <span class="number">20</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">18</span>  <span class="number">8</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>这个结果不太好很有可能就是我们选择的这2个基因信息量不足以将不同组织区分开来，如果我们使用所有的基因进行kmeans计算，那么我们就能极大地改善聚类结果，现在我们使用MDS图来展示这个结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">km &lt;- kmeans(t(e), centers=<span class="number">7</span>)</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(mds[,<span class="number">1</span>], mds[,<span class="number">2</span>])</div><div class="line">plot(mds[,<span class="number">1</span>], mds[,<span class="number">2</span>], col=km$cluster, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911220820.jpeg">

</div>
<p>上图礣是使用前两个PC来绘制的聚类结果，右图是使用所有的基因来绘制的MDS图，使用颜色标明了不同的组织。</p>
<p>通过查看结果中的列表，我们就可以看到聚类的效果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(true=tissue,cluster=km$cluster)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=tissue,cluster=km$cluster)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">2</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span> <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">0</span> <span class="number">37</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div></pre></td></tr></table></figure>
<h2 id="热图">热图</h2>
<p>在遗传学文献中，热图的使用非常广泛。它们能够查看所有样本的不同基因的表达情况，有的时候还会在热图的上面或旁边添加上聚类后的树状图。现在我们来看一下如何创建热图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(RColorBrewer)</div><div class="line">hmcol &lt;- colorRampPalette(brewer.pal(<span class="number">9</span>, <span class="string">"GnBu"</span>))(<span class="number">100</span>)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line"></div><div class="line">rv &lt;- rowVars(e)</div><div class="line"><span class="comment"># We will create heatmp using th e50 most variable genes and the function heatmap.2</span></div><div class="line"></div><div class="line">idx &lt;- order(-rv)[<span class="number">1</span>:<span class="number">40</span>]</div></pre></td></tr></table></figure>
<p>现在我们使用<code>gplots</code>包中的<code>heatmap.2</code>了娄来绘制热图，并在热图的顶部添加组织信息，如下所示</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(gplots) <span class="comment">##Available from CRAN</span></div><div class="line">cols &lt;- palette(brewer.pal(<span class="number">8</span>, <span class="string">"Dark2"</span>))[as.fumeric(tissue)]</div><div class="line">head(cbind(colnames(e),cols))</div><div class="line"></div><div class="line">heatmap.2(e[idx,], labCol=tissue,</div><div class="line">          trace=<span class="string">"none"</span>,</div><div class="line">          ColSideColors=cols,</div><div class="line">          col=hmcol)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(cbind(colnames(e),cols))</div><div class="line">                       cols     </div><div class="line">[<span class="number">1</span>,] <span class="string">"GSM11805.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">2</span>,] <span class="string">"GSM11814.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">3</span>,] <span class="string">"GSM11823.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">4</span>,] <span class="string">"GSM11830.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">5</span>,] <span class="string">"GSM12067.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">6</span>,] <span class="string">"GSM12075.CEL.gz"</span> <span class="string">"#1B9E77"</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911221507.jpeg">

</div>
<p>在热图中我们并没有使用组织信息，我们仅用了最显著的40个基因就发现了不同的组织。</p>
<h2 id="练习">练习</h2>
<p>P374</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/21/DAL/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/DAL/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/" itemprop="url">DALS021-MDS与PCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T12:00:00+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,847
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第2小节，这一部分的主要内容涉及MDS和PCA，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/highdim/mds.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="mds">MDS</h2>
<p>MDS的全称为multi-dimensional scaling，即多维数据缩放。在这 一部分中，我们会使用基因表达的数据来作为案例讲解一下。为了简化说明，我们仅考虑3个组织：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">colind &lt;- tissue%<span class="keyword">in</span>%c(<span class="string">"kidney"</span>,<span class="string">"colon"</span>,<span class="string">"liver"</span>)</div><div class="line">mat &lt;- e[,colind]</div><div class="line">group &lt;- factor(tissue[colind])</div><div class="line">dim(mat)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; dim(mat)</div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>    <span class="number">99</span></div></pre></td></tr></table></figure>
<p>现在我们要研究一下这个数据集，我们想知道，储存在<code>mat</code>列中的基因表达谱的数据在不同的组织间的相似性如何。由于数据很大，无法直接画出相应的多维点图。我们通常只能绘制出二维图形，如果我们要绘制出每两个样本之间的基因表达情况不现实。而MDS图形就是为了解决这个问题而提出来的。</p>
<h3 id="mds背后的数学原理">MDS背后的数学原理</h3>
<p>前面我们已经知道了SVD和矩阵代数，那么我们理解MDS就相对清楚了。为了说明MDS，我们先来看一下SVD分解，如下所示： <span class="math display">\[
\mathbf{Y} = \mathbf{UDV}^\top
\]</span> 我们假设 <span class="math inline">\(\mathbf{U^\top Y=DV^\top}\)</span> 的前两列的平方和剩余列的平方和。因此它们可以写为<span class="math inline">\(d_1+ d_2 \gg d_3 + \dots + d_n\)</span> 其中 <span class="math inline">\(d_i\)</span> 是<span class="math inline">\(\mathbf{D}\)</span> 是第i列（原文是i-th entry）。当出现这种情况时，我们就会得到如下公式：</p>
<p><span class="math display">\[
\mathbf{Y}\approx [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&amp;0\\
    0&amp;d_{2}\\
  \end{pmatrix}
  [\mathbf{V}_1 \mathbf{V}_2]^\top
\]</span></p>
<p>这就表明，第<span class="math inline">\(i\)</span>列近似等于： <span class="math display">\[
\mathbf{Y}_i \approx
[\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&amp;0\\
    0&amp;d_{2}\\
  \end{pmatrix}
  \begin{pmatrix}
    v_{i,1}\\
    v_{i,2}\\
     \end{pmatrix}
    =
    [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}
\]</span> 如果我们们定义下面的二维向量：</p>
<p><span class="math display">\[
\mathbf{Z}_i=\begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}
\]</span></p>
<p>那么： <span class="math display">\[
\begin{align*}
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) &amp;\approx \left\{ [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \right\}^\top \left\{[\mathbf{U}_1 \mathbf{U}_2]  (\mathbf{Z}_i-\mathbf{Z}_j)\right\}\\
&amp;= (\mathbf{Z}_i-\mathbf{Z}_j)^\top [\mathbf{U}_1 \mathbf{U}_2]^\top [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \\
&amp;=(\mathbf{Z}_i-\mathbf{Z}_j)^\top(\mathbf{Z}_i-\mathbf{Z}_j)\\
&amp;=(Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\end{align*}
\]</span> 上面的这个推导告诉我们，在样本<span class="math inline">\(i\)</span>和样本<span class="math inline">\(j\)</span>之最的距离近拟等于下面二维数据点的距离：</p>
<p><span class="math display">\[
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) \approx
 (Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\]</span></p>
<p>因为<span class="math inline">\(Z\)</span>是一个二维向量，因此我们可以通过绘制<span class="math inline">\(\mathbf{Z_{1}}\)</span>和<span class="math inline">\(\mathbf{Z_{2}}\)</span>来发展示这两个样本的距离。现在我们绘制出它们的距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(mat-rowMeans(mat))</div><div class="line">PC1 &lt;- s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 &lt;- s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC1,PC2,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090640.jpeg">

</div>
<p>从图片上我们可以看出，数据点按照相应的组织区分开来了。上面的这种分开的精确近似取决于前两个主成分解释变异的程度。像上面那样所示，我们可以绘制出每个主成分可以解释的变异程度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090819.jpeg">

</div>
<p>虽然前两个主成分解释了超过50%的变异，不过前面的图形还是没有展示出大量的信息。但是这种图已经足够用于进行可视化大量的数据了。此外，我们还可以注意到，我们能够绘制其它的主成分来研究这些数据点，例如我们绘制第3个和第4个主成分：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PC3 &lt;- s$d[<span class="number">3</span>]*s$v[,<span class="number">3</span>]</div><div class="line">PC4 &lt;- s$d[<span class="number">4</span>]*s$v[,<span class="number">4</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC3,PC4,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091057.jpeg">

</div>
<p>从上面图形中我们可以看到，第4个主成分能够将肾脏组织的样本强烈分开。在后面的部分中，我们会讲到批次效应(batch effects)会解释这种情况。</p>
<h3 id="cmdscale函数"><code>cmdscale()</code>函数</h3>
<p>我们在上面使用了<code>svd()</code>函数来进行计算，不过R中有一个专门的函数用于计算MDS，生成MDS图。这个函数就是<code>cmdscale()</code>函数，这个函数将距离对象作为参数，然后使用主成分分析来对这些距离进行近似计算。这个函数比使用<code>svd()</code>函数更高效（因为不可能实现完全的<code>svd()</code>函数计算，那样比较花时间）。此函数默认返回二维的数据，不过我们通过设定参数<code>k</code>（默认情况下，<code>k=2</code>）可以改变结果中的维度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(mat))</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar()</div><div class="line">plot(mds[,<span class="number">1</span>],mds[,<span class="number">2</span>],bg=as.numeric(group),pch=<span class="number">21</span>,</div><div class="line">xlab=<span class="string">"First dimension"</span>,ylab=<span class="string">"Second dimension"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091915.jpeg">

</div>
<p>再看另外一个：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">2</span>)&#123;</div><div class="line">plot(mds[,i],s$d[i]*s$v[,i],main=paste(<span class="string">"PC"</span>,i))</div><div class="line">b = ifelse( cor(mds[,i],s$v[,i]) &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</div><div class="line">abline(<span class="number">0</span>,b) <span class="comment">##b is 1 or -1 depending on the arbitrary sign "flip"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911092010.jpeg">

</div>
<h3 id="任意符号">任意符号</h3>
<p>SVD并非是唯一的，只要我们用<code>-1</code>乘以<span class="math inline">\(\mathbf{U}\)</span>的样本列，我们就能使用<code>-1</code>乘以<span class="math inline">\(\mathbf{V}\)</span>的任意列，通过下面的转换我们就能看出来（这一段不懂）： <span class="math display">\[
\mathbf{-1UD(-1)V}^\top = \mathbf{UDV}^\top
\]</span></p>
<h3 id="扣除平均值">扣除平均值</h3>
<p>在所有的计算中，当我们计算SVD时，都会扣除行(row)的均值。如果我们要试图计算两列之间的近似距离，那么在<span class="math inline">\(\mathbf{Y}_{i}\)</span>和<span class="math inline">\(\mathbf{Y}_{j}\)</span>之间的距离就与<span class="math inline">\(\mathbf{Y}_i - \mathbf{\mu}\)</span>和<span class="math inline">\(\mathbf{Y}_j - \mathbf{\mu}\)</span>之间的距离相同，因为当我们过计算时，中间的<span class="math inline">\(\mu\)</span>就会被消去： <span class="math display">\[
\left\{ ( \mathbf{Y}_i- \mathbf{\mu} ) - ( \mathbf{Y}_j - \mathbf{\mu} ) \right\}^\top \left\{ (\mathbf{Y}_i- \mathbf{\mu}) - (\mathbf{Y}_j - \mathbf{\mu} ) \right\} = \left\{  \mathbf{Y}_i-  \mathbf{Y}_j  \right\}^\top \left\{ \mathbf{Y}_i - \mathbf{Y}_j  \right\}
\]</span> 因为扣除行均值可以降低总的变异，它可以使得SVD的结果近更为逼近。</p>
<h2 id="练习">练习</h2>
<p>P357</p>
<h2 id="pca">PCA</h2>
<p>PCA的相关资料可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/PCA.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经提到了PCA，这里继续深入一步，讲一下PCA背后的数学原理。</p>
<h3 id="案例双胞胎身高">案例：双胞胎身高</h3>
<p>我们先使用模拟数据的案例展示一个旋转，这个旋转与PCA有着很大的有关系：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">Y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(Y[<span class="number">1</span>,], Y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=thelim, ylim=thelim)</div><div class="line">points(Y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], Y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911094030.jpeg">

</div>
<p>这里我们专门来解释一下什么是什么成分（principla components）。</p>
<p>我们使用 <span class="math inline">\(\mathbf{Y}\)</span> 这个 <span class="math inline">\(2 \times N\)</span> 矩阵来表示我们的数据。这个类似于我们检测了两组基因的信息，每列表示1个样本。现在我们的任何就是，找到一个 <span class="math inline">\(2 \times 1\)</span> 向量 <span class="math inline">\(\mathbf{u}_1\)</span> ，使其满足 <span class="math inline">\(\mathbf{u}_1^\top \mathbf{v}_1 = 1\)</span>，它能使 <span class="math inline">\((\mathbf{u}_1^\top\mathbf{Y})^\top (\mathbf{u}_1^\top\mathbf{Y})\)</span> 最大。这个过程可以被视为每个样本，或<span class="math inline">\(\mathbf{Y}\)</span>向子空间 <span class="math inline">\(\mathbf{u}_1\)</span> 的投影。因此，我们需要将坐标系进行置换，使新的坐标系能够显示出最大变异。</p>
<p>我先试一下 <span class="math inline">\(\mathbf{u}=(1,0)^\top\)</span>。这个投影公仅能够给出双胞胎1的身高（橘黄色）。图片标题中显示的是平方和。</p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1, fig.align</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(t(Y), xlim=thelim, ylim=thelim,</div><div class="line">     main=paste(&quot;Sum of squares :&quot;,round(crossprod(Y[1,]),1)))</div><div class="line">abline(h=0)</div><div class="line">apply(Y,2,function(y) segments(y[1],0,y[1],y[2],lty=2))</div><div class="line">points(Y[1,],rep(0,ncol(Y)),col=2,pch=16,cex=0.75)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911160126.jpeg">

</div>
<p>我们能否找到一个方向，使得坐标系旋转后，能够表示更高的变异？例如</p>
<p><span class="math inline">\(\mathbf{u} =\begin{pmatrix}1\\-1\end{pmatrix}\)</span> 这个怎么样？它不满足 <span class="math inline">\(\mathbf{u}^\top\mathbf{u}= 1\)</span> ，因此我们可以使用另外一个向量，即 <span class="math inline">\(\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\-1/\sqrt{2}\end{pmatrix}\)</span></p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1_either, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">u &lt;- matrix(c(1,-1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar(1,1)</div><div class="line">plot(t(Y),</div><div class="line">     main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),xlim=thelim,ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,-1,col=2)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i],Z[2,i],Y[1,i],Y[2,i],lty=2)</div><div class="line">points(t(Z), col=2, pch=16, cex=0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161254.jpeg">

</div>
<p>这个图形与双胞胎的差异有关，我们知道这个差异很少的。通常平方和我们可以确实这一点，最后我们试一下这个向量：</p>
<p><span class="math display">\[
\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\1/\sqrt{2}\end{pmatrix}
\]</span></p>
<figure class="highlight plain"><figcaption><span>PC1, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">u &lt;- matrix(c(1,1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar()</div><div class="line">plot(t(Y), main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),</div><div class="line">     xlim=thelim, ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,1,col=2)</div><div class="line">points(u%*%w, col=2, pch=16, cex=1)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i], Z[2,i], Y[1,i], Y[2,i], lty=2)</div><div class="line">points(t(Z),col=2,pch=16,cex=0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161447.jpeg">

</div>
<p>这个图形与重新缩放(re-scaled)后的平均高度有关，它有着最大的平方和。这是一个数学计算程序，它能够计算出一个 <span class="math inline">\(\mathbf{v}\)</span> ，能够使平方和最大，SVD就是这样的一个程序。</p>
<h4 id="主成分">主成分</h4>
<p>正交向量能够使平方和最大：</p>
<p><span class="math display">\[
(\mathbf{u}_1^\top\mathbf{Y})^\top(\mathbf{u}_1^\top\mathbf{Y})
\]</span></p>
<p><span class="math inline">\(\mathbf{u}_1^\top\mathbf{Y}\)</span> 指的就是第1PC。e用于获得PC的加权(weights) <span class="math inline">\(\mathbf{u}\)</span> 指的就是因子载荷(loadings)。使用旋转这种操作，它指的就是第1PC的旋转方向。</p>
<p>为了获得第2PC，我们可以重复上述操作，但是残差如下：</p>
<p><span class="math display">\[\mathbf{r} = \mathbf{Y} - \mathbf{u}_1^\top \mathbf{Yv}_1 \]</span></p>
<p>第2PC的向量含有以下性质：</p>
<p><span class="math display">\[ \mathbf{v}_2^\top \mathbf{v}_1=0\]</span></p>
<p>它能使 <span class="math inline">\((\mathbf{rv}_2)^\top \mathbf{rv}_2\)</span>最大，</p>
<p>当 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(N \times m\)</span> 时，我们可以重复地找到第3，第4，第5，等主成分。</p>
<h4 id="prcomp"><code>prcomp</code></h4>
<p>我们已经介绍了如何使用SVD来计算PC。介理，R中有一个专门的函数可以用于找到主成分，即<code>prcomp()</code>，在这个案例中，数据默认中心化的，这个函数的使用如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc &lt;- prcomp( t(Y) )</div></pre></td></tr></table></figure>
<p>计算出的结果与SVD相同，直到符号翻转（produces the same results as the SVD up to arbitrary sign flips，实在没理解这句话什么意思）</p>
<figure class="highlight plain"><figcaption><span>pca_svd, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd( Y - rowMeans(Y) )</div><div class="line">mypar(1,2)</div><div class="line">for(i in 1:nrow(Y) )&#123;</div><div class="line">  plot(pc$x[,i], s$d[i]*s$v[,i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911165120.jpeg">

</div>
<p>因子载荷可以通过下面方式计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$rotation</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pc$rotation</div><div class="line">           PC1        PC2</div><div class="line">[<span class="number">1</span>,] <span class="number">0.7072304</span>  <span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.7069831</span> -<span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>它就相当于 (up to a sign flip？这个不懂) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s$u</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; s$u</div><div class="line">           [,<span class="number">1</span>]       [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.7072304</span> -<span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">0.7069831</span>  <span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>解释的方差等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$sdev</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; pc$sdev</div><div class="line">[<span class="number">1</span>] <span class="number">1.2542672</span> <span class="number">0.2141882</span></div></pre></td></tr></table></figure>
<p>现在我们将<code>Y</code>转置一下，因为<code>prcomp()</code>函数与我们平时所用的高通量数据储存有点不太一样，平时我们的数据是列为样本，行为特征值，而<code>prcomp()</code>函数则是正好相反，它处理的数据列是特征值，行是样本名。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/20/DAL/DALS020_Distance_and_Dimension_Reduction1_SVD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/DAL/DALS020_Distance_and_Dimension_Reduction1_SVD/" itemprop="url">DALS020-距离与降维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T12:00:00+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,505
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第1小节，这一部分的主要内容涉及降维分析的一些原理，例如SVD，投影，旋转等，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/distance.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>距离(distance)的概念非常直接，例如，当我们把动物聚为亚群时，我们其实就是隐含地定义了一个距离，从而使我们可以说亚群内的动物彼此“接近”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909115530.png">

</div>
<p>我们使用的分析高通量数据的方法地都直接或间接地与距离有关。许多聚类方法和机器学习方法都需要使用特征值或预测因子来定义距离。例如热图是基因组学与高通量数据领域里使用最为广泛的工具，如果我们要生成热图，就需要明确计算距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130059.png">

</div>
<p>在上面的热图中，每个方格代表的数值储存在一个矩阵里，每具方格的行与列被聚类后（注：热图常用红色与绿色表示，但是对色盲人士来说，这两种颜色是最难分辨的颜色）用不同的颜色表示。在这一部分中，我们将学习必要的数学知识与计算技能来了解和创建热图。我们先来回顾一下数学上对距离的定义。</p>
<h2 id="欧氏距离euclidean-distance">欧氏距离(Euclidean Distance)</h2>
<p>现在我们在一个笛卡尔坐标系(Cartesian plane)中定义A点与B点的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>),pch=<span class="number">16</span>,cex=<span class="number">2</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,bty=<span class="string">"n"</span>,xlim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>),ylim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>))</div><div class="line">lines(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</div><div class="line">text(<span class="number">0</span>,<span class="number">.2</span>,expression(paste(<span class="string">'(A'</span>[x]*<span class="string">',A'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(<span class="number">1</span>,<span class="number">1.2</span>,expression(paste(<span class="string">'(B'</span>[x]*<span class="string">',B'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(-<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">"A"</span>,cex=<span class="number">2</span>)</div><div class="line">text(<span class="number">1.1</span>,<span class="number">1</span>,<span class="string">"B"</span>,cex=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130731.jpeg">

</div>
<p>其中，欧氏距离的定义如下所示： <span class="math display">\[
\sqrt{ (A_x-B_x)^2 + (A_y-B_y)^2}
\]</span></p>
<h2 id="高维数据的距离">高维数据的距离</h2>
<p>现在我们使用一个数据集，这个数据集中含有189个样本，22215个基因，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(devtools)</div><div class="line"><span class="comment"># install_github("genomicsclass/tissuesGeneExpression")</span></div><div class="line"></div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div></pre></td></tr></table></figure>
<p>这些数据代表了8个组织（每个组织中有多个样本）的RNA表达水平，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>   <span class="number">189</span></div><div class="line">&gt; table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们现在描述一下在这个数据集中，不同样本之间的距离。我们也许对在不同样本中表达相似的基因感兴趣。</p>
<p>为了定义这个距离，我们需要知道这些点是什么，因为我们计算数学上的距离需要这些点。由于这个数据集是高维数据集，这些点就无法直接放在笛卡尔坐标系中。相反，我们会把这个数据集放在更高维度的坐标系中。例如样本<span class="math inline">\(i\)</span>是由22215维空间的一个点定义的（这个空间可以写为<span class="math inline">\((Y_{1,i},\dots,Y_{22215,i})^\top\)</span>）。特征值<span class="math inline">\(g\)</span>是由一个189维空间的一个点定义的（这个空间可以写为<span class="math inline">\((Y_{g,1},\dots,Y_{g,189})^\top\)</span>）。</p>
<p>一旦我们定义好了这些点，那么欧氏距离就可以使用我们前面类似的方法进行计算，例如，两个样本<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>的距离为： <span class="math display">\[
\mbox{dist}(i,j) = \sqrt{ \sum_{g=1}^{22215} (Y_{g,i}-Y_{g,j })^2 }
\]</span> 两个特征值<span class="math inline">\(h\)</span>和<span class="math inline">\(g\)</span>的距离为： <span class="math display">\[
\mbox{dist}(h,g) = \sqrt{ \sum_{i=1}^{189} (Y_{h,i}-Y_{g,i})^2 }
\]</span></p>
<h3 id="矩阵代数与距离">矩阵代数与距离</h3>
<p>样本<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之间的距离可以写为： <span class="math display">\[
\mbox{dist}(i,j) = (\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j)
\]</span> 其中，<span class="math inline">\(\mbox{Y}_{i}\)</span>和<span class="math inline">\(\mbox{Y}_{j}\)</span>代表第<span class="math inline">\(i\)</span>列和第<span class="math inline">\(j\)</span>列。这种写法在实际计算中非常方便。</p>
<h3 id="案例">案例</h3>
<p>现在我们使用上面的矩阵代数来计算一下距离。现在我们计算样本1与样本2（它们都是肾脏组织）的距离，然后再过计算样本87的距离（结肠），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x &lt;- e[,<span class="number">1</span>]</div><div class="line">y &lt;- e[,<span class="number">2</span>]</div><div class="line">z &lt;- e[,<span class="number">87</span>]</div><div class="line">sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，肾脏组织之间距离比较近。另外一种计算距离更快的方式就是使用矩阵代数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqrt( crossprod(x-y) )</div><div class="line">sqrt( crossprod(x-z) )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt( crossprod(x-y) )</div><div class="line">        [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">85.8546</span></div><div class="line">&gt; sqrt( crossprod(x-z) )</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>现在我们一次计算出所有的距离，我们可以使用<code>dist()</code>函数，这个函数可以计算出每行之间的距离，现在我们感兴趣的是不同样本之间的相似性，因此我们需要使用<code>t()</code>来转换一下矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(e))</div><div class="line">class(d)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- dist(t(e))</div><div class="line">&gt; class(d)</div><div class="line">[<span class="number">1</span>] <span class="string">"dist"</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，计算结果<code>d</code>是一个<code>dist</code>类，为了得到它的具体数值，我们需要将其强行转换为矩阵，并使用索引操作，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>这里我们需要注意的是，我们对数据集<code>e</code>使用了函数<code>dist()</code>，这个函数计算的是基因之间所有两两矩离，它最终会形成一个<span class="math inline">\(22215\times 22215\)</span>的矩阵。</p>
<h2 id="练习">练习</h2>
<p>P322</p>
<h2 id="降维操作">降维操作</h2>
<p>相应的Rmarkdown见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/pca_motivation.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>可视化数据是分析高通量数据中最重要的步骤之一。正确的可视化方法可能会发现实验数据的问题，这些数据可以呈现标准分析的结果。我们已经展示了可视化数据的全局方法，但是由于数据的高维特性，使得发现列之间或行之间关系的图形变得复杂。例如，如果要比较189个样本之间的特性，我们必不得不创建17766个MA图。创建一个单独的散点图明显不合适，因为数据量太大。</p>
<p>我们将介绍其于降维的探索性数据分析的强大技巧。一般的想法就是将数据集降至较低维度的同时又保留重要的特性，例如样本之间的距离。如果我们能够将数据降低到2维，那么我们就能很容易地画出图形。降维的背后就是奇异值分解(Singular value decomposition, SVD)，这种思路也可以应用于其他情况。在介绍SVD背后的复杂数学原理之前，我们将会使用一个简单的案例来介绍一下它的思路。</p>
<h3 id="案例将2维数据降低至1维">案例：将2维数据降低至1维</h3>
<p>现在我们来看一个案例，这个案例是有关双胞胎身高的。我们来模拟生成100个二维数据点，它们表示每个人与其均值的偏离的标准差的数目，每对数据点表示一对又胞胎，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">plot(y[<span class="number">1</span>,], y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=c(-<span class="number">3</span>,<span class="number">3</span>), ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909151311.jpeg">

</div>
<p>为了辅助说明问题，我们可以将上面的模拟数据视为高通量基因表达数据，其中双胞胎的配对数据表示了N个样本，双胞胎的2个身高表示基因表达数据。我们是对任意2个之间的距离感兴趣。我们可以使用<code>dist()</code>函数来进行计算。例如，上图的2个橙色数据点的距离为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d=dist(t(y))</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d=dist(t(y))</div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">1.140897</span></div></pre></td></tr></table></figure>
<p>如果两维数据太复杂（这里只是假设），我们只想制备一维图，那怎么办呢？例如，我们能否将这些数据减化为一维矩阵，同时保留这些点与点之间的距离信息呢？</p>
<p>如果我们回顾再来看这张图，在任何一对数据点之间画一条线，那么这条线的长度就是这两点这之间的距离。这些线倾向于沿着对角线的方向分布。我们以前到过MA图，这种图就是将原始散点图的对角线“旋转”了一下，将原来的对角线旋转到与x轴平行的位置形成的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">z1 = (y[<span class="number">1</span>,]+y[<span class="number">2</span>,])/<span class="number">2</span> <span class="comment">#the sum</span></div><div class="line">z2 = (y[<span class="number">1</span>,]-y[<span class="number">2</span>,]) <span class="comment">#the difference</span></div><div class="line">z = rbind( z1, z2) <span class="comment">#matrix now same dimensions as y</span></div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized \</span></div><div class="line"><span class="string">height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece \</span></div><div class="line"><span class="string">in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909153046.jpeg">

</div>
<p>上图的左图就是原始的散点图，右图则是MA图。</p>
<p>在后面章节中，我们将会使用线性代数来表示这些数据的变换（也就是旋转）。这里我们可以通过将<code>y</code>的相乘来得到<code>z</code>，如下所示： <span class="math display">\[
A = \,
\begin{pmatrix}
1/2&amp;1/2\\
1&amp;-1\\
\end{pmatrix}
\implies 
z = A y
\]</span> 我们将两侧都乘以<span class="math inline">\(A^{-1}\)</span>，则得到z，如下所示： <span class="math display">\[
A^{-1} = \,
\begin{pmatrix}
1&amp;1/2\\
1&amp;-1/2\\
\end{pmatrix}
\implies 
y = A^{-1} z
\]</span></p>
<h3 id="旋转">旋转</h3>
<p>在上图相，相对于其它点之间的距离，两个橙色上炽之间的距离大致保持一致。所以的点其实都是如此。对上面转换进行简单的重新缩放，将会使前后的距离完全相同。我们要做的就是乘以一个标量，从而保留每个数据点的标准差。如果你认为<code>y</code>的列是一个独立随机变量，其标准差为<span class="math inline">\(\sigma\)</span>，那么我们要注意到<span class="math inline">\(M\)</span>与<span class="math inline">\(A\)</span>的标准差如下所示： <span class="math display">\[
\mbox{sd}[ Z_1 ] = \mbox{sd}[ (Y_1 + Y_2) / 2 ] = \frac{1}{\sqrt{2}} \sigma \mbox{ and } \mbox{sd}[ Z_2] = \mbox{sd}[ Y_1 - Y_2  ] = {\sqrt{2}} \sigma
\]</span> 这就说明，如果我们将上面的转换变为如下形式： <span class="math display">\[
A = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1&amp;1\\
1&amp;-1\\
\end{pmatrix}
\]</span> 那么<span class="math inline">\(Y\)</span>列的SD就会变得与<span class="math inline">\(Z\)</span>列的方差一样。此外，我们要注意到，<span class="math inline">\(A^{-1}A=I\)</span>。我们称这种特性为<code>正交</code>(orthogonal)，并且它保留了上述SD的特性。因此就保留了距离信息：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">A &lt;- <span class="number">1</span>/sqrt(<span class="number">2</span>)*matrix(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z &lt;- A%*%y</div><div class="line">d &lt;- dist(t(y))</div><div class="line">d2 &lt;- dist(t(z))</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d2)) <span class="comment">#as.numeric turns distnaces into long vector</span></div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154417.jpeg">

</div>
<p>我们称这种转换为<code>y</code>的旋转：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154529.jpeg">

</div>
<p>我们之所以优先使用这种转换，是因为我们注意到所有的点是沿着对角线进行分布的，我们将对角线进行转换后，对角线与x轴平行。所以这个旋转实际上就达到了我们最初的要求：我们只需要一个维度就可以保留点与点之间的距离。现在让我们删除了第二个维度<code>z</code>，并重新计算一下距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3 = dist(z[<span class="number">1</span>,]) <span class="comment">##distance computed using just first dimension</span></div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d3))</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909155706.jpeg">

</div>
<p>仅用一维数据进行的距离计算就很接近实际距离，并且降低了维度，将2维降低到了1维。转换后的数据的第1约就是第一主成分。这一思想促进了使用主成分分析(PCA)和奇异值分解(SVD)来实现更广泛的降维。</p>
<h3 id="关于与其他解释区别的重要说明">关于与其他解释区别的重要说明</h3>
<p>如果你在网上搜索PCA的描述，你会注意到网上的描述与我们这里描述在符号上有些出入。这主要是因为在PCA中，通常使用行来表示实验单元（就是样本）。因此，在我们这里的实验中，<span class="math inline">\(Y\)</span>通常会被转换为<span class="math inline">\(N \times 2\)</span>矩阵。在统计学中，这也是最为普遍的表示数据的方式：每行表示一个样本。然而，由于实际原因，在遗传学中，通常使用列表示样本。例如行表示基因，列表示样本。由于这个原因，在这本书中，我们会解释PCA和与之相应的数学计算会与常规的方式有所不同。因此，在网上找到的相关的许多PCA的解释都是先从样本的协方差矩阵开始的，它通常使用<span class="math inline">\(\mathbf{X}^\top\mathbf{X}\)</span>表示，并且每个单元格表示两个实验单元之间的协方差。然而，要做到这一点，我们需要使用<span class="math inline">\(\mbox{X}\)</span>的行表示实验单元。因此，在我们上面的符号中，在经过缩放后，你必须要使用<span class="math inline">\(\mathbf{Y}\mathbf{Y}^\top\)</span>来进行计算。总之，如果你想让我们的解释与其他有关的PCA内容相符，就必须对这本书中使用的矩阵进行转置。</p>
<h2 id="奇异值分解">奇异值分解</h2>
<p>相关的Rmarkdown参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/svd.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在前面的部分中，我们展示了降维分析，以及如何让我们使用一维数据来替代原来的二维数据，近似地表示点与点之间的距离。奇异值分解(SVD)是我们这种方法的推广。在这个案例中，SVD对原始数据进行了转换。这种转换具有一些非常有用的属性。</p>
<p>SVD计算的主要结果就是，我们可以写为一个<span class="math inline">\(m\times n\)</span>矩阵，对于矩阵<span class="math inline">\(\mbox{Y}\)</span>就写为：</p>
<p><span class="math display">\[
\mathbf{U}^\top\mathbf{Y} = \mathbf{DV}^\top
\]</span> 其中， * <span class="math inline">\(\mathbf{U}\)</span> 是一个 <span class="math inline">\(m \times p\)</span> 正交矩阵； * <span class="math inline">\(\mathbf{V}\)</span> 是一个 <span class="math inline">\(p \times p\)</span> 正交矩阵； * <span class="math inline">\(\mathbf{D}\)</span> 是一个 <span class="math inline">\(n \times p\)</span> 对角矩阵。</p>
<p>其中，<span class="math inline">\(p=\mbox{min}(m,n)\)</span>，<span class="math inline">\(\mathbf{U}^\top\)</span>对数据<span class="math inline">\(\mathbf{Y}\)</span>进行旋转，这一步非常有用，因为<span class="math inline">\(\mathbf{U}^\top \mathbf{Y}=\mathbf{VD}\)</span>列的变异（精确的平方和）会下降。因此<span class="math inline">\(\mathbf{U}\)</span>是正交辞职，我们可以将SVD写为如下形式： <span class="math display">\[
\mathbf{Y} = \mathbf{UDV}^\top
\]</span> 实际上这个公式更加普遍，我们也可以将转换写为如下形式： <span class="math display">\[
\mathbf{YV} = \mathbf{UD}
\]</span> <span class="math inline">\(Y\)</span>的这种转换也会生成一个矩阵，这个矩阵的列的乘方和是递减的。</p>
<p>将SVD应用到我们的案例中，就是如下结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y &lt;- t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">s &lt;- svd(y)</div></pre></td></tr></table></figure>
<p>我们可以马上就是看到使用了SVD后生成的转换后的矩阵非常类似于我们前面的案例中的结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div><div class="line">       [,<span class="number">1</span>]   [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.982</span> -<span class="number">1.017</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">1.017</span>  <span class="number">0.982</span></div></pre></td></tr></table></figure>
<p>当我们旋转后，绘制成的图形称为主成分(principal coimponent)：这里只绘制出了第一个主成分和第二个主成分。如果我们想要从SVD中获取主成分，只需要旋转后的<span class="math inline">\(\mathbf{U}^\top\mathbf{Y}\)</span> 即可：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PC1 = s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 = s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">plot(PC1,PC2,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173315.jpeg">

</div>
<h3 id="用途">用途</h3>
<p>使用SVD的用途并不十分明显，我们可以看一些案例。在这个案例中，我们将会极大地降低<span class="math inline">\(V\)</span>的组倒数，并且仍然能够构建<span class="math inline">\(Y\)</span>。</p>
<p>现在我们来对基因表达谱进行SVD的计算，我们可以只使用表达谱中的100个基因的子集，这样计算会快一点，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">ind &lt;- sample(nrow(e),<span class="number">500</span>)</div><div class="line">Y &lt;- t(apply(e[ind,],<span class="number">1</span>,scale)) <span class="comment">#standardize data for illustration</span></div></pre></td></tr></table></figure>
<p>使用<code>svd()</code>函数可以返回3个矩阵（D矩阵仅返回对角线元素），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(Y)</div><div class="line">U &lt;- s$u</div><div class="line">V &lt;- s$v</div><div class="line">D &lt;- diag(s$d) <span class="comment">##turn it into a matrix</span></div></pre></td></tr></table></figure>
<p>我们首选要注意到，我们可以重构<span class="math inline">\(y\)</span>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Yhat &lt;- U %*% D %*% t(V)</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>如果我们看一下<span class="math inline">\(\mathbf{UD}\)</span>的平方和，我们会看到最后几个非常接近于0（也许我们会有一些重复的列）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173946.jpeg">

</div>
<p>这意味着<span class="math inline">\(V\)</span>的最后一列对于<span class="math inline">\(Y\)</span>的重建非常小。为了说明这一点，我们可以考虑<span class="math inline">\(V\)</span>最后一项为0的这种极端情况。在这个案例中，<span class="math inline">\(V\)</span>的最后一列根本用不到。由于SVD的这种创建方式，<span class="math inline">\(V\)</span>的列对<span class="math inline">\(Y\)</span>的重建影响越来越小。我们通常认为这种描述为“解释了较少的变异”。这就意味着，对于一个大型矩阵，当你到达最后一列时，可能已经没有太多需要“解释”的内容了。例如，当我们把最后4列删除，看一下计算结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- ncol(U)-<span class="number">4</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>最大的残差基本上就等于0了，就意味着<code>Yhat</code>实际上是与<code>Y</code>一样，但是，我们至少需要4个维度来传输信息。</p>
<p>通过查看<span class="math inline">\(d\)</span>，我们可以看到，在这个特定的数据集中，我们能得到一个很好的近似值，它只保留了94列。在下面的图形中，我们可以看到每列能解释的变异程度是多少：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909174959.jpeg">

</div>
<p>还可以看一下累积曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plot(cumsum(s$d^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>,ylim=c(<span class="number">0</span>,\</div><div class="line"><span class="number">100</span>),type=<span class="string">"l"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175047.jpeg">

</div>
<p>虽然刚开始的时候，我们的数据是189维，但是我们可以使用95维来近似表示<span class="math inline">\(Y\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- <span class="number">95</span> <span class="comment">##out a possible 189</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">boxplot(resid,ylim=quantile(Y,c(<span class="number">0.01</span>,<span class="number">0.99</span>)),range=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175150.jpeg">

</div>
<p>因此， 我们只使用了一半的维度就保留了原始数据中的大部分的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var(as.vector(resid))/var(as.vector(Y))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; var(as.vector(resid))/var(as.vector(Y))</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>这个计算结果说明，我们使用了降维后的数据解释了原始95%的变异，我们需要注意的是，我们是通过<span class="math inline">\(D\)</span>来计算的这个比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>因此，<span class="math inline">\(D\)</span>中的元素可以告诉我们每个PC在解释变异方面所贡献的程度大小。</p>
<h3 id="高度相关数据">高度相关数据</h3>
<p>为了辅助理解SVD是如何工作的，我们使用两组高度相关的列来构建一个数据集，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">2</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- cbind(x,x)+e</div><div class="line">cor(Y)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; cor(Y)</div><div class="line">          x         x</div><div class="line">x <span class="number">1.0000000</span> <span class="number">0.9998873</span></div><div class="line">x <span class="number">0.9998873</span> <span class="number">1.0000000</span></div></pre></td></tr></table></figure>
<p>在这个案例中，第2列添加了很少的“信息”，因此所有的<code>Y[,1]-Y[,2]</code>都接近于0。使用<code>rowMeans(Y)</code>计算更加有效，这是因为<code>Y[,1]-rowMeans(Y)</code>和<code>Y[,2]-rowMeans(Y)</code>更接近于0。<code>rowMenas(Y)</code>最终生成的结果在<span class="math inline">\(U\)</span>的第1列中。SVD的计算结果表明，仅使用第1列就能解释大多数的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- svd(Y)$d</div><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999441</span></div></pre></td></tr></table></figure>
<p>在这个案例中，许多列的数据高度相关，我们可以进行更大程度的降维操作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">25</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- replicate(n,x)+e</div><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999065</span></div></pre></td></tr></table></figure>
<h2 id="练习-1">练习</h2>
<p>P338</p>
<h2 id="投影">投影</h2>
<p>原始Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/projections.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经详细地描述了降维的概念，以及SVD和主成分分析的内容，现在我们来谈一下它们背后的数学原理。我们先从投影(projection)开始讲起。投影是一个线性代数的概念，它能帮助我们理解许多关于高通量数据的许多数学操作。如果想要了解更多相关的知识，可以找本线性代数的书来看一下有关投影的内容。在这一部分里，我们会提供一个快速的回顾，然后提供一些数据分析的相关案例。</p>
<p>作为回顾，我们需要注意的是，投影就是点与其子空间之间的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910145026.png">

</div>
<p>在上图中，顶部的点指向空间中的一点。在上图的这个卡通图中，空间是二维的，但是我们可以更加抽象地思考一下。这个空间由笛卡尔平面表示，小人站的这条线是点的一个子空间。将点投影到这个子空间上所对应的位置，就是这个子空间上这个位置距离原点最近的点。几何学告诉我们，我们可以通过从点到子空间一条垂线（虚线）来找到子空间上的这点。小人站在这个子空间上，这个人从原点走到投影点的位置时，就是这个点投影到子空间后的坐标。</p>
<p>为了扩展投影的概念，我们可以使用标准矩阵线性符号来说明这个点， <span class="math inline">\(\vec{y} \in \mathbb{R}^N\)</span>是一个N维空间的点，<span class="math inline">\(L \subset \mathbb{R}^N\)</span>是一个更小的子空间。</p>
<h3 id="案例当n2">案例：当N=2</h3>
<p>先看一个案例，<span class="math inline">\(Y = \begin{pmatrix} 2 \\ 3\end{pmatrix}\)</span>，我们可以画出这个向量的图形：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar (<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">4</span>),c(<span class="number">0</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910151328.jpeg">

</div>
<p>我们可以马上定义一个坐标系统，将这个向量投影到空间中：<span class="math inline">\(\begin{pmatrix} 1\\ 0\end{pmatrix}\)</span> （x轴）和 <span class="math inline">\(\begin{pmatrix} 0\\ 1\end{pmatrix}\)</span> （y轴）。 <span class="math inline">\(Y\)</span> 向子空间的投影可以通过点2和3分别进行定义：</p>
<p><span class="math display">\[
\begin{align*}
Y &amp;= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&amp;=2  \begin{pmatrix} 1\\ 0\end{pmatrix} + 3 \begin{pmatrix} 0\\ 1\end{pmatrix} 
\end{align*}
\]</span> 我们可以说 <span class="math inline">\(2\)</span> 和<span class="math inline">\(3\)</span>是向量<span class="math inline">\(Y\)</span>的坐标，<span class="math inline">\(\begin{pmatrix} 1\\ 0\end{pmatrix} \mbox{and} \begin{pmatrix} 0\\1 \end{pmatrix}\)</span> 是它的基。</p>
<p>现在我们定义一个新的子空间。红线（后面我们会画出这个图形）是一个子集(subset)<span class="math inline">\(L\)</span>，它由满足 <span class="math inline">\(c \vec{v}\)</span> with <span class="math inline">\(\vec{v}=\begin{pmatrix} 2&amp; 1\end{pmatrix}^\top\)</span>的点构成。那么 <span class="math inline">\(\vec{y}\)</span> 在<span class="math inline">\(L\)</span>上的投影就是<span class="math inline">\(L\)</span>上最接近于 <span class="math inline">\(\vec{y}\)</span> 的点。因此我们需要找一个向量<span class="math inline">\(c\)</span>，它是位于 <span class="math inline">\(\vec{y}\)</span> 和<span class="math inline">\(c\vec{v}=(2c,c)\)</span>之间最小的距离。从线性代数的知识我们可知，这些点之间的距离正交于空间：</p>
<p><span class="math display">\[
(\vec{y}-\hat{c}\vec{v}) \cdot \vec{v} = 0
\]</span></p>
<p>上面公式也可以写为：</p>
<p><span class="math display">\[
\vec{y}\cdot\vec{v} - \hat{c}\vec{v}\cdot\vec{v} =  0
\]</span></p>
<p>即： <span class="math display">\[
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}
\]</span> <span class="math display">\[\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}\]</span></p>
<p>这里我们使用点号 <span class="math inline">\(\cdot\)</span> 来表示点积(dot product): <span class="math inline">\(\,\, \vec{x} \cdot \vec{y} = x_1 y_1+\dots x_n y_n\)</span>.</p>
<p>下面我们使用R来演示一下上面的案例：</p>
<figure class="highlight plain"><figcaption><span>projection, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(c(0,4),c(0,4),xlab=&quot;Dimension 1&quot;,ylab=&quot;Dimension 2&quot;,type=&quot;n&quot;)</div><div class="line">arrows(0,0,2,3,lwd=3)</div><div class="line">abline(0,0.5,col=&quot;red&quot;,lwd=3) #if x=2c and y=c then slope is 0.5 (y=0.5x)</div><div class="line">text(2,3,&quot; Y&quot;,pos=4,cex=3)</div><div class="line">y=c(2,3)</div><div class="line">x=c(2,1)</div><div class="line">cc = crossprod(x,y)/crossprod(x)</div><div class="line">segments(x[1]*cc,x[2]*cc,y[1],y[2],lty=2)</div><div class="line">text(x[1]*cc,x[2]*cc,expression(hat(Y)),pos=4,cex=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910153202.jpeg">

</div>
<p>我们需要注意的是，如果 <span class="math inline">\(\vec{v}\)</span> 满足 <span class="math inline">\(\vec{v}\cdot \vec{v}=1\)</span>, 那么<span class="math inline">\(\hat{c}\)</span> 就是 <span class="math inline">\(\vec{y} \cdot \vec{v}\)</span> ，空间 <span class="math inline">\(L\)</span>并没有发生改变，这处简化担任就是我们喜欢正交矩阵的一个原因。</p>
<h3 id="案例样本均值就是投影">案例：样本均值就是投影</h3>
<p>设 <span class="math inline">\(\vec{y} \in \mathbb{R}^N\)</span> ，<span class="math inline">\(L \subset \mathbb{R}^N\)</span> 被以下向量张成：</p>
<p><span class="math display">\[
\vec{v}=\begin{pmatrix} 1\\ \vdots \\  1\end{pmatrix};
L = \{ c \vec{v}; c \in \mathbb{R}\}
\]</span> 在这个空间里，向量的分量(components）都是相同的数目，因此我们可以把这个空间看作为常数：在投影中，每个维度都是相同的值。那么<span class="math inline">\(c\)</span>如何才能使得 <span class="math inline">\(c\vec{v}\)</span> 与 <span class="math inline">\(\vec{y}\)</span> 之间的距离最小呢？</p>
<p>当我们谈到这个问题时，我们会使用前面的二维图形。我们可以简单地抽象将<span class="math inline">\(\vec{y}\)</span>视为N维空间上的一个点，将<span class="math inline">\(L\)</span>视为一个更小数目的子空间，在这个案例中就是<span class="math inline">\(c\)</span>。</p>
<p>回到我们的问题，我们知道，投影就是：</p>
<p><span class="math display">\[\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}\]</span></p>
<p>在这个案例中它就是平均值： <span class="math display">\[
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}} = \frac{\sum_{i=1}^N Y_i}{\sum_{i=1}^N 1} = \bar{Y}
\]</span></p>
<p>在这个案例中，它也非常容易使用微积分进行计算：</p>
<p><span class="math display">\[
\frac{\partial}{\partial c}\sum_{i=1}^N (Y_i - c)^2 = 0 \implies 2 \sum_{i=1}^N (Y_i - \hat{c}) = 0 \implies
\]</span> <span class="math display">\[
N c = \sum_{i=1}^N Y_i \implies \hat{c}=\bar{Y
}
\]</span></p>
<h3 id="案例回归也是一种投影">案例：回归也是一种投影</h3>
<p>现在来看一下略微复杂的案例。简单线性回归也能用投影来解释。我们的数据 <span class="math inline">\(\mathbf{Y}\)</span>（这里我们不再使用<span class="math inline">\(\vec{y}\)</span>符号）是一个N维向量，我们使用一个线性方程<span class="math inline">\(\beta_0 + \beta_1 X_i\)</span>来预测<span class="math inline">\(Y_i\)</span> 。此时我要找到能够使<span class="math inline">\(Y\)</span>和由以下向量定义的空间的最小距离时的 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span> ，其中： <span class="math display">\[
\vec{v}_0=
\begin{pmatrix}
1\\
1\\
\vdots \\
1\\
\end{pmatrix} 
\mbox{ and }
\vec{v}_1=
\begin{pmatrix}
X_{1}\\
X_{2}\\
\vdots \\
X_{N}\\
\end{pmatrix} 
\]</span></p>
<p>我们的 <span class="math inline">\(N\times 2\)</span> 矩阵 <span class="math inline">\(\mathbf{X}\)</span> 是 <span class="math inline">\([ \vec{v}_0 \,\, \vec{v}_1]\)</span> ，<span class="math inline">\(L\)</span>中的任何点都可以被写为 <span class="math inline">\(X\vec{\beta}\)</span>.</p>
<p>正交投影的多维形式的方程为：</p>
<p><span class="math display">\[
X^\top (\vec{y}-X\vec{\beta}) = 0
\]</span></p>
<p>我们在之前看到过种形式：</p>
<p><span class="math display">\[
X^\top X \hat{\beta}=  X^\top \vec{y} 
\]</span></p>
<p><span class="math display">\[
\hat{\beta}= (X^\top X)^{-1}X^\top \vec{y}
\]</span></p>
<p>它向<span class="math inline">\(L\)</span>的投影就是：</p>
<p><span class="math display">\[
X (X^\top X)^{-1}X^\top \vec{y}
\]</span></p>
<h2 id="旋转-1">旋转</h2>
<p>相关的Rmarkdown参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/rotations.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>与投影相关的一个最常见的应用就是坐标旋转(coordinate rotations)。在数据分析中，简单的旋转可以很好地对数据进行可视化和解释。我们将会介绍旋转背后的数学原理，并且给出一些简单的数据分析案例。</p>
<p>前面我们使用了下面的例子： <span class="math display">\[
Y = \begin{pmatrix} 2 \\ 
3 
\end{pmatrix} 
= 
2  
\begin{pmatrix} 1\\
0 
\end{pmatrix} + 
3 
\begin{pmatrix} 0\\ 
1 
\end{pmatrix}
\]</span> 我们注意到，<span class="math inline">\(Y\)</span>的坐标是<span class="math inline">\((2,3)\)</span>，现在我们使用如下的代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">segments(<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">segments(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910165242.jpeg">

</div>
<p>但是，我们可以用其它的一些线性组合来表示点<span class="math inline">\((2,3)\)</span>： <span class="math display">\[
\begin{align*}
Y &amp;= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&amp;= 2.5 \begin{pmatrix} 1\\ 1\end{pmatrix} + -1 \begin{pmatrix} \phantom{-}0.5\\ -0.5\end{pmatrix} 
\end{align*}
\]</span> 新的坐标就是： <span class="math display">\[
Z = \begin{pmatrix} 2.5 \\ -1 \end{pmatrix}
\]</span> 从图形上我们可以看出来，这个坐标就是我们由新的基定义的空间的投影</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">abline(<span class="number">0</span>,-<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">y=c(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">x1=c(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">##new basis</span></div><div class="line">x2=c(<span class="number">0.5</span>,-<span class="number">0.5</span>)<span class="comment">##new basis</span></div><div class="line">c1 = crossprod(x1,y)/crossprod(x1)</div><div class="line">c2 = crossprod(x2,y)/crossprod(x2)</div><div class="line">segments(x1[<span class="number">1</span>]*c1,x1[<span class="number">2</span>]*c1,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">segments(x2[<span class="number">1</span>]*c2,x2[<span class="number">2</span>]*c2,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233102.jpeg">

</div>
<p>我们可以使用矩阵乘法在表示<span class="math inline">\((2,3)\)</span>的这两个坐标中进行转换： <span class="math display">\[
Y =   AZ\\
\]</span></p>
<p><span class="math display">\[
 A^{-1} Y =  Z\\
\]</span></p>
<p><span class="math display">\[
A= \begin{pmatrix} 1&amp; \phantom{-}0.5\\ 1 &amp; -0.5\end{pmatrix} \implies 
A^{-1}= \begin{pmatrix} 0.5&amp; 0.5 \\ 1 &amp;-1\end{pmatrix}
\]</span></p>
<p>其中，<span class="math inline">\(Z\)</span>和<span class="math inline">\(Y\)</span>表示了相同的信息，但是它们位于不同的坐标系中。</p>
<h3 id="案例双胞胎身高">案例：双胞胎身高</h3>
<p>我们先来看100个二维数据点<span class="math inline">\(Y\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n = <span class="number">100</span></div><div class="line">mypar()</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>),matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233353.jpeg">

</div>
<p>这里就使用了旋转：<span class="math inline">\(Z = A^{-1} Y\)</span>，图形如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = matrix(c(<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z = A%*%y</div><div class="line">mypar()</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlab=<span class="string">"Average"</span>,ylab=<span class="string">"Difference"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233448.jpeg">

</div>
<p>我们在这里进行的操作就是对数据进行旋转，从而使行新的坐标系<span class="math inline">\(Z\)</span>的第一维是平均身高（就是相当于x轴），崦第二维则是两个双胞胎身高的差值（y轴）。</p>
<p>我们已经使用了奇异值分解计算主成分。有时候将SVD视为应动力非常有用，例如 <span class="math inline">\(\mathbf{U}^\top \mathbf{Y}\)</span> 就会构建出一个新的坐标系 <span class="math inline">\(\mathbf{DV}^\top\)</span> ，在这个新的坐标系中，它们的维度按照维度能够解释变异的程序进行排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/19/DAL/DALS019_StatisticalModels2_Beyes_Hierarchical/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/DAL/DALS019_StatisticalModels2_Beyes_Hierarchical/" itemprop="url">DALS019-统计模型2-贝叶斯分布与层次分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T12:00:00+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,055
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第7章统计模型的第2小节，这一部分的主要内容涉及贝叶斯统计的一些原理。相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/modeling/bayes.Rmd" target="_blank" rel="external">Github</a>，另外，如果想补充一些贝叶斯的相关知识，可以参考这本书《统计学关我什么事：生活中的极简统计学》，这是一本有关贝叶斯统计的科普书，公式不多。</p>
<h2 id="贝叶斯统计">贝叶斯统计</h2>
<p>高通量数据的一个明显特点就是，虽然我们最终会报道一些特定的基因，但是我们还会观察到许多相关的结果。例如，我们检测会数千个基因或者是代表了蛋白结合位点的数千个峰图，或者是一些CpGs的甲基化水平。但是，我们这里使用的多数统计推断方法都是独立地处理每个特征值，并且几乎忽略了来自其它特征的数据。在这一部分里，我们将会了解到，如何通过对特征值的联合建模来进行统计。这里方法中使用最为广泛的就是层次模型(hierachical models)，我们会在后面的贝叶斯统计中进行解释。</p>
<h3 id="贝叶斯定理">贝叶斯定理</h3>
<p>先来看一个案例，如果我们有一种检测手段来检测囊性纤维化(cystic fibrosis)。假设这个检测手段的精确程度为99%，我们可以使用下面的公式来表示： <span class="math display">\[
\mbox{Prob}(+ \mid D=1)=0.99, \mbox{Prob}(- \mid D=0)=0.99
\]</span> 其中，<span class="math inline">\(+\)</span>表示阳性结果，<span class="math inline">\(D\)</span>表示检测的结果，其中<span class="math inline">\(1\)</span>表示得病，，<span class="math inline">\(0\)</span>表示不得病。</p>
<p>现在我们随机选择一个人进行检测，结果如果是阳性，那么这个人患病的概率是多大？也就是说要计算<span class="math inline">\(\mbox{Prb}(D=1|+)\)</span>的结果。囊性纤维化的发病率是每1/3900，也就是说，<span class="math inline">\(\mbox{Prob}(D=1|+)=0.0025\)</span>，为了计算出这个人患病的概率，我们就会使用到贝叶斯定理，贝叶斯定理公式如下所示： <span class="math display">\[
\mbox{Pr}(A \mid B)  =  \frac{\mbox{Pr}(B \mid A)\mbox{Pr}(A)}{\mbox{Pr}(B)}
\]</span> 这个公式就可以应用到我们的案例中，如下所示： <span class="math display">\[
\begin{align*}
\mbox{Prob}(D=1 \mid +) &amp; =  \frac{ P(+ \mid D=1) \cdot P(D=1)} {\mbox{Prob}(+)} \\
&amp; =  \frac{\mbox{Prob}(+ \mid D=1)\cdot P(D=1)} {\mbox{Prob}(+ \mid D=1) \cdot P(D=1) + \mbox{Prob}(+ \mid D=0) \mbox{Prob}( D=0)} 
\end{align*}
\]</span> 换成实际数字，则如下所示： <span class="math display">\[
\frac{0.99 \cdot 0.00025}{0.99 \cdot 0.00025 + 0.01 \cdot (.99975)}  =  0.02
\]</span> 也就是说，虽然这种检测手段有99%的精度，但是一个人的检测结果如果是阳性，那么这个人得病的概率只有0.02。这似乎有点反直觉。其原因就是，我们必须要考虑，当我们随机选择一个人时，这个人患上这种疾病时非常罕见的可能性。为了说明这一个，我们随便使用Monte Carlo模拟来计算一下。</p>
<h3 id="模拟">模拟</h3>
<p>下面的模拟旨在帮助你能够以可视化的形式来理解贝叶斯定理。我们首选从一个总体中随机选择1500人，其中患病的概率是5%，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">3</span>)</div><div class="line">prev &lt;- <span class="number">1</span>/<span class="number">20</span></div><div class="line"><span class="comment">##Later, we are arranging 1000 people in 80 rows and 20 columns</span></div><div class="line">M &lt;- <span class="number">50</span> ; N &lt;- <span class="number">30</span></div><div class="line"><span class="comment">##do they have the disease?</span></div><div class="line">d&lt;-rbinom(N*M,<span class="number">1</span>,p=prev)</div></pre></td></tr></table></figure>
<p>现在进行一项检测，这个检测的准确率是90%，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">accuracy &lt;- <span class="number">0.9</span></div><div class="line">test &lt;- rep(<span class="literal">NA</span>,N*M)</div><div class="line"><span class="comment">##do controls test positive?</span></div><div class="line">test[d==<span class="number">1</span>] &lt;- rbinom(sum(d==<span class="number">1</span>), <span class="number">1</span>, p=accuracy)</div><div class="line"><span class="comment">##do cases test positive?</span></div><div class="line">test[d==<span class="number">0</span>] &lt;- rbinom(sum(d==<span class="number">0</span>), <span class="number">1</span>, p=<span class="number">1</span>-accuracy)</div></pre></td></tr></table></figure>
<p>由于没有患病的人数要远远超过患病的人数，即使存在着极低的假阳性率，那么在检测为阳性的结果中，不患病人的也要多于患病的人，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">cols &lt;- c(<span class="string">"grey"</span>,<span class="string">"red"</span>)</div><div class="line">people &lt;- expand.grid(<span class="number">1</span>:M,N:<span class="number">1</span>)</div><div class="line">allcols &lt;- cols[d+<span class="number">1</span>] <span class="comment">##Cases will be red</span></div><div class="line">positivecols &lt;- allcols</div><div class="line">positivecols[test==<span class="number">0</span>] &lt;- <span class="literal">NA</span> <span class="comment">##remove non-positives</span></div><div class="line">negativecols &lt;- allcols</div><div class="line">negativecols[test==<span class="number">1</span>] &lt;- <span class="literal">NA</span> <span class="comment">##remove non-positives</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">layout(matrix(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>),<span class="number">2</span>,<span class="number">2</span>),width=c(<span class="number">0.35</span>,<span class="number">0.65</span>))</div><div class="line"><span class="comment">###plot of all people</span></div><div class="line">plot(people,col=allcols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste0(<span class="string">"Population: "</span>,round(mean(d)*<span class="number">100</span>),<span class="string">"% are red"</span>))</div><div class="line">plot(people,col=positivecols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste(<span class="string">"Tested Positive:"</span>,round(mean(d[test==<span class="number">1</span>])*<span class="number">100</span>),<span class="string">"% are red"</span>))</div><div class="line">plot(people,col=negativecols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste(<span class="string">"Tested Negative:"</span>,round(mean(d[test==<span class="number">0</span>])*<span class="number">100</span>,<span class="number">1</span>),<span class="string">"% are red"</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908153222.jpeg">

</div>
<p>现在解释一下上面的图：</p>
<p>顶图：红点表示患者。每个人接受检测的话，有90%的可能性结果是准确的。即<span class="math inline">\(\mbox{Pr}(D=1)\)</span>；</p>
<p>下左图：检测结果为阳性（无论结果对不对，这里面含有真阳性与假阳性）的人，即<span class="math inline">\(\mbox{Pr}(D=1|+)\)</span></p>
<p>下右图：检测结果为阴性的人，即<span class="math inline">\(\mbox{Pr}(D=0|+)\)</span></p>
<h3 id="贝叶斯的实际运用">贝叶斯的实际运用</h3>
<p>José Iglesias是一名职业棒球运行员，在2013年4月份，他开始了职业生成，他表表现得很好，成绩如下所示：</p>
<table>
<thead>
<tr class="header">
<th>Month</th>
<th>At Bats</th>
<th>H</th>
<th>AVG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>April</td>
<td>20</td>
<td>9</td>
<td>.450</td>
</tr>
</tbody>
</table>
<p>平均击球率(battingaverage, AVG)统计是一种检测成功的方式。粗略地说，这个指标是告诉我们击球时的成功情况。<code>AVG=0.450</code>就表明，这个运动员在他击球的时间内（对应上面的<code>At Bats</code>）成功了45%，这是一个非常高的水平。为什么水平高呢，因为自1941年Ted Williams的<code>AVG=0.400</code>以来，还没有人能超过这个水平。为了说明层次模型的强大功能，我们将会在后面对Jose的数据进行预测。</p>
<p>在本书的前面部分到此为止，我们所到到的统计学技术可以被称为频率学派技术(frequentist techniques)，使用这种知识做出的结论就是能计算出一个置信区间。我们可以把击打(hitting)这个事件看作是一个二元结果，其成功的概论为<span class="math inline">\(p\)</span>。因此，如果成功率是0.450的话，那么击球次数是20次时，标准误为： <span class="math display">\[
\sqrt{\frac{.450 (1-.450)}{20}}=.111
\]</span> 也就是说，我们计算出的置信区间为<code>.450-.222</code> to <code>.450+.222</code>或<code>.228</code> to <code>.672</code>。</p>
<p>使用这种手段进行预测存在着两个问题。第一，实际用处不大。第二，成功率在0.450之间波动，也就是说这个人打破了Ted William的纪录。如果你自己关注棒球运动的话，打破Ted William纪录这种描述似乎是有问题，这是因为你隐含地使用了一个层次模型，这个模型会影响后面几年棒球的信息。在这里，我们对这种直觉进行量化。</p>
<p>首选，我们来研究一下前三个赛季里所有超过500次击打(at bats)的运动员的击球率的分布情况：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">tmpfile &lt;- tempfile()</div><div class="line">tmpdir &lt;- tempdir()</div><div class="line">download.file(<span class="string">"http://seanlahman.com/files/database/lahman-csv_2014-02-14.zip"</span>,tmpfile)</div><div class="line"><span class="comment">##this shows us files</span></div><div class="line">filenames &lt;- unzip(tmpfile,list=<span class="literal">TRUE</span>)</div><div class="line">players &lt;- read.csv(unzip(tmpfile,files=<span class="string">"Batting.csv"</span>,exdir=tmpdir),as.is=<span class="literal">TRUE</span>)</div><div class="line">unlink(tmpdir)</div><div class="line">file.remove(tmpfile)</div><div class="line"></div><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line"><span class="keyword">for</span>(y <span class="keyword">in</span> <span class="number">2010</span>:<span class="number">2012</span>)&#123;</div><div class="line">  dat &lt;- filter(players,yearID==y) %&gt;% mutate(AVG=H/AB) %&gt;% filter(AB&gt;<span class="number">500</span>)</div><div class="line">  hist(dat$AVG*<span class="number">1000</span>,xlab=<span class="string">"AVG"</span>,freq=<span class="literal">FALSE</span>,main=y,xlim=c(<span class="number">200</span>,<span class="number">360</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908211314.jpeg">

</div>
<p>我们注意到，普通运行员的AVG为0.275，总体运动员的标准差为0.027。所以，我们看到，0.45这个数字与它们假设偏离非常大，因为这个数字离平均值的差距超过了6个标准差。Jose的这个数字是由于运气，还是说他确实是过去50年来最好的运动员？或者是这两者的结合？但是，他有多幸运，以及运动天赋有多高？如果我们确信他是由于运气出现的这个数字，我们应该把他送到相信他确实是0.45这个水平的球队里，并且有可能高估了他的潜力。</p>
<h3 id="层次模型"><strong>层次模型</strong></h3>
<p>层次模型为我们提供了如何观察到0.45的这个数字的数学描述。首先，我们会随机选择一个内在能力为<span class="math inline">\(\theta\)</span>运动员，然后，我们看到成功概率为<span class="math inline">\(\theta\)</span>的20个随机结果（这一段不太懂，原文为：The hierarchical model provides a mathematical description of how we came to see the observation of .450. First, we pick a player at random with an intrinsic ability summarized by, for example, <span class="math inline">\(\theta\)</span>, then we see 20 random outcomes with success probability <span class="math inline">\(\theta\)</span>.），其中： <span class="math display">\[
\begin{align*}
\theta &amp;\sim N(\mu, \tau^2) \mbox{ describes randomness in picking a player}\\
Y \mid \theta &amp;\sim N(\theta, \sigma^2) \mbox{ describes randomness in the performance of this particular player}
\end{align*}
\]</span> 我们要注意2个层次（这就是为什么要称为层次分析的原因）：</p>
<ol style="list-style-type: decimal">
<li>运动员与运动员之间的变异；</li>
<li>击球时，运气因素导致的变异。</li>
</ol>
<p>在贝叶斯框架中，第一个水平称为先验分布(prior distribution)，第二个水平称为采样分布(sampling distribution)。</p>
<p>现在我们使用贝叶斯模型来计算Jose的数据。假设我们想预测构成他真实击球平均水平<span class="math inline">\(\theta\)</span>的内在能力的话。使用层次模型就按下面的方法表示： <span class="math display">\[
\begin{align*}
\theta &amp;\sim N(.275, .027^2) \\
Y \mid \theta &amp;\sim N(\theta, .111^2) 
\end{align*}
\]</span> 我们现在就可以计算出一个后验分布(posterior distribution)来描述我们对<span class="math inline">\(\theta\)</span>的预测。这里我们可以使用贝叶斯规则的连续计算方法推导后验概率，后验概率是对给定观测数据参数<span class="math inline">\(\theta\)</span>的分布： <span class="math display">\[
\begin{align*}
f_{ \theta \mid Y} (\theta\mid Y) &amp;=
\frac{f_{Y\mid \theta}(Y\mid \theta) f_{\theta}(\theta)
}{f_Y(Y)}\\
&amp;= \frac{f_{Y\mid \theta}(Y\mid \theta) f_{\theta}(\theta)}
{\int_{\theta}f_{Y\mid \theta}(Y\mid \theta)f_{\theta}(\theta)}
\end{align*}
\]</span> 我们主要是对能够使后验概率<span class="math inline">\(f_{\theta\mid Y}(\theta\mid Y)\)</span>的值最大的<span class="math inline">\(\theta\)</span>感兴趣。在我们的案例中，我们可以看出后验概率服从正态分布，我们能计算出均值<span class="math inline">\(\mbox{E}(\theta\mid y)\)</span>，方差<span class="math inline">\(\mbox{var}(\theta\mid y)\)</span>，尤其，我们可以计算出这个分布的均值服从以下分布： <span class="math display">\[
\begin{align*}
\mbox{E}(\theta\mid y) &amp;= B \mu + (1-B) Y\\
&amp;= \mu + (1-B)(Y-\mu)\\
B &amp;= \frac{\sigma^2}{\sigma^2+\tau^2}
\end{align*}
\]</span> 这是一个总体均值<span class="math inline">\(\mu\)</span>和观测数据<span class="math inline">\(Y\)</span>的加权均值。其权重取决于总体<span class="math inline">\(\tau\)</span>的SD和我们观测数据<span class="math inline">\(\sigma\)</span>的SD。这个加权均值有时候也会被称为<code>shrinking</code>，因为它缩小(shrink)了对先验均值的估计，在Joes Iglesias的数据中，结果如下所示： <span class="math display">\[
\begin{align*}
\mbox{E}(\theta \mid Y=.450) &amp;= B \times .275 + (1 - B) \times .450 \\
&amp;= .275 + (1 - B)(.450 - .275) \\
B &amp;=\frac{.111^2}{.111^2 + .027^2} = 0.944\\
\mbox{E}(\theta \mid Y=450) &amp;\approx .285
\end{align*}
\]</span> 方差如下所示： <span class="math display">\[
\mbox{var}(\theta\mid y) = \frac{1}{1/\sigma^2+1/\tau^2}
= \frac{1}{1/.111^2 + 1/.027^2} = 0.00069
\]</span> 标准差因此是0.026。我们开始时，使用了传统频率学派的思路计算出的95%置信区间忽略了来自于其他运动员的数据，因此会单纯地认为Joes的数据是0.0450 ± 0.220。我们随后使用了贝叶斯方法，整合了来源于其他运动员的数据，以及前几年的数据，计算出了后验概率。这种计算思路实际上就是经验贝叶斯方法，因此我们使用了数据先构建了先验知识。从后验结果中我们可以知道，通过报告一个以均值为中心的区间来报告所谓的95%的可信区间，其发生的概率为95%，在这个案例中，其结果是0.285 ± 0.052。原文：From the posterior we can report what is called a 95% credible interval by reporting a region, centered at the mean, with a 95% chance of occurring. In our case, this turns out to be: 0.285 ± 0.052.</p>
<p>贝叶斯可信区间表明，如果其他的球队发现了0.45这个数字，我们应该考虑到Joses可能转会到其他球队，因为我们预测到了Jose的水平高于平均不水平。有意思的是，Red Sox在7月份的时候将Jose转会到了Detroit Tigers队。这里是Jose在接下来的5个月内的击球率：</p>
<table>
<thead>
<tr class="header">
<th>Month</th>
<th>At Bat</th>
<th>Hits</th>
<th>AVG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>April</td>
<td>20</td>
<td>9</td>
<td>.450</td>
</tr>
<tr class="even">
<td>May</td>
<td>26</td>
<td>11</td>
<td>.423</td>
</tr>
<tr class="odd">
<td>June</td>
<td>86</td>
<td>34</td>
<td>.395</td>
</tr>
<tr class="even">
<td>July</td>
<td>83</td>
<td>17</td>
<td>.205</td>
</tr>
<tr class="odd">
<td>August</td>
<td>85</td>
<td>25</td>
<td>.294</td>
</tr>
<tr class="even">
<td>September</td>
<td>50</td>
<td>10</td>
<td>.200</td>
</tr>
<tr class="odd">
<td>Total w/o April</td>
<td>330</td>
<td>97</td>
<td>.293</td>
</tr>
</tbody>
</table>
<p>虽然这两个区间都包括了最终的击球平均值，但是贝叶斯可信区间提供了更精确的预测，尤其是，这种方法预测到Jose在本赛季的剩余时间里表现不佳。</p>
<h2 id="练习">练习</h2>
<p>P308</p>
<h2 id="层次模型-1">层次模型</h2>
<p>有关层次模型的内容可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/modeling/hierarchical_models.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在这一部分里，我们会使用数据理论来描述在高通量数据分析中常用的方法。常规的思路就是构建一个两层的层次模型。一层用于描述样本/实验单元之间的变异，另外一层用于描述特征值之间的变异。这种分析方法类似于我们前面讲的棒球案例，即第一层用于描述不同运动员之间的变异，第二层用于描述一个运动员成功的随机性。我们这里𢪮的所有模型与方法都考虑了第一个变异水平，例如构建t检验的醋。第二个水平允许我们通过从所有的特征值里“借用(borrow)”信息用于对特征值进行统计推断，从而提供检验效能。</p>
<p>现在我们来看一个在基因表达数据中使用最为广泛的统计学方法。这个统计学方就是由<code>limma</code>Bioconductor包提供的。这个方法已经被用于改造分析RNAseq数据，例如edgeR<a href="https://www.ncbi.nlm.nih.gov/pubmed/19910308" target="_blank" rel="external">《edgeR: a Bioconductor package for differential expression analysis of digital gene expression data.》</a>和DESeq2<a href="https://www.ncbi.nlm.nih.gov/pubmed/25516281" target="_blank" rel="external">《Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2》</a>。这两个包提供了t检验的替代方案，它们通过对方差进行建模从而极大地改善了统计功效。然而在棒球案例中，我们是对均值进行了建模，这是与那两种方法建模的不同之处。对方差建模需要更深的数学知识，但是思路是一样的。我们以一个案例来说明一下这种方法。</p>
<p>下图是一个火山图，它显示了使用t检验来分析数据的结果，显示了效应大小(effect size)和p值，其中使用了6个重复样本（对照组3个，干预组3个），其中有16个基因是人为设定的差异基因。只有这16个基因的备选假设为真，在火山图上它们标记为蓝色，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(SpikeInSubset) <span class="comment">##Available from Bioconductor</span></div><div class="line">data(rma95)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">fac &lt;- factor(rep(<span class="number">1</span>:<span class="number">2</span>,each=<span class="number">3</span>))</div><div class="line">tt &lt;- rowttests(exprs(rma95),fac)</div><div class="line">smallp &lt;- with(tt, p.value &lt; <span class="number">.01</span>)</div><div class="line">spike &lt;- rownames(rma95) %<span class="keyword">in</span>% colnames(pData(rma95))</div><div class="line">cols &lt;- ifelse(spike,<span class="string">"dodgerblue"</span>,ifelse(smallp,<span class="string">"red"</span>,<span class="string">"black"</span>))</div><div class="line">with(tt, plot(-dm, -log10(p.value), cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">xlim=c(-<span class="number">1</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">4.5</span>),</div><div class="line">xlab=<span class="string">"difference in means"</span>,</div><div class="line">col=cols))</div><div class="line">abline(h=<span class="number">2</span>,v=c(-<span class="number">.2</span>,<span class="number">.2</span>), lty=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908225643.jpeg">

</div>
<p>上图是使用t检验计算了两组样本的差异基因，其中Spiked-in基因使用蓝色。剩下的基因中，p小于的用红色标明。</p>
<p>在上面的火山图中，我们将y轴的截止值(cut-off)设为了4.5，但是有一个蓝点的p值小于<span class="math inline">\(10^{-6}\)</span>。但是，从这张图中我们会发现2点怪异之处。第一，按照5% FDR的标准，只有一个阳性结果是显著的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum( p.adjust(tt$p.value,method = <span class="string">"BH"</span>)[spike] &lt; <span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum( p.adjust(tt$p.value,method = <span class="string">"BH"</span>)[spike] &lt; <span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这个结果与每组3个样本的低统计效能有关。第二，如果我们忽略掉统计推断，仅仅是基于t检验统计量的大小简单地对这些基因进行排序，那么我们会在任何大于1的排序列表中得到很多假阳性结果。例如，按照t检验统计量进行排序，位列前10名的基因中，有6个都是假阳性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table( top50=rank(tt$p.value)&lt;= <span class="number">10</span>, spike) <span class="comment">#t-stat and p-val rank is the same</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table( top50=rank(tt$p.value)&lt;= <span class="number">10</span>, spike) <span class="comment">#t-stat and p-val rank is the same</span></div><div class="line">       spike</div><div class="line">top50   <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line">  <span class="literal">FALSE</span> <span class="number">12604</span>    <span class="number">12</span></div><div class="line">  <span class="literal">TRUE</span>      <span class="number">6</span>     <span class="number">4</span></div></pre></td></tr></table></figure>
<p>在火山图中，我们注意到，大多数基因的效能大小都非常小，这说明，估计的标准误非常小，我们可以通过画图的手段来看一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tt$s &lt;- apply(exprs(rma95), <span class="number">1</span>, <span class="keyword">function</span>(row)</div><div class="line">  sqrt(<span class="number">.5</span> * (var(row[<span class="number">1</span>:<span class="number">3</span>]) + var(row[<span class="number">4</span>:<span class="number">6</span>]) ) ) )</div><div class="line">with(tt, plot(s, -log10(p.value), cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">              log=<span class="string">"x"</span>,xlab=<span class="string">"estimate of standard deviation"</span>,</div><div class="line">              col=cols))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908230650.jpeg">

</div>
<p>在这里我们就可以看到层次模型的用处了。如果我们假设这些变异的分布在所有基因中，然后我们通过分布来“调整”那些“太小”估计值，就可以改善我们的计算结果。在本书的前面部分中，我们提到F分布与观测到的方差分布近似，即： <span class="math display">\[
s^2 \sim s_0^2 F_{d,d_0}
\]</span> 因为我们有数千个数据点，我们实际上可以检验一下这个假设，并且估计出参数<span class="math inline">\(s_{0}\)</span>和<span class="math inline">\(d_{0}\)</span>。这种估计方法指的就是经验贝叶斯统计，因为我们使用现有的数据（经验）就可以构建先验分布（贝叶斯方法）。</p>
<p>现在我们将前面的棒球案例应用到标准误的估计中。像以前一样，我们已经有了每个基因的观测值<span class="math inline">\(s_{g}\)</span>，这是一个采样分布，用它来作为先验分布。我们因此可以计算出方差<span class="math inline">\(\sigma_{g}^2\)</span>的后来又做分布，并且获得一个后验均值，细节可以参考文献<a href="https://www.ncbi.nlm.nih.gov/pubmed/16646809" target="_blank" rel="external">《Linear models and empirical bayes methods for assessing differential expression in microarray experiments.》</a>，均值如下所示： <span class="math display">\[
\mathrm{E}\left[\sigma_{g}^{2} | s_{g}\right]=\frac{d_{0} s_{0}^{2}+d s_{g}^{2}}{d_{0}+d}
\]</span> 与棒球案例一样，后验均值会降低我们观测到的方差<span class="math inline">\(s_{g}^2\)</span>偏向于全局方差<span class="math inline">\(s_{0}^2\)</span>，其权重取决于样本大小，以及含有自由度<span class="math inline">\(d\)</span>的样本数目，在这个案例中，就是取决于通过<span class="math inline">\(d_{0}\)</span>的先验分布形状。（原文：AAs in the baseball example, the posterior mean <em>shrinks</em> the observed variance <span class="math inline">\(s_g^2\)</span> towards the global variance <span class="math inline">\(s_0^2\)</span> and the weights depend on the sample size through the degrees of freedom <span class="math inline">\(d\)</span> and, in this case, the shape of the prior distribution through <span class="math inline">\(d_0\)</span>. ）</p>
<p>在上面的图形中，我们可以看到40个基因的方差估计是如何缩小(shrink)的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">fit &lt;- lmFit(rma95, model.matrix(~ fac))</div><div class="line">ebfit &lt;- ebayes(fit)</div><div class="line">n &lt;- <span class="number">40</span></div><div class="line">qs &lt;- seq(from=<span class="number">0</span>,to=<span class="number">.2</span>,length=n)</div><div class="line">idx &lt;- sapply(seq_len(n),<span class="keyword">function</span>(i) which(as.integer(cut(tt$s^<span class="number">2</span>,qs)) == i)[<span class="number">1</span>])</div><div class="line">idx &lt;- idx[!is.na(idx)]</div><div class="line">par(mar=c(<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">plot(<span class="number">1</span>,<span class="number">1</span>,xlim=c(<span class="number">0</span>,<span class="number">.21</span>),ylim=c(<span class="number">0</span>,<span class="number">1</span>),type=<span class="string">"n"</span>,</div><div class="line">     xlab=<span class="string">"variance estimates"</span>,ylab=<span class="string">""</span>,yaxt=<span class="string">"n"</span>)</div><div class="line">axis(<span class="number">2</span>,at=c(<span class="number">.1</span>,<span class="number">.9</span>),c(<span class="string">"before"</span>,<span class="string">"after"</span>),las=<span class="number">2</span>)</div><div class="line">segments((tt$s^<span class="number">2</span>)[idx],rep(<span class="number">.1</span>,n),</div><div class="line">         ebfit$s2.post[idx],rep(<span class="number">.9</span>,n))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908232355.jpeg">

</div>
<p>上图显示的就是估计值如何向先验期望缩小的，40个基因包括了我们选择值的整个范围。</p>
<p>这种调整的一个重要方面就是使那些样本标准差接近于0的基因的样本偏差不再接近于0（向<span class="math inline">\(s_{0}\)</span>收缩）。我们现在就创建一个t检验的统计模型，用于替代使用这个后验均值或“收缩“(shrunken)后的方差估计值。我们称这种t检验模型为适度t检验（moderated t-test）。当我们使用适应t检验后从火山图上就能明显地看到其改进之处：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">fit &lt;- lmFit(rma95, model.matrix(~ fac))</div><div class="line">ebfit &lt;- ebayes(fit)</div><div class="line">limmares &lt;- data.frame(dm=coef(fit)[,<span class="string">"fac2"</span>], p.value=ebfit$p.value[,<span class="string">"fac2"</span>])</div><div class="line">with(limmares, plot(dm, -log10(p.value),cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">                    col=cols,xlab=<span class="string">"difference in means"</span>,</div><div class="line">                    xlim=c(-<span class="number">1</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">5</span>)))</div><div class="line">abline(h=<span class="number">2</span>,v=c(-<span class="number">.2</span>,<span class="number">.2</span>), lty=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908233029.jpeg">

</div>
<p>这个火山图显示的就是使用适度t检验比较两组的差异基因结果。Spiked-in基因用蓝色进行了标注。剩下的基因中，p值小于的用红色标注。</p>
<p>现在我们来看一下排列前10的基因中假阳性的数目，这个数目就降为了2，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table( top50=rank(limmares$p.value)&lt;= <span class="number">10</span>, spike)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table( top50=rank(limmares$p.value)&lt;= <span class="number">10</span>, spike)</div><div class="line">       spike</div><div class="line">top50   <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line">  <span class="literal">FALSE</span> <span class="number">12608</span>     <span class="number">8</span></div><div class="line">  <span class="literal">TRUE</span>      <span class="number">2</span>     <span class="number">8</span></div></pre></td></tr></table></figure>
<h2 id="练习-1">练习</h2>
<p>P315</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/18/DAL/DALS018_StatisticalModels1_binomal_Possion_MLE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/DAL/DALS018_StatisticalModels1_binomal_Possion_MLE/" itemprop="url">DALS018-统计模型1-二项分布与泊松分布，MLE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T12:00:00+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,870
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第7章统计模型的第1小节，这一部分的主要内容涉及高维数据统计的一些原理，例如二项分布，泊松分布，最大似然估计等。</p>
<p>相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/modeling/modeling.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>当我们在文献中看到p值的时候，它意味着使用某种概率分布来对零假设进行量化。很多时候我们很容易地就能找到使用哪种分布。例如，在女士品茶这个案例中，我们就能使用简单的概率计睡来确定零分布。文献中的大多数p值都是基于线性模型的样本均值或最小二乘估计来进行计算的，并利用CLT近似地救出它们的零分布。</p>
<p>CLT有着理论支持，它能保证这种近似是正确的。但是，我们无法一直使用这种近似法，例如当我们的样本太少时。以前面部分中，我们提到了，当总体数据近似服从正态分布时，样本的平均近似服从t分布。但是这种假设没有理论上的支持。在这一部分里，我们就会对这种情况进行建模。在研究身高时，我们从经验中就知道，这是一个非常好的模型。</p>
<p>但是，这并不意味着我们收集的每个数据集都服从正态分布。我们常见的一些例子，例如掷硬币，中彩票的人数，美国的收入。正态分布不是建模过程中的唯一参数分布。在这一部分里，我们会描述一些最广泛使用的参数分布以及它们在生命科学研究中的作用。我们还会介绍贝叶斯统计相关的知识，以及给出使用分层模型的使用案例。</p>
<h2 id="二项分布">二项分布</h2>
<p>在<span class="math inline">\(N\)</span>次实验中，成功<span class="math inline">\(S=k\)</span>次的概率，公式如下所示： <span class="math display">\[
\mbox{Pr}(S=k) = {N \choose k}p^k (1-p)^{N-k}
\]</span> 其中<span class="math inline">\(p\)</span>是成功的概率，二项分布的一个最有名案例就是掷硬币，当我们掷<span class="math inline">\(N\)</span>次硬币，有<span class="math inline">\(S\)</span>次是正面朝上的概率，在这个案例中，<span class="math inline">\(p=0.5\)</span>。</p>
<p><span class="math inline">\(S/N\)</span>是独立随机变量的均值，因此CLT告诉我们，当<span class="math inline">\(N\)</span>足够大时，<span class="math inline">\(S\)</span>近似地服从正态分布。这种分布在生命科学研究中应用很广，最近，此分布在NGS检测variant callers和表型(genotyper)应用很广，它的一个特殊分布则是泊松分布(poisson distribution)（二顶分布的极限是泊松分布）。</p>
<h2 id="泊松分布">泊松分布</h2>
<p>由于买彩票的结果只有两个，中彩票与不中彩票，因此，那些赢得彩票的人数从理论上服从二项分布（我们是假设每个人只能买一张彩票）的。试验次数<span class="math inline">\(N\)</span>是买彩票的人数，这个数字通常非常大。但是，赢得彩票的的人数通常是0到3之间，这就表明，赢得彩票的人数是不服从正态分布的。那么，为什么CLT在这种情况下不成立呢？从数学上可以对此进行解释，但是直觉又告诉我们，如果成功的总和是如此接近，并且大于1，这种分布就不可能是正态分布，这里我们进行一个快速的模拟：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p=<span class="number">10</span>^-<span class="number">7</span> <span class="comment">##1 in 10,000,0000 chances of winning</span></div><div class="line">N=<span class="number">5</span>*<span class="number">10</span>^<span class="number">6</span> <span class="comment">##5,000,000 tickets bought</span></div><div class="line">winners=rbinom(<span class="number">1000</span>,N,p) <span class="comment">##1000 is the number of different lotto draws</span></div><div class="line">tab=table(winners)</div><div class="line">plot(tab)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190905223653.jpeg">

</div>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; prop.table(tab)</div><div class="line">winners</div><div class="line">    <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span> </div><div class="line"><span class="number">0.617</span> <span class="number">0.294</span> <span class="number">0.080</span> <span class="number">0.009</span></div></pre></td></tr></table></figure>
<p>达种情况下，<span class="math inline">\(N\)</span>会非常大，<span class="math inline">\(p\)</span>会非常小，因此我们可以计算出<span class="math inline">\(N \times p\)</span>（此时我们之为<span class="math inline">\(\lambda\)</span>）的值，例如位于0到10之间，而<span class="math inline">\(S\)</span>此时就服从泊松分布，其简单的公式如下所示： <span class="math display">\[
\mbox{Pr}(S=k)=\frac{\lambda^k \exp{-\lambda}}{k!}
\]</span></p>
<p>RNA-seq分析中常常用到泊松分布。因为我们对数千个分子进行采样，并且多数基因仅仅代表了所有基因中一小部分，因此在RNA-seq分析中使用泊松分布比较合适。</p>
<p>我们知道了泊松分布后，它对我们有什么作用？其中一个方面就是这种分布可以为我们提供实际分析过程中关于统计属性的总结信息。例如我们只从患者组和对照组中各取一个样本进行RNA-seq实验并研究基因的倍数变化。此时，在零假设成立的前提下（也就是这两个样本没有差异），利用泊松分布，我们可以计算出，统计学上的统计变异取决于基因的总丰度。我们可以从数学上来展示一下这个过程，下面是模拟这个过程：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">N=<span class="number">10000</span><span class="comment">##number of genes</span></div><div class="line">lambdas=<span class="number">2</span>^seq(<span class="number">1</span>,<span class="number">16</span>,len=N) <span class="comment">##these are the true abundances of genes</span></div><div class="line">y=rpois(N,lambdas)<span class="comment">##note that the null hypothesis is true for all genes</span></div><div class="line">x=rpois(N,lambdas)</div><div class="line">ind=which(y&gt;<span class="number">0</span> &amp; x&gt;<span class="number">0</span>)<span class="comment">##make sure no 0s due to ratio and log</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">splot(log2(lambdas),log2(y/x),subset=ind)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906202636.jpeg">

</div>
<p>对于低较的<code>lambda</code>的值，存在着更多的变异，如果我们计算出了大于2倍或更高倍数的基因，那些对于低丰度的基因来说，假阳性率也会变大。</p>
<h3 id="ngs与poisson分布">NGS与Poisson分布</h3>
<p>在这一部分里，我们还是要使用公共数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BiocManager::install("parathyroidSE")</span></div><div class="line"><span class="keyword">library</span>(parathyroidSE) <span class="comment">##available from Bioconductor</span></div><div class="line">data(parathyroidGenesSE)</div><div class="line">se &lt;- parathyroidGenesSE</div></pre></td></tr></table></figure>
<p>上述的这个数据包含在<code>SummarizedExperiment</code>对象中，在此不再赘述，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; class(parathyroidGenesSE)</div><div class="line">[<span class="number">1</span>] <span class="string">"RangedSummarizedExperiment"</span></div><div class="line">attr(,<span class="string">"package"</span>)</div><div class="line">[<span class="number">1</span>] <span class="string">"SummarizedExperiment"</span></div></pre></td></tr></table></figure>
<p>我们只需要知道它包含一个数据矩阵，其中每一行都是基因组特征（可以理解为基因），每列都是一个样本。我们可以使用<code>assay()</code>函数提取这个矩阵。对于这个数据集，数据矩阵中每个单元格的数值对应了一个特定样本的一个特定基因的reads数。因此，我们可以绘制出前面类似的图形，从而表明利用实验数据构建的模型的预测行为，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x &lt;- assay(se)[,<span class="number">23</span>]</div><div class="line">y &lt;- assay(se)[,<span class="number">24</span>]</div><div class="line">ind=which(y&gt;<span class="number">0</span> &amp; x&gt;<span class="number">0</span>)<span class="comment">##make sure no 0s due to ratio and log</span></div><div class="line">splot((log2(x)+log2(y))/<span class="number">2</span>,log(x/y),subset=ind)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906203804.jpeg">

</div>
<p>如果我们计算出4个个体的标准差，它要比利用泊松模型预测的要高得多。假设大多数基因在不同的个体之间的表达不同，那么，如果泊松模型适用于此情况，那么此图中应该存在着线性关系：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(matrixStats)</div><div class="line">vars=rowVars(assay(se)[,c(<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">21</span>)]) <span class="comment">##we now these four are 4</span></div><div class="line">means=rowMeans(assay(se)[,c(<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">21</span>)]) <span class="comment">##different individulsa</span></div><div class="line">splot(means,vars,log=<span class="string">"xy"</span>,subset=which(means&gt;<span class="number">0</span>&amp;vars&gt;<span class="number">0</span>)) <span class="comment">##plot a subset of data</span></div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="number">2</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906204226.jpeg">

</div>
<p>上面图中的变异包括生物变异，但是泊松分布则无法对此进行建模。此时，我们需要另外一种分布，即负二项分布（negative binomial distribution)，这种分布整合了服从泊松分布的采样变异(sampling variability)和生物变异(biological variability)，它更适合对这种情况进行建模。负二项分布有两个参数，在处理计数数据(count data)方面有更大的灵活性。有关RNA-seq与负二项分布的内容可以参考这篇文献<a href="https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106" target="_blank" rel="external">《Differential expression analysis for sequence count data》</a>。而泊松分布只是负二项分布的一个特例。</p>
<h2 id="最大似然估计">最大似然估计</h2>
<p>为了说明最大似然估计(Maximum Likelihood Estimation, MLE)的概念，我们使用一个相对简单的数据集来进行演示，这个数据集包含HMCV（人巨细胞病毒，human cytomegalovirus）基因组的回文位置(palindrome location)信息。我们从HMCV基因组每4kb个间隔中读取回文序列的数目，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">datadir=<span class="string">"http://www.biostat.jhsph.edu/bstcourse/bio751/data"</span></div><div class="line">x=read.csv(file.path(datadir,<span class="string">"hcmv.csv"</span>))[,<span class="number">2</span>]</div><div class="line">breaks=seq(<span class="number">0</span>,<span class="number">4000</span>*round(max(x)/<span class="number">4000</span>),<span class="number">4000</span>)</div><div class="line">tmp=cut(x,breaks)</div><div class="line">counts=table(tmp)</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(counts)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906232857.jpeg">

</div>
<p>上图中的计数数据似乎服从泊松分布，但是，<span class="math inline">\(\lambda\)</span>是多少呢？常见的估计<span class="math inline">\(\lambda\)</span>的方法是最大似然估计(maximum likelihoood estimation)。最了找到最大的MLE，我们要注意这些数据是独立的，我们所观察到这些数据的概率可以用以下公式来表示： <span class="math display">\[
\Pr(X_1=k_1,\dots,X_n=k_n;\lambda) = \prod_{i=1}^n \lambda^{k_i} / k_i! \exp ( -\lambda)
\]</span> 当下面这个公式取最大值时候，MLE就等于<span class="math inline">\(\lambda\)</span>： <span class="math display">\[
\mbox{L}(\lambda; X_1=k_1,\dots,X_n=k_1)=\exp\left\{\sum_{i=1}^n \log \Pr(X_i=k_i;\lambda)\right\}
\]</span> 在实际计算过程中我们通常使用log转换后似然值(log-likehood)。下面我们使用一些代码来计算一下任意的<span class="math inline">\(\lambda\)</span>下的log-likehood，并且我们使用函数<code>optimized()</code>来计睡一下能够值得这个函数值最大的时候的<span class="math inline">\(\lambda\)</span>，最后我们绘制出log-likehood的曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">l&lt;-<span class="keyword">function</span>(lambda) sum(dpois(counts,lambda,log=<span class="literal">TRUE</span>))</div><div class="line">lambdas&lt;-seq(<span class="number">3</span>,<span class="number">7</span>,len=<span class="number">100</span>)</div><div class="line">ls &lt;- exp(sapply(lambdas,l))</div><div class="line">plot(lambdas,ls,type=<span class="string">"l"</span>)</div><div class="line">mle=optimize(l,c(<span class="number">0</span>,<span class="number">10</span>),maximum=<span class="literal">TRUE</span>)</div><div class="line">abline(v=mle$maximum)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907145959.jpeg">

</div>
<p>如果进行一些微积分计算，就会发现计算MLE其实非常简单，就是计算其均值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print( c(mle$maximum, mean(counts) ) )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print( c(mle$maximum, mean(counts) ) )</div><div class="line">[<span class="number">1</span>] <span class="number">5.157894</span> <span class="number">5.157895</span></div></pre></td></tr></table></figure>
<p>我们会注意到，观察到的计数数据与通过泊松分布预测的计算数据非常吻合：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">theoretical&lt;-qpois((seq(<span class="number">0</span>,<span class="number">99</span>)+<span class="number">0.5</span>)/<span class="number">100</span>,mean(counts))</div><div class="line">qqplot(theoretical,counts)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907155849.jpeg">

</div>
<p>因此，我们可以使用泊松分布来计算回文数据，其中<span class="math inline">\(\lambda = 5.16\)</span>。</p>
<h2 id="正连续值的分布">正连续值的分布</h2>
<p>不同的基因在生物学重复中的变化不同。在后面我们会介绍次聚类模型(hierarchical model)，这是在分析基因组学数学中最有影响力的统计学方法之一。该方法以能够极大地改善了分析差异基因的初级方法。它是通过模拟基因变异的分布来进行建模的。在这里我们会介绍这种方法的参数模型。</p>
<p>我们想模拟一下基因特异性标准误(gene-specific standard erros)。这些分布是正态分布吗？这里我们需要记住，我们现在模拟的是总体的标准误，因此CLT在此种情况下并不适用，即使我们我们拥有数几千个基因。</p>
<p>下面就是案例，在这个案例中，我们会使用一个实验数据，这个数据中包含了小鼠基因表达的技术重复和生物学重复，我们会计算出技术重复和生物学重复的基因特异性样本标准误：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(Biobase) <span class="comment">##available from Bioconductor</span></div><div class="line"><span class="comment"># install_github("genomicsclass/maPooling")</span></div><div class="line"><span class="keyword">library</span>(maPooling) <span class="comment">##available from course github repo</span></div><div class="line">data(maPooling)</div><div class="line">pd=pData(maPooling)</div><div class="line"><span class="comment">##determin which samples are bio reps and which are tech reps</span></div><div class="line">strain=factor(as.numeric(grepl(<span class="string">"b"</span>,rownames(pd))))</div><div class="line">pooled=which(rowSums(pd)==<span class="number">12</span> &amp; strain==<span class="number">1</span>)</div><div class="line">techreps=exprs(maPooling[,pooled])</div><div class="line">individuals=which(rowSums(pd)==<span class="number">1</span> &amp; strain==<span class="number">1</span>)</div><div class="line"><span class="comment">##remove replicates</span></div><div class="line">individuals=individuals[-grep(<span class="string">"tr"</span>,names(individuals))]</div><div class="line">bioreps=exprs(maPooling)[,individuals]</div><div class="line"><span class="comment">###now compute the gene specific standard deviations</span></div><div class="line"><span class="keyword">library</span>(matrixStats)</div><div class="line">techsds=rowSds(techreps)</div><div class="line">biosds=rowSds(bioreps)</div></pre></td></tr></table></figure>
<p>下面提研究样本的标准差(sample standard deviation)：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###now plot</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">shist(biosds,unit=<span class="number">0.1</span>,col=<span class="number">1</span>,xlim=c(<span class="number">0</span>,<span class="number">1.5</span>))</div><div class="line">shist(techsds,unit=<span class="number">0.1</span>,col=<span class="number">2</span>,add=<span class="literal">TRUE</span>)</div><div class="line">legend(<span class="string">"topright"</span>,c(<span class="string">"Biological"</span>,<span class="string">"Technical"</span>), col=c(<span class="number">1</span>,<span class="number">2</span>),lty=c(<span class="number">1</span>,<span class="number">1</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907172043.jpeg">

</div>
<p>从上面的图形中我们可以发现，生物学变异(biological variability)远远大于技术变异(technical variability)。这就为我们提供了一个证据，即基因确实具有基因特异性生物学变异。如果我们想要模拟这种变异，我们首先要注意到，这些变异不服从正态分布，因为上面的曲线明显出现了拖尾现象。此外，由于SD为正数，因此上面的分布也存在着一定的限制。现在我们使用qq图来看一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qqnorm(biosds)</div><div class="line">qqline(biosds)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907172353.jpeg">

</div>
<p>一些参数分布可以处理这些情况（例如严格正向右拖尾分布，strictly positive and heavy right tails）。其中比较典型的分布就是gamma分布与F分布，gamma分布的密度函数为： <span class="math display">\[
f(x;\alpha,\beta)=\frac{\beta^\alpha x^{\alpha-1}\exp{-\beta x}}{\Gamma(\alpha)}
\]</span> 这个分布有2个参数，分别是<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>，它们间接控制了曲线的位置(location)与缩放(scale)。它们也控制着曲线的形状，有关这些分布的知识可以参考<a href="https://www.stat.berkeley.edu/~rice/Book3ed/index.html" target="_blank" rel="external">《Mathematical Statistics and Data Analysis》</a>这本书。</p>
<p>gamma分布的两个特例是卡方分布与指数分布，我们前面了解到了可以使用卡方分布来计算二联表。对于卡方分布来说，我们的参数是<span class="math inline">\(\alpha=\nu/2\)</span>，<span class="math inline">\(\beta=2\)</span>，其中<span class="math inline">\(\nu\)</span>表示自由度。对于指数分布来说，<span class="math inline">\(\alpha=1\)</span>，<span class="math inline">\(\beta=\lambda\)</span>。</p>
<p>F分布在ANOVA中使用，它也是一个正向分布，并且存在着严格的右拖尾曲线，它的2个参数影响其曲线形状，，F分布的密度函数为： <span class="math display">\[
f(x,d_1,d_2)=\frac{1}{B\left( \frac{d_1}{2},\frac{d_2}{2}\right)}
  \left(\frac{d_1}{d_2}\right)^{\frac{d_1}{2}}  
  x^{\frac{d_1}{2}-1}\left(1+\frac{d1}{d2}x\right)^{-\frac{d_1+d_2}{2}}
\]</span> 这个函数中含有<span class="math inline">\(B\)</span>函数（即<span class="math inline">\(\beta\)</span>函数），还有2个自由度，即<span class="math inline">\(d_{1}\)</span>和<span class="math inline">\(d_{2}\)</span>。</p>
<h3 id="模拟变异">模拟变异</h3>
<p>在后面部分中，我们会介绍用于改善变异估计的层级模型(hierarchical model)。在这些案例中，从数学上很方便地能模拟出<span class="math inline">\(\sigma^2\)</span>的分布，关于层级模型的内容可以参考<a href="https://www.ncbi.nlm.nih.gov/pubmed/16646809" target="_blank" rel="external">《Linear models and empirical bayes methods for assessing differential expression in microarray experiments.》</a>这篇文献，此文献指出，对基因的标准差进行采样服从校正后的F统计： <span class="math display">\[
s^2 \sim s_0^2 F_{d,d_0}
\]</span> 其中<span class="math inline">\(d\)</span>表示了计算中<span class="math inline">\(s^2\)</span>的自由度。例如，当我们比较两组样本时，每组3个样本，那么自由度就是4（文中后面提到了<code>This leaves two free parameters to adjust to the data</code>，直译就是<code>剩下的2个自由参数用于调整数据</code>，不太理解）。这里的<span class="math inline">\(d\)</span>用于控制位置(location)，<span class="math inline">\(s_{0}\)</span>用于控制缩放(scale)。下面的代码是F分布的一些案例，我们绘制出了相应的图形，并且标注上了样本的方差：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">sds=seq(<span class="number">0</span>,<span class="number">2</span>,len=<span class="number">100</span>)</div><div class="line"><span class="keyword">for</span>(d <span class="keyword">in</span> c(<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>))&#123;</div><div class="line">  <span class="keyword">for</span>(s0 <span class="keyword">in</span> c(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>))&#123;</div><div class="line">    tmp=hist(biosds,main=paste(<span class="string">"s_0 ="</span>,s0,<span class="string">"d ="</span>,d),xlab=<span class="string">"sd"</span>,ylab=<span class="string">"density"</span>,freq = <span class="literal">FALSE</span>,nc=<span class="number">100</span>,xlim=c(<span class="number">0</span>,<span class="number">1</span>))</div><div class="line">    dd=df(sds^<span class="number">2</span>/s0^<span class="number">2</span>,<span class="number">11</span>,d)</div><div class="line">    <span class="comment">##multiply by normalizing constant to assure same range on plot</span></div><div class="line">    k=sum(tmp$density)/sum(dd)</div><div class="line">    lines(sds,dd*k,type=<span class="string">"l"</span>,col=<span class="number">2</span>,lwd=<span class="number">2</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907184007.jpeg">

</div>
<p>从上面的图形我们要找到哪个图形的<span class="math inline">\(s_{0}\)</span>与<span class="math inline">\(d\)</span>最能拟合我们的数据？这是一个比较麻烦的过程，因为MLE并不会计算这个特殊的分布（具体可以参考Wmyth(2004)）。Bioconductor上的<code>limma</code>包提供的估计这些参数的函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">estimates=fitFDist(biosds^<span class="number">2</span>,<span class="number">11</span>)</div><div class="line">theoretical&lt;- sqrt(qf((seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span>, <span class="number">11</span>, estimates$df2)*estimates$scale)</div><div class="line">observed &lt;- biosds</div></pre></td></tr></table></figure>
<p>拟合模型确实提供了一个合理的估计，从qq图和直方图就能看出来：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">qqplot(theoretical,observed)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">tmp=hist(biosds,main=paste(<span class="string">"s_0 ="</span>, signif(estimates[[<span class="number">1</span>]],<span class="number">2</span>), <span class="string">"d ="</span>, signif(estimates[[<span class="number">2</span>]],<span class="number">2</span>)), xlab=<span class="string">"sd"</span>, ylab=<span class="string">"density"</span>, freq=<span class="literal">FALSE</span>, nc=<span class="number">100</span>, xlim=c(<span class="number">0</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">9</span>))</div><div class="line">dd=df(sds^<span class="number">2</span>/estimates$scale,<span class="number">11</span>,estimates$df2)</div><div class="line">k=sum(tmp$density)/sum(dd) <span class="comment">##a normalizing constant to assure same area in plot</span></div><div class="line">lines(sds, dd*k, type=<span class="string">"l"</span>, col=<span class="number">2</span>, lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907184617.jpeg">

</div>
<h2 id="练习">练习</h2>
<p>P297</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">220</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">111</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共876.4k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
