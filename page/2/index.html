<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/2/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/2/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/04/BioStatistics/生物统计-StatQuest学习笔记21-逻辑回归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/04/BioStatistics/生物统计-StatQuest学习笔记21-逻辑回归/" itemprop="url">StatQuest学习笔记21——逻辑回归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-04T12:10:54+08:00">
                2018-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,317
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列视频教程的第56小节，主要内容是逻辑回归（Logistic Regression）。</p>
<h2 id="回顾线性回归">回顾线性回归</h2>
<p>在讲逻辑回归之前，我们先回顾一下线性回归。</p>
<p>例如我们有一批数据，研究的是体重与小鼠的大小之间的关系，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/3F35a64AGf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们可以找到一条回归曲线，来研究这两者之间的关系，通过这条曲线，我们可以得到以下信息：</p>
<ol style="list-style-type: decimal">
<li>计算出<span class="math inline">\({R}^2\)</span>，这个数值可以看出体重与大小之间的相关程度，数值越大，就越能表明这两者关系密切；</li>
<li>计算出p值，这个p值可以看出<span class="math inline">\({R}^2\)</span>是否有统计学上的意义；</li>
<li>计算出这个曲线的方程，利用体重来预测小鼠的大小。</li>
</ol>
<p>如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/3596fGlbGh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>例如，我们有一个新的小鼠体重，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/b2h0GH3aF6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>通过这个点向做一条垂直于x轴（也就是体重）的直线，然后找到这个直线与前面回归曲线的交点，再通过这个交点做一条平行于x轴的直线，与y轴交叉的地方就是小鼠的大小，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/i3Bm58EHj6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这种用某个数据预测另外一个数据的方法其实就是机器学习的范畴了，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/7mfkcjElD4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们再回顾一下多元线性回归，现在我们利用体重（weight），血量（blood volumne）来预测小鼠的大小（size），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/jiG6gF0d36.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>多元线性回归的计算与二元线性回归的计算一样，计算出<span class="math inline">\({R}^2\)</span>，再计算出<span class="math inline">\({R}^2\)</span>的p值，然后利用线性回归的方程通过体重和血量来预测小鼠的大小，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/6icm9CaBbC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此外，我们还提到了通过不同的检测指标，例如表型（genotype）来预测小鼠的大小，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/iBAd9d90mf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们比较一下二元线性回归与多元线性回归，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/70DElbJkg6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>通过比较这两种线性回归，我们知道，如果我们使用更多的变量（例如在多元线性回归中，我们添加了血量这个变量）来预测大小，结果会更加精确，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/2dALKihmFF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="逻辑回归简介">逻辑回归简介</h2>
<p>现在要学习另外一种回归，就是逻辑回归。逻辑回归与线性回归比较类似，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/Hed6b904d0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>逻辑回归预测的结果并不是具体的某个数据，而某个结果是<code>True</code>还是<code>False</code>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/J86m8Af94D.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>例如，在上面的案例中，有9只小鼠，最上面的5只小鼠是肥胖小鼠，下面的4只小鼠是非肥胖型小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/lh0C6GdiFf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们要找一条曲线来拟合这些数据，不过这条曲线与线性回归的直线不同，它是S型的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/J0F55JHEHg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中纵坐标的范围是0到1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/183IFgELG9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这就说明，我们最终计算的结果是一个概率，就是由小鼠的体重来预测这个小鼠是否是肥胖小鼠的概率，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/g0F7L243h7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果一个小鼠的体重很重，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/D3ADki9LD3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么，通过这个点做一条垂直于横坐标的直线，与逻辑回归的曲线相交，我们就可以发现，这个小鼠有很大的概率是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/Jhm9CEiA6e.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果一个小鼠的体重处于中间地带，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/3deL01Ac5e.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么这只小鼠可能只有50%的可能性是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/lD1Cg9I8J6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果一只小鼠的体重很小，那么它就不太可能是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/jegmFh0kAb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>虽然逻辑回归会告诉我们一只小鼠是否是肥胖小鼠，但是逻辑回归在多数情况下，是用于分类的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/k4ehK1H5dk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>同理，如果一只小鼠是肥胖小鼠的概率是50%，那么我们就会把它归于肥胖小鼠这一类，否则，我们会把这只小鼠归于非肥胖小鼠这一类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/93cI309Gkm.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="逻辑回归简单案例">逻辑回归简单案例</h2>
<p>现在我们来看一个逻辑回归的简单案例，在这个案例中，我们使用小鼠的体重来预测是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/2lk57K459i.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们还有可能会涉及一个更复杂的案例，例如通过体重和表型来预测小鼠是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/igD1fI9520.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>或者是更加复杂的案例，例如使用体重，表型，年龄来预测小鼠是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/Ib0Bd6d7k9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>或者说，还要复杂，例如通过体重，表型，年龄，星座（astrological sign？？）来预测小鼠是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/LKelL70kgf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>换句话说，逻辑回归与线性回归相同之处在于，逻辑回归也可以使用连续型变量（例如体重与年龄），，与离散型变量（例如表型与星座）来进行计算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/iaiidg06BC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们还检测一下每个变量是否能够用于预测小鼠是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/d1bF3IJmkD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但是，逻辑回归与线性回归不同，我们不太容易比较复杂回归与简单回归，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/2mJC2IJ6Fd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>相反，我们不会直接比较复杂回归与简单回归，而是通过Wald方法检验一下，一个变量是否能够对预测结果产生明显的影响（与0相比），如果这个变量对预测结果没有什么影响，那么此变量就无法为预测提供相应的信息，这种如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/lf6C8cCeg1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们检验了这些变量的话，那么我们就发现，星座这个变量对预测小鼠是否肥胖没什么帮助，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/1I0e1151l0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这就说明，我们在计算逻辑回归的方程时，就可以不使用星座这个变量，从而节省时间与空间，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/DCc12d8C2a.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>逻辑回归使用连续型变量和离散型变来来计算概率，它能对一个新的样本进行分类，这是一种常用的机器学习方法，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/G111GfaHbI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>线性回归与逻辑回归的一个最大的区别在于，如何找到一条拟合这些数据的曲线，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/J0JdCD4Hji.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在线性回归中，我们通常使用最小二乘法来寻找拟合这些数据的曲线，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/F79DmfaFCL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>换句话说，我们找到的这条曲线，每个点到这条曲线的距离平方和（残差）最小，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/49fKk9lljB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们还要利用残差来计算<span class="math inline">\({R}^2\)</span>，用于比较简单线性回归与复杂线性回归，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/Jd9A8LEl9e.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>逻辑回归没有线性回归中“残差”的概念，因此，我们无法使用最小二乘法来计算曲线，也无法计算<span class="math inline">\({R}^2\)</span>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/FdC3cAFKEG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算逻辑回归曲线方程的方法是“最大似然法”，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/lgJHb1bJFG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最大似然法以前讲过，在这里，只是用一种比较简单粗糙，不严谨的语言来描述一下。</p>
<p>首先，把小鼠的体重经过缩放（scaled），先拟合出一条曲线，此时，这条曲线只是初步的一条曲线，不是最终的曲线。找到第1只小鼠（这只小鼠是非肥胖小鼠）的体重在这条曲线上对应的概率，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/m9I5c99F5b.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，计算一下这个非肥胖小鼠（也就是第1只小鼠）与这条曲线上小鼠对应的概率的相符的似然性（likelihood），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/mhDHmHFkEk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后，再找到第2只小鼠在这条曲线上对应的概率，以及计算第2只小鼠与这个概率的似然性，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/mKI7ccejl5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>所有的小鼠都这么计算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/246jD2k4Kd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终，把这些小鼠的所有似然性都相乘，就是这条曲线与这些数据的似然性，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/DE0f1BJ947.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们已经计算了第1条曲线了的似然性了，此时，还转换一下曲线，计算这条新的曲线的似然性，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/A3j9k5fC1g.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>还有第3条曲线，也是如此计算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/9echI5hgI0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终，我们会通过极大似然法找到最适合的这条曲线，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/84LgAbEGE2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在总结一下，逻辑回归是用于对样本分类的算法，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/km2D3ehDdd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>它可以使用不同的数据类型（例如大小和表型）来对数据进行分类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/2cC7ED6Ijg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这种方法还可以用评估哪些变量可以用于分类（例如星座就无法用于分类），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180706/jgilBmLDD5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="总结">总结</h2>
<p>上面只是一种非常精浅的逻辑回归的描述，并没有涉及到如何计算，如果看结果。如果真正要运用的话，还需要看其他的统计学书籍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/02/BioStatistics/生物统计-StatQuest学习笔记20-随机森林/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/BioStatistics/生物统计-StatQuest学习笔记20-随机森林/" itemprop="url">StatQuest学习笔记20——随机森林</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T12:10:54+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,004
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  39
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列视频的第53-55节，其中第53节讲的是随机森林，第54节讲的是缺失值的处理，第55节讲的是R与随机森林。</p>
<h2 id="决策树的局限">决策树的局限</h2>
<p>随机森林（Random Forests）来源于决策树，因此如果不了解决策树的话，可以看上一篇笔记，决策树如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/mBad6JaBa5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>决策树很容易构建，也很好用，也很好题解。但事实上，决策树并非完美无缺，引用《The Elements of Statistical Learning》（又名《The Bible of Machine Learning》），中文译名为《统计学习基础：数据挖掘、推理与预测》的话讲，决策树的不精确准确（inaccuracy）决定了它无法作为一个理想的预测学习工具，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/aBbJ4gcaEb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>换句话说，就是决策树的构建要利用大量的数据，但是当用这个构建好的决策树来对一批新的数据进行分类时，决策树并不能灵活地处理这些新数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/399HEbI6F6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="随机森林的优势">随机森林的优势</h2>
<p>随机森林综合了决策树简洁的特征，同时又具备灵活性，因此随机森林在精确性方面也得到了极大的提高，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/JJ2khjJll2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="构建随机森林">构建随机森林</h2>
<p>接着，我们来看一下随机森林的构建过程。</p>
<h3 id="第一步构建自举数据集">第一步：构建自举数据集</h3>
<p>构建随机森林的第一步就是从原始数据中随机挑选数据，构建“自举”数据集（自举：bootstrap），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/jG9AG0BC4b.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>下面是原始的数据集，这个数据集还是我们上篇笔记中的那个数据集，里面有4个变量，分别为<code>胸痛（Chest Pain）</code>，<code>良好血液循环（Good Blood Circ.）</code>，<code>动脉阻塞（Blocked Arteries）</code>，<code>体重（Weight），</code>虽然这个数据集非常小，但是不影响使用，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/a0D7AKiLGB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了构建一个与原始数据集同样大小的自举数据集（bootstrapped dataset），我们仅需要随机地从原始数据中挑选样本即可，这个随机挑选的过程是有放回地挑选（这就是bootstrap），也就是我从原始数据集中随机挑一个样本，然后放回去，再随机挑一个样本，这样的话，相同有样本有可能被挑中好几次，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/gd0d48B7IK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们先随机挑一个样本，这次挑中了第2个样本，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/IiallkjcK3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>把这个样本放到我们的自举数据集中，就成了自举数据集中的第1个样本，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/kFA79deJHh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再随机挑一个样本，这次挑中了原始数据集中的第1个样本，把它放到我们的自举数据集中，就是自举数据集中的第2个样本，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/3lG9c93H6a.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再从原始数据中随机挑一个，放到自举数据集中，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/BaJJB4aHI0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再随机挑一个，放到自举数据集中，这里需要注意的是，我们挑了两次原始数据集中第4个样本，这样在自举数据集中就有了2个重复的样本，这个没关系，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/JhkHIAJ2kl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们就构建好了一个自举数据集，这个自举数据集的大小与原始数据集的大小相同，也就是说有同样数目的样本，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/IgKh9d4kaj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="第二步构建树">第二步：构建树</h3>
<p>构建随机森林的第二步就是利用我们构建的自举数据集来构建一个决策树，并且一次只能使用一个变量（或列）的随机亚集（subset）进行构建，在这个案例中，我们每一步只会使用2个变量（列），至于为什么使用2个变量，后文会讲解，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/1iiCkJ45DJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，我们不会使用所有的4个变量来区分根节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/fFfhebJ9Hi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而是随机选择2个变量来区分根节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/8Akl9FJ5If.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个案例中，我们随机使用<code>良好血液循环（Good Blood Circulation）</code>和<code>动脉阻塞（Blocked Arteries）</code>这两个变量来区分根节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/L43Lk17DbK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>就像我们这个案例的目的一样，我们假设良好血液循环（Good Blood Circulation）能够很好地区分样本，我们就用它作为根节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/j3hF705DFm.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于我们使用过了良好血液循环（Good Blood Circulation）这个变量，因此这里把它变灰，以便于我们研究剩余的变量，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/9DAJCCIJEf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们看一下中间节点如何区分，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/40b38C6DDE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>与根节点一样，我们并不使用剩余的所有3个变量，而是随机选择2个变量用于区分，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/l38bICB5j0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，我们就像以前构建决策树那样，构建树，不过我们一次只使用一个变量的随机亚集，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/ACeJjHaH6B.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终的结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/EAhmf9agb8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在回顾一下我们构建这个树的过程：第一步，构建自举数据集；第二步，每一步随机选择一个变量亚集来构建节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/CA69CE988h.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="第三步循环第1到到第2步">第三步：循环第1到到第2步</h3>
<p>此时，我们就构建好了一个树，现在我们再回到第一步，重复操作，再生成一个自举数据集，还是一次使用变量的一个随机亚集来构建一个树（就是下图中第2个树），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/66l2Kj7dh9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>不断地重复这个过程，重复100次，这样我们会构建一系列的树，下图只是显示了其中的6种树，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/IHedjl9E9K.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>通过利用一个自举样本，一次只利用变量的一个随机亚集，就会产生大量不同的树，这些树就构成了随机森林（一次生成一棵树，多次运算，就是多棵树，也就是森林了），它远比单一的决策树有效，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/EjeDJhckA5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="随机森林的使用">随机森林的使用</h2>
<p>此时，我们已经学会了构建随机森林的基本思想，那么随机森林有什么用处呢，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/cj12hDdH5F.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们看一个案例，例如，我们遇到了一个新病人，他的各种参数如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/IDAlJAEk4c.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们想知道，他是否得有心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/5IbLbe2mGJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么，我们把他的数据放到我们生成随机森林中，先放到第1棵树上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/HAcL2D9g5C.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>运算结果显示Yes，此时记录一下这个数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/AC8eKH91CC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在把这个人的参数放到随机森林中的第2棵树上运行，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/7jgbCHH1K8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算结果是Yes，此时记录下这个数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/j3F52kG0if.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们把这个人的数据再放到随机森林中的其他的树中运算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/bfK5gB2Eh8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>总之，就是不断地放到不同的树上运算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/lfd04ekm5i.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>当运算结果后，我们记录下所有树的运算结果，我们会看到Yes或No哪个得票最多，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/mjlCF2BH90.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个案例中，明显Yes得票最多，因此我们就能下结论，这个人得了心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/cBH6L6Fikf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="随机森林相关术语">随机森林相关术语</h2>
<p>自举数据并对它们进行汇总做出的决策称为袋装法（Bagging），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/F83ELb4824.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="随机森林的评估">随机森林的评估</h2>
<p>我们已经了解了随机森林构建的基本思想，也知道了如何使用它，此时可能还有一个问题，这个模型的好坏程度到底如何，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/h0fld9alC4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们回到前面构建自举数据集的内容，我们在前文中说过，在一个自举数据集中，我们允许两条相同的记录（entry，记录可以理解为一个样本，也就是一行数据）存在，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/30edf2ddE9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终在自举数据集中，没有包含原始数据集中的第3条目录，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/HAlEAjdJ54.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>通常来说，大概会有三分之一的原始数据集中的记录不会包含在自举数据集中，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/mJLlAJ7HGL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>下图的右侧就是那条未包含在自举数据集中的记录，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/d045DbHhC8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果原始数据集非常大的话，那么就有不止一条记录不包含在自举数据集中，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/7jfEA5h0GK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这些不包含在自举数据集上的记录被称为“出袋数据集”（out-of-bag dataset，未找到相应的中文译名，此处暂译为“出袋数据集”），这样命名主要是因为，如果把自举数据集看成一个袋子，这些数据并不在这个袋子中，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/eafKbahH1G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于这些出袋数据集并没有用于构建这些树，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/LchFLH7BaI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，我们可以把这个数据集当作是一个新的样本，把它放到随机森林中计算，看能不能得到想要的结果（没得心脏病），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/lCAJ9Dm96J.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个案例中，这个样本最终的计算结果是No，也就是没得心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/HhK9g8H6FF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后我们把这些出袋数据集放到其他树中计算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/6h2cgbd30g.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>有一个树计算的结果是Yes，这个明显是错误的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/j8CB5mKkkE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其他的树计算结果是No，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/j6k2Ijkm5l.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>对所有树的计算结果进行统计，我们发现，No的得票最多，那么我们就能下结论，这个样本的结果是没得心脏病，与样本本身的结果一致，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/bA2K84A965.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们对其他的出袋数据集继续进行计算（出袋数据据不止一个样本，有很多），这个样本的结果是Yes，与样本本身的结果一致，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/BkIg73GJ7f.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再计算另外的样本，样本本身的结果是No，但计算出来的结果却是Yes，并不一致，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/5CBIgcck91.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过不断地计算，我们会得到很多计算结果，最终我们再计算一下，随机森林计算的样本结果与样本本身的结果一致的比例，我们就能得到随机森林的精确程度，其中随机森林计算的结果与样本本身的结果不一致的比例，我们称为出袋错误（Out-Of-Bag Error）（未找到相应的中文译名，此处暂译为“出袋错误”），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/3L14cCDm9d.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>至此，我们了解了这些内容：第一，构建随机森林；第二，使用随机森林；第三，评估随机森林的精确性。</p>
<p>既然我们知道了如何评估随机森林的精确性，那么此时我们再回到第一部分，了解一下随机森林是的构建原理，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/l2i2aJCg3H.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在构建随机森林时，我们最初在每一步中，使用的是随机选择的2个变量，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/jFbKaikKgH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们就要比较一下，使用随机选择的2个变量与3个变量导致的出袋错误的差异，我们测试一些不同的参数，来研究一下如何选择一个最为精确的随机森林，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/aajGd6Hmcc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>换句话讲，我们做上述事件的顺序是：</p>
<p>第一，构建随机森林；</p>
<p>第二，评估随机森林的精确性。</p>
<p>接着，改变每一个步骤中的变量数目，不断地重复这个过程，得到一个最精确的随机森林，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/m2HFH79kAL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>通常来说，我们最初使用的变量数目为总变量数目的平方根，例如在前面的案例中，总变量数目是4，它的平方根是2，那么我们一开始就先使用2个变量作为每次运算时变量的数目，然后在这个数目上下进行调整，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/k43H1igE3g.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在构建随机森林的过程中我们可能会遇到缺失值，缺失值有两种，我们先看第一种缺失值的处理。</p>
<h2 id="第一种缺失值的处理">第一种缺失值的处理</h2>
<p>我们看一下我们的原始数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/b13k7bJK39.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>原始数据一共是4个患者，其中第4名患者有2个数据缺失，用问号表示，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/6A2f4J1ifF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>随机森林中有2类缺失值，分别为：第一，用于构建随机森林的原始数据集中的数据缺失，就是上面的情况；第二，用于归类的，一个新的样本中的数据缺失情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/eFKamIHeIC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们先讲第一种数据的缺失情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/k2ib7kfLHK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们要从上面的原始数据集中构建随机森林，但是不清楚第4个患者的动脉阻塞与体重数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/4Ldc08lH38.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>处理这种缺失数据的常规方式是观察其他数据，先做出一个可能不太好的初始猜测，然后逐步改进这个猜测，直到这个猜测变得比较好为止（希望如此），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/m431fEGJF9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们就做这样的猜测，我们先看血管阻塞这个变量，然后找到这个变量出现最多的数据就可做出猜测，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/dJ8KCIGJ2H.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们发现，在这个变量中，<code>No</code>出现的频率最高（2个No，1个Yes），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/bFib95k0h7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，我们就可以猜测，在这个变量中，第4个患者的值可能是<code>No</code>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/EE1ajeIBCf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>猜测完血管阻塞这个变量中的缺失值后，我们再猜测一下体重这个变量在第4个患者中的缺失值，体重是一种连续型变量（数值），因此我们可以看一下这个变量中其他数值的中位数即可（在决策树中，这种缺失值的处理，要么使用中位数，要么使用中位数），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/F5C7iakkK8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在其他的患者中，体重这个变量的中位数是180，因此我们就可以把第4个患者的体重缺失值写为180，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/iF21Da5GaI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过这样的处理，原始数据中缺失的数据就填充好了，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/dL0cfK4fcH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>填充好缺失值后，我们还要评估这些数据猜测得到底合理不合理，现在就需要看一下哪些样本与含有缺失值的样本比较类似，接着我们就会讲一下这种相似性如何计算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/eJg68a3bmK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第一步：构建随机森林，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/5hFJ8K7lf3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二步：将所有的原始数据放到随机森林中运行，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/glaHhiGDkj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们先在随机森林中的第1棵树上运行，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/lC8f1E9dgF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>把所有患者的数据依次放进去，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/c2Gec9Bheb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这4个患者的数据经过计算后，我们会发现，患者3和患者4最终位于同一片叶子节点上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/CfEA2cgd7E.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这就说明，第3个患者与第4个患者相似，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/Agc9dbHh1f.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="相似性矩阵">相似性矩阵</h3>
<p>现在我们用一个相似性矩阵（Proximity Matrix）来研究相似的患者数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/g2BH8dlbCH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>相似性矩阵的每行代表一个样本，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/91BKAAcC93.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>相似性矩阵的每列也代表一个样本，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/ICm1aeFjJg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因为第3个样本与第4个样本最终位于同一个叶子节点上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/91llLEk24J.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们把患者3和患者4交叉的地方填上1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/f9Jk995iah.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此外，还有一个交叉点，也填上1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/J3DigH4J3a.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于在随机森林中第1棵树上运行后，除了第3个患者和第4个患者的最终结果相同外，并没有其他的患者结果相同，因此我们在第1棵树上运行后，得到的相似性矩阵就如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/7Cad24GKhC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们把所有的数据放到随机森林的第2棵树上运行，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/dEDHEb2c7B.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>运行过程如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/Ja5kbgCIi6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终我们发现，患者2，患者3和患者4位于同一个叶子节点上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/H5150HibAG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们再看一下，经过第1棵树运行后的相似性矩阵如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/0kH8AjFfmL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过第2棵树的运算，我们把有相同结果的患者交叉处填上1，如果原来的交叉位置有1，就加1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/b6jge077l6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从中我们可以看到，患者3和患者4还是位于同一个叶子节点上，因此就在原有的基础上再加1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/GcALEgBhK5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>患者2和患者3位于同一个节点，患者2和患者4位于同一个节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/0i21DEFdHb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们把所有的数据放到第3棵树上运行，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/g9kiE841bK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>得到结果后，我们再更新一下相似性矩阵，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/ABkK8JgeA9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中我们发现，患者3和患者4还是位于同一个节点上，再加1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/jje9l39Amf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终，我们运行完所有的树，得到一个最终的相似性矩阵，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/mlamgg0bAC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后，我们把这个相似性矩阵中的所有值除以所有树的数目，在这个案例中，所有的树的数目是10，得到结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/1c0ddjG0ck.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们使用这个近似矩阵来评估一下我们对缺失值猜测的效果如何，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/IAC4iHJIal.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>对于动脉阻塞这个变量来说，我们使用这个近似值来计算Yes与No的加权频率，对于体重缺失值的处理，也是如此，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/Ih05Ci79Ic.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中动脉阻塞这个变量中，除了缺失值外，在剩下的数据中，Yes的频率是1/3，No的频率是2/3，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/BJCKF81hd4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么对Yes的加权频率计算如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/HELc0h4m8G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>患者2中Yes对应的近似值为0.1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/G1A0Jgg710.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后除以患者4中所有近似值的和，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/HKafiJhL0B.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>Yes的权重是0.1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/2H5J8LCA5l.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么Yes的加权频率就是0.03，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/h532e5I9cl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再来计算No的权加频率，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/kg7GedBBbI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>它的公式为：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/5i3biLFB6F.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>No的权重是0.9，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/b1C73GbL5C.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终计算结果是0.6，我们发现，No的加权频率更高，也就是说，我们可以在这个缺失值处填上No，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/C6F4Akd82D.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>对于体重缺失值的处理，我们也是采用近似值来计算它的加权平均数，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/Bl1m5fbmhD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>加权平均数的的公式如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/a78i4leKfh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第一个样本的加权平均体重是0.1，用125乘以它即可，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/2jgc5JAC99.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着计算患者2的权加平均数，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/j0fg7AL1bE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终计算出加权平均数，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/bFmJHj184L.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，把这个结果（也就是198.5）填到缺失值处，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/EHcmDid9hi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们再重新审视一下我们的猜测，重新再运行一次数据，然后构建一个随机森林，在所有的树中计算数据，重新计算近似值，再次计算缺失值，这个过程要重复6或7次，直接覆盖所有的缺失值（直到我们再次计算时，这个数据不再变化为止），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/8ijccID0HK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="相似矩阵的拓展">相似矩阵的拓展</h2>
<p>这里我们先看一下相似矩阵的一些很有意思的东西，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/LdkHke2A27.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们再看一下在除以10（随机森林的所有树的数目）之间前的相似矩阵，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/935gjBi5IE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果样本3和样本4最终都落在了所有的10个树的同一个叶子节点上，那么上述的数字8就是10，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/ggjhlEhEah.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们再除以10（所有树的数目），我们就看到在这个相似矩阵中最大的数值就是1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/C6le8gbL7G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个近似矩阵中，1意味着这两个样本是尽可能接近的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/j7Dam86KFc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们用1减去这些近似值，就得到了某个距离，那么样本3和样本4的近似值是1，1减去1，就是0，也就是说这两个样本之间没有距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/7jGKbkL8da.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>样本1和样本4之间的的估计值是0.1，用1减去这个数值，得到0.9，那么这就表示，这两个样本的距离很大，也就表示它们之间离得远，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/mD88Ffh3fG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们把1减去这个近似值矩阵得到的新矩阵称为距离矩阵（distance matrix），画出热图就是下面的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/E5jabjgImc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们也可以绘制出MDS图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/HiDe2gJ4km.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们对相似矩阵的这些拓展计算很有意思，因为，无论你的数据是什么形式（有序数据，多个选择，连续型数据），如果我们使用这些数据构建一个树，我们就能画出热图或者是MDS图，用于研究不同样本的之间的相似性，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/lFgcABg8EA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="第二种缺失值的处理">第二种缺失值的处理</h2>
<p>此时，再回到缺失值的处理上来，前面我们只是介绍了一种缺失值的处理，也就是用于构建随机森林的原始数据中的缺失值处理，现在我们介绍一下另外一种缺失值的处理，也就是我们想用于分类的新的样本中的缺失值处理，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180704/CG5c3JHA0d.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>试想，我们已经通过现有的数据构建了一个随机森林，此时我们要将下面的的这个患者进行分类，不过他的一个动脉阻塞参数是缺失的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/A3hm7F0gJE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但我们还是想要知道这个患者是否患有心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/BH077KlKFC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但我们不知道动脉阻塞这个参数，因此我们需要对这个参数进行一个猜测，其过程就是把这个患者的其他参数放到随机森林中运行，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/GgI70eafGf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第一步：我们先猜测这个患者得了心脏病与不得心脏病这两种情况，做出两份数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/B8675gLLf5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后我们使用先前提到的迭代方法来对这动脉阻塞这个参数进行猜测，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/GeH0D3m51C.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>猜测结果一个是Yes，一个是No，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/FbbKkB1B39.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后把这两个数据放到随机森林中运算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/j1I8LHkmcf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后我们观察这两个数据在随机森林中的运行结果，看一下哪个结果数目最多，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/b2CdLFgDE3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在第一个数据中，所有的3个树都标记了其为Yes，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/LBBK7efkiJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在第二个数据中，只有一个树正确地标记了No，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/gHc8km75i9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此第一个数据是正确的数据，因为所有的树中它被正确计算的次数最多，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/EChDAEba53.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="r语言与随机森林">R语言与随机森林</h2>
<h3 id="加载包">加载包</h3>
<p>在使用R语言构建随机森林的时候，需要使用如下三个包：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(ggplot2)</div><div class="line"><span class="keyword">library</span>(cowplot)</div><div class="line"><span class="keyword">library</span>(randomForest)</div></pre></td></tr></table></figure>
<h3 id="数据集的处理">数据集的处理</h3>
<p>原始数据使用UCI机器学习的数据，这里的数据很多，我们只用其中的心脏病方面的一个数据集，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/Ee1H7e343c.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">url &lt;- <span class="string">"http://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data"</span></div><div class="line">data &lt;- read.csv(url, header=<span class="literal">FALSE</span>)</div><div class="line">head(data)</div></pre></td></tr></table></figure>
<p>数据如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(data)</div><div class="line">  V1 V2 V3  V4  V5 V6 V7  V8 V9 V10 V11 V12 V13 V14</div><div class="line"><span class="number">1</span> <span class="number">63</span>  <span class="number">1</span>  <span class="number">1</span> <span class="number">145</span> <span class="number">233</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">150</span>  <span class="number">0</span> <span class="number">2.3</span>   <span class="number">3</span> <span class="number">0.0</span> <span class="number">6.0</span>   <span class="number">0</span></div><div class="line"><span class="number">2</span> <span class="number">67</span>  <span class="number">1</span>  <span class="number">4</span> <span class="number">160</span> <span class="number">286</span>  <span class="number">0</span>  <span class="number">2</span> <span class="number">108</span>  <span class="number">1</span> <span class="number">1.5</span>   <span class="number">2</span> <span class="number">3.0</span> <span class="number">3.0</span>   <span class="number">2</span></div><div class="line"><span class="number">3</span> <span class="number">67</span>  <span class="number">1</span>  <span class="number">4</span> <span class="number">120</span> <span class="number">229</span>  <span class="number">0</span>  <span class="number">2</span> <span class="number">129</span>  <span class="number">1</span> <span class="number">2.6</span>   <span class="number">2</span> <span class="number">2.0</span> <span class="number">7.0</span>   <span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="number">37</span>  <span class="number">1</span>  <span class="number">3</span> <span class="number">130</span> <span class="number">250</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">187</span>  <span class="number">0</span> <span class="number">3.5</span>   <span class="number">3</span> <span class="number">0.0</span> <span class="number">3.0</span>   <span class="number">0</span></div><div class="line"><span class="number">5</span> <span class="number">41</span>  <span class="number">0</span>  <span class="number">2</span> <span class="number">130</span> <span class="number">204</span>  <span class="number">0</span>  <span class="number">2</span> <span class="number">172</span>  <span class="number">0</span> <span class="number">1.4</span>   <span class="number">1</span> <span class="number">0.0</span> <span class="number">3.0</span>   <span class="number">0</span></div><div class="line"><span class="number">6</span> <span class="number">56</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">120</span> <span class="number">236</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">178</span>  <span class="number">0</span> <span class="number">0.8</span>   <span class="number">1</span> <span class="number">0.0</span> <span class="number">3.0</span>   <span class="number">0</span></div></pre></td></tr></table></figure>
<p>从数据中我们可以发现，第一行对于每个变量的命名并不是特别的规范，因此，根据网站提供的信息，我们把这些变量名改一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">colnames(data) &lt;- c(</div><div class="line">  <span class="string">"age"</span>,</div><div class="line">  <span class="string">"sex"</span>,</div><div class="line">  <span class="string">"cp"</span>,</div><div class="line">  <span class="string">"trestbps"</span>,</div><div class="line">  <span class="string">"chol"</span>,</div><div class="line">  <span class="string">"fbs"</span>,</div><div class="line">  <span class="string">"restecg"</span>,</div><div class="line">  <span class="string">"thalach"</span>,</div><div class="line">  <span class="string">"exang"</span>,</div><div class="line">  <span class="string">"oldpeak"</span>,</div><div class="line">  <span class="string">"slope"</span>,</div><div class="line">  <span class="string">"ca"</span>,</div><div class="line">  <span class="string">"thal"</span>,</div><div class="line">  <span class="string">"hd"</span></div><div class="line">)</div><div class="line">head(data)</div></pre></td></tr></table></figure>
<p>更改后的结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(data)</div><div class="line">  age sex cp trestbps chol fbs restecg thalach exang oldpeak slope  ca thal hd</div><div class="line"><span class="number">1</span>  <span class="number">63</span>   <span class="number">1</span>  <span class="number">1</span>      <span class="number">145</span>  <span class="number">233</span>   <span class="number">1</span>       <span class="number">2</span>     <span class="number">150</span>     <span class="number">0</span>     <span class="number">2.3</span>     <span class="number">3</span> <span class="number">0.0</span>  <span class="number">6.0</span>  <span class="number">0</span></div><div class="line"><span class="number">2</span>  <span class="number">67</span>   <span class="number">1</span>  <span class="number">4</span>      <span class="number">160</span>  <span class="number">286</span>   <span class="number">0</span>       <span class="number">2</span>     <span class="number">108</span>     <span class="number">1</span>     <span class="number">1.5</span>     <span class="number">2</span> <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">2</span></div><div class="line"><span class="number">3</span>  <span class="number">67</span>   <span class="number">1</span>  <span class="number">4</span>      <span class="number">120</span>  <span class="number">229</span>   <span class="number">0</span>       <span class="number">2</span>     <span class="number">129</span>     <span class="number">1</span>     <span class="number">2.6</span>     <span class="number">2</span> <span class="number">2.0</span>  <span class="number">7.0</span>  <span class="number">1</span></div><div class="line"><span class="number">4</span>  <span class="number">37</span>   <span class="number">1</span>  <span class="number">3</span>      <span class="number">130</span>  <span class="number">250</span>   <span class="number">0</span>       <span class="number">0</span>     <span class="number">187</span>     <span class="number">0</span>     <span class="number">3.5</span>     <span class="number">3</span> <span class="number">0.0</span>  <span class="number">3.0</span>  <span class="number">0</span></div><div class="line"><span class="number">5</span>  <span class="number">41</span>   <span class="number">0</span>  <span class="number">2</span>      <span class="number">130</span>  <span class="number">204</span>   <span class="number">0</span>       <span class="number">2</span>     <span class="number">172</span>     <span class="number">0</span>     <span class="number">1.4</span>     <span class="number">1</span> <span class="number">0.0</span>  <span class="number">3.0</span>  <span class="number">0</span></div><div class="line"><span class="number">6</span>  <span class="number">56</span>   <span class="number">1</span>  <span class="number">2</span>      <span class="number">120</span>  <span class="number">236</span>   <span class="number">0</span>       <span class="number">0</span>     <span class="number">178</span>     <span class="number">0</span>     <span class="number">0.8</span>     <span class="number">1</span> <span class="number">0.0</span>  <span class="number">3.0</span>  <span class="number">0</span></div></pre></td></tr></table></figure>
<p>查看一下数据结构，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; str(data)</div><div class="line"><span class="string">'data.frame'</span>:	<span class="number">303</span> obs. of  <span class="number">14</span> variables:</div><div class="line"> $ age     : num  <span class="number">63</span> <span class="number">67</span> <span class="number">67</span> <span class="number">37</span> <span class="number">41</span> <span class="number">56</span> <span class="number">62</span> <span class="number">57</span> <span class="number">63</span> <span class="number">53</span> <span class="keyword">...</span></div><div class="line"> $ sex     : num  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ cp      : num  <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="keyword">...</span></div><div class="line"> $ trestbps: num  <span class="number">145</span> <span class="number">160</span> <span class="number">120</span> <span class="number">130</span> <span class="number">130</span> <span class="number">120</span> <span class="number">140</span> <span class="number">120</span> <span class="number">130</span> <span class="number">140</span> <span class="keyword">...</span></div><div class="line"> $ chol    : num  <span class="number">233</span> <span class="number">286</span> <span class="number">229</span> <span class="number">250</span> <span class="number">204</span> <span class="number">236</span> <span class="number">268</span> <span class="number">354</span> <span class="number">254</span> <span class="number">203</span> <span class="keyword">...</span></div><div class="line"> $ fbs     : num  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ restecg : num  <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ thalach : num  <span class="number">150</span> <span class="number">108</span> <span class="number">129</span> <span class="number">187</span> <span class="number">172</span> <span class="number">178</span> <span class="number">160</span> <span class="number">163</span> <span class="number">147</span> <span class="number">155</span> <span class="keyword">...</span></div><div class="line"> $ exang   : num  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ oldpeak : num  <span class="number">2.3</span> <span class="number">1.5</span> <span class="number">2.6</span> <span class="number">3.5</span> <span class="number">1.4</span> <span class="number">0.8</span> <span class="number">3.6</span> <span class="number">0.6</span> <span class="number">1.4</span> <span class="number">3.1</span> <span class="keyword">...</span></div><div class="line"> $ slope   : num  <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="keyword">...</span></div><div class="line"> $ ca      : Factor w/ <span class="number">5</span> levels <span class="string">"?"</span>,<span class="string">"0.0"</span>,<span class="string">"1.0"</span>,..: <span class="number">2</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ thal    : Factor w/ <span class="number">4</span> levels <span class="string">"?"</span>,<span class="string">"3.0"</span>,<span class="string">"6.0"</span>,..: <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="keyword">...</span></div><div class="line"> $ hd      : int  <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="keyword">...</span></div></pre></td></tr></table></figure>
<p>现在解释一下各个变量：</p>
<p><code>sex</code>是性别，其中0表示女性，1表示男性，在分析时，需要把<code>sex</code>这个变量根据1或0更改为M或F。</p>
<p><code>cp</code>是<code>chest pain</code>的缩写，其数值是1-3，这个范围表示不同类型的胸痛，4表示没有胸痛。</p>
<p><code>ca</code>与<code>thal</code>是因子数据类型，我们看到，其中有的数值是<code>?</code>，这个是不符合规范的，因此后面我们会把它改为<code>NA。</code></p>
<p>此外，还要把其它的变量更改为因子类型，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">data[data == <span class="string">"?"</span>] &lt;- <span class="literal">NA</span></div><div class="line">data[data$sex == <span class="number">0</span>,]$sex &lt;- <span class="string">"F"</span></div><div class="line">data[data$sex == <span class="number">1</span>,]$sex &lt;- <span class="string">"M"</span></div><div class="line">data$sex &lt;- as.factor(data$sex)</div><div class="line">data$cp &lt;- as.factor(data$cp)</div><div class="line">data$fbs &lt;- as.factor(data$fbs)</div><div class="line">data$restecg &lt;- as.factor(data$restecg)</div><div class="line">data$exang &lt;- as.factor(data$exang)</div><div class="line">data$slope &lt;- as.factor(data$slope)</div><div class="line">data$ca &lt;- as.integer(data$ca)</div><div class="line">data$ca &lt;- as.factor(data$ca)</div><div class="line">data$thal &lt;- as.factor(data$thal)</div><div class="line">data$hd &lt;- ifelse(test=data$hd == <span class="number">0</span>, yes = <span class="string">"Healthy"</span>, no=<span class="string">"Unhealthy"</span>)</div><div class="line">data$hd &lt;- as.factor(data$hd)</div></pre></td></tr></table></figure>
<p>查看一下数据类型，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; str(data)</div><div class="line"><span class="string">'data.frame'</span>:	<span class="number">303</span> obs. of  <span class="number">14</span> variables:</div><div class="line"> $ age     : num  <span class="number">63</span> <span class="number">67</span> <span class="number">67</span> <span class="number">37</span> <span class="number">41</span> <span class="number">56</span> <span class="number">62</span> <span class="number">57</span> <span class="number">63</span> <span class="number">53</span> <span class="keyword">...</span></div><div class="line"> $ sex     : Factor w/ <span class="number">2</span> levels <span class="string">"F"</span>,<span class="string">"M"</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ cp      : Factor w/ <span class="number">4</span> levels <span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>: <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="keyword">...</span></div><div class="line"> $ trestbps: num  <span class="number">145</span> <span class="number">160</span> <span class="number">120</span> <span class="number">130</span> <span class="number">130</span> <span class="number">120</span> <span class="number">140</span> <span class="number">120</span> <span class="number">130</span> <span class="number">140</span> <span class="keyword">...</span></div><div class="line"> $ chol    : num  <span class="number">233</span> <span class="number">286</span> <span class="number">229</span> <span class="number">250</span> <span class="number">204</span> <span class="number">236</span> <span class="number">268</span> <span class="number">354</span> <span class="number">254</span> <span class="number">203</span> <span class="keyword">...</span></div><div class="line"> $ fbs     : Factor w/ <span class="number">2</span> levels <span class="string">"0"</span>,<span class="string">"1"</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ restecg : Factor w/ <span class="number">3</span> levels <span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>: <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="keyword">...</span></div><div class="line"> $ thalach : num  <span class="number">150</span> <span class="number">108</span> <span class="number">129</span> <span class="number">187</span> <span class="number">172</span> <span class="number">178</span> <span class="number">160</span> <span class="number">163</span> <span class="number">147</span> <span class="number">155</span> <span class="keyword">...</span></div><div class="line"> $ exang   : Factor w/ <span class="number">2</span> levels <span class="string">"0"</span>,<span class="string">"1"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ oldpeak : num  <span class="number">2.3</span> <span class="number">1.5</span> <span class="number">2.6</span> <span class="number">3.5</span> <span class="number">1.4</span> <span class="number">0.8</span> <span class="number">3.6</span> <span class="number">0.6</span> <span class="number">1.4</span> <span class="number">3.1</span> <span class="keyword">...</span></div><div class="line"> $ slope   : Factor w/ <span class="number">3</span> levels <span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>: <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="keyword">...</span></div><div class="line"> $ ca      : Factor w/ <span class="number">4</span> levels <span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>: <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ thal    : Factor w/ <span class="number">4</span> levels <span class="string">"?"</span>,<span class="string">"3.0"</span>,<span class="string">"6.0"</span>,..: <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="keyword">...</span></div><div class="line"> $ hd      : Factor w/ <span class="number">2</span> levels <span class="string">"Healthy"</span>,<span class="string">"Unhealthy"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="keyword">...</span></div></pre></td></tr></table></figure>
<h3 id="补充缺失值">补充缺失值</h3>
<p>由于我们要生成随机森林，此时我们设一个种子，用于生成随机数，这样我们可以重复我们的计算结果，在构建随机森林之间，由于我们的数据集中的缺失值，此时要对缺失值进行补充，补充缺失值使用的是<code>rfImpute()</code>函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">42</span>)</div><div class="line">data.imputed &lt;- rfImpute(hd ~.,data=data,iter=<span class="number">6</span>)</div></pre></td></tr></table></figure>
<p><code>hd~.</code>是第1个参数，它表示，我们使用hd（heart disease）这一列作为最终的预测，也就是说拿一个患者的数据，预测患者是否得有心脏病。</p>
<p><code>data = data</code>这个表示，我们使用<code>data</code>这个数据集来构建随机森林。</p>
<p><code>iter=6</code>用来指定迭代多少次来评估缺失值，从理论上讲，这个值是4到6就足够了，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/Cj4eI7ijfg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>运行结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; data.imputed &lt;- rfImpute(hd ~.,data=data,iter=<span class="number">6</span>)</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">17.49</span>% <span class="number">12.80</span>% <span class="number">23.02</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">16.83</span>% <span class="number">14.02</span>% <span class="number">20.14</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">17.82</span>% <span class="number">13.41</span>% <span class="number">23.02</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">17.49</span>% <span class="number">14.02</span>% <span class="number">21.58</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">17.16</span>% <span class="number">12.80</span>% <span class="number">22.30</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">18.15</span>% <span class="number">14.63</span>% <span class="number">22.30</span>%</div></pre></td></tr></table></figure>
<p>经过每次迭代，<code>rflmpute()</code>就会在第2列输出出袋错误率（OOB，即Out-of-Bag），如果估计值在不断地改善，那么这个值就会不断地变小，但在这个结果中，我们发现这个值并没有不断地变小，那么我们就可以认为，我们利用此函数得到的估计值可以满足计算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/dEjEkhCB74.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="构建随机森林-1">构建随机森林</h3>
<p>接着，我们使用<code>randomForest()</code>函数来构建随机森林，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">model &lt;- randomForest(hd ~., data=data.imputed, proximity= <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>在这些参数中，第1个参数不用解释，跟前面的一样，第2个参数<code>data.imputed</code>是填充了估计值后的数据集，第3个参数是<code>proximity = TRUE</code>，它表示要返回相似矩阵，最终我们可以使用这个数据来进行聚类。</p>
<p>现在我们看一下结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; model</div><div class="line"></div><div class="line">Call:</div><div class="line"> randomForest(formula = hd ~ ., data = data.imputed, proximity = <span class="literal">TRUE</span>) </div><div class="line">               Type of random forest: classification</div><div class="line">                     Number of trees: <span class="number">500</span></div><div class="line">No. of variables tried at each split: <span class="number">3</span></div><div class="line"></div><div class="line">        OOB estimate of  error rate: <span class="number">16.83</span>%</div><div class="line">Confusion matrix:</div><div class="line">          Healthy Unhealthy class.error</div><div class="line">Healthy       <span class="number">142</span>        <span class="number">22</span>   <span class="number">0.1341463</span></div><div class="line">Unhealthy      <span class="number">29</span>       <span class="number">110</span>   <span class="number">0.2086331</span></div></pre></td></tr></table></figure>
<p>现在说明一下这个结果，先看第一部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Call:</div><div class="line"> randomForest(formula = hd ~ ., data = data.imputed, proximity = <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>这一部分是构建随机森林的一些参数。</p>
<p>再看第二部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Type of random forest: classification</div></pre></td></tr></table></figure>
<p>这一部分的意思是讲，我们构建随机森林的类型是分类（classification），如果我们使用随机森林来预测体重或身高这种连续型变量，那么这个就是回归（regression），如果我们忽略随机森林要预测的某个变量（我的理解就是，即不预测分类，也就是说不预测心脏病，也不预测回归，也就是说不预测体重或身高），那么这里就是无监督（unsupervised），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/9meC64bAJ4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再看下一部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Number of trees: <span class="number">500</span></div></pre></td></tr></table></figure>
<p>这里是说，随机森林中有多少棵树，默认的数字是500，随后我们会看一下500棵树能否做出一个很好的分类。</p>
<p>再看下一部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No. of variables tried at each split: <span class="number">3</span></div></pre></td></tr></table></figure>
<p>这一段文字是说，在每个内部节点上，使用的变量（也就是列）的数目，用于分类的随机森林默认使用变量数目的平方根进行计算，例如在这个案例中，变量的数目是13（不包括hd这个变量），那么13的平方根就是3.6，取整数（这里不是四舍五入），就是3，至于这个3是不是最好的数值，我们随后会进行调整，如果是用于回归的随机森林，那么这个数字就是变量的数目除以3，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/bljiFd1EI4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再看下一部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OOB estimate of  error rate: <span class="number">16.83</span>%</div></pre></td></tr></table></figure>
<p>这一部分是出袋错误率（OOB，即Out-of-Bag），这表明，这个随机森林能够将83.5%的OOB样本正确地归类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/lLFadBLCB8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后一部分是混淆矩阵（confusion matrix），如下所示（可能与教程中的有些出入，但整体相差不大）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Confusion matrix:</div><div class="line">          Healthy Unhealthy class.error</div><div class="line">Healthy       <span class="number">142</span>        <span class="number">22</span>   <span class="number">0.1341463</span></div><div class="line">Unhealthy      <span class="number">29</span>       <span class="number">110</span>   <span class="number">0.2086331</span></div></pre></td></tr></table></figure>
<p>混淆矩阵是总结分类模型预测结果的情形分析表，它以矩阵形式将数据集中的记录按照真实的类别与分类模型作出的分类判断两个标准进行汇总，那么，在上面的这个矩阵中，我们可以看到：</p>
<ol style="list-style-type: decimal">
<li>有142名健康的病人被正确地标记为“健康”；</li>
<li>有29名健康的病人被错误地标记为“健康”；</li>
<li>有22名健康的病人被错误地标记为“不健康”；</li>
<li>有110名不健康的病人被正确地标记为“不健康”。</li>
</ol>
<h3 id="绘制错误率图">绘制错误率图</h3>
<p>此时，我们看一下，500棵树能否做出一个良好的分类，我们先画出错误率，绘图使用的是ggplot2包，因此要构建一个数据框用于ggplot2的识别，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">oob.error.data &lt;- data.frame(</div><div class="line">  Trees=rep(<span class="number">1</span>:nrow(model$err.rate),times=<span class="number">3</span>),</div><div class="line">  Type=rep(c(<span class="string">"OOB"</span>,<span class="string">"Healthy"</span>,<span class="string">"Unhealthy"</span>),each=nrow(model$err.rate)),</div><div class="line">  Error=c(model$err.rate[,<span class="string">"OOB"</span>],</div><div class="line">          model$err.rate[,<span class="string">"Healthy"</span>],</div><div class="line">          model$err.rate[,<span class="string">"Unhealthy"</span>]))</div></pre></td></tr></table></figure>
<p>这段代码有点复杂，现在解释一下：</p>
<ol style="list-style-type: decimal">
<li>这段代码的大部分都是基于<code>model</code>这个数据中的<code>err.rate</code>来构建的，我们查看下这个数据，如下所示：</li>
</ol>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; head(model$err.rate)</div><div class="line">           OOB   Healthy Unhealthy</div><div class="line">[<span class="number">1</span>,] <span class="number">0.2571429</span> <span class="number">0.2765957</span> <span class="number">0.2413793</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.2470588</span> <span class="number">0.2068966</span> <span class="number">0.2891566</span></div><div class="line">[<span class="number">3</span>,] <span class="number">0.2783019</span> <span class="number">0.2758621</span> <span class="number">0.2812500</span></div><div class="line">[<span class="number">4</span>,] <span class="number">0.2704918</span> <span class="number">0.2647059</span> <span class="number">0.2777778</span></div><div class="line">[<span class="number">5</span>,] <span class="number">0.2592593</span> <span class="number">0.2600000</span> <span class="number">0.2583333</span></div><div class="line">[<span class="number">6</span>,] <span class="number">0.2597865</span> <span class="number">0.2467532</span> <span class="number">0.2755906</span></div><div class="line">&gt; tail(model$err.rate)</div><div class="line">             OOB   Healthy Unhealthy</div><div class="line">[<span class="number">495</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">496</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">497</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">498</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">499</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">500</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div></pre></td></tr></table></figure>
<p>其中第1列是OOB错误率，第2列是健康患者错误率（就是说有多大的可能性会把健康患者错误分类），第3列是不健康患者错误率（就是说有多大的可能性会把不健康患者错误分类）。</p>
<p>每1行表示的是，在构建随机森林的不同阶段的的错误率，如下所示：</p>
<div class="figure">
<img src="C:\Users\20161111\AppData\Local\Temp\1530801100691.png" alt="1530801100691">
<p class="caption">1530801100691</p>
</div>
<p>其中，第1行表示构建了第1棵树后的错误率，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/h0fC9f2ah4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第2行表示，构建了前2棵树后的错误率，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/jL4BfBAi40.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么最后1行则表示，已经构建了随机森林中500棵树后的错误率，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/h4k3bkEkfF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，使用上述代码，我们最终生成的数据框则是下面的这个样本，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(oob.error.data)</div><div class="line">  Trees Type     Error</div><div class="line"><span class="number">1</span>     <span class="number">1</span>  OOB <span class="number">0.2571429</span></div><div class="line"><span class="number">2</span>     <span class="number">2</span>  OOB <span class="number">0.2470588</span></div><div class="line"><span class="number">3</span>     <span class="number">3</span>  OOB <span class="number">0.2783019</span></div><div class="line"><span class="number">4</span>     <span class="number">4</span>  OOB <span class="number">0.2704918</span></div><div class="line"><span class="number">5</span>     <span class="number">5</span>  OOB <span class="number">0.2592593</span></div><div class="line"><span class="number">6</span>     <span class="number">6</span>  OOB <span class="number">0.2597865</span></div></pre></td></tr></table></figure>
<p>第1列数字则表示的是随机森林中树的数目，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/g2d0bj2j30.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第2列则是错误类型，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/jK2Cl6DKb6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再看一下其他的：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/j6DfFLFBja.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后1列是错误的实际数值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/cDIEdjEJj5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>调用ggplot函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ggplot(data=oob.error.data,aes(x=Trees,y=Error)) +</div><div class="line">  geom_line(aes(color=Type))</div></pre></td></tr></table></figure>
<p>绘图结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/D16lggFmc0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中蓝线是对不健康患者进行归类时的错误率，绿线是总的OOB错误率，红线是对健康患者进行归类时的错误率。通常我们发现，随着随机森林中的树越来越多，错误率是逐步下降的，如下所示</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/1jFhED6JEA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="各项参数调整">各项参数调整</h3>
<h4 id="添加树的数目">添加树的数目</h4>
<p>我们试想一下，如果我们增加更多的树，错误率会不会更低，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/gKkFkHejJ2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们将树的数目设为1000，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">model &lt;- randomForest(hd ~., data=data.imputed, ntree = <span class="number">1000</span>, proximity= <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>这里我们需要注意一下，前面我们并没有使用<code>ntree=1000</code>这个参数，这是因为<code>randomForest</code>默认的<code>ntree=500</code>，因此这个参数如果使用默认值，就可以不添加，如果要改变这个数字，就需要更改，现在看一下结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Call:</div><div class="line"> randomForest(formula = hd ~ ., data = data.imputed, ntree = <span class="number">1000</span>,      proximity = <span class="literal">TRUE</span>) </div><div class="line">               Type of random forest: classification</div><div class="line">                     Number of trees: <span class="number">1000</span></div><div class="line">No. of variables tried at each split: <span class="number">3</span></div><div class="line"></div><div class="line">        OOB estimate of  error rate: <span class="number">16.5</span>%</div><div class="line">Confusion matrix:</div><div class="line">          Healthy Unhealthy class.error</div><div class="line">Healthy       <span class="number">142</span>        <span class="number">22</span>   <span class="number">0.1341463</span></div><div class="line">Unhealthy      <span class="number">28</span>       <span class="number">111</span>   <span class="number">0.2014388</span></div></pre></td></tr></table></figure>
<p>看一下<code>OOB estimate of  error rate: 16.5%</code>这一行，它的OOB值是16.5%，而当<code>ntree=500</code>时，这个数值是16.83%，基本上两者是相同的，我们再看一下<code>ntree=500</code>时的混淆矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Confusion matrix:</div><div class="line">          Healthy Unhealthy class.error</div><div class="line">Healthy       <span class="number">142</span>        <span class="number">22</span>   <span class="number">0.1341463</span></div><div class="line">Unhealthy      <span class="number">29</span>       <span class="number">110</span>   <span class="number">0.2086331</span></div></pre></td></tr></table></figure>
<p>这两者的数值也差不多，再看一下绘图结果，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/m2a4jgFEhL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从这个绘图结果来看，当树的数目超过500后，错误率基本上就稳定了，因此我们添加再多的树，意义不大，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/FDmlkEJ1L6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h4 id="更改节点变量数目">更改节点变量数目</h4>
<p>现在我们再来看一下构建原来内部节点时使用的变量数目，原来使用的是3，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/7FaicGcC96.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们改一下这个数字，此时我们需要一个空向量，它所含元素的数目是10，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">oob.values &lt;- vector(length = <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>然后再使用一个循环，用于测试构建每个内部节点的不同变量数目，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/4EAAEeJ3gi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>代码为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>查看一下输出结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">oob.values</div><div class="line">[<span class="number">1</span>] <span class="number">0.1650165</span> <span class="number">0.1716172</span> <span class="number">0.1650165</span> <span class="number">0.1815182</span> <span class="number">0.1848185</span> <span class="number">0.1815182</span> <span class="number">0.1848185</span> <span class="number">0.1914191</span></div><div class="line">[<span class="number">9</span>] <span class="number">0.1881188</span> <span class="number">0.1881188</span></div></pre></td></tr></table></figure>
<p>其中第3个数值对应的就是<code>mtry=3</code>，它是构建随机森林的默认数字，从中我们可以发现，这个数字基本上是最小的（0.1716172），也就是说它有最低的OOB错误率，因此，默认数值已经是最好的数值了，不过，如果我们不知道最优的数值，那么就要尝试一下其他的数值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/9D0eG8Fjd9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="绘制随机森林的mds图">绘制随机森林的MDS图</h3>
<p>最后，我们绘制一下随机森林的MDS图，首先利用<code>dist()</code>函数从<code>1- 相似矩</code>中构建一个距离矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">distance.matrix &lt;- dist(<span class="number">1</span>-model$proximity)</div></pre></td></tr></table></figure>
<p>然后使用缩放函数<code>cmdscale</code>，再计算距离矩阵的x轴与y轴的占总变异的百分比，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mds.stuff &lt;- cmdscale(distance.matrix,eig=<span class="literal">TRUE</span>,x.ret=<span class="literal">TRUE</span>)</div><div class="line">mds.var.per &lt;- round(mds.stuff$eig/sum(mds.stuff$eig)*<span class="number">100</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>构建ggplot绘图的数据集并绘图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mds.values &lt;- mds.stuff$points</div><div class="line">mds.data &lt;- data.frame(Sample = rownames(mds.values),</div><div class="line">                       X=mds.values[,<span class="number">1</span>],</div><div class="line">                       Y=mds.values[,<span class="number">2</span>],</div><div class="line">                       Status=data.imputed$hd)</div><div class="line"></div><div class="line">ggplot(data=mds.data, aes(x=X, y=Y, label=Sample)) +</div><div class="line">  geom_text(aes(color=Status)) +</div><div class="line">  theme_bw()+</div><div class="line">  xlab(paste(<span class="string">"MDS1 - "</span>, mds.var.per[<span class="number">1</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>)) +</div><div class="line">  ylab(paste(<span class="string">"MDS2 - "</span>, mds.var.per[<span class="number">2</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>)) +</div><div class="line">  ggtitle(<span class="string">"MDS plot using(1 - Random Forest Proximities)"</span>)</div></pre></td></tr></table></figure>
<p>最终绘图结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/E6hflkBd2j.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从图上我们可以得到如下信息：</p>
<ol style="list-style-type: decimal">
<li>不健康的患者位于左侧，健康的患者位于右侧；</li>
<li>但在左侧，有几个患者被错误归类了（绿色中的红色文字）；</li>
<li>我们再看一下x轴，可以发现，MDS1占了总变异的47.7%，y轴上是MDS2，它占据了总异的14.2%；</li>
<li>整个图形呈一个V型（教程中是倒V型，我不太理解为什么我绘图出来是反的），它的开口是朝上x轴的相反方向的，这表明，在V型的两臂上，两个样本相离得越远，他们之间的差异就越大；</li>
<li>如果我们拿到一个新的患者的数据，在不知道他是否得了心脏病的情况下，如果经计算，他被归类到V型的左臂，那么我们就可以得到一个肯定的结论，他得了心脏病，如下所示：</li>
</ol>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180705/79b6GiHJ4B.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/01/BioStatistics/生物统计-StatQuest学习笔记19-决策树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/BioStatistics/生物统计-StatQuest学习笔记19-决策树/" itemprop="url">StatQuest学习笔记19——决策树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T12:10:54+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,434
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记是StatQuet系列视频教程的第50节和第51节，主要内容是决策树（decision tree）。其中第50节的内容是决策木树的基本思想，第51节的内容是在构建决策树中，缺失值的处理。</p>
<h2 id="决策树简单案例1">决策树简单案例1</h2>
<p>先看一下简单的决策树案例，在这个案例中，我们提出一个问题，也就是问某人，“请问，你喜欢StatQuest的主题曲吗”。回答者会回答“Yes”或“No”，根据回答者的这个回答，我们可以把回答者分为两类，如果回答Yes，则就是下面的情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Cd1LKJkeCI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果回答No，那么就是下面的这种情况：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/L9jGl7D9Dg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在一个常规的决策树中，通常会问一个问题，然后根据回答者的回答（就是Yes或No），就把他们进行分类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/60kFb792aL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>同样的，我们还可以根据一些数据来构建决策树，例如根据人的静息心率（resting heart rate）是否大于100bpm，那么就可以对他们进行分类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/kjBfK2CmGD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果一个人的静息心率大于100bpm，那么就是说他的静息心率比较高，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/1kClFLCCb3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么他就需要去看医生，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/DB6eEDce42.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果一个人的静息心率并不高，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/6gF3e54GAe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么这个人就属于比较健康的状态了，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/LEi4iihaH6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="决策树简单案例2">决策树简单案例2</h2>
<p>再来看一个决策树的简单案例。在这个案例中，决策树的构建的依据是一个分级数据（ranked data），其中数据<code>Appetite rank =1</code>表示<code>非常饿</code>，<code>Appetite rank = 2</code>表示<code>一般饿</code>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/iijAkB7kmA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果一个人非常饿（<code>Appetite rank = 1</code>）时，那么他就需要吃东西，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/2k5djAijmb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果这个人只是处于一般饿的状态（<code>Appetite rank = 2</code>），那么他只需要只一点东西即可，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/LLJmijH449.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果这个人不是特别的饿，那么他也可以不吃东西，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/c16b9maACC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>需要注意的是，决策树中的分类可以是一些二分类变量，如下图左侧所示，也可以是一些连续型变量（数值型变量），如下图右侧所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/9gB6ihKDjl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>例如，上图的右侧，我们使用小鼠的体重来预测小鼠的大小（size），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/37lbghkl38.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="复杂案例">复杂案例</h2>
<p>我们再看一个比较复杂的决策树案例，在这个决策树中，它混合了连续型变量和二分类变量，下图是决策树中的连续型变量，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/k9l9a1cDiB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着是二分类变量，它使用的yes/no来进行区分，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/CcD07EjbFf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个决策树中，我们需要注意的是，静息心率的阈值并非都是相同的，例如在左侧，它的阈值是100bpm，而在右侧，它的阈值是120bpm，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/dBlH5g2EJ8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在决策树中，问题的顺序也可以不一样，例如在左侧，第一个问题是静息心率，然后为是否吃甜甜圈（doughnut），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/bb8ihg3Gba.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而在右侧，第一个问题则为是否吃甜甜圈，然后是静息心率，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/L8cheH0859.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后的归类可以是一样的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Gli1fImE7f.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>还有两个相同的分支，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/BmaCgL2b11.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>对于大多数的决策树来说，它们都很直观，从顶层开始，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/dI7mi4I52D.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着进入下一层，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/kH02DK5gd1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再下一层，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/K49c4Jb63F.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>一直到最底层为止，此时就对一个样本进行了分类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/2eaJD2hDJ7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="决策树术语">决策树术语</h2>
<p>我们来看一下决策树的相关术语，我们把树最顶层的部分称为<code>根结点（Root Node</code>）或直接称为<code>根（The root）</code>。如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/ID9jBiJk6G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>把根节点以下最底层之间的部分称为<code>内部节点（Internal Nodes）</code>或<code>节点（Nodes）</code>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/eI05J7icDk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>内部节点通过箭头指向下一级的内部节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/jeEDDm4de2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>或者是指离（point away）下一层的内部节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Lc90Eb3b71.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那些终点（也就是没有下一层的节点）被称为<code>叶子节点（Leaf Nodes）</code>或<code>叶子（Leaves）</code>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/IGdGjG0b3C.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>内部节点的箭头指向叶子，但叶子自身已经没有箭头指向其他地方，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/cImgALF937.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="构建决策树">构建决策树</h2>
<p>现在我们讲一下，如何利用一批数据构建决策树，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/FIjAG8Hf7K.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们会利用这个表中的<code>胸痛（chest pain）</code>、 <code>良好血液循环（good blood circulation）</code>和 <code>动脉阻塞状态（blocked artery status）</code>构建一个决策树来预测一个患者是否患有心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/ED0dJ5bADG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第一步我们需要知道的是，我们使用哪些变量作为根结点，是<code>胸痛（chest pain）</code>、<code>良好血液循环（good blood circulation）</code>，还是<code>动脉阻塞状态（blocked artery status）</code>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/9e0aKKB5H5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="单一变量1构建决策树">单一变量1构建决策树</h3>
<p>此时，我们先看一下，<code>胸痛（chest pain）</code>这一个变量预测心脏病的效果如何，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/kiKDG8mEe3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>先用这一个变量（胸痛（chest pain））来构建一个小的决策树，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/geI6JJ4eem.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>先看第一行的数据，这个患者没有出现胸痛，也没有心脏病，对应到决策树上就是右侧的<code>False</code>中的<code>No</code>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/38956HbBdb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再看第2行，也就是第2个患者，他出现了胸痛，也出现了心脏病，就归于左侧的<code>True</code>的<code>Yes</code>这一类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/1298h62kG9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再看第3行，也就是第3个患者，他出现了胸痛，但没有出现心脏病，就归到了左侧<code>True</code>的<code>No</code>这个分类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Aa8b5L7Gc0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>把所有的患者（303个）都统计后，会得到最终是否得心脏病的统计信息，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/lC6LK8k78E.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="单一变量2构建决策树">单一变量2构建决策树</h3>
<p>现在我们使用<code>良好血液循环（good blood circulation）</code>这个变量来构建小的决策树，整个过程与前面的一样，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/JIH82EG316.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终得到的结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/dGAFgD83Cf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="单一变量3构建决策树">单一变量3构建决策树</h3>
<p>现在我们使用<code>动脉阻塞状态（blocked artery status）</code>这个变量来构建小的决策树，整个过程与前面的一样，如下所示：<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/8bFj362H6D.png?imageslim" alt="mark"></p>
<p>不过这个变量中有一个不明（也就是说除了Yes或No外，还有一个其他的结果，就是三个问号<code>???</code>，这个我们后面会继讲到如何处理），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180711/J1Ahg3mjmA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终的结果如下所示：：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/bll6L088Fd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="根节点设置">根节点设置</h2>
<p>前面我们使用了三个不同的变量，即胸痛（chest pain）、 良好血液循环（good blood circulation）和 动脉阻塞状态（blocked artery status）构来构建小的决策树，我们最终的目标就是要找到使用哪个变量做为根节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/2ajl6EAec5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时我们看一下胸痛（chest pain）这个变量对是否患有心脏病的区分效果，虽然能够区分，但是效果并非完美，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/g32j1hKE6g.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因为那多数患有心脏病的患者最终会落到<code>Yes</code>这个叶子节点上来，大多数没有心脏病的患者会落后右侧<code>No</code>这个节点上来，我们看一下患有心脏病患者的节点情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/1mbCE088L6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再看一下没有患心脏病的患者情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/kle82jF63K.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们再看一下良好血液循环（good blood circulation）这个变量对心脏病患者的区分情况，它也不是特别的完美，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/b94GH79h32.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终，我们看一下动脉阻塞状态（blocked artery status）这个变量对患者的区分情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/2bJBj4gjbK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们发现，这三个不同的变量用于区分患者是否患有心脏病的数目是不同的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/F6GFJ0fC3B.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="基尼不纯度gini-impurity">基尼不纯度（Gini impurity）</h3>
<p>从中我们可以发现，没有一个叶子节点能够显示100%的患有心脏病，或者是100%没有患心脏病，因此我们称这些叶子节点不纯（<code>impure</code>），为了找到哪个区分的程度更好，我们计算并比较不纯度（impurity），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/E0d5gGAB8d.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算不纯度（impurity）的方法很多，其中最常用的方法称为基尼（Gini）不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/FIbfjcIl94.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们计算一下胸痛（Chest pain）这个变量构建的决策树的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/hHfDAlgljH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>对于某个叶子结点来说，它的基尼不纯度公式如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/jA8g9GB4fc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，再计算另外一个叶子结点的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/98150klJD5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于我们已经计算了这两个叶子节点为的基尼不纯度，那么我们就能计算使用了胸痛（chest pain）这个变量区分患者的总基尼不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/IBbgj3a6ml.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>左侧的叶子节点一共有144个患者，右侧的叶子节点一共有159个患者，计算胸痛这个变量来区分患者的总的基尼不纯度的就是叶子节点不纯度加权平均数（weighted average of the leaf node impurities），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/7ae5b8Hg9g.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>它的公式是，常规的基尼不纯度乘以某个叶子节点的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/dClJ85h4ji.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>另外一部分则是如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/jAcckGIkA2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>总的结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/mHBGcmbHBK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，计算出剩余两个变量的总基尼不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/JjA9Dmmhm6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从中我们可以发现，良好血液循环（good blood circulation）这个变量的总基尼不纯度的值最低，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/J8Bg4H6jfF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么我们就使用它作为根节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/EbDcI4dlJf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>虽然我们采用了良好血液循环（good blood circulation）这个变量作为根节点，但它的叶子节点是“不纯”（impure）的，每个叶子中都含有患心脏病与不患心脏病的患者，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/H369a5chKk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>例如，在良好血液循环（good blood circulation）的决策树的叶子节点中，有164个患者，其中37个患有心脏病，127个没有心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/mJ4aEIh31H.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在右侧的叶子结点中，有133个患者，其中100个患有心脏病，33个不患心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Egj3EjlLBE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们需要计算出胸痛（chest pain）和动脉阻塞状态（blocked artery status）这两个变量用于区分左侧164个患者的情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/k1b90m5eb2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们分别计算一下胸痛（chest pain）和动脉阻塞状态（blocked artery status）在良好血液循环（good blood circulation）的决策树的左侧叶子节点下的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/ai6mKmHkhd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于动脉阻塞状态（blocked artery status）在这个叶子节点的基尼不纯度数值最低，因此，我们使用这个变量来区分这些患者，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/IECa6LDhJI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们知道了，我们构建的这个决策树，先是使用了良好血液循环（good blood circulation）作为根节点，然后使用了动脉阻塞状态（blocked artery status）作为内部节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/F7dBcIcfIe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后，我们使用剩下的变量，即胸痛（chest pain）来区分上一级的内部节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/5aBIjh23HC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终我们会发现，胸痛（chest pain）这个变量能够很好地区分最后一个叶子节点中的患者，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/5ecig0HD20.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们再看一下胸痛（chest pain）这个变量区分右侧叶子节点的情况，在这个节点中有115名患者，其中不患心脏病的患者是102人，比例为89%，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/m5llb536Ke.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时把上面红圈的那个内部节点用胸痛（chest pain）这个变量进行区分，并计算它的基尼不纯度，结果为0.29，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/AI99c4jddd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们不使用胸痛（chest pain）这个变量来区分这个叶子结点，我们计算一下它的基尼不纯度，就是0.2，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/71GBe7hAe3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从中我们可以发现，如果我们使用了胸痛（chest pain）这个变量来区分这个叶子节点，那么它的基尼不纯度就相比没有使用变量之前上升了，因此我们并不需要胸痛这个变量来区分这个叶子节点，只把它当成叶子节点，而不是进一步地区分，当其当成内部节点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/ALBcl6H6IG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此在决策树的左侧这些节点中，我们已经计算出了最终的结果，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/l3jGFldH6E.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们现在转向右侧的决策树，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/dH4lmI768d.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算右侧的所有节点跟左侧的一样，流程如下所示：</p>
<p>第一，计算出所有的基尼不纯度；</p>
<p>第二，如果节点自身的基尼不纯度比那些加了变量后进一步区分后的基尼不纯度还要低，那么这个节点就被设置为叶子节点；</p>
<p>第三，如果区分的数据会改善最终的分类结果，那么就选择最低不纯度来进行区分，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/gE778hghd9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终，我们会生成一个完整的决策树，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/k89b1Ljjmd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="连续型变量构建决策树">连续型变量构建决策树</h2>
<p>前面我们讲的都是二分类变量（yes或no）构建决策树的过程，如果我们的变量是连续型的，例如患者的体重，如何构建决策树呢，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/5Cl7je9J3l.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>下面就讲这种变量构建决策树的流程：</p>
<p>第一步：对体重进行排序，顺序从小到大，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Fj3b6GAbiL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二步：计算所有相邻患者的加权平均数，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Lj4C3GjC8H.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三步：计算每个加权平均数的不纯度值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/DAB81C4aLk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在看一下计算流程，先看第一个167.5这个平均数的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/J9eLHe5eDL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算出的结果为0，再计算一下右侧的基尼不纯度，为0.375，那么计算一下总的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/KkD15mgE9i.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在计算出所有的变量的基尼不纯度，我们发现205这个体重的基尼不纯度为0.27，它的值最低，因此我们会选择205作为阈值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/agfH1Jh4C8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="含有排序数据的决策树构建">含有排序数据的决策树构建</h2>
<p>我们前面讲了含有二分类变量（yes或no）与连续型变量（体重）数据的决策树构建，现在我们再谈一种含有“排序数据”（ranked data）的决策树构建，排序数据就是像这样的数据，例如“把我的笑话按照搞笑程度从1到4排列”。</p>
<p>此外，我们还会涉及一种多个选择数据（multiple choice data）的决策树的构建，多个选择数据就像这样的数据，“你喜欢什么颜色，红色，绿色，还是蓝色？”如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/9FL41aeIf5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>排序数据类似于连续型变量的数据（例如体重），只不过我们计算的是这些可能排序的不纯度，例如，把我的笑话按照搞笑程度进行排序，其中4是最搞笑，1不太搞笑，现在我们计算这些笑话的不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/4hFFigjGGd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在计算这几个数据的不纯度时，我们并不计算<code>Joke Rank &lt;=4</code>这种情况，因此它基本上包括了所有的情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/9JGdI6k8Ik.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们看一下含有多个选择的数据，例如你喜欢什么颜色，颜色可以选择蓝色，绿色或红色，此时我们会计算每个组合的不纯度，在这个案例中，我们只有这三个种颜色，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/jbeLAb4gI0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>它的计算过程如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Cgc93lKJ1E.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个案例中，我们并不过计算“蓝色或绿色或红色”这种情况，因此这种情况包含了所有的情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/m85HFEiLjA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="决策树的过拟合">决策树的过拟合</h2>
<p>在前面的案例中，我们使用了一组数据来构建决策树，这组数据中有三个变量，分别为胸痛（chest pain）<code>、</code>良好血液循环（good blood circulation）和动脉阻塞状态（blocked artery status），如下图左图所示，下图右图是构建好的决策树，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Kam8FC19F5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>当我们构建了决策树后，我们就可以寻问患者第一个问题了，你的血液循环是否良好，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/hdheleGHF7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，询问是否出现了动脉阻塞，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/82fh4DFBC1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后再询问，是否胸痛，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/iJaEl8L91b.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果都回答是，那么这个患者就有很大的可能性患了心脏病，因为17个类似的回答的患者都患有心脏病，仅有3个类似回答的患者没有患心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/89GHJB6c1F.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果在是否出现胸痛这个问题时，回答是否，那么这个患者就不太可能患有心脏病，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/CE54jbJ7gF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们再往后退一层，如果一个患者回答说他的血液循环良好，并且没有出现动脉阻塞，此时我们就不需要再问他是否出现胸痛了，因为在这一层中计算所得的不纯度更低，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/93A92LchaK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>换句话讲，当我们在这个节点中使用了胸痛这个变量进行区分后，它的不纯度得分为0.29，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/CciebF5a60.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果不用胸痛这个变量进行区分，它的不纯度得分只有0.20，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Li1D21CGhk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于我们不用胸痛这个变量进行区分时，它的不纯度得分更低，因此它就是一个叶子节点（也就是说不要进行进一步的区分），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/bkF0GBIG9C.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们试想一下，如果胸痛这个变量从来就不能给出一个更低的不纯度，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/H0i8bf2ggF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这种情况下，我们就不要用胸痛这个变量来区分患者了，我们就要把这个变量从决策树中除去，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/5JBGCcB1eF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>即使我们有胸痛这个变量，也不要添加到决策树上，此时决策树上只剩了血液循环和动脉阻塞这两个变量，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/bDem4Jchkg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这就是一种自动特征选择，但是，我们还是需要设定一个阈值，从而使不纯度降低到足以能够产生很强区分的程度，最终我们会构建出一个更加简洁的决策树，并且这个决策树不出现“过拟合”，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/7aeB2FiBK8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这个提到了一个术语，“过拟合”（over fit），过拟合指的是我们构建的决策树与原始数据（就是构建决策树的数据）匹配得很好，但是这个决策树却与其他的数据（我们拿到一个新的数据，放到这个决策树中）无法很好的匹配，决策树如果构建不好，很容易出现的毛病就是“过拟合”，如果要解决这个问题，就需要大幅度地降低决策树的不纯度，从而避免决策树过拟合，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/F0K760Fla1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，简单来说，这就是特征选择要做的内容，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/1ckiD28c0H.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="缺失值的处理">缺失值的处理</h2>
<p>在前面的案例中，我们看到了动脉阻塞这个变量中有个缺失值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/1052m9m1B1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这个缺失值是在第4行，也就是第4个患者中，当我们统计到第4个患者时，就会遇到，此时我们就会跳过这个患者，因为我们不知道这个缺失值原来是Yes，还是No，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/lkkLBmhhbd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但是，并非只有一种跳过这种处理方式，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/JKBg0a1lgj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们可以在这个变量中，找到哪个变量（yes或no）出现的频率最高，就选它即可，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Fd53Ja74F4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果在动脉阻塞这个变量中，yes出现的频率更高，那么我们就把这个缺失值当作yes，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/HBIKe8gadE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此外，我们还可以找到另外一列（例如第1列的胸痛）与这一列（动脉阻塞）关系，这种关系可以为我们提供指导，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/dK8g4dKcd3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个案例中，我们发现，胸痛与动脉阻塞通常是相似的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/388LH5Kccj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>例如，第1行，两个变量都是No，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/7FF1d70BFF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第2行，两个变量都是Yes，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/kfajH4hl78.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第3行，两个变量都是No，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/miEeibaB7K.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，我们就可以在这个缺失值上填上Yes，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/E0BjgHK2B8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们再考虑一种情况，假如我们此时没有动脉阻塞这个变量，这一处的变量用体重进行了替换，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/929CefImKa.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们此时，可以使用体重这个变量的均值或中位数来替换这个缺失值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/1i0kahI5IK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此外，我们还可以找到第1列（身高）与第3列（体重）之间的关系，用于确定体重的缺失值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/256dAmgi44.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个案例中，我们发现身高与体重高度相关，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/782H1dim1i.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于它们都是连续型变量，因此我们可以做一下线性回归，求出这个值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/8GIm0Akk2b.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终的结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/k6clG9i71m.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/30/BioStatistics/生物统计-StatQuest学习笔记18-K邻近算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/30/BioStatistics/生物统计-StatQuest学习笔记18-K邻近算法/" itemprop="url">StatQuest学习笔记18——K邻近算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-30T12:10:54+08:00">
                2018-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,391
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是StatQuest系列视频教程的第50节，主要内容是讲K邻近算法（K-Nearest neighbors algorithm，缩写为KNN）。K邻近算法是一种对数据进行分类的，非常简单的算法。例如我们已经有了很多对细胞进行分类的数据，那么我们要研究某个细胞属于这些分类中的哪个类别，就需要使用这种算法，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/cJiDgAF61c.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="k邻近算法基本思想">K邻近算法基本思想</h2>
<p>先看一个简单的案例。</p>
<p>第一步，我们拥有一批数据，这批数据已经进行了分类，在下图中，来源于小肠肿瘤中的这些细胞拥有不同的分类，我们使用PCA对这些细胞进行聚类，如下图所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/lCCejBDFcF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二步，当我们再往这批数据中添加一个新的细胞时，我们此时并不清楚这个新细胞的分类，因为这个细胞是从另外的一个肿瘤中取出来的，不好归类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/1hj04hfJKI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三步：我们计算这个新的细胞离它最近的那个分类（也就是最近的领居“nearest neighbors”），这个细胞就属于这个分类。如果“K最近的邻居（K-nearest neighbors）”中的这个K等于1（这个K表示的是邻居的数目），那么我们就能把这个新的细胞归于这个离它最近的分类中，在这个案例中，这个最近的分类是绿色的。如果K等于11，那我们就需要使用11个最近的邻居，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/efF6a3jBE5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>假如这个新的细胞在其它的地方，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Ldk19D3CA9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果K=11（这个意思表示，最这个点最近的邻居有11个），那么这个新的细胞就位于两类或更多的类中间，我们就把它归于得到“票数”最多的那个类别，那么在这个案例中，有7个最近的邻居是红色，3个最近的邻居是橘黄色，有1个最近的邻居是绿色，由于红色得到的票数最多，那么这个新的细胞就属于红色这一类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/K3Dg3dkdLe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="热图案例">热图案例</h2>
<p>K邻近算法同样适用于热图，下面的这个热图是用采用层次聚类算法得到的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/ggBCL7fCgl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时如果我们有一个新的细胞，它的基因表达模式位于热图中浅蓝色区域的中央，如果K=1，那么我们仅仅需要看一下离它最近的细胞，我们就知道这个新的细胞是属于哪个类型的，这种情况下，它属于浅蓝色区域的分类，如果K=5，我们看一下离个细胞最近的邻居，它还是属于这个浅蓝色区域（仔细数一下，浅蓝色区域中有17列），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/d19Jg0hjFj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>假如这个新的细胞的基因表达模式位于浅蓝色区域的偏左侧的话，如果此时K=11，我们就需要进行一个投票，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/kh3kBkdGm2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过投票发现，在这11个最近的邻居中，有7个位于浅蓝色区域，有4个位于浅绿色区域，因此，我们把这个新细胞类型归于浅蓝色区域，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/Kck4mfEiGA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果这个新的细胞分类正好位于两个区域中央，这个细胞的归类就有两种解决方法：</p>
<p>第一，如果K值是奇数，那么我们就很容易进行计算；</p>
<p>第二，（如果K值是偶数），那么我们就会得到一个比较很麻烦的投票，此时就要靠投硬币来决定这个细胞属于哪个分类了，或者就是不归类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/A4C4Aa77hd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="训练数据">训练数据</h2>
<p>在这里我们讲一些简单的机器学习方面的内容，我们把那些用于最初始聚类的数据（这些数据我们已经知道它们是什么分类了）称为“训练数据”（training data），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/LLb8hBce9J.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="如何选择k值">如何选择K值</h2>
<p>K值只是算法意义上的数字，它无关生理学或生物学方面的意义，因此在设置K值之前，你或许会尝试设置多设几个K值。在多设几个K值时，此时假定你不清楚一部分训练数据（实际上是知道的）的分类，那么通过K邻近算法（KNN），你对这些未知的训练数据进行分类，进而查看你的数据（此处是非训练数据）的分类情况。</p>
<p>上面的这一段是完全翻译视频中的文字，我是不太理解，但就我自己的理解而言，就先找一批训练数据，这些数据的分类已经很明确了，把这些数据分成2份，分别定义为A和B，其中A用于聚类（这部分数据通常比较大），另外一份B用KNN进行分类（也就是A中分好的类），此时能找出最佳的K值，然后再使用一批新的数据C进行KNN分类。</p>
<p>如果K值比较低（例如K=1或K=2），那么噪音就会比较大，会受到异常值的影响。如果K值过大，虽然会解决K值过小的问题，但是，你也不会想让K值太大，因为如果你只有几个样本，那么运算时间会过长，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180703/J2ElCChBjm.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/29/BioStatistics/生物统计-StatQuest学习笔记17-聚类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/29/BioStatistics/生物统计-StatQuest学习笔记17-聚类/" itemprop="url">StatQuest学习笔记17——聚类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-29T12:10:54+08:00">
                2018-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,359
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是StatQuest系列教程的第47，48，49节。第47节与第48节有很在一部分内容是重复的，主要讲的是层次聚类，第49节讲提K-means聚类。</p>
<h2 id="热图简单案例">热图简单案例</h2>
<p>平时在读一个测序文章时，我们可能会经常看到热图，就像现在的这种图：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/dL1AdJLch6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们来解释一下这张图：</p>
<ol style="list-style-type: decimal">
<li>这是一张热图（heatmap），为什么要叫热图呢，因为它用不同的颜色来表示数值的大小，通常来说，用暖色（红色）表示数值大，冷色（蓝色）表示数值小。</li>
<li>这个热图的行（row）是基因名（可能太小看不清楚），列是RNA-seq的样本名。</li>
<li>当原始数据通过热图来展现时，数据经过了两种修饰来展示出来。第一种修饰就是相对丰度（relative abundances），以这种方式展示的数据，它研究的是一个基因在不同样本中的相对表达情况，这种展示方式，需要对同一行（也就是相同的基因在不同样本中的表达水平）的数据进行缩放（scaled），也就是Z转换。从下面的图中，我们就可以看到，样本1的某基因表达量明显高于其它样本（因为样本1的颜色最红，根据图例，它的表达值就最高），如下所示：</li>
</ol>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/h7dEL9fFAl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了方便理解，我随手用Excel做了一下简陋的热图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/6FLhE5fhi2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>可以看出，基因4在样本1中的表达量很高。不过按照第一种展示数据的方式，无法比较不同基因的表达水平差异，例如，在上图的黑色方框中，基因4显红色，这只能表达，样本1中基因4的表达水平比其它的样本高，不能说明样本1中的其它基因（例如基因3）的水平也比其它样本高，这种数据的展示方式只用于研究同一个基因在不同的样本中的表达水平差异。</p>
<p>第二处修饰后的展示方式就是根据这些基因表达的相似性，把它们放到一块，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/hah163Lk94.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再看下面的图形：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/E3FC8GmfJD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从上到下，我们可以看到这些基因的表达的模式。</p>
<p>在第一个紫红色的方框中，我们可以看到，这些基因在第2个样本中表达水平最高，而在第4个样本中表达水平最低。</p>
<p>在第二个黑色的方框中，我们可以看到，这些基因在第1个样本中表达水平最高，而在第4个样本中表达水平最低。</p>
<p>在第三个橙色方框中中，我们可以看到，这些基因在第2个样本中的表达水平最高，而在第3个栖中的表达水平最低。</p>
<p>根据不同基因表达模式的相似性进行的“聚类”（clustering）并不是偶然的，而是通过一定的算法实现的，这些算法会将那些表达模式类似的基因放到一块，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/6eiAbIJH1e.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果不进行聚类（clustering），那么用热图展示出来就是下图右边的那个样子，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/0LahAClc3b.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果热图中既不进行聚类（clustering），也不进行缩放（scaling），那么热图就变成了如下的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/4c6I04LHEC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从图上我们可以看到，红色部分的这个基因表达水平最高（比其他的基因表达高太多了），可以把它视为一个异常值。</p>
<h2 id="热图复杂案例">热图复杂案例</h2>
<p>现在我们再看一下比较复杂的热图案例，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/cLmkBgCi8A.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从这个图的标题上我们可以看出，这个貌似是一个结肠的单细胞测序数据的热图。这个热图的数据经过了缩放（scaled）与聚类（clustered），它的缩放是全局的，因此，这一组数据中并没有异常值，这里的缩放要与前面热图的缩放区分开来，前面的前面是按照某个基因进行缩放的，也就是把同一行的数据当成整体，进行了缩放（也就是z转换），而这个数据是把所有的数据当作整体，进行缩放。</p>
<p>再看聚类。这个热图的聚类是按照列（column，也就是样本）和行（row，也就是基因）同时进行的聚类，如下所示：</p>
<div class="figure">
<img src="C:\Users\20161111\AppData\Local\Temp\1530270167021.png" alt="1530270167021">
<p class="caption">1530270167021</p>
</div>
<p>在上图中，我们可以看到，纵矩形的部分表示基因表达模式相似的样本聚在了一起，横矩形表示的是，表达模式相似的基因聚集在了一起。它们的交集表示，这些样本的基因表达模式相似，以及有哪些基因相似。</p>
<p>如果不进行聚类，也不进行数据缩放（scaling），那么下图的右上表示的就是不聚类的热图，右下表示的就是即不进行聚类，又不进行缩放的热图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/14gdLJ5Dd2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时我们再回到前面的那个简单热图案例中来，我们试想一个问题，在那张热图中，如果我们对所有的基因进行整体的缩放（global scaling），而非单个基因的缩放，那么这个热图会怎么样，我们看下图：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/j1KB7adB6h.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过全局缩放（global scaling）后，得到下面的图形，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/7BC2efKA00.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们会发现，这些聚类的结果就会发生了改变，并且新生成的图形中出面了异常高的热图，它是异常值，这个异常值会导致热图整体上出来严重的偏离，并且不容易观察基因的变化，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/JHDfE9hbIa.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，我们从上面的结果可以知道，缩放（scaling）会影响两个结果，第一，不同表达水平基因的颜色，这会影响你比较不同样本中的相同基因的表达水平，第二，影响聚类（clustering），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/kAEdkI73g1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="如何对数据进行缩放scale">如何对数据进行缩放（scale）</h2>
<p>此时，我们再回到数据的缩放这个话题上，无论你对相同基因在不同样本中进行缩放，还是对全局的基因进行缩放，最常用的方法就是Z值缩放法（Z-Score Scaling），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/5A1acJDkeh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，我们具体看一下这种方法是如何实现数据的缩放的。在下图中，我们看到一个数轴上分布了几个样本的reads数，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/lDlgGh00DK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第一步：计算其均值（均值为16.5），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/2Jmfcld5K4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二步：每个样本的数值减去均值，此时，如果这个数值大，就表示此样本的某基因转录水平高；如果数值小，就表示此样本的某基因转录水平低，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/69kmIJ0LJ8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三步：计算标准差（标准差为6.28）；</p>
<p>第四步：将第2步中的数值除以标准差，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/l3mEe6aA6f.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过上述的处理后，无论原始数据的变异程度如何，这些数据的范围最终会缩小，之所以这样处理，就是因为如果原始数据之间差异过大，那么不同基因表达水平就会变化程度（more subtle）更高的色度（shade）来表示，经过这样的处理，用较小程度的色度（shade）就能表示出基因水平的差异，方便观察，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/m1dK3h3DAk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们可能会遇到这样的一种情况，例如，如果数据中出现异常值时，数据会怎么样，就像下面的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/LffeJAeKKc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时如果进行Z转换的话，标准差会很大，也就是Z值的分子会很大，最终得到的值会有一部分集中在0附近，只能用很少的色度来进行区分，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/0fii46d086.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>例如，我们如果采用全局缩放来处理原始数据中，在第一个案例中，我们就会得到下面这样的图形，其中有一个基因明显表达水平非常高，使得其它的基因差异很难看出来，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/2amLFgmJ9C.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="如何聚类">如何聚类</h2>
<p>原始数据经过缩放后（scaling），此时就可以进行聚类了，聚类有2种方法，分别是层次聚类（hierarchical clustering）和K-均值（K-means）聚类，我们先讲层次聚类（hierarchical clustering），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/6g819j4cFD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="层次聚类hierarchical-clustering">层次聚类（hierarchical clustering）</h2>
<p>先看一个简单的案例，在这个案例中，有3个样本，每个样本4个基因，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/352346CFjf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这种聚类方法的思路是这样的：</p>
<p>第一步，计算出哪些基因与基因1最为接近，基因2明显与基因1表达模式不同，基因3与基因1的表达形式比较类似，基因4与基因1的表达模式也比较类似，但是，在这几个基因中，与基因1表达模式最接近的还是基因3，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/gDj4GdG2gJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二步，计算出哪些基因的表达模式与基因2最为接近（然后是基因3，基因4），经计算发现，基因4与基因2的表达模式最相似，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/Fc768iJDGK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三步，我们在前面找到基因1和基因3的表达模式相似，基因2和基因4的表达模式相似，但是，基因1和基因3的相似程度要比基因2和基因4的相似程度高，我们把前面的组合（基因1和基因3）放到一个簇（cluster）中，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/iCL7g1LAFA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第四步：此时再回到第一步，把基因1和基因3构成的簇（Cluster # 1）当作一个基因，然后再按照第二步，第三步来计算，经计算，此时，基因2和基因4最相似，把它们再放到一个簇中（Cluster #2），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/IaGfmFLdim.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>通常情况下，层次聚类（Hierarchical Clustering）通常会用一个树形图（dendrogram）连接起来，用于表明聚类成员之间的相似性和聚类次序，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/0mgHGg316E.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在右侧的树形中，我们可以发现，<code>Cluster #1</code>是最先形成的聚类，它们的相似性最高，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/hFK168G5JE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p><code>Cluster #2</code>是第二个形成的聚类，它们的相似性次高，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/jDEgcD90bh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而第三个聚类<code>Cluster #3</code>则包含了所有的基因，它是最后形成的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/Ec8kbJiKBf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="层次聚类的原理">层次聚类的原理</h2>
<p>前面我们提到过，层次聚类的第一步就是计算两组基因的相似性，此时我们详细介绍一下如何进行计算。</p>
<p>在计算相似性方面并没有一个统计的标准，但有一些常用的手段。第一种计算相似性的方法就是欧氏距离（Euclidian distance），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/2h4kL662LJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了简单地说明欧氏距离（Euclidian distance），我们以最简单的例子来说明，在这个例子中，有2个样本，每个样本有2个基因，然后两个样本的相同基因的差值的平方相加，并开平方，得到的数值就是欧氏距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/1CaGjFHmCc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>除了欧氏距离可以计算相似性外，还可以使用曼哈顿距离（Manhattan distance）和坎贝拉距离（Canberra distance）来计算相似性，其中曼哈顿距离只是不同样本之间相同基因差值的绝对值之和，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/fEJhhDJkJ1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们看一下用不同的方法计算相似性的区别，下图的左侧图使用的欧氏距离（Euclidian distance）来得到的热图，右图使用的是曼哈顿距离（Manhattan distance）得到的热图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/gG6BkBI8cH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从图上来看，使用这两种不同的相似性计算方法得到的热图略有差异，具体要使用哪种方法来计算相似性，并没有一个统计的标准，它们也没有什么生物学意义。</p>
<p>此时，我们再回到原来的案例中来，在前面部分中我们提到，基因1和基因3的相似程度最高，把它们都放到一个簇（Cluster #1）中，此时，我们如何计算Cluster #1和基因2，基因4的相似性呢？有几种方法。</p>
<p>其中最简单的一种方法就是求出Cluster #1中的两个基因的平均值，然后进行计算。但还有其它的方法，这些方法同样会影响聚类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/bal5a72fBf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了简单地说明簇（Cluster #1）与其它基因相似性计算的问题，我们假设有一批数据，分布在X-Y轴上，此时，我们已经生成了2个簇，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/HA5IIj26Da.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们仅需要计算最后一个点属于哪个簇，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/jmLBI1be69.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时我们可以采用以下这些方法进行计算：</p>
<p>第一，计算这个点与两个簇平均值的距离（centroid），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/7JgK2aEki3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二，计算这个点到两个簇最近的点的距离（single-linkage），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/d4G6f8c9C0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三，计算这个点到两个簇中最远的点的距离（complete-linkage），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/AF9hbE8aGg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们用前面的单细胞测序的热图来说明一下这三种方法，从左到右分别是：某点到某簇最远点的距离（在R中默认的就是这个选项），某点到某簇均值的距离，某点到某簇最近的点的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/0DgKlAla9j.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="k-means聚类">K-means聚类</h2>
<h3 id="什么是k-means">什么是K-means</h3>
<p>先看一个场景，例如我们手中有这样的一批数据，把它们绘制到一个数轴上，此时你的目的就是把它们分成3个簇（cluster），这三个数据或许是来源于三种不同的细胞或都是三种不同的肿瘤，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/gDeDE7iHmG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们仅从肉眼观察，就知道这一批数据明显可以分成3个簇，但是，如果我们不用肉眼来观察，用计算机来计算，如何得到这3个簇呢？此时就需要用到一种算法，即K-means聚类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/DcfFeBHbbI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="k-means的基本思想">K-means的基本思想</h3>
<p>此时，我们先了解一下K-means聚类的基本思想。</p>
<p>第一步：选择你要聚类的个数，K-means聚类中的这个<code>K</code>就是你要聚类的数目的意思，此时，你们选择<code>K=3</code>，这也就是说，我们想把这些数据取成3个簇（cluster），对这个<code>K</code>值如何选择，我们后文会提到，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/8BH3AcA263.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二步，随机选择3个不同的数据点当成3个簇，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/K3Lh1G1H2K.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三步：计算第1个点到这三个簇的距离，先计算第1个点到蓝簇的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/dCfiK0DjLi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，计算第1个点到绿簇的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/J9IL0c82m9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后，计算第1个点到橘黄簇的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/3kem6H6Dcd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第四步：将第1个点归于离它最近的簇，在这个案例中，第1个点就属于蓝簇，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/0HKBg8Ek26.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，重复前面的步骤，只是这次计算的第2个点，第2个点最终的计算结果它属于绿簇，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/16BHi1J6Fg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再计算第3个点，它属于橘黄簇，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/JgJ8E8AAHa.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过最终计算，第3个点到最后的点都属于橘黄簇，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/d0J5FGBJ72.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，所有的点都进行了聚类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/56K013Bd3G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第五步：计算每个簇的均值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/m1jH7kh39B.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们还按照前面的方法，计算每个点到这三个簇的均值的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/CbeIFBIkdl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终计算结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/dbf9kmDIAB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过最终的计算，我们发现，这些聚类结果并没有发生改变，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/j68dJ3jiE4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>也就是说，K-means的聚类结果似乎比我们肉眼进行的聚类的结果还要差，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/26i11J8043.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们需要对聚类的结果进行评估，其方法就是计算每个簇的变异，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/6mbdE59BDe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于K-means的聚类过程并不能“看”到最佳的聚类，只能追踪这些簇与这些簇的总变异，然后通过不断更改起始的数据点进行迭代。</p>
<p>此时我们回到起点，再将随机选择3个初始数据点作为初始的簇，按照前面同样的自救，计算剩余的点到这三个簇的距离，计算每个簇的均值，然后基于新的均值进行聚类，直接这些簇不再改变为止，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/dJ67kIAKKc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算的结果如下所示，此时这些数据已经进行了聚类，再计算这三个簇的变异，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/ca9iGdlm3C.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这一轮迭代结束，然后再来一轮，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/bC105LmmI9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们把这三次的聚类结果放一块儿，我们可以发现，第二次的聚类结果最好，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180629/bFC04780ba.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但是我们并不清楚这个结果是不是所有可能的聚类结果中最好的（总变异最小），因此我们需要进行更多次的聚类，然后才能下结论。</p>
<p>此时我们提出一个问题，<code>K</code>值应该如何选？在这个案例中，明显可以知道K值为3，但是，有的时候，这个K值并不像本案例中这么明显，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/m1aGjKhhL3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中一种确定K值的方法就是不断地使用不同的K值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/egDhGG7KDb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们先使用K=1这个数值，通过计算总的变异程度，明显这个结果不行，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/6ghJ92Le5c.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再使用K=2，此时我们计算一下总变异，这个结果比K=1的时候要好一些，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/Ama8J4IkJF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，我们使用K=3，通过计算它的总变异，我们发现K=3的结果要比K=2更好，因为它的总变异更低，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/lfBdI98Gk2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再继续，使K=4，我们发现，K=4的总变异比K=3的总变异还要小，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/2J695k5akc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从前面的这些计算结果来看，我们能总结出一个规律，每当我们添加一个新的簇时，总变异就会降低，当簇的数目等于总的数据点的数目时，总变异就是0，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/3EGek4GAll.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们把K值与变异降低的程度绘制成曲线，那么就能得到下面的这条曲线：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/mbE30AGBIb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从这个曲线上我们可以看到，当K=3时，它之后的K值每增加1，总变异的降低幅度就没有前面的快，我们把K=3这个点称为拐点（elbow plot）。</p>
<h3 id="k-mean聚类与层次聚类的区别">K-mean聚类与层次聚类的区别</h3>
<p>此时，我们再提出一个问题：K-mean聚类与层次聚类有什么区别？</p>
<p>K-means聚类会把数据聚成你所期望的簇的数目，而层次聚类则中介告诉你，哪两个数据是最相似的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/ik6bbeH932.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="二维坐标的k-means">二维坐标的K-means</h2>
<p>如果我们的数据无法绘制到一条数轴上时，如何进行K-means聚类呢，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/jCcAef2fJe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这种情况下，它的聚类原理跟一维数轴的原理一样，第一步就是随机找到三个点（前提是你想聚成3个簇），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/kLGjcHj5G5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后，计算不同的点到这三个簇的欧氏距离（Euclidean distance），在二维坐标中，计算这个欧氏距离就是采用勾股定理，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/44mkHa9eKE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，就像前面讲的那样，距离最近的就属于某个簇，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/ihJ6Dm0aDi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第一次的聚类结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/hbhFKjhFL8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再接着，我们会像前面是找到的那样，计算出每个族的中心点（也就是均值），然后再聚类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/0L83284FFa.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后，得到比较满意的聚类图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/Dek6j3LGEd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="热图的k-means">热图的K-means</h2>
<p>如果我们的数据是热图，那么如何进行K-means聚类呢？</p>
<p>为了方便描述，我们就以下面的案例说明一下，两个样本（sample 1和sample 2），分别有4个基因，现在把这两个样本分别命令为X，Y，把它们的基因放到二维坐标轴上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/08BKa2g4dE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后像前面那样进行聚类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/9729jIEbAC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>事实上，在实际的计算过程中，我们并不需要把数据投射到二维坐标上，只用计算不同样本之间的距离即可，例如欧氏距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/b3A3hJ9hEh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="r的kmeans函数备注">R的kmeans()函数备注</h2>
<p>在R中，进行K-menas聚类的函数是<code>kmeans()</code>，它有一些注意事项。</p>
<ol style="list-style-type: decimal">
<li>此函数会对每个距离加上权重，因此那些大簇（large clusters）的权重要略高于小簇（small clusters）的权重。</li>
<li>默认情况下，此函数只有一组原始的簇，如果你要使用多个不同的起始数据点，那么你需要设定参数<code>nclust=25</code>或者是25左右的数字，例如（<code>kmans(data, k=3, nclust=25)</code>)。</li>
</ol>
<p>如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180630/FFb5iHFie2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/27/BioStatistics/生物统计-StatQuest学习笔记16-tSNE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/BioStatistics/生物统计-StatQuest学习笔记16-tSNE/" itemprop="url">StatQuest学习笔记16——t-SNE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T12:00:00+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,409
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一篇笔记是StatQuest系列视频的第46节，它的主要内容是t-SNE，t-SNE是一种对复杂数据的降维分类方法，我最初知道这种方法是在接触质谱流式细胞仪CytoTOF的时候，当时的很多文献对细胞的分类方法都是采用t-SNE，现在很多单细胞测序类文章也会使用t-SNE方法。</p>
<h2 id="t-sne的基本思想">t-SNE的基本思想</h2>
<p>我们首选看一个t-SNE的图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/Ik263a8lJ0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>t-SNE是一种将复杂的高维数据进行降维，同时还保留大量原始数据信息的一种方法。我们先看一个非常简单的案例，在这个案例中，我们将会展示t-SNE如何将一个二维的图形转变为一维图形，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/c0JfEeF245.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>通过这个最简单的案例，我们就会了解t-SNE最基本的思想，为处理以后更复杂的数据打下基础。</p>
<p>如果我们把这个二维图中的信息都投射到二维图中的坐标轴上，例如先投射到纵坐标上，那么我们就会得到一些比较杂乱的信息，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/eF48Bdc31f.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>尤其是纵坐标的上部分，它混合了蓝点与红点的信息，因此，纵坐标上没有保留原始聚类的信息，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/HhkdFlG9m7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们把这些聚类的点投射到横坐标上，也会得到一些混乱的信息，如下所示，它也没有很好地保留原始信息：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/9jGmcDf8h0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时我们可以采用t-SNE来处理这些数据，我们可以把高维的图形（这里是二维图）转换成低维的图形（这里是一维图），从而在低维的图形中仍然保留高维图形中的信息，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/m68f5CH6Bh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们讲一下t-SNE是如何实现降维的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/G2cHCblchb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第一步，我们首先获得原始的二维散点图，然后把这些点随机地投射到一个数轴上（就是一维坐标），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/Hk5Jjj57h7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二步，从这一步开始，t-SNE会移动这些投射到一维坐标上的点，但一次仅移动一个点，直到这些点聚集起来，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/19G5Icg2lA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三步，在这一步我们可以看一下t-SNE是如何移动第1个点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/AldHLBH0AC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于第1个点是红点，它是某个聚类中的一个成员（就是二维图中红色的分类），因此第1个点移动的话，它会移向与它同类的这些点附近，也就是向右移动，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/Jm5ILL49jG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>与此同时，第1个点右边的2个黄点和1个蓝点（其实就是第1个红点与第2个红点之间的这3个点）在二维图中离得比较远，因此它们会被推回去，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/JIe2fHkhh7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，在第一次移动的时候，第1个红点移向右边的那三个红点，第1个红点右侧的两个黄点与一个蓝色移到左边，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/j0jKc81jg4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个案例中，第1个红点被右侧的3个红点吸引，它的吸引力最强，因此移向右侧（我的理解就是，只看红点，如果把它们聚集起来，必定要移动，我们首先移动的是第1个红点，第2个红点右边是3个红点，因此第1个红点受到的吸引最大），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/b5HC4Gadkl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>红点移动后就是下面的这个样子（一次移动一个位置）：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/H8HkIf9Ebd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>移动后，第1个点就变成了黄点，如果再次移动的话，黄点的移动就跟前面的红点移动过程一样了，它受到右边三个黄点的吸引，就会移动过去，移动后，红点就又被推了回去，跟前面的原理是一样的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/Dc8cGEFAkC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，黄点移向右侧，与那三个黄点更加接近，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/bAjA3hgKKc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>移动后，就成了这个样子（部分叠加起来了），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/KiLGi5J4fH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后不断地重复上述过程，这些不同类型的点就会一点一点聚集起来，如下所示：</p>
<p>先是这样：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/FljchElg63.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后是这样：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/li2b9ICc2i.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再然后是这样：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/jhbi5cBJ31.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终就成了这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/78DkGIEJCh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>上面的整个动态过程建议看原视频，讲得很透彻。</p>
<h2 id="t-sne的原理">t-SNE的原理</h2>
<p>前面只是t-SNE的基本思想，我们以最简单的二维降一维的过程看了t-SNE是如何工作的，此时，我们进入t-SNE的具体原理，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/GhFKLGBBl0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="第一步计算不同点之间的距离">第一步：计算不同点之间的距离</h3>
<p>t-SNE原理的第一步就是计算二维散点图中所有点的“相似性”（similarity），例如，我们先看第1个点（下图黑点）与剩余所有点的相似性，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/i87Kfi800d.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在计算相似性的时候，首先要计算两个点之间的距离，然后绘制出一个正态分布曲线，这个正态分布曲线是以当前的点为中心的（也就是前面的第1个点，黑点），最终，绘制出蓝点到正态分布曲线的距离（就是下图中黑色虚线部分），这个长度就叫非标度相似性（unscaled similarity）（审作者自己提出的这个术语，这样比较方便后续的理解），它的数值就是非标度相似性的值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/Ga7BEClmBC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，计算第1个点与下一个点的非标度相似性（unscaled similarity），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/Cf1bB3BiDF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>还有另外的一个点的非标度相似性，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/KBCaa5bGGG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在计算第1个点（黑点）与左下方黄点的距离时，通过将黄点投射到正态分布上，我们可以发现，这两个点相似性的数值极低，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/1L12g9d0be.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而在同一个分类中的点，它们的相似性却很高，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/8IIKHDckAf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终，我们会计算出所有的点与第1个点（黑点）的距离，然后把它们都绘制到正态分布曲线上，随机测量这些点到正态分布曲线上的距离，从而得到非标度相似性得分（unscaled similarity scores），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/mGkDDHhfmB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="第二步转换非标度相似性">第二步：转换非标度相似性</h3>
<p>在这一步中，我们将这些非标度相似性（unscaled similarities）进行缩放（scale），从而使它们加起来等于1，此时我们或许会问，为什么要使它们加起来等于1呢，后面我们会解释，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/mHdHjmB8da.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此处解释为什么它们为要加起来等于1，为了更方便地说明这个问题，我们在原有的分类基础上再加上一个分类（原来有3个分类），第4个分类（紫色）的密度是其它分类密度的一半（我的理解就是这个密度是点与点之间的那种远近关系，从图上明显可以看出来，在紫色的分类中，它的4个点之间比较稀疏，而其他的三个分类内的点比较接近，也就是说密度比紫色的高），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/h263mIHFFa.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们再回到原来的第1个点（为了与后文进行区分，此处命名为黑点A）上来，我们在将黑点A与其它点的距离投射到正态分布曲线上时，正态分布曲线的宽度取决于黑点A与其附近的点的密度（其实可以理解为距离），我们再看一下第4个分类中的黑点（此处命名为黑点B），在将黑点B与其它点的距离投到正态分布曲线上时，我们就可以发现，黑点A所在的正态分布曲线比黑点B所在的正态分布曲线要瘦（也就是前者更窄，表示其密度更大），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/JLCa3fek27.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，如果黑点B的密度只有黑点A密度的一半，那么黑点A所有的正态分布曲线的宽度只有黑色点B正态分布曲线宽度的一半，然后对相似性分数（similarity scores）重新进行缩放（scale），就会让这两个分数的值相同，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/AJDaHDJ1ed.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此处解释一下为什么缩放后它们的值为一样。</p>
<p>黑点A所在正态分布曲线（缩写为曲线A）的标准差为1，那么两个蓝点到曲线A的非标度相似性值分别就是0.24和0.05，而黑点B所在正态分布曲线（缩写为曲线B）的标准差为2（这两个紫色点到曲线B的非标度相似性的值就是0.12和0.024，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/CGcLFLfj01.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>对这些相似性得分（similarity scores）进行缩放（scale），从而使它们加起来1，计算公式与计算结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/I6m5HFkA6B.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从上面的计算结果我们可以发现，这两个曲线的两个点结果是一样的。这就表明，在密度相对大的聚类和密度相对小的聚类中，它们的缩放（scale）后的得分是相同的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/LCje7fg9CI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>不过在实际运行中，情况更加复杂，但原理还是一样的。t-SNE有一个困惑度（perplexity）参数，它就相当于期望密度，当使用了这个参数时，对于某些点，这些聚类会比你认为的相似还要“相似”，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/5g20j4Ec1j.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，再回到原始数据，我们已经计算了第1个点（黑点）与其它点的相似性分数（similarity scores）了，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/eAB5ffe5Hi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，我们计算另外一个点与其它点的相似性分数，剩余的点都照此操作，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/59Am2l2a4d.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终我们使用这些全部的相似性分数（similarity scores）来处理这个二维图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/C3Llm7IFfB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于投射的正态分布曲线的宽度主要取决于某个点与其周围点的密度，因此下图中的黑色点与黄色点的相似性分数和这个色点的分布与黑色点的分布不一样，如下所示：</p>
<p>这个是黑色点到黄色点的相似性分数：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/3DbEdeAI0G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这个是黄色点与原黑色点（现在是蓝色点）的相似性分数，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/aLjEKiFJFK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，t-SNE会计算这两个点前后两次不同方向的相似性分数的平均值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/d4HE7Ai55k.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="第三步相似性分数矩阵">第三步：相似性分数矩阵</h3>
<p>最终，我们会得到一个相似性分数的矩阵，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/h586Ill5h7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这个矩阵的行与列表示的是某个点（这个点在矩阵中用深色表示）与其它点的相似性分数，红色表示具有高度相似性，白色表示不明显的相似性，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/el02HHdD1e.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们就计算出了这个二维图的相似性分数，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/d0E9GEb0e0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="第四步t分布曲线">第四步：t分布曲线</h3>
<p>现在，我们把这个二维图的点都投射到一个数轴上（一维图），并计算它们的相似性分数，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/F70KlekibG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这种计算方法跟前面的类似，还以第1个点为例，计算它与第2个点的距离，然后以这个点为中心画一个t分布曲线，把第2个点投射到这个t分布曲线上来，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/5IK6jkdbDd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此处要提一下t分布，这是一种与正态分布类似的分布，它常用于小样本分布检测，t分布的中间要比正态分布低，但它的两侧要比正态分布高，如果样本足够大的时候，t分布就与正态分布非常接近了，t-SNE中的这个t指的就是t分布，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/EEF29CkC5F.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>因此，使用这个t分布，我们就能像前文提到的那样，计算出这些点的非标度分数，并对这些分数进行归一化处理，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/eLH8k1g38k.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终我们会得到一个相似性分数的矩阵，不过这个矩阵与前面我们使用的原始矩阵相比，它显得不是那么整齐，比较混乱，如下所示：</p>
<div class="figure">
<img src="C:\Users\20161111\AppData\Local\Temp\1530112580340.png" alt="1530112580340">
<p class="caption">1530112580340</p>
</div>
<p>我们最终的目标就是想要把数轴中第1个点向右移动，移动的结果就像右侧的矩阵那样，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/B6fCB1KC14.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>t-SNE一次只移动一个位置，并且每次它会选择一个方向，从而使左侧的矩阵更像右侧的矩阵，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/1HI1BdhAd3.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>t-SNE使用小步移动（small steps，我的理解就是一次移一个位置），就像下国际象棋一样，它不能一次就移动到位，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/7hKjdea1Jl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后，我们要讲一下，我为什么前面要使用t分布来计算相似分数，因为如果不使用t分布，这些聚类就会挤成一堆，很难观察这些聚类的效果（不是特别的懂，个人理解就是，如果你使用正态分布，这三个聚类的点最终就会挤成一个，你就无法直观地观察几个数据点的分布了，使用t分布就能避免这个问题，因为t分布毕竟比正态分布要松散一些），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/Ia7IHJ3426.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/26/BioStatistics/生物统计-StatQuest学习笔记15-MDS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/26/BioStatistics/生物统计-StatQuest学习笔记15-MDS/" itemprop="url">StatQuest学习笔记15——MDS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-26T12:10:54+08:00">
                2018-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,486
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列视频教程的第44和第45节，其中，第44讲的是多维尺度变换（multidimensional scaling，MDS）与主坐标分析（principal coordinate analysis,PCoA）。第45节讲的是用R来计算MDS和PCoA。</p>
<h2 id="mds">MDS</h2>
<h3 id="mds的分类">MDS的分类</h3>
<p>MDS与PCA非常相似，都是一种降维的方法。MDS分为度量MDS（Metric Multidimensional scaling）和非度量MDS（Non-metric Multidimensional scaling），其中非度量MDS也称为经典（Classical）MDS，也叫做主坐标分析（principal coordinate analysis,PCoA），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/I0JJiH2m9m.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="mds的基本思想">MDS的基本思想</h3>
<p>为了更方便地理解MDS，我们还是像介绍PCA那些，先讲一个比较简单的例子，例如，我们在下面的图形中，我们先看一群绿色的点，把它们当成是一群正常的细胞（当然了，如果你不是做生物的，你也可以把它们视为一群人，或一批汽车，或者城市等），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/hfJBB7E01k.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>虽然这群细胞看起来比较像，但实际上，它们有可能不同，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/eHbm8Em37b.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>当然了，还有可能像这个样子，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/0lCjI2f6Lj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但问题就在于，仅从直观的角度来看，我们不太容易区分它们，但我们可以通过类似RNA-Seq这样的手段来发现这些细胞有哪些基因是活跃的，这样就可以理解这些细胞的具体功能，如果这是一群人，我们可以测量他们的血压，身高等数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/FDeK8BdJHd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们就当它们是细胞，这是测完RNA-seq的一些数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/jB1584cJhj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中，第1行表示的是样本，第1列是基因名，其余的部分是不同样本某个基因的表达水平，此时，如果根据我们前面介绍的PCA法对这些数据进行分析，那么我们就能把不同样本之间的相互关系转换到一个二维的坐标图上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/f4d0ahIb0G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那些高度相关的样本就会聚集成一块，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/g4jkaDBc2E.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们再回到MDS和PCoA上来，这两种方法非常像PCA，只是它们不是把样本之间的相互关系转换成二维坐标，而是把不同样本之间的距离转换成二维坐标，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/mC7Gk6cjhe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了进行MDS和PCoA分析，我们可以计算两两样本之间的距离，就像下面的这个样子，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/Cge1Ee7eGE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了方便理解，我们此时就只计算一下Cell1和Cell2的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/24Kh9L38dI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="欧氏距离">欧氏距离</h3>
<p>一种常见的计算两个样本之间距离的方法是欧氏距离(Euclidean Distance) 计算法，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/CgIJBkAlK0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果此时我们只有两个基因，就像下面的这个样子，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/3i5k85mjCH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了计算这两个样本之间的欧氏距离，我们可以用线段来表示它们基因之间的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/DhFbhicIB2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后通过勾股定理，计算出欧氏距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/IEekfl2k6k.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们有更多的基因，那么就按照这种方法，求出两个样本中，相同基因的差值，再求其平方和的平方根，像下面的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/F7CfmEd961.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>一旦我们计算好了不同样本之间的欧氏距离，那么我们就可以把这些样本绘制到一个二维坐标图上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/IiLHe9K2C6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>利用欧氏距离（Euclidean Distance）来进行的MDS和PCoA分析的一个局限就是，最终生成的二维坐标轴基本上与PCA生成的二维坐标图是一样的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/ElAbHaGDm2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>换句话讲，这种基于最小线性距离的聚类（clustering）与最大化线性相关是一样的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/cFlFHDKgA4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>不过，计算两两样本之间的距离并非只有欧氏距离（Euclidean Distance）一种方法，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180627/1HJLh9KccE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="其他距离方法">其他距离方法</h3>
<p>例如，另外一种计算两两样本之间的距离方法就是计算基因间差值的log转换的平均值，例如在下面的案例中，对于Cell1和Cell2的Gene1，它经过log转换后的数值就是<code>log(3/0.25)</code>，同理，Gene2和Gene 8的计算也同样如此，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/clhfD69k9l.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>经过计算，再取它们的绝对值，最终我们计算出这些数值的平均值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/6H99LKLa7I.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终我们看一下分别使用了欧氏距离的MDS图（左侧）和使用了差异倍数log转换的MDS图的坐标轴（右侧），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/icHHd1gKJ9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>不过，在生物学家眼中，通常会选择表达差异倍数的log转换值来计算两两样本之间的距离，因为他们研究的基因通常是成倍变化的，这样用表达差异倍数的log转换会比较合适，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/lA62j8Bdd8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们常见的计算样本间距离的方法有：曼哈顿距离（Manhattan Distance）、汉明距离（Hamming Distance）、大圆距离（Great Circle Distance）等，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/baE8kdC9bK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="总结">总结</h2>
<p>PCA构建二维坐标图的方法基础是不同样本之间的相关性，而MDS和PCoA构建二维坐标图的方法基础则是基于不同样本之间的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/30JEFaj9hb.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>PCA的计算流程为：计算样本间的相关性 -&gt; 复杂数学运算（主要是特征值分解） -&gt; 绘图、主成分变异，Loading Scores。</p>
<p>而MDS和PCoA的计算流程与PCA的计算流程的不同之处就在于，第一步是计算样本间的距离，其余的部分与PCA的计算差异不大。</p>
<h2 id="r与mdspcoa">R与MDS/PCoA</h2>
<h3 id="生成模拟数据集">生成模拟数据集</h3>
<p>在使用R进行MDS/PCoA分析之前，我们还需要使用R来生成一些随机数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(ggplot2)</div><div class="line">data.matrix &lt;- matrix(nrow=<span class="number">100</span>, ncol=<span class="number">10</span>)</div><div class="line"><span class="comment"># generate some fake data</span></div><div class="line"><span class="comment"># This dataset consists of a matrix with 10 columns, corresponding to 10 samples</span></div><div class="line"><span class="comment"># and 100 rows, corresponding to measurements from 100 genes</span></div><div class="line"></div><div class="line">colnames(data.matrix) &lt;- c(</div><div class="line">  paste(<span class="string">"wt"</span>, <span class="number">1</span>:<span class="number">5</span>, sep=<span class="string">""</span>),</div><div class="line">  paste(<span class="string">"ko"</span>, <span class="number">1</span>:<span class="number">5</span>, sep=<span class="string">""</span>))</div><div class="line"></div><div class="line">rownames(data.matrix) &lt;- paste(<span class="string">"gene"</span>, <span class="number">1</span>:<span class="number">100</span>, sep=<span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">100</span>)&#123;</div><div class="line">  wt.values &lt;- rpois(<span class="number">5</span>, lambda = sample(x=<span class="number">10</span>:<span class="number">1000</span>, size = <span class="number">1</span>))</div><div class="line">  ko.values &lt;- rpois(<span class="number">5</span>, lambda = sample(x=<span class="number">10</span>:<span class="number">1000</span>, size = <span class="number">1</span>))</div><div class="line"></div><div class="line">  data.matrix[i,] &lt;- c(wt.values, ko.values)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终生成的数据如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(data.matrix)</div><div class="line">      wt1 wt2 wt3 wt4 wt5 ko1 ko2 ko3 ko4 ko5</div><div class="line">gene1 <span class="number">257</span> <span class="number">263</span> <span class="number">246</span> <span class="number">246</span> <span class="number">233</span> <span class="number">993</span> <span class="number">945</span> <span class="number">961</span> <span class="number">931</span> <span class="number">958</span></div><div class="line">gene2 <span class="number">822</span> <span class="number">888</span> <span class="number">866</span> <span class="number">845</span> <span class="number">855</span> <span class="number">232</span> <span class="number">210</span> <span class="number">217</span> <span class="number">209</span> <span class="number">225</span></div><div class="line">gene3 <span class="number">122</span> <span class="number">127</span> <span class="number">139</span> <span class="number">156</span> <span class="number">140</span> <span class="number">370</span> <span class="number">336</span> <span class="number">366</span> <span class="number">371</span> <span class="number">370</span></div><div class="line">gene4 <span class="number">812</span> <span class="number">806</span> <span class="number">874</span> <span class="number">860</span> <span class="number">896</span> <span class="number">918</span> <span class="number">934</span> <span class="number">963</span> <span class="number">939</span> <span class="number">982</span></div><div class="line">gene5 <span class="number">925</span> <span class="number">870</span> <span class="number">845</span> <span class="number">931</span> <span class="number">921</span> <span class="number">583</span> <span class="number">582</span> <span class="number">547</span> <span class="number">539</span> <span class="number">546</span></div><div class="line">gene6 <span class="number">646</span> <span class="number">611</span> <span class="number">644</span> <span class="number">676</span> <span class="number">644</span> <span class="number">535</span> <span class="number">590</span> <span class="number">530</span> <span class="number">537</span> <span class="number">551</span></div></pre></td></tr></table></figure>
<h3 id="pca分析">PCA分析</h3>
<p>为了比较MDS/PCoA分析和PCA分析的区别，在这里，我们先进行一下PCA的分析，代码跟上一篇笔记的PCA分析中的代码类似，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pca &lt;- prcomp(t(data.matrix), scale = <span class="literal">TRUE</span>, center=<span class="literal">TRUE</span>)</div><div class="line">pca.var &lt;- pca$sdev^<span class="number">2</span></div><div class="line">pca.var.per &lt;- round(pca.var/sum(pca.var)*<span class="number">100</span>, <span class="number">1</span>)</div><div class="line">pca.var.per</div><div class="line">pca.data &lt;- data.frame(Sample=rownames(pca$x),</div><div class="line">                       X=pca$x[,<span class="number">1</span>],</div><div class="line">                       Y=pca$x[,<span class="number">2</span>])</div><div class="line">pca.data</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; pca.var.per</div><div class="line"> [<span class="number">1</span>] <span class="number">87.8</span>  <span class="number">3.3</span>  <span class="number">2.6</span>  <span class="number">1.5</span>  <span class="number">1.4</span>  <span class="number">1.2</span>  <span class="number">0.8</span>  <span class="number">0.8</span>  <span class="number">0.6</span>  <span class="number">0.0</span></div><div class="line">&gt; pca.data &lt;- data.frame(Sample=rownames(pca$x),</div><div class="line">+                        X=pca$x[,<span class="number">1</span>],</div><div class="line">+                        Y=pca$x[,<span class="number">2</span>])</div><div class="line">&gt; pca.data</div><div class="line">    Sample         X          Y</div><div class="line">wt1    wt1 -<span class="number">8.698916</span>  <span class="number">1.8065989</span></div><div class="line">wt2    wt2 -<span class="number">8.724745</span> -<span class="number">2.5129243</span></div><div class="line">wt3    wt3 -<span class="number">8.848156</span>  <span class="number">0.1415564</span></div><div class="line">wt4    wt4 -<span class="number">9.161110</span>  <span class="number">1.2735904</span></div><div class="line">wt5    wt5 -<span class="number">8.993328</span> -<span class="number">0.7037979</span></div><div class="line">ko1    ko1  <span class="number">9.387947</span>  <span class="number">0.9745217</span></div><div class="line">ko2    ko2  <span class="number">9.093852</span> -<span class="number">1.2375433</span></div><div class="line">ko3    ko3  <span class="number">8.764754</span>  <span class="number">1.6803429</span></div><div class="line">ko4    ko4  <span class="number">8.584933</span>  <span class="number">1.6705990</span></div><div class="line">ko5    ko5  <span class="number">8.594769</span> -<span class="number">3.0929438</span></div></pre></td></tr></table></figure>
<p>绘制PCA图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ggplot(data=pca.data, aes(x=X, y=Y, label=Sample))+</div><div class="line">  geom_text() +</div><div class="line">  xlab(paste(<span class="string">"PC1 - "</span>, pca.var.per[<span class="number">1</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>))+</div><div class="line">  ylab(paste(<span class="string">"PC2 - "</span>, pca.var.per[<span class="number">2</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>))+</div><div class="line">  theme_bw()+</div><div class="line">  ggtitle(<span class="string">"My PCA Graph"</span>)</div></pre></td></tr></table></figure>
<p>最终图形如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/EBjkj14JCd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中PC1占据了总变异的87.7%，PC2占据了总变异的3.3%。另外，在图上我们可以看出，wt组都位于左侧，ko组都位于右侧，它们主要是被PC1区分了开来。</p>
<h3 id="mdspcoa分析">MDS/PCoA分析</h3>
<p>第一步，构建距离距离，使用<code>dist()</code>函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">distance.matrix &lt;- dist(scale(t(data.matrix), center=<span class="literal">TRUE</span>, scale=<span class="literal">TRUE</span>),</div><div class="line">                        method=<span class="string">"euclidean"</span>)</div><div class="line"><span class="comment"># parameter of method has 6 types different distnace to choose</span></div></pre></td></tr></table></figure>
<p>第二步：在距离矩阵的基础上进行多维尺度变换，这里使用<code>cmdscale()</code>函数，这个函数的名称比较奇怪，其实它是Classical Muti-Dimensional Scaling的缩写，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mds.stuff &lt;- cmdscale(distance.matrix, eig=<span class="literal">TRUE</span>, x.ret=<span class="literal">TRUE</span>)</div><div class="line"><span class="comment"># eig=TRUE willl return eigen values</span></div></pre></td></tr></table></figure>
<p>其中使用<code>eig=TRUE</code>会返回特征值，用这些特征来计算最终MDS图中的每个坐标占距离矩阵总变异的比例。<code>x.ret=TRUE</code>用于表示是否返回双中心对称的距离矩阵。如果使用<code>eigen()</code>函数替代<code>cmdscale()</code>函数来演示做MDS分析时，这就比较有用（不太理解这一段的意思），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/LLdkJfEAhl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三步：计算MDS图中的每个坐标占总变异的比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mds.var.per &lt;- round(mds.stuff$eig/sum(mds.stuff$eig)*<span class="number">100</span>,<span class="number">1</span>)</div><div class="line">mds.var.per</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mds.var.per</div><div class="line"> [<span class="number">1</span>] <span class="number">87.8</span>  <span class="number">3.3</span>  <span class="number">2.6</span>  <span class="number">1.5</span>  <span class="number">1.4</span>  <span class="number">1.2</span>  <span class="number">0.8</span>  <span class="number">0.8</span>  <span class="number">0.6</span>  <span class="number">0.0</span></div></pre></td></tr></table></figure>
<p>第四步：绘图，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mds.values &lt;- mds.stuff$points</div><div class="line">mds.data &lt;- data.frame(Sample=rownames(mds.values),</div><div class="line">                       X=mds.values[,<span class="number">1</span>],</div><div class="line">                       Y=mds.values[,<span class="number">2</span>])</div><div class="line"></div><div class="line">ggplot(data=mds.data, aes(x=X, y=Y, label=Sample))+</div><div class="line">  geom_text() +</div><div class="line">  xlab(paste(<span class="string">"MDS1 - "</span>, mds.var.per[<span class="number">1</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>))+</div><div class="line">  ylab(paste(<span class="string">"MDS2 - "</span>, mds.var.per[<span class="number">2</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>))+</div><div class="line">  theme_bw()+</div><div class="line">  ggtitle(<span class="string">"MDS plot using Euclidean distance"</span>)</div></pre></td></tr></table></figure>
<p>最终图形如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/JCL9LbbDKe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从MDS的这个图形中我们可以看出来，它的结果与PCA比较类似，都是wt组位于左侧，ko组位于右侧，其中MDS1所占总变异的87.8%，MDS2占总变异的3.3%。</p>
<p>实地上，PCA的图与MDS的图不仅看上去相似，实际上它们是一样的，我们把PCA的图与MDS的图放一起来比较看一下：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/amK4Ik0c5H.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我生成的图形与教程中不太一样，教程中的这两张图基本上是一样的，并且发现，貌似MDS中的点的位置正好与PCA中的相应点的位置正好相反，此时，还不清楚怎么解决，先放这里。</p>
<h4 id="使用其它的距离">使用其它的距离</h4>
<p>前面使用的欧氏距离，此时我们使用一下其它的距离，例如表达差异的log值转换，其实对于基因表达差异的常用分析，通常是用<code>edgeR</code>来完成的，此处我们使用<code>plotMDS()</code>函数进行表达差异的log值计算，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/3L3i4J7d75.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第一步：计算每个基因表达是不是的log2值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log2.data.matrix &lt;- log2(data.matrix)</div></pre></td></tr></table></figure>
<p>由于差异倍数的log转换值的平均值并不是一种距离度量，无法直接被<code>dist()</code>函数调用，因此我们需要手动来计算距离，下面的代码是创建一个空矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">log2.data.matrix &lt;- log2(data.matrix)</div><div class="line"></div><div class="line">log2.distance.matrix&lt;- matrix(<span class="number">0</span>,</div><div class="line">                              nrow=ncol(log2.data.matrix),</div><div class="line">                              ncol=ncol(log2.data.matrix),</div><div class="line">                              dimnames = list(colnames(log2.data.matrix),</div><div class="line">                                              colnames(log2.data.matrix)))</div><div class="line">log2.distance.matrix</div></pre></td></tr></table></figure>
<p>log2.distance.matrix的这个矩阵如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; log2.distance.matrix</div><div class="line">    wt1 wt2 wt3 wt4 wt5 ko1 ko2 ko3 ko4 ko5</div><div class="line">wt1   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">wt2   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">wt3   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">wt4   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">wt5   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">ko1   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">ko2   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">ko3   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">ko4   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div><div class="line">ko5   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></div></pre></td></tr></table></figure>
<p>然后，向这个矩阵填表达差异倍数log转换值绝对值平均值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/59l2GaGhBH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:ncol(log2.distance.matrix))&#123;</div><div class="line">  <span class="keyword">for</span>(j <span class="keyword">in</span> <span class="number">1</span>:i)&#123;</div><div class="line">    log2.distance.matrix[i,j]&lt;-</div><div class="line">      mean(abs(log2.data.matrix[,i] - log2.data.matrix[,j]))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>填充后的矩阵如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt; log2.distance.matrix</div><div class="line">           wt1       wt2        wt3        wt4      wt5        ko1        ko2</div><div class="line">wt1 <span class="number">0.00000000</span> <span class="number">0.0000000</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span> <span class="number">0.000000</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span></div><div class="line">wt2 <span class="number">0.11484382</span> <span class="number">0.0000000</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span> <span class="number">0.000000</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span></div><div class="line">wt3 <span class="number">0.09904503</span> <span class="number">0.1019653</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span> <span class="number">0.000000</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span></div><div class="line">wt4 <span class="number">0.09221168</span> <span class="number">0.1037076</span> <span class="number">0.09493001</span> <span class="number">0.00000000</span> <span class="number">0.000000</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span></div><div class="line">wt5 <span class="number">0.09885778</span> <span class="number">0.1108717</span> <span class="number">0.09948529</span> <span class="number">0.09023129</span> <span class="number">0.000000</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span></div><div class="line">ko1 <span class="number">1.31334287</span> <span class="number">1.2943370</span> <span class="number">1.29838285</span> <span class="number">1.29338723</span> <span class="number">1.282153</span> <span class="number">0.00000000</span> <span class="number">0.00000000</span></div><div class="line">ko2 <span class="number">1.29918744</span> <span class="number">1.2802797</span> <span class="number">1.28559603</span> <span class="number">1.28138419</span> <span class="number">1.268754</span> <span class="number">0.09949390</span> <span class="number">0.00000000</span></div><div class="line">ko3 <span class="number">1.29038890</span> <span class="number">1.2721498</span> <span class="number">1.27904237</span> <span class="number">1.27301615</span> <span class="number">1.263254</span> <span class="number">0.09166573</span> <span class="number">0.09141794</span></div><div class="line">ko4 <span class="number">1.30741667</span> <span class="number">1.2850593</span> <span class="number">1.29054531</span> <span class="number">1.28755635</span> <span class="number">1.273766</span> <span class="number">0.09707109</span> <span class="number">0.09566890</span></div><div class="line">ko5 <span class="number">1.29516621</span> <span class="number">1.2726247</span> <span class="number">1.27697549</span> <span class="number">1.27384192</span> <span class="number">1.260347</span> <span class="number">0.10435400</span> <span class="number">0.10674809</span></div><div class="line">           ko3        ko4 ko5</div><div class="line">wt1 <span class="number">0.00000000</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">wt2 <span class="number">0.00000000</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">wt3 <span class="number">0.00000000</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">wt4 <span class="number">0.00000000</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">wt5 <span class="number">0.00000000</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">ko1 <span class="number">0.00000000</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">ko2 <span class="number">0.00000000</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">ko3 <span class="number">0.00000000</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">ko4 <span class="number">0.08960051</span> <span class="number">0.00000000</span>   <span class="number">0</span></div><div class="line">ko5 <span class="number">0.10106993</span> <span class="number">0.09935345</span>   <span class="number">0</span></div></pre></td></tr></table></figure>
<p>此时，使用新的矩阵进行MDS分析，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mds.stuff &lt;- cmdscale(as.dist(log2.distance.matrix),</div><div class="line">                      eig=<span class="literal">TRUE</span>,</div><div class="line">                      x.ret=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>接着计算MDS图中每个坐标所占总变异的比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mds.var.per &lt;- round(mds.stuff$eig/sum(mds.stuff$eig)*<span class="number">100</span>,<span class="number">1</span>)</div><div class="line">mds.var.per</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mds.var.per</div><div class="line"> [<span class="number">1</span>] <span class="number">99.1</span>  <span class="number">0.3</span>  <span class="number">0.2</span>  <span class="number">0.1</span>  <span class="number">0.1</span>  <span class="number">0.1</span>  <span class="number">0.1</span>  <span class="number">0.1</span>  <span class="number">0.0</span>  <span class="number">0.0</span></div></pre></td></tr></table></figure>
<p>绘图，绘图前先把数据转换成ggplot能识别的格式，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mds.values &lt;- mds.stuff$points</div><div class="line">mds.data &lt;- data.frame(Sample=rownames(mds.values),</div><div class="line">                       X=mds.values[,<span class="number">1</span>],</div><div class="line">                       Y=mds.values[,<span class="number">2</span>])</div><div class="line">mds.data</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; mds.data</div><div class="line">    Sample          X           Y</div><div class="line">wt1    wt1 -<span class="number">0.6577291</span>  <span class="number">0.05852077</span></div><div class="line">wt2    wt2 -<span class="number">0.6369172</span> -<span class="number">0.01660477</span></div><div class="line">wt3    wt3 -<span class="number">0.6427329</span> -<span class="number">0.02665479</span></div><div class="line">wt4    wt4 -<span class="number">0.6386594</span>  <span class="number">0.01136691</span></div><div class="line">wt5    wt5 -<span class="number">0.6262231</span> -<span class="number">0.02766676</span></div><div class="line">ko1    ko1  <span class="number">0.6529016</span>  <span class="number">0.01159350</span></div><div class="line">ko2    ko2  <span class="number">0.6394952</span>  <span class="number">0.02054915</span></div><div class="line">ko3    ko3  <span class="number">0.6323059</span>  <span class="number">0.04457294</span></div><div class="line">ko4    ko4  <span class="number">0.6455593</span> -<span class="number">0.02576489</span></div><div class="line">ko5    ko5  <span class="number">0.6319998</span> -<span class="number">0.04991206</span></div></pre></td></tr></table></figure>
<p>此时，使用ggplot绘图，代码如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ggplot(data=mds.data, aes(x=X, y=Y, label=Sample)) +</div><div class="line">  geom_text()+</div><div class="line">  theme_bw()+</div><div class="line">  xlab(paste(<span class="string">"MDS1 - "</span>, mds.var.per[<span class="number">1</span>],<span class="string">"%"</span>, sep=<span class="string">""</span>))+</div><div class="line">  ylab(paste(<span class="string">"MDS2 - "</span>, mds.var.per[<span class="number">2</span>],<span class="string">"%"</span>, sep=<span class="string">""</span>))+</div><div class="line">  ggtitle(<span class="string">"MDS plot using avg(logFC) as the distance"</span>)</div></pre></td></tr></table></figure>
<p>图形如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/H581CBICC5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们把利用欧氏距离绘制的MDS图和表达差异log转换后的MDS图比较一下，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/hL1BmlhhEj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从上图中可以发现，这两个图比较相似，但是不一样。我们看一下两张图的坐标轴，右侧MDS-1的是99.1%，左图是87.8%，也就是说使用了log转换后的表达倍数差异值所占总变异的比例更高。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/24/Principle/各种基因名笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/24/Principle/各种基因名笔记/" itemprop="url">各种基因名笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-24T12:00:00+08:00">
                2018-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物信息学/" itemprop="url" rel="index">
                    <span itemprop="name">生物信息学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,010
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基因名">基因名</h2>
<p>不同的数据据中的对于一个基因的描述不同，例如p53，它又叫P53，又叫TP53，或BCC7，或ENSG00000141510或OTTHUMG00000162125。通常来说，对p53的描述使用的是Official Gene Symbol（例如TP53）。</p>
<p>另外，在NCBI数据库中我们查找TP53，会出现下面这些信息：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180624/bCd0JaAJcB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们从第一行开始解释：</p>
<ol style="list-style-type: decimal">
<li><code>TP53 tumor protein p53 [ Homo sapiens (human) ]</code>：它表示这个基因是TP53肿瘤蛋白53，TP表示的是tumor protein，p表示的是protein，53的意思是这个蛋白的分子量是53kDa（其实当初在跑SDS-PAGE胶时，这个蛋白位于53kDa附近，就命名为p53，其实后来发现，这个蛋白中富含脯氨酸，在SDS-PAGE胶中迁移速度偏慢，它表示出来的分子量要比实际的分子量大，此蛋白的实际分子量是43.7kDa，不过由于命名太久了，也就将错就错了），后面的<code>Homo sapiens (human)</code>是人类的意思，它表示这个基因是人源的。</li>
<li><code>Gene ID</code>：7157，表示的是基因的entrez的系统代号，Entrez 是美国国家生物技术信息中心所提供的在线资源检索器。该资源将GenBank序列与其原始文献出处链接在一起。如果我们在Entrez中直接检索7157，也能直接搜索到TP53。Entrez ID实际上是指的Entrez gene ID，是对应于染色体上一个gene location的。每一个发现的基因都会被编制一个统一的编号，而Entrez ID是指的来自于NCBI旗下的Entrez gene数据库所使用的编号。每个基因的编号具有唯一性，包括不同种属生物间的同源基因编号也不相同，例如同样是TP53基因，人源TP53的Entrez ID为7157，zebrafish源的Entrez ID为30590，chichen源的Entrez ID为396200。EntrezID标记的基因具有唯一性，可以理解为它就是基因的身份证，通过一串数字就能区分每个基因。</li>
<li><code>Official Symbol</code>，这个是我们常用的这个基因的名称，即TP53，这个命名是由HGNC批准的，HGNC的全称是HUGO Gene Nomenclature Committee，其中HUGO的全称是Human Genome Organisation，即国际人类基因组组织，而HGNC则是HUGO基因命名委员会。</li>
<li><code>Official Full Name</code>，官方的全称。</li>
<li><code>Ensembl:ENSG00000141510</code>：ENSEMBL是一个由由英国Sanger研究所Wellcome基金会及欧洲分子生物学实验室所属分部欧洲生物信息学研究所共同协作运营的一个数据库。Ensembl数据库的基因名称后面有的还有个小数点，这个表示基因的版本号，没多少用处，在进行生信分析的时候，可以去掉。</li>
<li>MIM:191170。OMIM 为“0nline Mendelian Inheritance in Man”的简称，即在线《人类孟德尔遗传》，是一个关于人类基因和遗传紊乱的数据库（持续更新）。主要着眼于遗传性的基因疾病，包括文本信息和相关参考信息、序列纪录、图谱和相关其他数据库。其中MIM号就是在OMIM数据库中的基因编号。</li>
<li><code>Vega:OTTHUMG00000162125</code>。脊椎动物基因组注释（Vertebrate Genome Annotation，Vega）数据库已经被设计为浏览来自各种脊椎动物基因组的完结序列的人工注释的一个社区资源。它的核心数据库是基于Ensembl样式的模式，扩展到包含精选-特异的元数据。</li>
</ol>
<p>常用的基因名转换工具：</p>
<ol style="list-style-type: decimal">
<li>DAVID：https://david.ncifcrf.gov/</li>
<li>Absolute Gene ID Conversion Tools：http://bioinformatics.louisville.edu/abid/</li>
<li>bioDBnet：（https://biodbnet-abcc.ncifcrf.gov/db/db2db.php）</li>
<li>ENSEMBL biomart：（http://asia.ensembl.org/biomart/martview/bbd9fa2dd0eac95aa098be3514472b0e）</li>
<li><code>bitr</code>是<code>clusterProfiler</code>包中的一个函数，它用于生物ID的转换，用法如下所示:</li>
</ol>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bitr(geneID, fromType, toType, OrgDb, drop = <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>其中，geneID是输入的基因ID，fromType是输入的ID类型，<code>toType</code>是输出的ID类型，<code>OrgDb</code>注释的db文件，<code>drop</code>剔除NA数据与否。</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://blog.csdn.net/liufeichendi/article/details/78819884" target="_blank" rel="external">各类基因ID转换</a></li>
<li>简述几种Gene ID的转换方法<br>
</li>
<li><a href="https://www.douban.com/note/544090098/" target="_blank" rel="external">OMIM数据库</a></li>
<li><a href="https://vip.biotrainee.com/d/109-entrez-id" target="_blank" rel="external">浅谈Entrez ID</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/23/BioStatistics/生物统计-StatQuest学习笔记14-PCA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/23/BioStatistics/生物统计-StatQuest学习笔记14-PCA/" itemprop="url">StatQuest学习笔记14——PCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-23T12:10:54+08:00">
                2018-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,551
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列视频教程的第39-43节，其中39节的内容是PCA；第40节的内容是PCA的基本思想；第41小节的内容还是PCA，此处与第39小节的内容重复，不记笔记，略过；第42节的内容是R语言与PCA；第43节的内容是Python与PCA。为了使笔记更有条理，笔记的顺序是按照视频教程40，39，42，43节的顺序进行的。</p>
<h2 id="pca的基本思想">PCA的基本思想</h2>
<p>我们先从最简单的案例入手，先看下面的一堆绿色的圆圈，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/mCGjjEiDid.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们可以把这些绿色圆圈当成一群正常的细胞，当然了，如果你不是学生物的，你也可以把它们理解成一群人，一群卡车，一群城市等，总之是一群事物。虽然这一群细胞看上去是一样的（至少表面上一样），但是，它们本质上也有可能不一样，例如像下面的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/7I3AhkDEij.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这群细胞分成了三群，不过从直观上来看，你太不容易能看出这一群细胞划分成了三群。</p>
<p>为了能够严格地划分这些细胞，我们可以对这些细胞进行测序，确认这些细胞中有哪些基因处于活跃状态，我们就能知道这些细胞的功能，这样就知道了这些细胞的种类，当然了，如果这是一群人，我们可以测量他们的身高，血压等，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/i9lDC77hHF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>现在我们测了这些细胞的基因，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/KEgBiH86A6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>假设，我们此时没有那么多细胞，只有2个细胞，那么我们就可以把这两个细胞的所有基因画在一个坐标上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/bj09g4b0dJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>就像上图显示的这样，基因1在细胞1中的高表达，而在细胞2中低表达，而基因9正好相反，在细胞1中低表达，而在细胞2中高表达，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/ej4hlkcIgC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从我们所列出的数据来看，细胞1和细胞2的基因表达水平很多呈相反的水平，那么我们很容易就知道，这两个细胞必定不是同一种类的细胞，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Ek8LmbBmck.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们把问题升级一下，我们有3个细胞，现在利用二维坐标系分别绘制出这三个细胞两两之间的基因表达水平，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Fa92jjgc8a.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但这种两两之间的比较太麻烦了，我们可以直接把它们放到一个三维坐标系中进行比较，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/91L0Hl5Hm5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个三维坐标系中，它的三个坐标轴分别表示细胞1，细胞2，细胞3，我们通过旋转坐标轴就可以发现每两个细胞之间的关系。</p>
<p>现在把问题再进一步，如果我们有4个细胞，比较直观的手段就是分别画出这4个细胞两两的平面坐标系，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/LmBCGaA1Bj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>或者是画出一个四维的坐标系，像下面的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/G8FbIEBD64.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但前面的方法就不太适用于这种情况，例如四维坐标就不太直观，此时我们可以采用主成分分析（PCA）的方法来对细胞分类。</p>
<p>PCA可以将不同细胞之间的关系转换到一个平面坐标系中，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/J5k20AKcHj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时我们可以发现，通过PCA这种方法，可以把一群细胞中高度相关的细胞聚集起来，像下面的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/0CDh0j5clF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了能够更直观地说明这种分析方法，我们可以把不同的细胞换成不同的颜色，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/i2DIkm3Cei.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们再回到最初的问题上来，通过PCA方法可以把一群细胞中高度相关的细胞给区分开来，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Chaf62gGdH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="pca的结果解释">PCA的结果解释</h2>
<p>此时我们来看一下，PCA的结果具体是什么含义，在PCA图中，它的坐标轴是按重要性进行排序的。其中PC1是第一主成分轴，它的重要性要强于PC2，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/3Hh8beb4m7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>假如一个PCA长得是下面的这个样子，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/9800044dAE.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，如果左上角的绿点与左下角的红点的距离是d1，右下角的黄点与左下角红点的距离是d2，此时d1=d2的话，那么我们就可以认为，黄色点与红色点的差异要大于绿色点与红色点的差异（因为PC1的坐标是第一主成分），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/HbffALgfcF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在我们了解了PCA之后，我们应该知道，PCA仅仅是一种划分不同数据类型的方法之一，此外，还有其他基于降维的统计学方法（dimension reduction），例如热图，t-SNE图，多维缩放（multi-dimensional scaling，MDS）等，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/6AfcGdaC8G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="pca的计算原理">PCA的计算原理</h2>
<h3 id="简单案例">简单案例</h3>
<p>在这一部分，我们使用SVD（singular value decomposition，中文译名“奇异值分解”）的方法来计算PCA。我们先看一个简单的案例，在这个案例中，我们检测了6只不同小鼠的2个基因，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/JJk9FI2bHl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其实我们可以把它再抽象化一下，把小鼠看成样本，基因看成2个变量，就像下面的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Em4HC50mh4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们还以小鼠的基因为例说明，如果我们只检测1个基因的话（Gene 1），那么我们根据基因1表达的情况，把小鼠的绘制到数轴上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/g7cj9J5fDj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中小鼠1，小鼠2，小鼠3的Gene 1表达水平比较高，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/I21b9F0EIi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而小鼠4，小鼠5，小鼠6的Gene 1水平则较低，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/a7dch4dbi7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>虽然这个图形比较简单，但是，我们从中还是能得到一些信息的，例如小鼠1，小鼠2和小鼠3比较接近，小鼠4，小鼠5和小鼠6比较接近，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/461AK884aI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们检测了2个基因，那么我们可以绘制一个二维坐标系，横轴是Gene 1，纵轴是Gene 2，那么小鼠1，小鼠2和小鼠3会聚在一起，小鼠4，小鼠5和小鼠6会聚在一起，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/KLDhhiH4D0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再进一步，如果我们检测了3个基因，那么我们可以绘制三维的坐标系，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/gaIeE8mgg9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在上图的这个3维坐系中，圆点越大，表示离你越近。</p>
<p>再进一步，如果我们检测了4个基因，此时我们很难绘制出四维的坐标系，那么我们就需要进行PCA分析了，PCA可以把超过4个的基因降维成二维的坐标系，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/KdBIKLiAm6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个PCA的二维坐标系中，我们可以发现，小鼠4、小鼠5和小鼠6是一类，小鼠1，小鼠2和小鼠3是一类，它们的各自的基因表达模式也类似，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/cCAGj8dhBg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>PCA在对数据进行聚类（clustering）时有很大的价值，例如，经过PCA分析，在它的二维坐标轴上我们可以发现，Gene 3在x轴上对样本的区分有贡献最大（这里不太理解为什么直接就看出了Gene 3，我猜测可能是基因3在这两群小鼠中的分布比较明显，一组高，一组低），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/CcC8D2kgm5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="计算原理">计算原理</h3>
<p>为了理解PCA是如何进行计算的，我们还回最初2个基因的案例上来，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/jKI4b7mE10.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着是计算过程。</p>
<p>第一，我们根据所有的样本的这两个基因的表达情况绘制出它们的平面坐标系，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/aJB9gBA8Ff.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第二，计算Gene 1表达水平的均值，就是下图中x轴上红叉的所在位置，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/jj12lll3ij.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第三，计算Gene 2表达水平的均值，就是下图中y轴上红叉的所在位置，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/ekE6CFh24a.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第四，有了Gene 1和Gene 2的这两个数值，我们就得到了整体数值的中心，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/KecAlDC79I.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们有了这个点（蓝叉所在位置）后，我们此时就不需要再看原始数据了，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/4f87ji9bKc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第五，我们把所有的数据点各左下角移动，将数据的中心与原点<code>(0,0)</code>重合，就像下面的这个样子，从左图移成右图的样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/6kHGL23a7A.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，虽然所有的数据点都移动了，但是每个点之间的相对距离是不变的，整体数据的中心就变成了原点<code>(0,0)</code>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/ag77labI60.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第六，我们找一条通过原点的直线，就像下面的这个样子，具体这条直线做什么的，先不用管：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/BI71C0ch8G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第七，旋转这条直线（红色虚线），使这条直线尽量匹配这些数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/cbbhJHa3Kf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>第八，最终，最匹配数据的直线就是下面的这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/dLL4fd0f49.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h4 id="第1主成分的计算原理">第1主成分的计算原理</h4>
<p>此时，我们可能有疑问，为什么这条直线是最匹配数据的，它的计算原理是什么，那么接着看。</p>
<p>我们先回到最初的直线，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/9ejiJk7I8m.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了准确地找出最佳匹配所有数据的直线，PCA会将所有数据点都役射到这条直线上来，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/BLHHg6GeK6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，可以计算这些数据点到投射到这条直线上的距离，并且使这些距离最小，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/bGFCed6Lcg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>除了可以计算数据点到直线的距离最小外，还要计算所有数据点投射到这条直线上的点（图中绿叉位置所在点）到原点的距离，使这个距离最大，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/LE8530JK45.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果你不理解上述的这种描述，那么还可以这么理解，当这条直线（红色虚线）尽量匹配这些数据点时，这些数据点到这条直线的距离是在缩小的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/g58GiLDD5G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>同样的，这些数据点投射到直线上的点到原点的距离是加大的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/21LfC4fiLJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了更好地以数学思维来理解这个过程，此时我们先看一个点的情况，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/58CghaiFl6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这个点是固定的，它到原点的距离也是固定的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/9J29llA58d.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>换句话讲，当直线（红色虚线）在旋转的过程中，这个点到原点的距离是不会变的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/h54L4bimBG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>当直线旋转到某一位置时，我们将这个点投射到直线上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/2k64FD0BLi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们会得到一个直角，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/f37m2clChK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>有了直角，我们就能得到如下的直角三角形，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/L9LhLA8b86.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们把这个直角三角形的三条边命名为<code>a</code>，<code>b</code>,<code>c</code>，那么根据勾股定理，我们就会得到这个公式，即<span class="math inline">\({a}^2={b}^2+{c}^2\)</span>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/J19amgjaK8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>三角形的斜边<code>a</code>是不会变的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/618DCbfk5D.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果直角边<code>b</code>变大的话，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/9bEFi4hJkJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么直角边<code>c</code>就会变小，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/9IefLHJf78.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>反之，也成立。而PCA计算的则是降低直角边<code>b</code>，也就是降低数据点投射到直线上的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/kGe9fh0KGF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>同时，PCA还要保证投到到直线上的点到原点的距离最大，也就是说要求<code>c</code>边最大，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/63kmmkaa3d.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>通过上面利用直角三角形的解释，就比较容易理解PCA计算最佳匹配直线的思路了。此时，再回到起点，将所有的数据点投射到直线上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/6kLA5Jm1Fg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后计算某个点到原点为的距离，我们把它命名为<span class="math inline">\({d}_1\)</span>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/CEEEEmDCJj.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>同理，计算第2点投射到直线上的点到原点的距离，命名为<span class="math inline">\({d}_2\)</span>，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/B9iHf7dmeg.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算剩余的点投射到直线上的点到原点的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/J72EbeiL1e.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后把这些值的平方加起来，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/d8E9CdcgBF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们旋转直线，直到最终这个<code>SS</code>的距离最大（这个距离最大，也就是说数据点到直线的距离最小）为止，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/HBmD9FF7cK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终，得到了我们想要的直线，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/l25cIEkClC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，这条直线就叫第一主成分（Principal Component 1，简称PC1），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/C1gG9C1ImD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>有了这个直线，它的斜率就很容易计算出来了，经计算，PC1的斜率为0.25，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Cg0JJ7m42I.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这个斜率0.25如何理解呢？它表示的意思就是，每当我们在Gene 1（x轴坐标）前进4个单位时，在这个直线上的数据点在Gene 2上就增加1个单位，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/beAGf9aLCH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果按照生物学意义来理解就是，这几个样本在Gene 1坐标轴上更加分散，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Bk5819h2aC.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而在Gene 2上的分散程度则较小，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/hlG7I56mfh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们可以根据鸡尾酒配方（cocktail recipe）来思考这个PC1（注：鸡尾酒是一种混合酒品，掺杂有不同的酒），例如为了生成PC1，我们可以加入4份的Gene 1，再加入1份的Gene 2，另外，我们可以发现，Gene 1与Gene 2的比值是4，它就说明在描述数据的分散程度方面，Gene 1这个基因更加重要，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Be8833JmCL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>但在数学上，把这种鸡尾酒配方（cocktail recipe）称为是Gene 1和Gene 2的线性组合（linear combination），在统计学上，描述PC1也可以这样，即“PC1是几个变量的一个线性组合”，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/4Cg0eje74K.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h4 id="第1主成分的特征值">第1主成分的特征值</h4>
<p>紧接上面的案例，继续进行，还要计算一些东西。对于PC1来说，它的斜率是0.25，那么我们在Gene 1增加4个单位，在Gene 2上就会增加1个单位，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/56H8B19Fi6.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么根据勾股定理，我们就可以计算出红色箭头的长度，长度为4.12，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/DaK5B1Gd76.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>当我们使用SVD（全称是Singular-value decomposition，中文是奇异值分解）进行PCA计算时，我们需要把这个红色箭头定义为1个单位，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/FE9cJC0kHI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>为了将这个红色箭头定义为1个单位，那么我们就要把这个三角形的各个连长都除以4.12，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/H77gcC99FH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么，除以4.12后，各个三角形的连长就成了这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/B44HjeFhlL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>也就是说三角形的三个边长分别变成了1，0.242，0.97，不过构成PC1的线性组合，即Gene 1和Gene 2的比值还是不变的，仍旧为4，那么此时我们就可以说取0.97份的Gene 1和0.242份的Gene 2，就构成了PC1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/316AcC8B5B.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们再回想一下我们计算PC1的整个过程：</p>
<ol style="list-style-type: decimal">
<li>原始数据；</li>
<li>最佳匹配直线；</li>
<li>单位向量计算，如下所示：</li>
</ol>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/jHBaDhB1jL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>图中的红色箭头是1个长度单位，它由0.97个Gene 1和0.242个Gene 2构成，它称为PC1的奇异向量（Singular vector），或者是特征向量（Eigenvector），而每个基因的比例则被称为载荷得分（Loading Scores），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/cDmE8fmFl2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此外，在PCA中，将SS（也就是各个点投射到最佳匹配的直线上的点到原点的距离的平方和）称为PC1的特征值（Eigenvalue），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/bGaiIK15di.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>PC1特征向量的值（Eigenvalue for PC1）的平方根被称为PC1的奇异值（Singular Value for PC1），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/098ACkB7Dc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h4 id="第2主成分的计算原理">第2主成分的计算原理</h4>
<p>前面是第1主成分（PC1）的计算，此时进行第2主成分的计算（PC2）。由于我们使用的二维坐标，PC2仅仅是一条通过了原点，并且与PC1垂直的直线，PC2并没有像PC1那样复杂的优化，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/b1Ch0Ij6je.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于PC2与PC1垂直，那么很容易地就能计算出PC2的斜率为-4，这也就是说，PC2是由-1个Gene 1和4个Gene 2构成的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/JeDhbL5174.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>当我们在PC2所在直线上定义一个单位长度的向量时，那么PC2就是由-0.242个Gene 1和0.97个Gene 2构成了，此时这个单位向量（蓝色箭头）就被称为PC2的奇异向量（Singular Vector）或特征向量（Eigenvector），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/m7Kb745lA2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而-0.242和0.97就是PC2的载荷分数，它表示的就是，基因2相当于4位的基因1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/3kGJlL1m6F.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>PC2的特征值则是数据点投到到PC2上的点到原点的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/1I74hCFjC2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，PC1和PC2的计算结束，绘制最终的PCA图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/092J48ddKi.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后旋转这个坐标，让PC1水平，PC2垂直，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/IcC32F9KL2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个新的坐标系中，图中黑色的叉就表示原始的样本6（Sample 6），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/DH5ad6fH06.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而Sample 6位于这个点上：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/jJ82IE9iD7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>同理，Sample 2在这里：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/0DGaCBm4bk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="各主成分的变异">各主成分的变异</h3>
<p>此时，再讲一些术语，先回忆一下前面的PC1的特征值和PC2的特征值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/AmFaa3li31.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们把原始的数据点投射到主成分上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/eGdLahED5m.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算投射到PC1上的点到原点的距离，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/09DIfJ8JJJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>所有的这些数值的平方和就是PC1的特征值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/fba5imkDhe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们也可以将特征值转为PC1到原点的变异，方法就是SS除以样本数减1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/1lLLkmLILc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>以这个案例为例说明，假如PC1的变异（Variation）为15，PC2的变异为3，这就表明主成分的总变异为18，那么也就是说PC1在总变异中所占的比值为83%（15/18=0.83），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/3KCh270B3h.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>而PC2占的总变异为17%（3/18=0.17），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/GhKHC6FG2a.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，我们把这两个主成分所占的比例画出来，这种图与条形图很像，不过在PCA中，这叫碎石图（scree plot），每个矩形表示每个PC所占总变异的比值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/05DdaJEiBB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="一个复杂案例">一个复杂案例</h2>
<p>我们看一个比较复杂的案例，在这个案例中，6只小鼠，检测了3个基因，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/8c0bF29BCk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>按照前面的思路，找到数据的中心，并将其移到原点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/aHJfHBm0gh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>找到最佳的匹配数据的直线，也就是PC1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Lh7L1cfL7G.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>不过这个PC1有3个成分，分别是0.62个Gene 1，0.15个Gene 2和0.77个Gene 3，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/0EL1h006kJ.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中，Gene3 是最主要的组成部分，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/abLgJG8IAf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后寻找PC2，PC2通过原点，并与PC1垂直，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/34da1hfI95.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最终，PC2的成分为0.77个Gene 1，0.62个Gene 2和0.15个Gene 3，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/3FJb3cEb8j.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在PC2中，Gene 1是最主要的组成部分，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/7KFeHcDk1F.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后，我们寻找PC3，PC3通过原点，同时与PC1和PC2垂直，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/cble1hcJfD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们有更多的基因，那么我们就会不断地寻找更多的主成分，也就是说不断地往这个坐标中加入与前一个主成分垂直的直线，从理论上讲，一个基因就有一个主成分（例如这个案例中，3个基因，最终找到了3个主成分），因此，主成分的数目要么跟变量相等，要么跟样本的数目相等（这个数目还是比较小的），如下所示：</p>
<div class="figure">
<img src="C:\Users\20161111\AppData\Local\Temp\1529938792438.png" alt="1529938792438">
<p class="caption">1529938792438</p>
</div>
<p>不过，真正在进行PCA的时候，最终的主成分数目是有限的，这个马上就要讲到。一旦计算出来了所有的主成分，那么我们就可以使用特征值来计算每个主成分的变异占总变异的比例，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/F9ifHAj37K.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个案例中，PC1的变异占总变异的79%，PC2占15%，PC3占6%，把这些主成分绘制成碎石图，就是下图左图的样子，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/jij1ldCbaI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从碎石图中我们可以看到，PC1和PC2占了变异的绝大比例，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/9Elb5ed2KF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这就表明了，在二维图中，我们基本上只使用PC1和PC2就能解释三维图中的数据，因为二维图中的PC1和PC2占据了整体的变异的94%，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/g9kID1h7KF.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们将三维图转换为二维图，画出PC1和PC2，以及原始数据点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/4Cc520fGLH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>将数据投射到这个新坐标的PC1上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/G86kJfLLck.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再投射到PC2上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/BLeLkdebhB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>然后，我们把这个坐标旋转一下，方便查看，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/15kaBDkIi2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>下面的这个点就是Sample 4对应的点，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/1iDbi4dBJ4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们再来回顾一下这个案例，首先我们把所有的数据点绘制到三维坐标中，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/mjj5Fj7CLI.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再计算主成分，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/IAHF0J93l5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>再计算主成分的特征值与变异比例，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/2chhIL90dL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后，我们使用PC1和PC2这个二维坐标来描述原始数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/J8e3b25ke2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们检测了6个样本的4个基因，那么我们并不需要绘制出4维坐标图，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/eCjh8JIILD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们可以计算出它们的主成分，画出碎石图，其中我们可以发现，PC1和PC2占据了变异的90%，那么我们仅使用PC1和PC2构成的二维PCA图就可以表示原始数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/Kella78eI2.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>将原始数据分别投射到PC1和PC2上，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/m137IB8C16.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>下面的这两个点就对应了Sample 2，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/GAJJ6k3h53.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>也就是这个点：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/fcImd6eh6I.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>那么，所有的点就是这个样子：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/LDcAchEdi7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>如果我们遇到下面的这种碎石图，在这种碎石图中，PC3和PC4也占据了相当比例的总变异，那么我们仅使用2个主成分（也就是PC1和PC2）就无法精确地代表原始数据，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/1808d217JG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>不过，即使是有瑕玼的PCA二维图，也可以用于数据的分类，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/E00bf5HFJD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在这个图中，黑色的点仍然可以被视为比较接近的类似，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/L9k065Dcl1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h2 id="r语言与pca">R语言与PCA</h2>
<p>计算PCA的工具很多，这里我们介绍一下用R来计算PCA，在R中，计算PCA的函数是<code>prcomp()</code>，绘图包是<code>ggplot2</code>，使用R，我们可以知道每个主成分的变异占总变异的比值，以及计算载荷得分（loading scores），发现哪个变量对图形的影响最大，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180625/meEml78Ihc.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="生成数据集">生成数据集</h3>
<p>我们先生成一个数据集，代码如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">data.matrix &lt;- matrix(nrow=<span class="number">100</span>, ncol=<span class="number">10</span>)</div><div class="line">colnames(data.matrix) &lt;- c(</div><div class="line">  paste(<span class="string">"wt"</span>,<span class="number">1</span>:<span class="number">5</span>,sep=<span class="string">""</span>),</div><div class="line">  paste(<span class="string">"ko"</span>,<span class="number">1</span>:<span class="number">5</span>,sep=<span class="string">""</span>))</div><div class="line">rownames(data.matrix) &lt;- paste(<span class="string">"gene"</span>, <span class="number">1</span>:<span class="number">100</span>, sep=<span class="string">""</span>)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">100</span>)&#123;</div><div class="line">  wt.values &lt;- rpois(<span class="number">5</span>, lambda = sample(x=<span class="number">10</span>:<span class="number">1000</span>, size=<span class="number">1</span>))</div><div class="line">  ko.values &lt;- rpois(<span class="number">5</span>, lambda = sample(x=<span class="number">10</span>:<span class="number">1000</span>, size=<span class="number">1</span>))</div><div class="line"></div><div class="line">  data.matrix[i,] &lt;- c(wt.values, ko.values)</div><div class="line">&#125;</div><div class="line"></div><div class="line">head(data.matrix)</div></pre></td></tr></table></figure>
<p>查看一下生成的数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(data.matrix)</div><div class="line">      wt1 wt2 wt3  wt4 wt5 ko1 ko2 ko3 ko4 ko5</div><div class="line">gene1 <span class="number">423</span> <span class="number">423</span> <span class="number">419</span>  <span class="number">423</span> <span class="number">372</span> <span class="number">582</span> <span class="number">589</span> <span class="number">563</span> <span class="number">534</span> <span class="number">566</span></div><div class="line">gene2 <span class="number">905</span> <span class="number">971</span> <span class="number">967</span> <span class="number">1031</span> <span class="number">910</span>  <span class="number">95</span>  <span class="number">96</span>  <span class="number">96</span>  <span class="number">89</span>  <span class="number">96</span></div><div class="line">gene3 <span class="number">139</span> <span class="number">177</span> <span class="number">147</span>  <span class="number">176</span> <span class="number">152</span> <span class="number">408</span> <span class="number">422</span> <span class="number">419</span> <span class="number">426</span> <span class="number">456</span></div><div class="line">gene4 <span class="number">702</span> <span class="number">712</span> <span class="number">717</span>  <span class="number">691</span> <span class="number">678</span> <span class="number">534</span> <span class="number">546</span> <span class="number">594</span> <span class="number">562</span> <span class="number">515</span></div><div class="line">gene5 <span class="number">582</span> <span class="number">572</span> <span class="number">616</span>  <span class="number">569</span> <span class="number">631</span> <span class="number">315</span> <span class="number">321</span> <span class="number">314</span> <span class="number">345</span> <span class="number">330</span></div><div class="line">gene6 <span class="number">765</span> <span class="number">853</span> <span class="number">781</span>  <span class="number">792</span> <span class="number">768</span> <span class="number">316</span> <span class="number">339</span> <span class="number">317</span> <span class="number">317</span> <span class="number">294</span></div></pre></td></tr></table></figure>
<h3 id="计算pca">计算PCA</h3>
<p>使用<code>prcomp</code>函数来对数据集进行PCA运算，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pca &lt;- prcomp(t(data.matrix),scale=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>代码解释：由于<code>prcomp</code>函数在默认情况下，会把行识别为样本，列识别为基因，而我们生成的数据集<code>data.matrix</code>正好相反，因此用到了<code>t</code>函数，它表示把原来的数据集转置一下，将其行与列交换。</p>
<p><code>prcomp</code>计算的结果含有主成分分析的各种信息，通过<code>str()</code>函数我们可以看一下有哪些东西，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; str(pca)</div><div class="line">List of <span class="number">5</span></div><div class="line"> $ sdev    : num [<span class="number">1</span>:<span class="number">10</span>] <span class="number">9.34</span> <span class="number">1.85</span> <span class="number">1.6</span> <span class="number">1.45</span> <span class="number">1.24</span> <span class="keyword">...</span></div><div class="line"> $ rotation: num [<span class="number">1</span>:<span class="number">100</span>, <span class="number">1</span>:<span class="number">10</span>] <span class="number">0.104</span> -<span class="number">0.107</span> <span class="number">0.106</span> -<span class="number">0.103</span> -<span class="number">0.106</span> <span class="keyword">...</span></div><div class="line">  ..- attr(*, <span class="string">"dimnames"</span>)=List of <span class="number">2</span></div><div class="line">  .. ..$ : chr [<span class="number">1</span>:<span class="number">100</span>] <span class="string">"gene1"</span> <span class="string">"gene2"</span> <span class="string">"gene3"</span> <span class="string">"gene4"</span> <span class="keyword">...</span></div><div class="line">  .. ..$ : chr [<span class="number">1</span>:<span class="number">10</span>] <span class="string">"PC1"</span> <span class="string">"PC2"</span> <span class="string">"PC3"</span> <span class="string">"PC4"</span> <span class="keyword">...</span></div><div class="line"> $ center  : Named num [<span class="number">1</span>:<span class="number">100</span>] <span class="number">489</span> <span class="number">526</span> <span class="number">292</span> <span class="number">625</span> <span class="number">460</span> <span class="keyword">...</span></div><div class="line">  ..- attr(*, <span class="string">"names"</span>)= chr [<span class="number">1</span>:<span class="number">100</span>] <span class="string">"gene1"</span> <span class="string">"gene2"</span> <span class="string">"gene3"</span> <span class="string">"gene4"</span> <span class="keyword">...</span></div><div class="line"> $ scale   : Named num [<span class="number">1</span>:<span class="number">100</span>] <span class="number">84.2</span> <span class="number">455.8</span> <span class="number">142.2</span> <span class="number">82.1</span> <span class="number">143.2</span> <span class="keyword">...</span></div><div class="line">  ..- attr(*, <span class="string">"names"</span>)= chr [<span class="number">1</span>:<span class="number">100</span>] <span class="string">"gene1"</span> <span class="string">"gene2"</span> <span class="string">"gene3"</span> <span class="string">"gene4"</span> <span class="keyword">...</span></div><div class="line"> $ x       : num [<span class="number">1</span>:<span class="number">10</span>, <span class="number">1</span>:<span class="number">10</span>] -<span class="number">8.92</span> -<span class="number">9.15</span> -<span class="number">8.71</span> -<span class="number">8.75</span> -<span class="number">8.77</span> <span class="keyword">...</span></div><div class="line">  ..- attr(*, <span class="string">"dimnames"</span>)=List of <span class="number">2</span></div><div class="line">  .. ..$ : chr [<span class="number">1</span>:<span class="number">10</span>] <span class="string">"wt1"</span> <span class="string">"wt2"</span> <span class="string">"wt3"</span> <span class="string">"wt4"</span> <span class="keyword">...</span></div><div class="line">  .. ..$ : chr [<span class="number">1</span>:<span class="number">10</span>] <span class="string">"PC1"</span> <span class="string">"PC2"</span> <span class="string">"PC3"</span> <span class="string">"PC4"</span> <span class="keyword">...</span></div><div class="line"> - attr(*, <span class="string">"class"</span>)= chr <span class="string">"prcomp"</span></div></pre></td></tr></table></figure>
<p>从这个结果中我们可以发现，有<code>sdev</code>，<code>rotation</code>，<code>center</code>，<code>scale</code>，<code>x</code>。其中<code>x</code>含有主成分，我们查看一下，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/L7fDK35jkd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们可以发现，<code>x</code>中有10个主成分（这是因为有10个样本），第1主成分占据了原始数据总变异的大部分，第2主成分占据了总变异的次大部分等。为了绘制二维图，我们通常使用PC1和PC2（个别情况下也会使用PC2和PC3），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/f6GDFED252.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>我们此时，使用<code>x</code>的前2列（即PC1和PC2）绘制一个二维图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(pca)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/3dHmCJ7lCd.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>其中，<code>pca$x[,1]</code>是PC1，pca$x[,2]`是PC2，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/dBGf7LeJ71.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>10个样本，分别位于图形的左右两侧，此时我们再看一下PC1占的总变异的比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pca.var &lt;- pca$sdev^<span class="number">2</span></div><div class="line">pca.var.per &lt;- round(pca.var/sum(pca.var)*<span class="number">100</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; pca.var</div><div class="line"> [<span class="number">1</span>] <span class="number">8.727308e+01</span> <span class="number">3.432450e+00</span> <span class="number">2.546956e+00</span> <span class="number">2.094293e+00</span> <span class="number">1.534746e+00</span> <span class="number">1.230408e+00</span></div><div class="line"> [<span class="number">7</span>] <span class="number">8.259253e-01</span> <span class="number">6.435822e-01</span> <span class="number">4.185583e-01</span> <span class="number">1.134741e-29</span></div><div class="line">&gt; pca.var.per</div><div class="line"> [<span class="number">1</span>] <span class="number">87.3</span>  <span class="number">3.4</span>  <span class="number">2.5</span>  <span class="number">2.1</span>  <span class="number">1.5</span>  <span class="number">1.2</span>  <span class="number">0.8</span>  <span class="number">0.6</span>  <span class="number">0.4</span>  <span class="number">0.0</span></div></pre></td></tr></table></figure>
<p>绘制出各个主成分对应的碎石图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">barplot(pca.var.per, </div><div class="line">        main=<span class="string">"Scree Plot"</span>, </div><div class="line">        xlab=<span class="string">"Principal Component"</span>, </div><div class="line">        ylab=<span class="string">"Percent Variation"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/LBijfCgLmk.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>上图中最长的那个就是PC1所占的总变异的比例，也就是说PC1就能在很大程度上解释两组数据的区分，我们在PC1和PC2的二维图上也能看出来，这两组数据之间主要是由PC1分开的，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/c7CKCCaHK8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="ggplot2">ggplot2</h3>
<p>ggplot2也能绘制类似的图形，先把数据转换为ggplot2能识别的格式，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pca.data &lt;- data.frame(Sample=rownames(pca$x),</div><div class="line">                       X=pca$x[,<span class="number">1</span>],</div><div class="line">                       Y=pca$x[,<span class="number">2</span>])</div><div class="line"><span class="comment"># one column with the sample ids</span></div><div class="line"><span class="comment"># Tow columns for the X and Y coordinates for each sample</span></div><div class="line">pca.data</div></pre></td></tr></table></figure>
<p>生成的数据如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; pca.data</div><div class="line">    Sample         X          Y</div><div class="line">wt1    wt1 -<span class="number">8.920074</span>  <span class="number">0.9049750</span></div><div class="line">wt2    wt2 -<span class="number">9.154298</span> -<span class="number">0.8467998</span></div><div class="line">wt3    wt3 -<span class="number">8.712942</span> -<span class="number">1.0756417</span></div><div class="line">wt4    wt4 -<span class="number">8.746978</span>  <span class="number">2.6207842</span></div><div class="line">wt5    wt5 -<span class="number">8.771551</span> -<span class="number">1.5756187</span></div><div class="line">ko1    ko1  <span class="number">8.854899</span>  <span class="number">2.7689355</span></div><div class="line">ko2    ko2  <span class="number">8.976103</span> -<span class="number">1.7855946</span></div><div class="line">ko3    ko3  <span class="number">9.077341</span>  <span class="number">0.2534441</span></div><div class="line">ko4    ko4  <span class="number">8.767547</span>  <span class="number">1.2557291</span></div><div class="line">ko5    ko5  <span class="number">8.629953</span> -<span class="number">2.5202131</span></div></pre></td></tr></table></figure>
<p>接着使用<code>ggplot</code>绘图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ggplot(data=pca.data, aes(x=X, y=Y, label=Sample))+</div><div class="line">  geom_text() +</div><div class="line">  xlab(paste(<span class="string">"PC1 - "</span>, pca.var.per[<span class="number">1</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>))+</div><div class="line">  ylab(paste(<span class="string">"PC2 - "</span>, pca.var.per[<span class="number">2</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>))+</div><div class="line">  theme_bw()+</div><div class="line">  ggtitle(<span class="string">"My PCA Graph"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/l54JJhBI7L.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从这个图形中，我们可以发现，X轴上标记了PC1所占总变异的比例为87.3%。Y轴上标记了PC2所占总变异的比例为3.4%。</p>
<h3 id="loading-scores计算">loading scores计算</h3>
<p><code>prcomp()</code>函数计算的结果中含有loading score，即<code>rotation</code>这一部分的内容，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loading_score &lt;- pca$rotation[,<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>由于PC1占所了总变异的大部分，因此我们只需要看PC1中的loading score，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/7faBK23CJ5.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>由于loading_score有负数，因此我们需要用<code>abs()</code>函数取它们的绝对值，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/Gf8BL3GKkK.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>取完绝对值，对所有的loading score进行排序，从高到低，代码如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gene_scores &lt;- abs(loading_score)</div><div class="line">gene_score_ranked &lt;- sort(gene_scores, decreasing = <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>此时，还要获排名前10的loading score基因的名称，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">top_10_genes &lt;- names(gene_score_ranked[<span class="number">1</span>:<span class="number">10</span>])</div><div class="line">top_10_genes</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; top_10_genes &lt;- names(gene_score_ranked[<span class="number">1</span>:<span class="number">10</span>])</div><div class="line">&gt; top_10_genes</div><div class="line"> [<span class="number">1</span>] <span class="string">"gene10"</span> <span class="string">"gene98"</span> <span class="string">"gene34"</span> <span class="string">"gene94"</span> <span class="string">"gene95"</span> <span class="string">"gene99"</span> <span class="string">"gene76"</span> <span class="string">"gene47"</span> <span class="string">"gene49"</span></div><div class="line">[<span class="number">10</span>] <span class="string">"gene72"</span></div></pre></td></tr></table></figure>
<p>最后，我们看一下这些基因的loading score的数值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pca$rotation[top_10_genes,<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; pca$rotation[top_10_genes,<span class="number">1</span>]</div><div class="line">    gene10     gene98     gene34     gene94     gene95     gene99     gene76     gene47 </div><div class="line"> <span class="number">0.1069736</span>  <span class="number">0.1069637</span>  <span class="number">0.1069535</span>  <span class="number">0.1069478</span> -<span class="number">0.1069281</span>  <span class="number">0.1069267</span>  <span class="number">0.1069243</span> -<span class="number">0.1069209</span> </div><div class="line">    gene49     gene72 </div><div class="line"> <span class="number">0.1069161</span>  <span class="number">0.1069037</span></div></pre></td></tr></table></figure>
<h2 id="python与pca">Python与PCA</h2>
<p>利用Python也可以进行PCA分析，在这一部分中，我们会介绍如何这些内容：</p>
<ol style="list-style-type: decimal">
<li>利用Python生成一些我们要分析的数据；</li>
<li>利用sklearn模块中的<code>PCA()</code>来进行分析，其中sklearn是scikit-learn的简称，它是一个机器学习的模块，支持包括分类、回归、降维和聚类四大机器学习算法。还包含了特征提取、数据处理和模型评估三大模块；</li>
<li>计算每个主成分占总变异的比例；</li>
<li>利用<code>matplotlib</code>来绘制PCA图；</li>
<li>计算变量的loading scores。</li>
</ol>
<p>如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/8elA2eKKg4.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="第一步导入各种函数与包">第一步，导入各种函数与包</h3>
<p>在进行PCA分析之前，Python需要导入各种包与函数，如果没有这些包，可以查一下如何下载，我使用的是Anaconda发行版，里面已经内置了各种有关数据分析的包，不用再下载各种包，直接导入即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </div><div class="line"><span class="comment"># import pandas package,</span></div><div class="line"><span class="comment"># pandas is short for "panel data"</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="comment"># numpy package will generate random numbers </span></div><div class="line"></div><div class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</div><div class="line"><span class="comment"># random package will generate an example dataset</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</div><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</div><div class="line"><span class="comment"># usr a function PCA() from sklearn.decomposition </span></div><div class="line"><span class="comment"># PCA() use to perform PCA</span></div><div class="line"><span class="comment"># preprocessing uses to scaling the data before perform PCA</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="comment"># draw PCA graphd</span></div></pre></td></tr></table></figure>
<h3 id="第二步生成模拟的数据">第二步：生成模拟的数据</h3>
<p>这一步与R中生成模拟数据集的目的一样，就是生成一个数据集，用于PCA分析，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">genes = [<span class="string">'gene'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)]</div><div class="line">wt = [<span class="string">'wt'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>)]</div><div class="line">ko = [<span class="string">'ko'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>)]</div><div class="line">data = pd.DataFrame(columns=[*wt, *ko], index=genes)</div><div class="line"><span class="keyword">for</span> gene <span class="keyword">in</span> data.index:</div><div class="line">    data.loc[gene, <span class="string">'wt1'</span>:<span class="string">'wt5'</span>] = np.random.poisson(lam=rd.randrange(<span class="number">10</span>,<span class="number">1000</span>),size=<span class="number">5</span>)</div><div class="line">    data.loc[gene, <span class="string">'ko1'</span>:<span class="string">'ko5'</span>] = np.random.poisson(lam=rd.randrange(<span class="number">10</span>,<span class="number">1000</span>),size=<span class="number">5</span>)</div><div class="line"></div><div class="line">print(data.head())</div><div class="line">print(data.shape)</div><div class="line"></div><div class="line"><span class="comment"># generate simulation dataset</span></div></pre></td></tr></table></figure>
<h3 id="第三进行pca分析">第三，进行PCA分析</h3>
<p>在进行PCA分析之前，先对数据进行中心化（我的理解是Z转换，转换后的数据均值是0，标准差是1），如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scaled_data = preprocessing.scale(data.T)</div></pre></td></tr></table></figure>
<p>需要注意的是，上述代码中使用了<code>data.T</code>，这是对表达的数据集进行转换，将其行与列交换，跟R中类似。此处我们使用的<code>sklearn</code>包中的preprocessing函数，我们还可以使用另外的函数进行转换，就是<code>StandardScaler().fit_transform(data.T)</code>。第二个函数在机器学习使用更加广泛，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/j7GjkFFElH.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此外，我们需要注意的是，<code>sklearn</code>中利用<code>preprocessing.scale</code>计算变异与R中利用<code>scale()</code>和<code>prcomp()</code>计算变异的公式略有不同，区别就在于前者的分子是测量值的数目，后者是这个数目减1，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/BEImJbbGiD.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>后者的分子是测量值的数目减1，这会导致最终的结果变大，这是一种无偏含估计，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/5k7mi1iFc9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>不过这两种方法都不影响PCA的分析，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/Jh9c6iL7DL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>它的局限就在于，它们会对最终的绘图造成一定的影响，因为最终绘图中的坐标来源于scaled后的数值乘以loading scores，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/i7bjjhK2c7.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>继续Python计算PCA，此时我们要创建一个PCA对象，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pca = PCA()</div></pre></td></tr></table></figure>
<p>这里要提一下，PCA不仅是一个函数，能够返回计算结果，在sklearn中，它还用于创建一个对象，使用一个数据集进行训练，进行对另外一个数据集进行计算。不过在这里，我们只用PCA计算这个数据集（我们不涉及机器学习的环境设置），其他的步骤非常繁琐，但也由此，我们也能了解一下机器学习的内容，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/04e4bHIjgG.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>计算PCA的所有结果，例如loading scores和每个主成分的变量占总变异的比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pca.fit(scaled_data)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pca.fit(scaled_data)</div><div class="line">PCA(copy=True, iterated_power=<span class="string">'auto'</span>, n_components=None, random_state=None,</div><div class="line">  svd_solver=<span class="string">'auto'</span>, tol=<span class="number">0.0</span>, whiten=False)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/806emi7L3i.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>接着，基于loading scores和scaled data来生成PCA图形中的坐标系，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pca_data = pca.transform(scaled_data)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/aJ2f7IF18C.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="第四绘图">第四，绘图</h3>
<p>首先，绘制一个碎石图（Scree plot），看一下应该使用多少个主成分比较合适，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">per_var = np.round(pca.explained_variance_ratio_*<span class="number">100</span>,decimals=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>这段代码主要是用于计算每个主成分所占总变量的比例，接着添加坐标轴的标签，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">labels = [<span class="string">'PC'</span> + str(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, len(per_var)+<span class="number">1</span>)]</div></pre></td></tr></table></figure>
<p>其次，使用<code>matplotlib</code>来绘制相应的图形，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plt.bar(x=range(<span class="number">1</span>,len(per_var)+<span class="number">1</span>), height=per_var, tick_label=labels)</div><div class="line">plt.ylabel(<span class="string">'Percentage of Explained Variance'</span>)</div><div class="line">plt.xlabel(<span class="string">'Principal Component'</span>)</div><div class="line">plt.title(<span class="string">'Scree Plot'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>图形如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/2fH8g2cmaB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>最后，我们绘制PCA图，我们使用<code>pd.DataFrame</code>函数把新的坐标系放到一个矩阵中来，它的行表示样本名称，列表示PC的标签，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pca_df = pd.DataFrame(pca_data, index=[*wt, *ko], columns=labels)</div></pre></td></tr></table></figure>
<p>继续绘制含有标题名与坐标标签的散点图，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">plt.scatter(pca_df.PC1,pca_df.PC2)</div><div class="line">plt.title(<span class="string">'My PCA Graph'</span>)</div><div class="line">plt.xlabel(<span class="string">'PC1 - &#123;0&#125;%'</span>.format(per_var[<span class="number">0</span>]))</div><div class="line">plt.ylabel(<span class="string">'PC2 - &#123;0&#125;%'</span>.format(per_var[<span class="number">1</span>]))</div></pre></td></tr></table></figure>
<p>最后，把样本名也添加上去，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> sample <span class="keyword">in</span> pca_df.index:</div><div class="line">    plt.annotate(sample, (pca_df.PC1.loc[sample],pca_df.PC2.loc[sample]))</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>最终的结果图如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/8iBd6gfDkL.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>从这张图中我们可以看到，wt组的数据集中在右侧，ko组都集中在了左侧。</p>
<h3 id="计算loading-score">计算loading score</h3>
<p>我们还可以计算一下PC1的loading scores，从而达珍哪些基因在不同的分类方面发挥了主要作用，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180626/5eJJh6DH56.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>首先，我们要创建一个pandas的series对象，这个对象用于计算loading scores，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">loading_scores = pd.Series(pca.components_[<span class="number">0</span>], index=genes)</div><div class="line"><span class="comment"># in python, first  number in index is 0, not 1</span></div><div class="line">sorted_loading_scores = loading_scores.abs().sort_values(ascending=<span class="keyword">False</span>)</div><div class="line"><span class="comment"># achieve absolute value using abs() function and sort them</span></div><div class="line">top_10_genes = sorted_loading_scores[<span class="number">0</span>:<span class="number">10</span>].index.values</div><div class="line">print(loading_scores[top_10_genes])</div></pre></td></tr></table></figure>
<p>最终结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(loading_scores[top_10_genes])</div><div class="line">gene31   <span class="number">-0.107133</span></div><div class="line">gene32    <span class="number">0.107131</span></div><div class="line">gene34    <span class="number">0.107070</span></div><div class="line">gene10   <span class="number">-0.107065</span></div><div class="line">gene45    <span class="number">0.107065</span></div><div class="line">gene28   <span class="number">-0.107064</span></div><div class="line">gene30   <span class="number">-0.107062</span></div><div class="line">gene39    <span class="number">0.107053</span></div><div class="line">gene93   <span class="number">-0.107041</span></div><div class="line">gene79    <span class="number">0.107036</span></div><div class="line">dtype: float64s</div></pre></td></tr></table></figure>
<p>计算结束。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/23/BioStatistics/生物统计-06非参数检验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/23/BioStatistics/生物统计-06非参数检验/" itemprop="url">非参数检验笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-23T12:02:00+08:00">
                2018-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,066
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>非参数检验(non-parametric test)是相对于参数检验(parametric test)而言的。如果总体分布为已知的数学形式，用参数检验，反之用非参数检验。当总体分布不能由已知的数学形式表达，没有总体参数时，就无法用参数检验，两个或多个正态总体方差不等，也不能用t检验或F检验的参数检验。对于不满足参数检验条件的数据，一是进行变量变换，使其满足参数检验条件，另外就是用非参数检验。非参检验对总体分布不作严格假定，又称任意分布检验(distribution-free test)，《医学统计学》（第三版，孙振球）书中采用的是秩转换的非参数检验，即将数值变量从小到大排列，再计算检验统计量。</p>
<p>非参数检验在总体分布未知时有很大的优越性，在分布未时，如果还假定总体诸如正态分布那样的已知分布，在进行统计推断时就可能产生错误。非参数检验总是比传统检验案例，但是在总体分布形式已经已知时，非参数检验就不如传统方法效率高，这是因为非参数方法利用的利息要少些。往往在传统方法可以拒绝零假设的情况下，非参数检验无法拒绝。用统计的术语来说，在总体分布已知时，传统方法有较大的功效(power)，效率要高；但非参数统计在总体分布未知时，效率往往比假定了错误总体分布时的传统方法要高，有时候要高很多。</p>
<h2 id="秩的概念">秩的概念</h2>
<p>非参数检验中的秩(rank)是最常用的概念，秩就是该数据按照升序排列后，每个观测值的位置。例如我们有下面的数据（样本量为10），其中第一行为数据本身，第二行就是它们的秩，可以看出，3最小，秩为1，13其次，秩为2，而最大的是98，秩为10，我们使用rank(x)表示x的秩，通常也用Ri表示观测值<span class="math inline">\(x_{i}\)</span>的秩，如下所示：</p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(x_{i}\)</span></th>
<th>98</th>
<th>67</th>
<th>63</th>
<th>3</th>
<th>38</th>
<th>16</th>
<th>21</th>
<th>53</th>
<th>13</th>
<th>81</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(R_{i}=rank(x_{i})\)</span></td>
<td>10</td>
<td>8</td>
<td>7</td>
<td>1</td>
<td>5</td>
<td>3</td>
<td>4</td>
<td>6</td>
<td>2</td>
<td>9</td>
</tr>
</tbody>
</table>
<h2 id="非参数检验的原理">非参数检验的原理</h2>
<p>如果零假设中确定了一个中位数<span class="math inline">\(M_{0}\)</span>，那么样本点应该以同样的概率出现在<span class="math inline">\(M_{0}\)</span>的两边，也就是说，如果每个样本点送去零假设的中位数，那么得到的差值有些为正，有些为负，如果零假设正确，那么正负符号数目应该差不多，如果差得很多，这就意味着零假设有问题，可以拒绝零假设。这也就是所谓的<strong>符号检验(sign test)</strong>。</p>
<p>这里没有涉及任何总体分布，在零假设下，样本点和<span class="math inline">\(M_{0}\)</span>的差值中负号的个数（记为<span class="math inline">\(S^-\)</span>）应该服从二项分布Bin(n,α)，而正号的个数（记为<span class="math inline">\(S^+\)</span>）䚱服从二项分布Bin(n,1-α)，注意，对于已知对称的分布，由于中位数和均值相等，对中位数的检验等同于对均值的检验，我们通过一个例子来解释符号检验。</p>
<h2 id="单样本的关于总体中位数的符号检验">单样本的关于总体中位数的符号检验</h2>
<p>案例A，质量监督部门对商店里出售的某厂家的西洋参片进行了抽查，对于25包写明为净重100g的西洋参片的称重结果如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180819/EhJ1bCk5HA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这里的总体分布未知（我们只是假设未知，其实它的分布是可以计算出来的），用M表示总体中位数，容易计算出，样本中位数为m=98.36，因为人们怀疑厂家包装的西洋参片分量。由于对于重量的总体分布不清楚，决定对其进行符号检验，需要的检验如下所示：</p>
<p><span class="math display">\[H_{0}:M=100\iff H_{1}:M&lt;100\]</span></p>
<p>按照零假设，每个观测值（每包西洋参的净重）大于中位数<span class="math inline">\(M_{0}=100\)</span>的概率和小于100的概率都是0.5，这应该服从二项分布Bin(25,0.5)，容易计算出大于100的只有<span class="math inline">\(S^+=8\)</span>，这样的参数为n=25，p=0.5的二项分布变量小于或等于8的概率为0.05388，这就是p值，历引，对于显著性水平α=0.05，根据这个符号检验，我们没有足够的证据拒绝零假设。在R中计算的过程如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; pbinom(<span class="number">8</span>,<span class="number">25</span>,<span class="number">0.5</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.05387607</span></div><div class="line"><span class="comment"># 或者按另外一种方法：</span></div><div class="line">&gt; raw &lt;-c(<span class="number">99.05</span>,<span class="number">100.25</span>,<span class="number">102.56</span>,<span class="number">99.15</span>,<span class="number">104.89</span>,<span class="number">101.86</span>,<span class="number">96.37</span>,<span class="number">96.79</span>,<span class="number">99.37</span>,</div><div class="line">+         <span class="number">96.9</span>,<span class="number">93.94</span>,<span class="number">92.97</span>,<span class="number">108.28</span>,<span class="number">96.86</span>,<span class="number">93.94</span>,<span class="number">98.27</span>,<span class="number">98.36</span>,<span class="number">100.81</span>,<span class="number">92.99</span>,</div><div class="line">+         <span class="number">103.72</span>,<span class="number">90.66</span>,<span class="number">98.24</span>,<span class="number">97.87</span>,<span class="number">99.21</span>,<span class="number">101.79</span>)</div><div class="line">&gt; pbinom(length(raw[raw&gt;=<span class="number">100</span>]),<span class="number">25</span>,<span class="number">0.5</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.05387607</span></div></pre></td></tr></table></figure>
<p>一般来说，根据样本中位数和零假设中的待检验总体中位数<span class="math inline">\(M_{0}\)</span>的比较，我们的检验为下面三种形式之一（记样本中位数为m），如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180819/3j1H5fkEb9.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>这里的关于中位数的符号检验概率，完全可以很容易地推广到关于总体α分位数的符号检验中，如果零假设中确定了一个α分位数<span class="math inline">\(Q_{\alpha0}\)</span></p>
<p>那么，样本点应该以概率α出现在<span class="math inline">\(Q_{\alpha0}\)</span>的左边，或者以概率1-α出现在<span class="math inline">\(Q_{\alpha0}\)</span>的右边，因此样本点减去<span class="math inline">\(Q_{\alpha0}\)</span>差值中铅的个数（记为<span class="math inline">\(S^-\)</span>）应该服从二项分布Bin(n,α)，而正号的个数（记为<span class="math inline">\(S^+\)</span>）应该服从二项分布Bin(n,1-α)。当α=0.5时，总体α分位数就是总体中位数。</p>
<h2 id="单样本的关于对称总体中位数的wilcoxon符号秩检验">单样本的关于对称总体中位数的Wilcoxon符号秩检验</h2>
<p>前面的符号检验仅仅用了样本点和零假设的中位数或α分位数的差的符号，我们可以看到，检验的结果p值大于0.05，但是这种检验方法没有利用这些差的大小，下面介绍的Wilcoxn符号秩检验（Wilcoxon signed-rank test）把差的绝对值的秩分别按照不同的符号相加作为其检验统计量，这里把对总体唯一假定是总体具有对称分布，这种检验方法我们可以看到，它的功效要比前面介绍的高（计算出来的p值小于0.05）。</p>
<h3 id="wilcoxon符号秩检验原理">Wilcoxon符号秩检验原理</h3>
<p>Wilcoxon符号秩检验的原理是这样的，假定<span class="math inline">\(x_{1},x_{2},\cdots,x_{n}\)</span>为来自连续对称总体的一个样本，如果我们的假设检验问题的零假设为中位数（均值）<span class="math inline">\(M=M_{0}\)</span>。那么，对于符号检验而言，只需计算<span class="math inline">\(x_{i}-M_{0}(i=1,2,\cdots,n)\)</span>中有多少正负符号，即可利用二项分布的概率来计算p值。但对于Wilcoxon符号秩检验，则要把<span class="math inline">\(|x_{i}-M_{0}|\)</span>排序，得到<span class="math inline">\(|x_{i}-M_{0}|\)</span>的秩。然后把<span class="math inline">\(x_{i}-M_{0}\)</span>的符号加到相应的秩上面。于是，就可以得到既带有正号的秩，又带有负号的秩，对带负号的秩的绝对值求和，即把满足<span class="math inline">\(x_{i}-M_{0}&lt;0\)</span>的<span class="math inline">\(|x_{i}-M_{0}|\)</span>的秩求和，并用<span class="math inline">\(W^+\)</span>表示。如果<span class="math inline">\(M_{0}\)</span>的确是中位娄和，那么<span class="math inline">\(W^-\)</span>和<span class="math inline">\(W^+\)</span>应该大体上差不多。如果<span class="math inline">\(W^-\)</span>或者<span class="math inline">\(W^+\)</span>过大或过小，则应该怀疑中位数<span class="math inline">\(M=M_{0}\)</span>的零假设。令<span class="math inline">\(W=min(W^-,W^+)\)</span>，则当W太小时，应该拒绝零假设。这个W就是Wilcoxon符号秩检验统计量。</p>
<h2 id="r中的非参数检验函数">R中的非参数检验函数</h2>
<p>在R中进行Wilcoxon检验的函数是<code>wilcoxon.test</code>，使用方法如下所示：</p>
<p>如果总体不服从正态分布，那么T检验就不再适用，此时我们可以利用非参数方法推断中位数。wilcoxon.test函数可实现符号秩检验，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x &lt;- rnorm(50,mean=10,sd=5)</div><div class="line">wilcox.test(x,conf.int=T) #指定conf.int让函数返回中位数的置信区间</div><div class="line">wilcox.test(x,mu=1) #指定mu让函数返回中位数为10的检验结果</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; wilcox.test(x,conf.int=T) #指定conf.int让函数返回中位数的置信区间</div><div class="line"></div><div class="line">	Wilcoxon signed rank test with continuity correction</div><div class="line"></div><div class="line">data:  x</div><div class="line">V = 1271, p-value = 9.93e-10</div><div class="line">alternative hypothesis: true location is not equal to 0</div><div class="line">95 percent confidence interval:</div><div class="line">  9.31246 12.20277</div><div class="line">sample estimates:</div><div class="line">(pseudo)median </div><div class="line">       10.7765 </div><div class="line"></div><div class="line">&gt; wilcox.test(x,mu=1) #指定mu让函数返回中位数为10的检验结果</div><div class="line"></div><div class="line">	Wilcoxon signed rank test with continuity correction</div><div class="line"></div><div class="line">data:  x</div><div class="line">V = 1269, p-value = 1.121e-09</div><div class="line">alternative hypothesis: true location is not equal to 1</div></pre></td></tr></table></figure>
<h2 id="单个样本wilcoxon检验案例">单个样本Wilcoxon检验案例</h2>
<h4 id="案例a">案例A</h4>
<p>现在我们再看一下前面的那个案例A，使用Wilcoxon检验来看一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; raw &lt;-c(<span class="number">99.05</span>,<span class="number">100.25</span>,<span class="number">102.56</span>,<span class="number">99.15</span>,<span class="number">104.89</span>,<span class="number">101.86</span>,<span class="number">96.37</span>,<span class="number">96.79</span>,<span class="number">99.37</span>,</div><div class="line">+         <span class="number">96.9</span>,<span class="number">93.94</span>,<span class="number">92.97</span>,<span class="number">108.28</span>,<span class="number">96.86</span>,<span class="number">93.94</span>,<span class="number">98.27</span>,<span class="number">98.36</span>,<span class="number">100.81</span>,<span class="number">92.99</span>,</div><div class="line">+         <span class="number">103.72</span>,<span class="number">90.66</span>,<span class="number">98.24</span>,<span class="number">97.87</span>,<span class="number">99.21</span>,<span class="number">101.79</span>)</div><div class="line">&gt; wilcox.test(raw,mu=<span class="number">100</span>,alternative = <span class="string">"less"</span>)</div><div class="line"></div><div class="line">	Wilcoxon signed rank test with continuity correction</div><div class="line"></div><div class="line">data:  raw</div><div class="line">V = <span class="number">100</span>, p-value = <span class="number">0.04763</span></div><div class="line">alternative hypothesis: true location is less than <span class="number">100</span></div><div class="line"></div><div class="line">Warning message:</div><div class="line">In wilcox.test.default(raw, mu = <span class="number">100</span>, alternative = <span class="string">"less"</span>) :</div><div class="line">  无法精確計算带连结的p值</div></pre></td></tr></table></figure>
<h4 id="案例b">案例B</h4>
<p>现在再看一个案例B，下面是随机挑选了12袋包装上写的重量是15g的干酵母粉，并进行称重所得到的重量的数据，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">12.39,15.64,14,14.17,14.08,14.16,13.94,14.61,14.7,12.81,14.12,13.37</div></pre></td></tr></table></figure>
<p>由于总体中位数是14.1，而零假设的总体均值是15，因此我们可以怀疑这种袋装酵母粉不够分量，相应的关于中位数的检验如下所示：</p>
<p><span class="math display">\[H_{0}:M=15\iff H_{1}:M&lt;15\]</span></p>
<p>假定总体是对称分布的，因此可以应用Wilcoxon符号秩检验，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; raw_b &lt;- c(<span class="number">12.39</span>,<span class="number">15.64</span>,<span class="number">14</span>,<span class="number">14.17</span>,<span class="number">14.08</span>,<span class="number">14.16</span>,<span class="number">13.94</span>,<span class="number">14.61</span>,<span class="number">14.7</span>,<span class="number">12.81</span>,<span class="number">14.12</span>,<span class="number">13.37</span>)</div><div class="line">&gt; wilcox.test(raw_b,m=<span class="number">15</span>,alternative = <span class="string">"less"</span>)</div><div class="line"></div><div class="line">	Wilcoxon signed rank test</div><div class="line"></div><div class="line">data:  raw_b</div><div class="line">V = <span class="number">3</span>, p-value = <span class="number">0.001221</span></div><div class="line">alternative hypothesis: true location is less than <span class="number">15</span></div></pre></td></tr></table></figure>
<h4 id="案例c">案例C</h4>
<p>例8-2 已知某地正常人尿氟含量的中位数为45.30μmol/L 。今在该地某厂随机抽取12名工人，测得尿氟含量见表8-2第（1）栏。问该厂工人的尿氟含量是否高于当地正常人的尿氟含量？（《医学统计学》，第三版，孙振球，P134）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data82 &lt;- c(44.21,45.30,46.39,49.47,51.05,53.16,53.26,54.37,57.16,67.37,71.05,87.37)</div><div class="line">wilcox.test(data82-45.30)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; wilcox.test(data82-45.30)</div><div class="line"></div><div class="line">	Wilcoxon signed rank test with continuity correction</div><div class="line"></div><div class="line">data:  data82 - 45.3</div><div class="line">V = 65, p-value = 0.005099</div><div class="line">alternative hypothesis: true location is not equal to 0</div></pre></td></tr></table></figure>
<p>这个结果与书上有出入，书中提到，p值是小于0.005，则R的计算出来是0.005099，小于0.05，但SPSS的计算结果与R一致。</p>
<h2 id="两个独立样本wilcoxon检验mann-whitney-u检验">两个独立样本Wilcoxon检验（Mann-Whitney U检验）</h2>
<p>如果是比较两个正态总体均值，那么就是使用t检验（检验均值之差为<span class="math inline">\(\mu_{1}-\mu_{2}\)</span>），如果不知道两组数据是否服从哪种特定的总体分布，我们就要考虑比较两组数据的中位数大小，我们需要的唯一定义就是两个总体的分布有类似的形状，但不要求对称。这里介绍的检验的原理很简单，假定第一个样本有m个观测值<span class="math inline">\(x_{1},\cdots,x_{m}\)</span>，第二个有n个观测值，<span class="math inline">\(y_{1},\cdots,y_{n}\)</span>。把两个样本混合之后把这个m+n个观测值按照大小次序排序，然后记下每个观测值在混合排序下面的秩，之后分别把两个样本所得到的秩相加。记第一个样本观测值的秩的和为<span class="math inline">\(W_{x}\)</span>，而第二个样本秩的和为<span class="math inline">\(W_{Y}\)</span>。这两个值可以互相推算，称为Wilcoxon统计量。该统计量的分布和两个总体分布无关，，由此分布可以得到p值。直观上看，如果<span class="math inline">\(W_{x}\)</span>与<span class="math inline">\(W_{Y}\)</span>之中有一个显著地大（或显著地小），则可以选择拒绝零假设。这个检验注称为Wilcoxon秩和检验(Wilcoxon rank-sum test)，也称为Mann-Whitney检验或Mann-Whitney-Wilcoxon检验。之所以有两个名称，这是因为Wilcoxon统计量和由Mann-Whitney导出的检验统计量等价。Mann-Whitney统计量也是一对：<span class="math inline">\(W_{XY}\)</span>和<span class="math inline">\(W_{YX}\)</span>；定义为两个样本中满足<span class="math inline">\(x_{i}&gt;y_{i}\)</span>的数目，而<span class="math inline">\(W_{XY}\)</span>定义为两个样本中满足<span class="math inline">\(x_{i}&lt;y_{i}\)</span>的数目。检验时，一般使用<span class="math inline">\(W=min(W_{XY},W_{YX})\)</span>作为检验统计量。</p>
<p>案例A：（《医学统计学》，第三版，孙振球，P136）</p>
<p>对10例肺癌病人和12例矽肺0期工人用X光片测量肺门横径右侧距RD值（cm），结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">肺癌：2.78,3.23,4.2,4.87,5.12,6.21,7.18,8.05,8.56,9.6</div><div class="line">矽肺：3.23,3.5,4.04,4.15,4.28,4.34,4.47,4.64,4.75,4.82,4.95,5.1</div></pre></td></tr></table></figure>
<p>问肺癌病人的RD值是否高于矽肺0期工人的RD值？</p>
<p>思路：第一组数据的样本量为10，中位数是5.665，第二组数据的样本量为12，中位数是4.405，这两个中位数看上去有点差异，令这两组数据的总体中位数分别为<span class="math inline">\(M_{1}\)</span>和<span class="math inline">\(M_{2}\)</span>，现在进行检验，如下所示：</p>
<p><span class="math display">\[H_{0}:M_{1}=M_{2}\iff H_{1}:M_{1}&gt;M_{2}\]</span></p>
<p>计算过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lc &lt;- c(2.78,3.23,4.2,4.87,5.12,6.21,7.18,8.05,8.56,9.6)</div><div class="line">si &lt;- c(3.23,3.5,4.04,4.15,4.28,4.34,4.47,4.64,4.75,4.82,4.95,5.1)</div><div class="line">wilcox.test(lc,si,correct=T)</div></pre></td></tr></table></figure>
<p>从结果中我们可以看到，p值等于0.04318，同时也得到中间结果<span class="math inline">\(W_{XY}=86.5\)</span>，因此哦可以说，对于大于p值的显著必不平都可以拒绝零假设，也就是说，这两组数据的中位数有显著性的差异。</p>
<h2 id="配对wilcoxon符号秩检验">配对Wilcoxon符号秩检验</h2>
<p>例8-1：对12份血清分别用原方法（检测时间20分钟）和新方法（检测时间10分钟）测谷-丙转氨酶，结果见表8-1的（2）、（3）栏。问两法所得结果有无差别？（《医学统计学》，第三版，孙振球，P132） <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">old &lt;- c(60,142,195,80,242,220,190,25,198,38,236,95)</div><div class="line">new &lt;- c(76,152,243,82,240,220,205,38,243,44,190,100)</div><div class="line">wilcox.test(old,new,paired = TRUE)</div></pre></td></tr></table></figure></p>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt; old &lt;- c(60,142,195,80,242,220,190,25,198,38,236,95)</div><div class="line">&gt; new &lt;- c(76,152,243,82,240,220,205,38,243,44,190,100)</div><div class="line">&gt; wilcox.test(old,new,paired = TRUE)</div><div class="line"></div><div class="line">	Wilcoxon signed rank test with continuity correction</div><div class="line"></div><div class="line">data:  old and new</div><div class="line">V = 11.5, p-value = 0.06175</div><div class="line">alternative hypothesis: true location shift is not equal to 0</div><div class="line"></div><div class="line">Warning messages:</div><div class="line">1: In wilcox.test.default(old, new, paired = TRUE) :</div><div class="line">  无法精確計算带连结的p值</div><div class="line">2: In wilcox.test.default(old, new, paired = TRUE) :</div><div class="line">  有0时无法計算精確的p值</div></pre></td></tr></table></figure>
<h2 id="有序的秩检验">有序的秩检验</h2>
<p>例8-4 39名吸烟工人和40名不吸烟工人的碳氧血红蛋白HbCO(%)含量见表8-6。问吸烟工人的HbCO(%)含量是否高于不吸烟工人的HbCO(%)含量？</p>
<h3 id="例8-4第1种方法wilcox.test检验">例8-4第1种方法：Wilcox.test检验：</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">smoke &lt;- c(1,8,16,10,4)</div><div class="line">no.smoke &lt;-c(2,23,11,4,0)</div><div class="line">rank.c &lt;- c(1:5)</div><div class="line">group1 &lt;- rep(rank.c,smoke)</div><div class="line">group2 &lt;- rep(rank.c,no.smoke)</div><div class="line">data84 &lt;- c(group1,group2)</div><div class="line">group.f &lt;-factor(c(rep(1,length(group1)),rep(2,length(group2))))</div><div class="line">wilcox.test(data84~group.f)</div></pre></td></tr></table></figure>
<h3 id="例8-4第2种方法kruskal检验">例8-4第2种方法：Kruskal检验：</h3>
<p>Kurskal-Wallis检验是Wilcoxon方法（其实是Mann-Whitney检验）用于多于两个样本的时候的升级版。当对两个样本进行比较的时候，Kurskal-Wallis检验与Mann-Whitney检验是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kruskal.test(data84~group.f)</div></pre></td></tr></table></figure>
<h3 id="例8-4第2种方法ridit检验">例8-4第2种方法：Ridit检验:</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">data84 &lt;- matrix(c(1,8,16,10,4,2,23,11,4,0),nrow=5)</div><div class="line">dimnames(data84) &lt;- list(cone=c(&quot;very low&quot;,&quot;low&quot;,&quot;median&quot;,&quot;a bit high&quot;,&quot;high&quot;),</div><div class="line">worker=c(&quot;smoker&quot;,&quot;no-smoker&quot;))</div><div class="line">if(!require(&quot;Ridit&quot;))&#123;</div><div class="line">  install.packages(&quot;Ridit&quot;)</div><div class="line">  library(Ridit)</div><div class="line">&#125;</div><div class="line">ridit(data84,2)</div><div class="line">chisq.test(data84)</div></pre></td></tr></table></figure>
<h2 id="例8-5">例8-5</h2>
<p>用三种药物杀灭钉螺，每批用200只活钉螺，用药后清点每批钉螺的死亡数、再计算死亡率（%），结果见表8-9。问三种药物杀灭钉螺的效果有无差别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">drug &lt;-rep(c(&quot;甲药&quot;,&quot;乙药&quot;,&quot;丙药&quot;),each=5)</div><div class="line">data &lt;- c(32.5,35.5,40.5,46,49,16,20.5,22.5,29,36,6.5,9.0,12.5,18,24)</div><div class="line">data85 &lt;- data.frame(drug,data)</div><div class="line">kruskal.test(data85$data~data85$drug)</div></pre></td></tr></table></figure>
<h2 id="例8-6">例8-6</h2>
<p>比较小白鼠接种三种不同菌型伤寒杆菌9D、11C和DSC1后存活日数，结果见表8-10。问小白鼠接种三种不同菌型伤寒杆菌的存活日数有无差别？ <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mice &lt;- as.factor(c(rep(&quot;9D&quot;,10),rep(&quot;11C&quot;,9),rep(&quot;DSC1&quot;,11)))</div><div class="line">data86 &lt;- c(2,2,2,3,4,4,4,5,7,7,5,5,6,6,6,7,8,10,12,3,5,6,6,6,7,7,9,10,11,11)</div><div class="line">data86 &lt;- data.frame(mice,data)</div><div class="line">kruskal.test(data86$data~data86$mice)</div></pre></td></tr></table></figure></p>
<h2 id="例8-7">例8-7</h2>
<p>四种疾病患者痰液内嗜酸性白细胞的检查结果见表8-11。问四种疾病患者痰液内的嗜酸性白细胞有无差别？注：这道例题与《医学统计学及SAS应用》（上海交通大学）的9.11类似 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">x1 &lt;- c(0,2,9,6)</div><div class="line">x2 &lt;- c(3,5,5,2)</div><div class="line">x3 &lt;- c(5,7,3,2)</div><div class="line">x4 &lt;- c(3,5,3,0)</div><div class="line"> </div><div class="line">freq &lt;- function(x)&#123;</div><div class="line">count &lt;-c()</div><div class="line">for(i in 1:4)&#123;</div><div class="line">count1 &lt;-c(rep(i,x[i]))</div><div class="line">count &lt;- append(count,count1)</div><div class="line">&#125;</div><div class="line">return(count)&#125;</div><div class="line">data87 &lt;-c(freq(x1),freq(x2),freq(x3),freq(x4))</div><div class="line">group &lt;- c(rep(1,sum(x1)),rep(2,sum(x2)),rep(3,sum(x3)),rep(4,sum(x4)))</div><div class="line">kruskal.test(data87~group)</div></pre></td></tr></table></figure></p>
<h2 id="例8-8">例8-8</h2>
<p>对例8-6资料（表8-10）作三个样本间的两两比较，Nemenyi检验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># 需要安装下列包：</div><div class="line">if(!require(&quot;pgirmess&quot;))&#123;</div><div class="line">  install.packages(&quot;pgirmess&quot;)</div><div class="line">  library(pgirmess)</div><div class="line">&#125;</div><div class="line">if(!require(&quot;coin&quot;))&#123;</div><div class="line">  install.packages(&quot;coin&quot;)</div><div class="line">  library(coin)</div><div class="line">&#125;</div><div class="line">if(!require(&quot;multcomp&quot;))&#123;</div><div class="line">  install.packages(&quot;multcomp&quot;)</div><div class="line">  library(multcomp)</div><div class="line">&#125;</div><div class="line"></div><div class="line">mice &lt;- as.factor(c(rep(&quot;9D&quot;,10),rep(&quot;11C&quot;,9),rep(&quot;DSC1&quot;,11)))</div><div class="line">data &lt;- c(2,2,2,3,4,4,4,5,7,7,5,5,6,6,6,7,8,10,12,3,5,6,6,6,7,7,9,10,11,11)</div><div class="line">data88 &lt;- data.frame(mice,data)</div><div class="line">kruskal.test(data~mice,data=data88)</div><div class="line">kruskalmc(data~mice, data=data88, probs=0.05) # 使用kruskalmc函数做两两比较，但此方法不能给出具体的值</div><div class="line"># 下面构建函数计算具体的p值</div><div class="line">mult &lt;- oneway_test(data ~ mice, data = data88,</div><div class="line">ytrafo = function(data) trafo(data, numeric_trafo = rank),</div><div class="line">xtrafo = function(data) trafo(data, factor_trafo = function(x)</div><div class="line">model.matrix(~x - 1) %*% t(contrMat(table(x), &quot;Tukey&quot;))),</div><div class="line">teststat = &quot;max&quot;, distribution = approximate(B = 90000)) </div><div class="line">pvalue(mult, method = &quot;single-step&quot;) #计算具体的p值</div></pre></td></tr></table></figure>
<h2 id="例8-9">例8-9</h2>
<p>8名受试对象在相同实验条件下分别接受4种不同频率声音的刺激，他们的反应率（%）资料见表8-12。问4种频率声音刺激的反应率是否有差别？ <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">freA &lt;- c(8.40,11.60,9.40,9.80,8.30,8.60,8.90,7.80)</div><div class="line">freB &lt;- c(9.60,12.70,9.10,8.70,8.00,9.80,9.00,8.20)</div><div class="line">freC &lt;- c(9.80,11.80,10.40,9.90,8.60,9.60,10.60,8.50)</div><div class="line">freD &lt;- c(11.70,12.00,9.80,12.00,8.60,10.60,11.40,10.80)</div><div class="line">matrix89 &lt;- matrix(c(freA,freB,freC,freD),nrow=8,dimnames=list(no=1:8,c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;)))</div><div class="line">friedman.test(matrix89)</div></pre></td></tr></table></figure></p>
<p>对两个以上样本进行比较的Kruskal-Wallis 秩和检验 kruskal.test() kruskal.test(formula, data, subset, na.action, …) 例子 为了比较属于同一类的四种不同食谱的营养效果，将25只老鼠随机的氛围4组，每组分别为8只，4只，7只和6只，采用食谱甲乙丙丁喂养，假设其他条件均值相同，12周后测得体重增加量如表所示，在alpha=0.05水平上，检验各食谱的营养效果是否有显著差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">food&lt;-data.frame(</div><div class="line">x=c(164, 190, 203, 205, 206, 214, 228, 257,</div><div class="line">185, 197, 201, 231,</div><div class="line">187, 212, 215, 220, 248, 265, 281,</div><div class="line">202, 204, 207, 227, 230, 276),</div><div class="line">g=factor(rep(1:4, c(8,4,7,6)))</div><div class="line">)</div><div class="line">kruskal.test(x~g, data=food)</div></pre></td></tr></table></figure>
<p>另一种写法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kruskal.test(food$x, food$g)</div></pre></td></tr></table></figure></p>
<p>或 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A&lt;-c(164, 190, 203, 205, 206, 214, 228, 257)</div><div class="line">B&lt;-c(185, 197, 201, 231)</div><div class="line">C&lt;-c(187, 212, 215, 220, 248, 265, 281)</div><div class="line">D&lt;-c(202, 204, 207, 227, 230, 276)</div><div class="line">kruskal.test(list(A,B,C,D))</div></pre></td></tr></table></figure></p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>关于Nemenyi检验的方法是参照丁香园的，原贴地址如下，帖子的作者有把写过《医学统计学及SAS应用》之R语言实现这本电子书，下载地址如下:<a href="http://www.dxy.cn/bbs/thread/26928446#26928446" target="_blank" rel="external">Nemenyi检验方法</a></li>
<li><a href="http://d.dxy.cn/detail/6143147" target="_blank" rel="external">《医学统计学及SAS应用》之R语言实现</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">117</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共456.0k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  










  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine@1.1.4/dist/Valine.min.js"></script>
  <script type="text/javascript">
    new Valine({
        av: AV,
        el: '#vcomments' ,
        verify: true,
        notify: true,
        app_id: '4ORLDMxXCFDLSHPJ4wSSDkkw-gzGzoHsz',
        app_key: 'HSWpCY7XlN0pGV5DCrKoC0ic',
        placeholder: 'Comment input placeholder'
    });
  </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
