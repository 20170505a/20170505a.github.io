<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/2/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/2/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/25/DAL/DALS025_Batch_Effect01_Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/DAL/DALS025_Batch_Effect01_Introduction/" itemprop="url">DALS025-批次效应01-什么是批次效应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T12:00:00+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,824
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第10章批次效应的第1小节，这一部分的主要内容涉及批次效应(Batch Effects)的介绍，有关批次效应的前言部分Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/intro_to_batch_effects.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="什么是批次效应">什么是批次效应</h2>
<p>高通量研究中一个经常被忽视的问题就是批次效应(batch effects)，批次效应受到当时检测的实验室条件、试剂批次和人员差异的影响。当批次效应与我们目标结果混淆并惬以不正确的结果时，这就成了一个主要问题。在这一章中，我们将详细地描述批次效应：对于批次效应如何检测、解释、建模和调整。</p>
<p>批次效应是基因组学研究中面临的最大挑战，尤其是在精确医学这个背景下。大多数情况（但并非全部）下，高通量技术已经被报道存在着一种形式或另外一种形式的批次效应[Leek et al. (2010) Nature Reviews Genetics 11, 733-739]。但是，批次效应并非基因组学所特有的。实际上， 在1972年一篇文献中，Mj Youden就在对物理常数的经验估计的背景下提到了批次效应。他指出，物理常数“存在着主观估计的特征”，以及如何在不同实验室之间变化的。例如，在下面的Table1中，Youden就展示了来自于不同实验室又的天文单的估计值。这些报告包括对离差(spread)（现在我们称之为置信区间）的估计。</p>
<figure class="highlight plain"><figcaption><span>astronomical_units,echo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(downloader)</div><div class="line">##Download the data from</div><div class="line">url &lt;- &quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/astronomicalunit.csv&quot;</div><div class="line">filename &lt;- tempfile() </div><div class="line">if (!file.exists(filename)) download(url, destfile=filename)</div><div class="line"></div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">year &lt;-  jitter(dat[,2]) ##add jitter so points are not on top of each other</div><div class="line"></div><div class="line">##Use color to denote the labs that reported more than one measurement</div><div class="line">labs &lt;- as.character(dat[,1]) ##what lab did it</div><div class="line">labs[ !labs%in%c(&quot;Jodrell Bank&quot;,&quot;Spencer Jones&quot;)] &lt;- &quot;Others&quot;</div><div class="line">labs &lt;- factor(labs, levels=c(&quot;Others&quot;,&quot;Spencer Jones&quot;,&quot;Jodrell Bank&quot;))</div><div class="line">cols=as.numeric(labs)</div><div class="line"></div><div class="line">current &lt;- 92.956039 ##this is the current estimate in millions of mph</div><div class="line"></div><div class="line">mypar()</div><div class="line">plot(year, dat[,3], ylim=c(min(dat[,4]),max(dat[,5])), pch=16, col=cols, </div><div class="line">     xlab=&quot;Year&quot;,ylab=&quot;Astronomical unit (millions of miles)&quot;)</div><div class="line">for(i in 1:nrow(dat))</div><div class="line">  lines(c(year[i],year[i]),c(dat[i,4],dat[i,5]),col=cols[i],lwd=3)</div><div class="line">legend(&quot;topright&quot;, legend=levels(labs), col=seq_along( labs ) ,cex=0.75, lty=1,pch=16)</div><div class="line">abline(h=current,lty=2)</div><div class="line">text(1905,current,&quot;Current estimate&quot;,pos=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914105414.jpeg">

</div>
<p>从不同实验室之间的可变性以及报道的界限（可以理解为置信区间）来看，都不能解释这种可变性，这就清楚地表明不同实验室之间，而非某个实验室内部存在着某些效应。这种类型的变异就是我们所谓的批次效应。请注意，有些实验室报告了两个估计值（紫色和橙色），这样我们就在相同的实验室也看到了批次效应。 我们可以使用统计学符号来精确地描述这个问题。我们使用下面的公式来表示这些检测值： <span class="math display">\[
Y_{i,j} = 
\mu + \varepsilon_{i,j}, j=1,\dots,N
\]</span></p>
<p>其中，<span class="math inline">\(Y_{i,j}\)</span> 表示第 <span class="math inline">\(i\)</span> 个实验室的第 <span class="math inline">\(j\)</span> 个检测值，而 <span class="math inline">\(\mu\)</span> 表示真实的物理常数，<span class="math inline">\(\varepsilon_{i,j}\)</span> 表示独立的检测误差。为了解释可变性，我们引入了 <span class="math inline">\(\varepsilon_{i,j}\)</span> ，随后我们根据数据来计算标准误。就像本书前面提到的那样，我们使用 <span class="math inline">\(N\)</span> 值均值来估计物理物理常数，如下所示： <span class="math display">\[
\bar{Y}_i = 
\frac{1}{N} \sum_{i=1}^{N} Y_{i,j}
\]</span></p>
<p>再来构建一个置信区间： <span class="math display">\[
\bar{Y}_i 
 \pm 2 s_i / \sqrt{N} \mbox{ with }
s_i^2= 
\frac{1}{N-1} \sum_{i=1}^N (Y_{i,j} - 
\bar{Y}_i)^2
\]</span></p>
<p>但是，这个置信区间太小，它无法覆盖批次效应的变异，下面是一个更加合适的模型： <span class="math display">\[
Y_{i,j} = \mu +
\gamma_i + \varepsilon_{i,j}, j=1, \dots, N
\]</span></p>
<p>其中 <span class="math inline">\(\gamma_i\)</span> 表示一个实验室特定的偏差或批次效应(batch effect)。从图片上我们可以明显看出来，实验室之间 <span class="math inline">\(\gamma\)</span> 的变化要远大于一个实验室内部 <span class="math inline">\(\varepsilon\)</span> 的变化。用统计学的术语来描述这个问题就是，<span class="math inline">\(\mu\)</span> 和 <span class="math inline">\(\gamma\)</span> 无法被识别。我们可以估计 <span class="math inline">\(\mu_i+\gamma_i\)</span> ，但是无法区分开。我们可以将 <span class="math inline">\(\gamma\)</span> 视为一个随机变量。在这个案例中，每个实验室都有一个错误项 <span class="math inline">\(\gamma_i\)</span> ，这一项在贯穿于该实验室的所有检测值，在每个检测值中，这一项是相同的，但是实验室与实验室间的这一项则不同。因此，这个问题就可以用以下方程表示： <span class="math display">\[
 s_i / \sqrt{N} \mbox{ with } 
 s_i^2= 
\frac{1}{N-1} \sum_{i=1}^N (Y_{ij} - 
\bar{Y}_i)^2
\]</span></p>
<p>这是对标准差的低估，因为它没有解释由 <span class="math inline">\(\gamma\)</span> 导致的实验室内的相关性（这一句不懂，原文如下：</p>
<blockquote>
<p>Under this interpretation the problem is that:is an underestimate of the standard error since it does not account for the within lab correlation induced by <span class="math inline">\(\gamma\)</span>.</p>
</blockquote>
<p>如果我们假设 <span class="math inline">\(\gamma=0\)</span> ，那么利用来自几个实验室的数据，我们实际上可以估计出 <span class="math inline">\(\gamma\)</span> 。或者说我们可以将它们视为随机效应，简单地将它们当成一个新的估计值，并使用所有的检测值来计算其标准差。以下是我们将报告中的均值值视为随机观察值的置信区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">avg &lt;- mean(dat[,3])</div><div class="line">se &lt;- sd(dat[,3]) / sqrt(nrow(dat))</div><div class="line">cat(&quot;95% confidence interval is: [&quot;,avg-1.96*se,&quot;,&quot;, avg+1.96*se,&quot;]&quot;)</div><div class="line">cat(&quot;which does include the current estimate is:&quot;,current)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"95% confidence interval is: ["</span>,avg-<span class="number">1.96</span>*se,<span class="string">","</span>, avg+<span class="number">1.96</span>*se,<span class="string">"]"</span>)</div><div class="line"><span class="number">95</span>% confidence interval is: [ <span class="number">92.8727</span> , <span class="number">92.98542</span> ]&gt; cat(<span class="string">"which does include the current estimate is:"</span>,current)</div><div class="line">which does include the current estimate is: <span class="number">92.95604</span></div></pre></td></tr></table></figure>
<p>Youden的论文还包括最近关于光速以及策略常数的批次效应估计的案例。在这一章里，我们只展示高通量生物数据中批次效应的广泛性和复杂性。</p>
<p>## 混杂</p>
<p>书中有一个术语，即<code>confounding</code>，这里译为<code>混杂</code>。这一部分内容的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/confounding.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>当批次效应与我们的目标结果混杂时，就会导致严重的𨤹。这里我们描述一下混杂(confounding)，以及它与我们数据解释的关系。</p>
<p>我们从这本书或者说从任何其它数据分析课程中尝到最重要的思想之一就是“相关不等于因果”。这句话多数情况就是真的，一个常见的案例就是混杂(confounding)。简单地讲，当我们观察到 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 之间存在着相关(correlation)或关联(association)时，往往就会存在着混杂，但严格来说，这是因为 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 都依赖于一个无关的变量 <span class="math inline">\(Z\)</span> 。这里我们会描述一个Simposon悖论，这是一个基于一个著名的法律案件的案例，接着，我们还会提到一个在高通量生物学研究中的一个混杂案例。</p>
<h3 id="案例之simpson悖论">案例之Simpson悖论</h3>
<p>加州大学伯克分校(UCB)1973年的入学数据显示，在录取的学生中，44%是男性，30%是女性，显著男性更多，以下是这些数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">library(dagdata)</div><div class="line">data(admissions)</div><div class="line">admissions$total=admissions$Percent*admissions$Number/100</div><div class="line">##percent men get in</div><div class="line">sum(admissions$total[admissions$Gender==1]/sum(admissions$Number[admissions$Gender==1]))</div><div class="line">##percent women get in</div><div class="line">sum(admissions$total[admissions$Gender==0]/sum(admissions$Number[admissions$Gender==0]))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; sum(admissions$total[admissions$Gender==<span class="number">1</span>]/sum(admissions$Number[admissions$Gender==<span class="number">1</span>]))</div><div class="line">[<span class="number">1</span>] <span class="number">0.4451951</span></div><div class="line">&gt; <span class="comment">##percent women get in</span></div><div class="line">&gt; sum(admissions$total[admissions$Gender==<span class="number">0</span>]/sum(admissions$Number[admissions$Gender==<span class="number">0</span>]))</div><div class="line">[<span class="number">1</span>] <span class="number">0.3033351</span></div></pre></td></tr></table></figure>
<p>卡方检验的结果明确拒绝零假设，即录取的性别是独立的，两者不受影响（也就是说，男女录取公平），如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">##make a 2 x 2 table</div><div class="line">index = admissions$Gender==1</div><div class="line">men = admissions[index,]</div><div class="line">women = admissions[!index,]</div><div class="line">menYes = sum(men$Number*men$Percent/100)</div><div class="line">menNo = sum(men$Number*(1-men$Percent/100))</div><div class="line">womenYes = sum(women$Number*women$Percent/100)</div><div class="line">womenNo = sum(women$Number*(1-women$Percent/100))</div><div class="line">tab = matrix(c(menYes,womenYes,menNo,womenNo),2,2)</div><div class="line">print(chisq.test(tab)$p.val)</div></pre></td></tr></table></figure>
<p>p值如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(chisq.test(tab)$p.val)</div><div class="line">[<span class="number">1</span>] <span class="number">9.139492e-22</span></div></pre></td></tr></table></figure>
<p>但经过更仔细的观察会发现一个自相矛盾的结果，以下是按专业划分后，不同性别的录取百分比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,c(1,3)],admissions[7:12,3])</div><div class="line">colnames(y)[2:3]=c(&quot;Male&quot;,&quot;Female&quot;)</div><div class="line">y</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; y</div><div class="line">  Major Male Female</div><div class="line"><span class="number">1</span>     A   <span class="number">62</span>     <span class="number">82</span></div><div class="line"><span class="number">2</span>     B   <span class="number">63</span>     <span class="number">68</span></div><div class="line"><span class="number">3</span>     C   <span class="number">37</span>     <span class="number">34</span></div><div class="line"><span class="number">4</span>     D   <span class="number">33</span>     <span class="number">35</span></div><div class="line"><span class="number">5</span>     E   <span class="number">28</span>     <span class="number">24</span></div><div class="line"><span class="number">6</span>     <span class="literal">F</span>    <span class="number">6</span>      <span class="number">7</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，不同专业之间没有性别偏见。</p>
<p>但是，我们在前面使用了卡方检验发现，入学和性别之间存在着某种关系。然而，当我们的数据按照不同专业进行分组时，这种依赖性似乎消失了，这是怎么一回事呢？</p>
<p>这就是Simpson悖论的一个案例。</p>
<p>我们上面进行的卡方检验表明，入学和性别之间存在依赖关系。然而，当数据按专业分组时，这种依赖性似乎消失了。到底怎么回事？现在我们绘制一个能显示申请专业的人，以及最终进入这个专业读书的人的百分比的图形，用于说明男女在录取比例方面的问题，如下所示：</p>
<figure class="highlight plain"><figcaption><span>hard_major_confounding, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,5],admissions[7:12,5])</div><div class="line">y=sweep(y,2,colSums(y),&quot;/&quot;)*100</div><div class="line">x=rowMeans(cbind(admissions[1:6,3],admissions[7:12,3]))</div><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">matplot(x,y,xlab=&quot;percent that gets in the major&quot;,</div><div class="line">        ylab=&quot;percent that applies to major&quot;,</div><div class="line">        col=c(&quot;blue&quot;,&quot;red&quot;),cex=1.5)</div><div class="line">legend(&quot;topleft&quot;,c(&quot;Male&quot;,&quot;Female&quot;),col=c(&quot;blue&quot;,&quot;red&quot;),pch=c(&quot;1&quot;,&quot;2&quot;),box.lty=0)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914162851.jpeg">

</div>
<p>从图片上我们可以发现，男生更想申请那些“容易”的专业。也就是说，男生这个变量与“容易”专业这个变量发生了混杂。</p>
<h3 id="混杂的图形解释">混杂的图形解释</h3>
<p>在这一部分里，我们将混杂图形化。在下面的图形中，每个字母表示一个学生。被录取的人用绿色表示，字母表示专业。在第1张图中，所有相同性别的学生都被放在一起，我们可以发现，男生中绿色的比较更大，如下所示：</p>
<figure class="highlight plain"><figcaption><span>simpsons_paradox_illustration, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">###make data for plot</div><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">CEX=0.5</div><div class="line">NC &lt;- 70</div><div class="line">tmp=rowSums(tab)</div><div class="line">FNC &lt;- round(NC*tmp[2]/tmp[1])</div><div class="line">SCALE &lt;- 1</div><div class="line">makematrix&lt;-function(x,n,addx=0,addy=0)&#123;</div><div class="line">  m&lt;-ceiling(length(x)/n)</div><div class="line">  expand.grid(1:n+addx,addy+1:m)[seq(along=x),] </div><div class="line">&#125;</div><div class="line">males&lt;- sapply(1:6,function(i)&#123;</div><div class="line">  tot=admissions[i,2]*SCALE</div><div class="line">  p=admissions[i,3]/100</div><div class="line">  x=rep(c(0,1),round(tot*c(1-p,p)))</div><div class="line">&#125;)</div><div class="line">allmales&lt;-Reduce(c,males)</div><div class="line">females&lt;- sapply(7:12,function(i)&#123;</div><div class="line">  tot=admissions[i,2]*SCALE</div><div class="line">  p=admissions[i,3]/100</div><div class="line">  rep(c(0,1),round(tot*c(1-p,p)))</div><div class="line">&#125;)</div><div class="line">allfemales&lt;-Reduce(c,females)</div><div class="line">mypar(1,1)</div><div class="line">malepoints &lt;- makematrix(allmales,NC)</div><div class="line">femalepoints &lt;- makematrix(allfemales,FNC,NC+NC/10)</div><div class="line">NR &lt;- max(c(malepoints[,2],femalepoints[,2]))</div><div class="line">plot(0,type=&quot;n&quot;,xlim=c(min(malepoints[,1]),max(femalepoints[,1])),ylim=c(0,NR),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;)</div><div class="line">PCH=LETTERS[rep(1:6,sapply(males,length))]</div><div class="line">o&lt;-order(-allmales)</div><div class="line">points(malepoints,col=2-allmales[o],pch=PCH[o],cex=CEX)</div><div class="line">PCH=LETTERS[rep(1:6,sapply(females,length))]</div><div class="line">o&lt;-order(-allfemales)</div><div class="line">points(femalepoints,col=2-allfemales[o],pch=PCH[o],cex=CEX)</div><div class="line">abline(v=NC+NC/20)</div><div class="line">axis(side=3,c(NC/2,NC+NC/2),c(&quot;Male&quot;,&quot;Female&quot;),tick=FALSE)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163227.jpeg">

</div>
<p>现在我们按照专业对不同性别的学生进行分级。这里我们要注意，大多数被录取的学生（绿色）来源于两个容易的专业，即A和B，如下所示：</p>
<figure class="highlight plain"><figcaption><span>simpsons_paradox_illustration2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">malepoints &lt;- vector(&quot;list&quot;,length(males))</div><div class="line">femalepoints &lt;- vector(&quot;list&quot;,length(males))</div><div class="line">N&lt;- length(males)</div><div class="line"> </div><div class="line">ADDY &lt;- vector(&quot;numeric&quot;,N+1)</div><div class="line">for(i in 1:N)&#123;</div><div class="line">  malepoints[[i]] &lt;- makematrix(males[[i]],NC,0,ADDY[i])</div><div class="line">  femalepoints[[i]] &lt;- makematrix(females[[i]],FNC,NC+NC/10,ADDY[i])</div><div class="line">   ADDY[i+1] &lt;- max(malepoints[[i]][,2],femalepoints[[i]][,2])+1</div><div class="line">&#125;</div><div class="line">plot(0,type=&quot;n&quot;,</div><div class="line">     xlim=c( min(sapply(malepoints,function(x)min(x[,1]))),max(sapply(femalepoints,function(x)max(x[,1])))),</div><div class="line">  ylim=c(0,max(sapply(femalepoints,function(x)max(x[,2])))),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;)</div><div class="line">          </div><div class="line">for(i in 1:N)&#123;</div><div class="line">  points(malepoints[[i]],col=2+sort(-males[[i]]),pch=LETTERS[i],cex=CEX)</div><div class="line">  points(femalepoints[[i]],col=2+sort(-females[[i]]),pch=LETTERS[i],cex=CEX)</div><div class="line">  if(i&gt;1) abline(h=ADDY[i])</div><div class="line">  &#125;</div><div class="line">abline(v=NC+NC/20)</div><div class="line">axis(side=3,c(NC/2,NC+FNC/2),c(&quot;Male&quot;,&quot;Female&quot;),tick=FALSE)</div><div class="line">axis(side=2,ADDY[-1]/2+ADDY[-length(ADDY)]/2,LETTERS[1:N],tick=FALSE,las=1)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163301.jpeg">

</div>
<h3 id="分层后的均值">分层后的均值</h3>
<p>在下图中，我们可以看到，我们根据专业设定条件或分层后，然后再看差异，也就是说，当我们控制了混杂项后，这就混杂效应就消失了，如下所示：</p>
<figure class="highlight plain"><figcaption><span>admission_by_major, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,3],admissions[7:12,3])</div><div class="line">matplot(1:6,y,xaxt=&quot;n&quot;,xlab=&quot;major&quot;,ylab=&quot;percent&quot;,col=c(&quot;blue&quot;,&quot;red&quot;),cex=1.5)</div><div class="line">axis(1,1:6,LETTERS[1:6])</div><div class="line">legend(&quot;topright&quot;,c(&quot;Male&quot;,&quot;Female&quot;),col=c(&quot;blue&quot;,&quot;red&quot;),pch=c(&quot;1&quot;,&quot;2&quot;),</div><div class="line">       box.lty=0)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163912.jpeg">

</div>
<p>事实上，在不同专业录取的学生中，性别差异仅表示为，男生比女生高3.5%，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mean(y[,1]-y[,2])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y[,<span class="number">1</span>]-y[,<span class="number">2</span>])</div><div class="line">[<span class="number">1</span>] -<span class="number">3.5</span></div></pre></td></tr></table></figure>
<h3 id="棒球中的simpson悖论">棒球中的Simpson悖论</h3>
<p>在棒球比赛的统计中我们也经常看到Simpson悖论，现在我们来看一个有名的案例，在1995年和1996年，David Justice的平均击球率高于Derek Jeter，但是Jeter的击球率却高于整体平均水平，如下所示：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>1995</th>
<th>1996</th>
<th>Combined</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Derek Jeter</td>
<td>12/48 (.250)</td>
<td>183/582 (.314)</td>
<td>195/630 (.310)</td>
</tr>
<tr class="even">
<td>David Justice</td>
<td>104/411 (.253)</td>
<td>45/140 (.321)</td>
<td>149/551 (.270)</td>
</tr>
</tbody>
</table>
<p>这里的混杂项就是比赛场次，Jeter的比赛场次数目更多，但是结果却是Justice击球率更高。</p>
<h3 id="混杂之高通量案例">混杂之高通量案例</h3>
<p>为了描述我们在生物学中遇到的混杂问题，我们将会使用<a href="https://www.ncbi.nlm.nih.gov/pubmed/17206142" target="_blank" rel="external">《Common genetic variants account for differences in gene expression among ethnic groups》</a>这篇文献中的数据集，这篇文献指出，两个不同种族的血液大约有50%的差异基因，现在我们来下载这个数据集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(Biobase) ##available from Bioconductor</div><div class="line">library(genefilter) </div><div class="line">load(&quot;GSE5859.rda&quot;) ##available from github</div></pre></td></tr></table></figure>
<p>我们使用Bioconductor中的函数<code>exprs</code>和<code>pData</code>就能提取基因的表达数据与样本信息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">geneExpression = exprs(e)</div><div class="line">sampleInfo = pData(e)</div></pre></td></tr></table></figure>
<p>需要注意，样本按照不同的时间进行了处理，如下所示：</p>
<p>Note that some samples were processed at different times.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">head(sampleInfo)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(sampleInfo)</div><div class="line">  ethnicity       date        filename</div><div class="line"><span class="number">1</span>       CEU <span class="number">2003</span>-<span class="number">02</span>-<span class="number">04</span> GSM25349.CEL.gz</div><div class="line"><span class="number">2</span>       CEU <span class="number">2003</span>-<span class="number">02</span>-<span class="number">04</span> GSM25350.CEL.gz</div><div class="line"><span class="number">3</span>       CEU <span class="number">2002</span>-<span class="number">12</span>-<span class="number">17</span> GSM25356.CEL.gz</div><div class="line"><span class="number">4</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">30</span> GSM25357.CEL.gz</div><div class="line"><span class="number">5</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">03</span> GSM25358.CEL.gz</div><div class="line"><span class="number">6</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">16</span> GSM25359.CEL.gz</div></pre></td></tr></table></figure>
<p>日期是一个无关的变量，它理论上不影响这个数据集中基因的表达值，然而，正如我们在前面分析中看到的那样，这个日期似乎也起了一些作用，因此我们在这里就来讲一下这个日期的因素。 我们可以明显看到，日期和种族这两个因素几乎完全混杂了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">year = factor( format(sampleInfo$date,&quot;%y&quot;) )</div><div class="line">tab = table(year,sampleInfo$ethnicity)</div><div class="line">print(tab)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; print(tab)</div><div class="line">    </div><div class="line">year ASN CEU HAN</div><div class="line">  <span class="number">02</span>   <span class="number">0</span>  <span class="number">32</span>   <span class="number">0</span></div><div class="line">  <span class="number">03</span>   <span class="number">0</span>  <span class="number">54</span>   <span class="number">0</span></div><div class="line">  <span class="number">04</span>   <span class="number">0</span>  <span class="number">13</span>   <span class="number">0</span></div><div class="line">  <span class="number">05</span>  <span class="number">80</span>   <span class="number">3</span>   <span class="number">0</span></div><div class="line">  <span class="number">06</span>   <span class="number">2</span>   <span class="number">0</span>  <span class="number">24</span></div></pre></td></tr></table></figure>
<p>通过t检验以及生成的火山图我们可以发现，不同种族之间似乎存在着数千个差异基因。但是，当我们仅仅对2002年和2003年的CEU人群进行比较发现，我们又发现了数千个差异基因：</p>
<figure class="highlight plain"><figcaption><span>volcano_plots, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">library(genefilter)</div><div class="line">##remove control genes</div><div class="line">out &lt;- grep(&quot;AFFX&quot;,rownames(geneExpression))</div><div class="line">eth &lt;- sampleInfo$ethnicity</div><div class="line">ind&lt;- which(eth%in%c(&quot;CEU&quot;,&quot;ASN&quot;))</div><div class="line">res1 &lt;- rowttests(geneExpression[-out,ind],droplevels(eth[ind]))</div><div class="line">ind &lt;- which(year%in%c(&quot;02&quot;,&quot;03&quot;) &amp; eth==&quot;CEU&quot;)</div><div class="line">res2 &lt;- rowttests(geneExpression[-out,ind],droplevels(year[ind]))</div><div class="line">XLIM &lt;- max(abs(c(res1$dm,res2$dm)))*c(-1,1)</div><div class="line">YLIM &lt;- range(-log10(c(res1$p,res2$p)))</div><div class="line">mypar(1,2)</div><div class="line">plot(res1$dm,-log10(res1$p),xlim=XLIM,ylim=YLIM,</div><div class="line">     xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;,main=&quot;Populations&quot;)</div><div class="line">plot(res2$dm,-log10(res2$p),xlim=XLIM,ylim=YLIM,</div><div class="line">     xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;,main=&quot;2003 v 2002&quot;)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914165820.jpeg">

</div>
<h2 id="练习">练习</h2>
<p>P419</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/24/DAL/DALS024_Basic_Machine_Learning03_Class_Prediction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/24/DAL/DALS024_Basic_Machine_Learning03_Class_Prediction/" itemprop="url">DALS024-机器学习03-分类预测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-24T12:00:00+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,035
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第3小节，这一部分的主要内容涉及类预测(Class Prediction)，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/machine_learning.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在这一部分中我们主要介绍分类预测(class prediction)。实际上，许多人将分类预测称为机器学习，有的时候我们会交替使用这两个术语。我们会对这个庞杂的主题做一个非常简单的介绍，重点关注一些具体的案例。</p>
<p>我们这里使用的案例来源于统计学的经典书籍，即Trevor Hastie, Robert Tibshirani and Jerome Friedman的《<em>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</em>》。与回归中的推断类似，机器学习(ML)也是研究结果 <span class="math inline">\(Y\)</span> 和协变量 <span class="math inline">\(X\)</span> 之间的关系。在ML中，我们将 <span class="math inline">\(X\)</span> 称为预测因子或特征值，ML和推断之间的主要区别在于，在ML中，我们主要研究使用 <span class="math inline">\(X\)</span> 来预测 <span class="math inline">\(Y\)</span> 。关于统计模型，我在常规的推断中，我们主要用来估计和解释模型参数，但在ML中，统计模型只是我们达到目的的手段，即预测 <span class="math inline">\(Y\)</span> 。</p>
<p>这里我们介绍理解ML的主要概念，以及两个具体的算法：回归(regression)和k近似算法(kNN,k nearest neighbors)。我们需要知道，绐中学习有几十种流行的算法，我们这里不一一列举。</p>
<p>在前面部分里，我们介绍了非常简单的单一预测因子案例。但是，大多数与这种案例相关的案例往往不止一个预测因子。为了说明这个问题，我们现在再介绍一个案例，其中 <span class="math inline">\(X\)</span> 是一个二维数据，<span class="math inline">\(Y\)</span> 是一个二分类结果。这个案例来源于Hastie, Tibshirani 和 Friedman的书中，在这个案例中， <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 并不线性关系。在下面的图形中，使用不 的颜色表示了实际的 <span class="math inline">\(f(x_1,x_2)=E(Y \mid X_1=x_1,X_2=x_2)\)</span> 值。下面的代码用于生成一个相对复杂的条件概率函数。我们随后会使用测试数据集与训练数据集。在下图中，我们使用红色来表示 <span class="math inline">\(f(x_1,x_2)\)</span>中接近于1的数据，使用蓝色表示接近于0的数据，中间过渡态使用黄色表示，如下所示：</p>
<figure class="highlight plain"><figcaption><span>conditional_prob, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(RColorBrewer)</div><div class="line">hmcol &lt;- colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(100)</div><div class="line">mycols=c(hmcol[1],hmcol[100])</div><div class="line">set.seed(1)</div><div class="line">##create covariates and outcomes</div><div class="line">##outcomes are alwasy 50 0s and 50 1s</div><div class="line">s2=0.15</div><div class="line">##pick means to create a non linear conditional expectation</div><div class="line">library(MASS)</div><div class="line">M0 &lt;- mvrnorm(10,c(1,0),s2*diag(2)) ##generate 10 means</div><div class="line">M1 &lt;- rbind(mvrnorm(3,c(1,1),s2*diag(2)),</div><div class="line">            mvrnorm(3,c(0,1),s2*diag(2)),</div><div class="line">            mvrnorm(4,c(0,0),s2*diag(2)))</div><div class="line">###funciton to generate random pairs</div><div class="line">s&lt;- sqrt(1/5)</div><div class="line">N=200</div><div class="line">makeX &lt;- function(M,n=N,sigma=s*diag(2))&#123;</div><div class="line">  z &lt;- sample(1:10,n,replace=TRUE) ##pick n at random from above 10</div><div class="line">  m &lt;- M[z,] ##these are the n vectors (2 components)</div><div class="line">  return(t(apply(m,1,function(mu) mvrnorm(1,mu,sigma)))) ##the final values</div><div class="line">&#125;</div><div class="line">###create the training set and the test set</div><div class="line">x0 &lt;- makeX(M0)##the final values for y=0 (green)</div><div class="line">testx0 &lt;- makeX(M0)</div><div class="line">x1 &lt;- makeX(M1)</div><div class="line">testx1 &lt;-makeX(M1)</div><div class="line">x &lt;- rbind(x0,x1) ##one matrix with everything</div><div class="line">test &lt;- rbind(testx0,testx1)</div><div class="line">y &lt;- c(rep(0,N),rep(1,N)) #the outcomes</div><div class="line">ytest &lt;- c(rep(0,N),rep(1,N))</div><div class="line">cols &lt;- mycols[c(rep(1,N),rep(2,N))]</div><div class="line">colstest &lt;- cols</div><div class="line">##Create a grid so we can predict all of X,Y</div><div class="line">GS &lt;- 150 ##grid size is GS x GS</div><div class="line">XLIM &lt;- c(min(c(x[,1],test[,1])),max(c(x[,1],test[,1])))</div><div class="line">tmpx &lt;- seq(XLIM[1],XLIM[2],len=GS)</div><div class="line">YLIM &lt;- c(min(c(x[,2],test[,2])),max(c(x[,2],test[,2])))</div><div class="line">tmpy &lt;- seq(YLIM[1],YLIM[2],len=GS)</div><div class="line">newx &lt;- expand.grid(tmpx,tmpy) #grid used to show color contour of predictions</div><div class="line">###Bayes rule: best possible answer</div><div class="line">p &lt;- function(x)&#123; ##probability of Y given X</div><div class="line">  p0 &lt;- mean(dnorm(x[1],M0[,1],s)*dnorm(x[2],M0[,2],s))</div><div class="line">  p1 &lt;- mean(dnorm(x[1],M1[,1],s)*dnorm(x[2],M1[,2],s))</div><div class="line">  p1/(p0+p1)</div><div class="line">&#125;</div><div class="line">###Create the bayesrule prediction</div><div class="line">bayesrule &lt;- apply(newx,1,p)</div><div class="line">colshat &lt;- bayesrule</div><div class="line">colshat &lt;- hmcol[floor(bayesrule*100)+1]</div><div class="line">mypar()</div><div class="line">plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912170040.jpeg">

</div>
<p>如果我们将那些 <span class="math inline">\(E(Y \mid X=x)&gt;0.5\)</span> 的点用红色表示，剩下的点用蓝色表示，我们就能看到一条明显的分界线，它将0与1的区域分开了，如下所示：</p>
<figure class="highlight plain"><figcaption><span>bayes_rule,fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">colshat[bayesrule&gt;=0.5] &lt;- mycols[2]</div><div class="line">colshat[bayesrule&lt;0.5] &lt;- mycols[1]</div><div class="line">plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div><div class="line">contour(tmpx,tmpy,matrix(round(bayesrule),GS,GS),levels=c(1,2),</div><div class="line">        add=TRUE,drawlabels=FALSE)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912170527.jpeg">

</div>
<p>通过上面的图形我们并没有看到“真相”(truth)。大多数的ML方法涉及估计的 <span class="math inline">\(f(x)\)</span> 。通常第一步就是将一个样本作为参数，也就是训练集(training set)，用它来估计 <span class="math inline">\(f(x)\)</span> 。我们将回顾一下两种具体的ML技术。首先，我们需要回顾一下我们用评估这些方法性能的主要概念。</p>
<h3 id="训练集">训练集</h3>
<p>在第一张图中，我们创建了一个训练集和一个测试集，现在我们画出来，如下所示：</p>
<figure class="highlight plain"><figcaption><span>test_train, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#x, test, cols, and coltest were created in code that was not shown</div><div class="line">#x is training x1 and x2, test is test x1 and x2</div><div class="line">#cols (0=blue, 1=red) are training observations</div><div class="line">#coltests are test observations</div><div class="line">mypar(1,2)</div><div class="line">plot(x,pch=21,bg=cols,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">plot(test,pch=21,bg=colstest,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912171217.jpeg">

</div>
<p>从上面我们可以看到，训练集（左侧）与测试集（右侧）有着相似的全局属性，因为它们是用相同的随机谈量生成的（蓝色点都趋向分布于右下角），但是它们的构建的过程还是不同的。原因在于，我们创建测试集和训练集的原因是通过测试与用于拟合模型或训练算法的数据不同的数据来检测过度训练。 我们将在下面看到它的重要性。</p>
<h4 id="利用回归进行预测">利用回归进行预测</h4>
<p>关于ML问题的第一个简单方法就是拟合一个双变量线性回归模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##x and y were created in the code (not shown) for the first plot</div><div class="line">#y is outcome for the training set</div><div class="line">X1 &lt;- x[,1] ##these are the covariates</div><div class="line">X2 &lt;- x[,2] </div><div class="line">fit1 &lt;- lm(y~X1+X2)</div></pre></td></tr></table></figure>
<p>一旦我们有了这些拟合的数据，我们就能使用 <span class="math inline">\(\hat{f}(x_1,x_2)=\hat{\beta}_0 + \hat{\beta}_1x_1 +\hat{\beta}_2 x_2\)</span> 来估计 <span class="math inline">\(f(x_1,x_2)\)</span> 。为了提供一个实际的预测结果，我们仅仅预测当 <span class="math inline">\(\hat{f}(x_1,x_2)&gt;0.5\)</span> 时结果为1（这一段不懂）。我们现在检测一个在训练集与测试集中的错误率，并绘制出边界区域，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">##prediction on train</div><div class="line">yhat &lt;- predict(fit1)</div><div class="line">yhat &lt;- as.numeric(yhat&gt;0.5)</div><div class="line">cat(&quot;Linear regression prediction error in train:&quot;,1-mean(yhat==y),&quot;\n&quot;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Linear regression prediction error <span class="keyword">in</span> train: <span class="number">0.295</span></div></pre></td></tr></table></figure>
<p>我们使用<code>predict()</code>函数就能很快地从任意数据集中来获得预测值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yhat &lt;- predict(fit1,newdata=data.frame(X1=newx[,1],X2=newx[,2]))</div></pre></td></tr></table></figure>
<p>现在我们生成图片，用于展示我们预测的1和0在图片上的分布，以及边界。我们还可以使用<code>predict()</code>函数从我们的测试集中生成预测数据。需要注意的是，我们无法在测试集中拟合模型：</p>
<figure class="highlight plain"><figcaption><span>regression_prediction, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">colshat &lt;- yhat</div><div class="line">colshat[yhat&gt;=0.5] &lt;- mycols[2]</div><div class="line">colshat[yhat&lt;0.5] &lt;- mycols[1]</div><div class="line">m &lt;- -fit1$coef[2]/fit1$coef[3] #boundary slope</div><div class="line">b &lt;- (0.5 - fit1$coef[1])/fit1$coef[3] #boundary intercept</div><div class="line">##prediction on test</div><div class="line">yhat &lt;- predict(fit1,newdata=data.frame(X1=test[,1],X2=test[,2]))</div><div class="line">yhat &lt;- as.numeric(yhat&gt;0.5)</div><div class="line">cat(&quot;Linear regression prediction error in test:&quot;,1-mean(yhat==ytest),&quot;\n&quot;)</div><div class="line">plot(test,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">abline(b,m)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div><div class="line">##test was created in the code (not shown) for the first plot</div><div class="line">points(test,bg=cols,pch=21)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912173537.jpeg">

</div>
<p>在上图中，我们使用 <span class="math inline">\(X_{1}\)</span>和 <span class="math inline">\(X_{2}\)</span> 作为预测因子估计了1的概率，预测的结果将高于0.5的数据标注成了红色，低于0.5的标注为了蓝色。</p>
<p>从计算结果来年地，训练集与测试集的错误率非常相似。因此我们可以相信似乎没有过度训练。这并不奇怪，因为我们使用了2参数模型来拟合400个数据点。不过需要注意的是，边界是一个直线。因为我们为这些数据拟合了一个平面，所以这里没有其它选择。线性回归方法过于僵化。这种僵化会让它稳定，并且避免过度训练。，但是线性回归也不能适合对 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(X\)</span> 之间的非线性关系进行拟合。我们之前在平滑部分中看到了这些东西。下一个ML技术将会达到我们之间平滑处理的那种效果。</p>
<h4 id="knn">kNN</h4>
<p>kNN的全称是K-nearest neighbors，即<code>k最近邻</code>，这种算法类似于微区间平滑处理，但是kNN更适合于多维数据。总的来说，只要给定我们想要估计的任意点 <span class="math inline">\(x\)</span> ，我们会寻找k个最近的点，然后取这些点的平均值。这就会估计 <span class="math inline">\(f(x_1,x_2)\)</span> , 跟微区间平滑处理生成一个条曲线类似。我们现在通过 <span class="math inline">\(k\)</span> 来控制灵活性。这时我们比较一下 <span class="math inline">\(k=1\)</span> 和 <span class="math inline">\(k=100\)</span> 时的计算结果：</p>
<figure class="highlight plain"><figcaption><span>message</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">mypar(2,2)</div><div class="line">for(k in c(1,100))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=k)</div><div class="line">  cat(&quot;KNN prediction error in train:&quot;,1-mean((as.numeric(yhat)-1)==y),&quot;\n&quot;)</div><div class="line">  ##make plot</div><div class="line">  yhat &lt;- knn(x,test,y,k=k)</div><div class="line">  cat(&quot;KNN prediction error in test:&quot;,1-mean((as.numeric(yhat)-1)==ytest),&quot;\n&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">&gt; <span class="keyword">for</span>(k <span class="keyword">in</span> c(<span class="number">1</span>,<span class="number">100</span>))&#123;</div><div class="line">+   <span class="comment">##predict on train</span></div><div class="line">+   yhat &lt;- knn(x,x,y,k=k)</div><div class="line">+   cat(<span class="string">"KNN prediction error in train:"</span>,<span class="number">1</span>-mean((as.numeric(yhat)-<span class="number">1</span>)==y),<span class="string">"\n"</span>)</div><div class="line">+   <span class="comment">##make plot</span></div><div class="line">+   yhat &lt;- knn(x,test,y,k=k)</div><div class="line">+   cat(<span class="string">"KNN prediction error in test:"</span>,<span class="number">1</span>-mean((as.numeric(yhat)-<span class="number">1</span>)==ytest),<span class="string">"\n"</span>)</div><div class="line">+ &#125;</div><div class="line">KNN prediction error <span class="keyword">in</span> train: <span class="number">0</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> test: <span class="number">0.375</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> train: <span class="number">0.2425</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> test: <span class="number">0.2825</span></div></pre></td></tr></table></figure>
<p>为了说明，当我们设定 <span class="math inline">\(k=1\)</span>时，训练集中没有错误，以及 <span class="math inline">\(k=100\)</span> 时错误升高的原因，我们用图片直观地展示一下上面的结果，如下所示：</p>
<figure class="highlight plain"><figcaption><span>knn, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">mypar(2,2)</div><div class="line">for(k in c(1,100))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=k)</div><div class="line">  ##make plot</div><div class="line">  yhat &lt;- knn(x,newx,y,k=k)</div><div class="line">  colshat &lt;- mycols[as.numeric(yhat)]</div><div class="line">  plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">  points(newx,col=colshat,cex=0.35,pch=16)</div><div class="line">  contour(tmpx,tmpy,matrix(as.numeric(yhat),GS,GS),levels=c(1,2),</div><div class="line">          add=TRUE,drawlabels=FALSE)</div><div class="line">  points(x,bg=cols,pch=21)</div><div class="line">  title(paste(&quot;Train: KNN (&quot;,k,&quot;)&quot;,sep=&quot;&quot;))</div><div class="line">  </div><div class="line">  plot(test,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">  points(newx,col=colshat,cex=0.35,pch=16)</div><div class="line">  contour(tmpx,tmpy,matrix(as.numeric(yhat),GS,GS),levels=c(1,2),</div><div class="line">          add=TRUE,drawlabels=FALSE)</div><div class="line">  points(test,bg=cols,pch=21)</div><div class="line">  title(paste(&quot;Test: KNN (&quot;,k,&quot;)&quot;,sep=&quot;&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912174226.jpeg">

</div>
<p>从图上我们可以发现，当 <span class="math inline">\(k=1\)</span> 时，在训练集中并没有出现错误，因为每个点都是它最接近的点，这个就是它自身。但是，我们可以看到一些蓝色的岛（由几个点构成的区域）在红色区域中，一旦我们将数据集移向测试集，就会出现一些错误。当 <span class="math inline">\(k=100\)</span> 时，我们没有这个问题（也就是说红蓝区域分得很开），我们可以看到，错误率比线性回归有着明显的降低。我们还看到，我们估计的 <span class="math inline">\(f(x_1,x_2)\)</span> 比较接近于真实情况。</p>
<h4 id="贝叶斯规则">贝叶斯规则</h4>
<p>在这一部分里，我们会比较了不同 <span class="math inline">\(k\)</span> 值下的训练集与测试集。我们还会比较当我们知道 <span class="math inline">\(\mbox{E}(Y \mid X_1=x1,X_2=x_2)\)</span> 时的错误率，这也就是所谓的贝叶斯规则(Bayes Rule)。</p>
<p>我们先来计算一下错误率，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">###Bayes Rule</div><div class="line">yhat &lt;- apply(test,1,p)</div><div class="line">cat(&quot;Bayes rule prediction error in train&quot;,1-mean(round(yhat)==y),&quot;\n&quot;)</div><div class="line">bayes.error=1-mean(round(yhat)==y)</div><div class="line">train.error &lt;- rep(0,16)</div><div class="line">test.error &lt;- rep(0,16)</div><div class="line">for(k in seq(along=train.error))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=2^(k/2))</div><div class="line">  train.error[k] &lt;- 1-mean((as.numeric(yhat)-1)==y)</div><div class="line">  ##prediction on test    </div><div class="line">  yhat &lt;- knn(x,test,y,k=2^(k/2))</div><div class="line">  test.error[k] &lt;- 1-mean((as.numeric(yhat)-1)==y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后绘制出不同 <span class="math inline">\(k\)</span> 值下的错误率。我们还以一条水平线来展示贝叶斯规则错误率，如下所示</p>
<figure class="highlight plain"><figcaption><span>bayes_rule2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ks &lt;- 2^(seq(along=train.error)/2)</div><div class="line">mypar()</div><div class="line">plot(ks,train.error,type=&quot;n&quot;,xlab=&quot;K&quot;,ylab=&quot;Prediction Error&quot;,log=&quot;x&quot;,</div><div class="line">     ylim=range(c(test.error,train.error)))</div><div class="line">lines(ks,train.error,type=&quot;b&quot;,col=4,lty=2,lwd=2)</div><div class="line">lines(ks,test.error,type=&quot;b&quot;,col=5,lty=3,lwd=2)</div><div class="line">abline(h=bayes.error,col=6)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;Train&quot;,&quot;Test&quot;,&quot;Bayes&quot;),col=c(4,5,6),lty=c(2,3,1),box.lwd=0)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913013135.jpeg">

</div>
<p>在上图中，粉色是训练集的错误率，绿色的是测试集的错误率。黄色是贝叶斯规则的错误率。</p>
<p>我们要知道，错误率是一个随机变量，它有着标准差。在下面的部分里，我们会提到交叉验证，这种方法有助于降低一些变异（这里我自己的理解就是错误率的变异）。然而即使将这些变异降低，从图中我们就可以看出来，当 <span class="math inline">\(k\)</span> 低于20时就会出现过拟合(over-fitting)，当 <span class="math inline">\(k\)</span> 超过100时就会出现低拟合(under-fitting)。</p>
<h2 id="交叉验证">交叉验证</h2>
<p>这里我们描述一下交叉验证(cross-validation)，交叉验证是机器学习中有关方法评估的一个基础工具，它能在一项预测或机器学习任务中进行参数选择。假设我们有一组许多特征值的观测值，并且每个观测值都与一个标签关联。我们将这个集合称为我们的训练集。我们的任务就是通过从训练数据中学习模式来预测任何新样本的标签。对于一个具体的例子来说，例如我们会将每个基因看作是一个特征值，然后我们再来计算一组没有标签的数据（测试数据集），看一下这组数据是新样本中的哪些组织类型。</p>
<p>如果我们选择了一个可调参数的机器学习算法，那么我们必须要有一个策略来这个参数选择一个最佳值。我们可以尝试着先计算一批数据，例如可以把一些已知样本的数据当作训练集，然后算法会计算出这些值产生的错误数据，然后我们会选择在我们的训练集中表现最好的值。</p>
<p>现在我们使用前面提到过的组织基要因表达数据集来看一下，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">library(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div></pre></td></tr></table></figure>
<p>为了说明我们这么做的目的，我们把那些样本数目较少的组织剔除掉，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">table(tissue)</div><div class="line">ind &lt;- which(tissue != &quot;placenta&quot;)</div><div class="line">y &lt;- tissue[ind]</div><div class="line">X &lt;- t( e[,ind] )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; table(tissue)</div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们把<code>placenta(胎盘)</code>这个组织去掉了，现在我们使用kNN法来进行归类，先使用 <span class="math inline">\(k=5\)</span> 这个参数试一下。当我们把这个参数用于训练集和测试集时，我们在预测训练集中的组织时，平均误差是多少呢？</p>
<p>计算过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">pred &lt;- knn(train =  X, test = X, cl=y, k=5)</div><div class="line">mean(y != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当我们使用 <span class="math inline">\(k=5\)</span> 这个参数时，没有发现错误，如果是 <span class="math inline">\(k=1\)</span> 呢？如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pred &lt;- knn(train=X, test=X, cl=y, k=1)</div><div class="line">mean(y != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当我们试图通过对观测值进行分类用于训练(train)模型时，这一过程可能有误导性。事实时，对于kNN法来说，使用 <span class="math inline">\(k=1\)</span> 这个参数时，总是能在训练集中得到0个分类错误，因为我们使用的是数据本身。了解算法是否可靠的方法就让它对未见过的样本进行预测。类似地，如果我们想知道可调参数的最佳值是什么，我们查看不同的参数值在那些不在训练集中的样本上表现如何。</p>
<p>交叉验证是机器学习中广泛使用的一种方法，它解决了训练集和测试集的问题，同时它仍然可以使用所有的数据用于检测预测的准确性。它通过将所有的数据分散成一定数据的折叠(fold)（注：这里有关交叉验证的问题，可以参考以前的文章<a href="http://rvdsd.top/2018/07/05/StatQuest/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B022-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/">《StatQuest学习笔记22——交叉验证》</a>）。如果我们有 <span class="math inline">\(N\)</span> 个折叠，那么算法的第一步就是使用 <span class="math inline">\((N-1)\)</span> 个折叠来训练算法，并且剩下一个折叠用于测试算法的准确性。然后重复 <span class="math inline">\(N\)</span> 次，直到所有的折叠都在测试集中一样被使用。如果我们有M个参数需要进行尝试，那么我们需要在外部循环中完成这个过程，因为我们需要总共拟合 <span class="math inline">\(N \times M\)</span>次。</p>
<p>在R中，我们使用<code>caret</code>包中的<code>createFolds()</code>函数来实现这个过程,在下面的案例中，我们使用5个折叠来计算我们的基因表达数据，这个数字与组织的数目比较接近。此外，<code>createFold()</code>函数中有个参数<code>k</code>，这里不要与kNN算法中的<code>k</code>混淆，它们只是相同的字符，具体意义不一样，它们完全不相关。<code>createFolds()</code>会寻问用户要创建多少个折叠，也就是上文提到的 <span class="math inline">\(N\)</span> 。而<code>knn()</code>中的参数<code>k</code>则是说明在一个新的样本中，使用多少个最接近的观测值。现在我们创建10个折叠，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">library(caret)</div><div class="line">set.seed(1)</div><div class="line">idx &lt;- createFolds(y, k=10)</div><div class="line">sapply(idx, length)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; sapply(idx, length)</div><div class="line">Fold01 Fold02 Fold03 Fold04 Fold05 Fold06 Fold07 Fold08 Fold09 Fold10 </div><div class="line">    <span class="number">18</span>     <span class="number">19</span>     <span class="number">17</span>     <span class="number">17</span>     <span class="number">18</span>     <span class="number">20</span>     <span class="number">19</span>     <span class="number">19</span>     <span class="number">20</span>     <span class="number">16</span></div></pre></td></tr></table></figure>
<p>折叠会以数字索引列表的形式返回，因此数据的第一个折叠是：</p>
<p>The folds are returned as a list of numeric indices. The first fold of data is therefore:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y[idx[[1]]] ##the labels</div><div class="line">head( X[idx[[1]], 1:3] ) ##the genes (only showing the first 3 genes...)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; y[idx[[<span class="number">1</span>]]] <span class="comment">##the labels</span></div><div class="line"> [<span class="number">1</span>] <span class="string">"kidney"</span>      <span class="string">"kidney"</span>      <span class="string">"hippocampus"</span> <span class="string">"hippocampus"</span> <span class="string">"hippocampus"</span> <span class="string">"cerebellum"</span> </div><div class="line"> [<span class="number">7</span>] <span class="string">"cerebellum"</span>  <span class="string">"cerebellum"</span>  <span class="string">"colon"</span>       <span class="string">"colon"</span>       <span class="string">"colon"</span>       <span class="string">"colon"</span>      </div><div class="line">[<span class="number">13</span>] <span class="string">"kidney"</span>      <span class="string">"kidney"</span>      <span class="string">"endometrium"</span> <span class="string">"endometrium"</span> <span class="string">"liver"</span>       <span class="string">"liver"</span>      </div><div class="line">&gt; head( X[idx[[<span class="number">1</span>]], <span class="number">1</span>:<span class="number">3</span>] ) <span class="comment">##the genes (only showing the first 3 genes...)</span></div><div class="line">                1007_s_at  1053_at   117_at</div><div class="line">GSM12075.CEL.gz  <span class="number">9.966782</span> <span class="number">6.060069</span> <span class="number">7.644452</span></div><div class="line">GSM12098.CEL.gz  <span class="number">9.945652</span> <span class="number">5.927861</span> <span class="number">7.847192</span></div><div class="line">GSM21214.cel.gz <span class="number">10.955428</span> <span class="number">5.776781</span> <span class="number">7.493743</span></div><div class="line">GSM21218.cel.gz <span class="number">10.757734</span> <span class="number">5.984170</span> <span class="number">8.525524</span></div><div class="line">GSM21230.cel.gz <span class="number">11.496114</span> <span class="number">5.760156</span> <span class="number">7.787561</span></div><div class="line">GSM87086.cel.gz  <span class="number">9.798633</span> <span class="number">5.862426</span> <span class="number">7.279199</span></div></pre></td></tr></table></figure>
<p>我们可以看到，事实上组织在10个折叠中表现非常平均：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sapply(idx, function(i) table(y[i]))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; sapply(idx, <span class="keyword">function</span>(i) table(y[i]))</div><div class="line">            Fold01 Fold02 Fold03 Fold04 Fold05 Fold06 Fold07 Fold08 Fold09 Fold10</div><div class="line">cerebellum       <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span></div><div class="line">colon            <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">3</span></div><div class="line">endometrium      <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span></div><div class="line">hippocampus      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span></div><div class="line">kidney           <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span></div><div class="line">liver            <span class="number">2</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span>      <span class="number">2</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span></div></pre></td></tr></table></figure>
<p>因为不同组织的表达谱不一样，因此使用所有的基因来预测组织非常容易。为了说明这种算法的原理，我们这里只使用二维数据来进行预测，现在我们使用<code>cmdscale()</code>函数进行降低处理：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">Xsmall &lt;- cmdscale(dist(X))</div><div class="line">plot(Xsmall,col=as.fumeric(y))</div><div class="line">legend(<span class="string">"topleft"</span>,levels(factor(y)),fill=seq_along(levels(factor(y))))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913180841.jpeg">

</div>
<p>现在我们在单个折叠上试一下kNN法。我们使用<code>Xsmall</code>中的样本（不用第1个样本），用<code>knn()</code>函数计算一下。我们使用<code>-idx[[1]]</code>移除第1个样本，这样将剩下来的样本当作测试集。参数<code>cl</code>用于指定真分类（true classificaiton）或者是训练集的标签（这里指的是组织）。现在我们使用5个观测值来为我们的kNN算法指定分类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pred &lt;- knn(train=Xsmall[ -idx[[1]] , ], test=Xsmall[ idx[[1]], ], cl=y[ -idx[[1]] ], k=5)</div><div class="line">table(true=y[ idx[[1]] ], pred)</div><div class="line">mean(y[ idx[[1]] ] != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=y[ idx[[<span class="number">1</span>]] ], pred)</div><div class="line">             pred</div><div class="line">true          cerebellum colon endometrium hippocampus kidney liver</div><div class="line">  cerebellum           <span class="number">2</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  colon                <span class="number">0</span>     <span class="number">4</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  endometrium          <span class="number">0</span>     <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span></div><div class="line">  hippocampus          <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">2</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  kidney               <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">4</span>     <span class="number">0</span></div><div class="line">  liver                <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">0</span>     <span class="number">2</span></div><div class="line">&gt; mean(y[ idx[[<span class="number">1</span>]] ] != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0.1666667</span></div></pre></td></tr></table></figure>
<p>现在我们出现了一些分类错误，我们计算一下剩余折叠，看一下情况怎么样？</p>
<p>Now we have some misclassifications. How well do we do for the rest of the folds?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (i in 1:10) &#123;</div><div class="line">  pred &lt;- knn(train=Xsmall[ -idx[[i]] , ], test=Xsmall[ idx[[i]], ], cl=y[ -idx[[i]] ], k=5)</div><div class="line">  print(paste0(i,&quot;) error rate: &quot;, round(mean(y[ idx[[i]] ] != pred),3)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>) &#123;</div><div class="line">+   pred &lt;- knn(train=Xsmall[ -idx[[i]] , ], test=Xsmall[ idx[[i]], ], cl=y[ -idx[[i]] ], k=<span class="number">5</span>)</div><div class="line">+   print(paste0(i,<span class="string">") error rate: "</span>, round(mean(y[ idx[[i]] ] != pred),<span class="number">3</span>)))</div><div class="line">+ &#125;</div><div class="line">[<span class="number">1</span>] <span class="string">"1) error rate: 0.111"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"2) error rate: 0.105"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"3) error rate: 0.118"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"4) error rate: 0.118"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"5) error rate: 0.278"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"6) error rate: 0.1"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"7) error rate: 0.105"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"8) error rate: 0.158"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"9) error rate: 0.15"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"10) error rate: 0.312"</span></div></pre></td></tr></table></figure>
<p>所以，我们会看到每个折叠都会发生一些变化，其错误率徘徊在0.1-0.3之间。但是，<span class="math inline">\(k=5\)</span> 是最佳的参数吗？为了研究 <span class="math inline">\(k\)</span> 的最佳数值，我们需要创建一个外部循环，我们会在其中尝试不同的 <span class="math inline">\(k\)</span> 值，然后计算出所有折叠的平均测试集误差。我们将会尝试从1到12的每个 <span class="math inline">\(k\)</span> 值。不过这里我们不使用<code>for</code>循环，我们将使用<code>sapply</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">set.seed(1)</div><div class="line">ks &lt;- 1:12</div><div class="line">res &lt;- sapply(ks, function(k) &#123;</div><div class="line">  ##try out each version of k from 1 to 12</div><div class="line">  res.k &lt;- sapply(seq_along(idx), function(i) &#123;</div><div class="line">    ##loop over each of the 10 cross-validation folds</div><div class="line">    ##predict the held-out samples using k nearest neighbors</div><div class="line">    pred &lt;- knn(train=Xsmall[ -idx[[i]], ],</div><div class="line">                test=Xsmall[ idx[[i]], ],</div><div class="line">                cl=y[ -idx[[i]] ], k = k)</div><div class="line">    ##the ratio of misclassified samples</div><div class="line">    mean(y[ idx[[i]] ] != pred)</div><div class="line">  &#125;)</div><div class="line">  ##average over the 10 folds</div><div class="line">  mean(res.k)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>对于每个 <span class="math inline">\(k\)</span> 值，我们都有一个来自于交叉验证的关联测试集错误率，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; res</div><div class="line"> [<span class="number">1</span>] <span class="number">0.1978212</span> <span class="number">0.1703423</span> <span class="number">0.1882933</span> <span class="number">0.1750989</span> <span class="number">0.1613291</span> <span class="number">0.1500791</span> <span class="number">0.1552670</span> <span class="number">0.1884813</span></div><div class="line"> [<span class="number">9</span>] <span class="number">0.1822020</span> <span class="number">0.1763197</span> <span class="number">0.1761318</span> <span class="number">0.1813197</span></div></pre></td></tr></table></figure>
<p>我们可以绘制出每个 <span class="math inline">\(k\)</span> 值下的错误率图，它可以帮助我们查看哪个区域中的错误率最小，如下所示：</p>
<figure class="highlight plain"><figcaption><span>misclassification_error, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(ks, res, type=&quot;o&quot;,ylab=&quot;misclassification error&quot;)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913184146.jpeg">

</div>
<p>我们要记住一点就是，训练集是一个随机变量，因为我们生成折叠的程序涉随机数的生成，因此，在产生“最好”的 <span class="math inline">\(k\)</span> 值时，这个 <span class="math inline">\(k\)</span> 值的产生过程也是一个随机变量。如果我们有新的训练集，并且如果我们再创建折叠，那么我们有可能会得到一个新的优化的 <span class="math inline">\(k\)</span> 值。</p>
<p>最后，为了说明基因表达数据能够很好的预测组织类型，我们使用5维数据，而非是2维数据来展示这个过程，毕竟5维数据的信息量更丰富，如下所示：</p>
<figure class="highlight plain"><figcaption><span>misclassification_error2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Xsmall &lt;- cmdscale(dist(X),k=5)</div><div class="line">set.seed(1)</div><div class="line">ks &lt;- 1:12</div><div class="line">res &lt;- sapply(ks, function(k) &#123;</div><div class="line">  res.k &lt;- sapply(seq_along(idx), function(i) &#123;</div><div class="line">    pred &lt;- knn(train=Xsmall[ -idx[[i]], ],</div><div class="line">                test=Xsmall[ idx[[i]], ],</div><div class="line">                cl=y[ -idx[[i]] ], k = k)</div><div class="line">    mean(y[ idx[[i]] ] != pred)</div><div class="line">  &#125;)</div><div class="line">  mean(res.k)</div><div class="line">&#125;)</div><div class="line">plot(ks, res, type=&quot;o&quot;,ylim=c(0,0.20),ylab=&quot;misclassification error&quot;)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913184233.jpeg">

</div>
<p>上图显示的是，使用5维数据后，错误分配与 <span class="math inline">\(k\)</span> 值变化的关系。</p>
<p>重要提示：我们使用<code>cmdscale()</code>函数来计算整个数据集，用于创建一个较小的数据集来说明kNN的计算过程。然而在真正的机器学习应用中，这样的处理会低估小样本测试数据集的错误，但是，使用未标记的完全数据集进行降维会改善这种情况。一个种更安全的做法就是为每个折叠分别转换数据（这句不懂， 我个人的猜测就是，对每个折叠进行计算，把几个折叠中的每一个都当作测试集，而不是将几个折叠放一块当作测试集），方法就是仅用训练集来计算旋转和降维，并将其应用于测试集。</p>
<p>最后一段实在没读懂，这里放原文：</p>
<blockquote>
<p>However, in a real machine learning application, this may result in an underestimation of test set error for small sample sizes, where dimension reduction using the unlabeled full dataset gives a boost in performance. A safer choice would have been to transform the data separately for each fold, by calculating a rotation and dimension reduction using the training set only and applying this to the test set.</p>
</blockquote>
<h2 id="练习">练习</h2>
<p>P407</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/23/DAL/DALS023_Basic_Machine_Learning02_Loess/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/DAL/DALS023_Basic_Machine_Learning02_Loess/" itemprop="url">DALS023-机器学习02-条件概率与Loess拟合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T12:00:00+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,248
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第2小节，这一部分的主要内容涉及条件概率与Loess回归，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/tree/master/ml/conditional_expectation.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="条件概率与期望">条件概率与期望</h2>
<p>预测问题的结果可以分为两类，分别为分类结果(categorical outcomes)和连续型结果(continuous outcomes)。但是，许多算法都可以应用于这两种情况，这是因为条件概率(conditional probabilities)和条件期望(conditional expectations)之间有着一定联系。</p>
<p>对于分类数据，例如二分类结果，如果我们知道给在一组预测因子<span class="math inline">\(X=(X_1,\dots,X_p)^\top\)</span>下预测的概率<span class="math inline">\(Y\)</span>可能是<span class="math inline">\(k\)</span>个结果中的任意一个，这种情况用方程表示就是： <span class="math display">\[
f_k(x) = \mbox{Pr}(Y=k \mid X=x)
\]</span> 我们就可以优化我们的预测结果。尤其是，对于任意的 <span class="math inline">\(x\)</span> ，我们可能预测出最大概率 <span class="math inline">\(f_k(x)\)</span> 时的 <span class="math inline">\(k\)</span> 。</p>
<p>为了简化我们的描述，我们只考虑二分类变量。我们可以认为 <span class="math inline">\(\mbox{Pr}(Y=1 \mid X=x)\)</span> 是当 <span class="math inline">\(X=x\)</span> 时，第1层的某结果在总体中的比例。考虑到期望是所有 <span class="math inline">\(Y\)</span> 值的均值，在这个案例中，期望的概率就等于：<span class="math inline">\(f(x) \equiv \mbox{E}(Y \mid X=x)=\mbox{Pr}(Y=1 \mid X=x)\)</span>。因此，我们在后面的描述中，就会使用期望，因为这种表示更加普遍。</p>
<p>通常来说，期望值是有着比较受欢迎的数学属性，因为它能够缩小预测值 <span class="math inline">\(\hat{Y}\)</span> 和 <span class="math inline">\(Y\)</span> 之间的距离： <span class="math display">\[
\mbox{E}\{ (\hat{Y} - Y)^2  \mid  X=x \}
\]</span></p>
<h4 id="预测中的回归问题">预测中的回归问题</h4>
<p>我们在前面使用了父子的身高数据来介绍了回归，这里我们使用机器学习来解释一下这个数据分析过程。在我们前面的那个案例中，我们试图通常父母的身高<span class="math inline">\(X\)</span>来预测儿子的身高<span class="math inline">\(Y\)</span>。这里我们只有一个预测值(predictor)。现在如果我们被问到随机选择一个儿子，这个儿子的身高是多少，我们也许会使用平均值来回答，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">data(<span class="string">"father.son"</span>)</div><div class="line">x=round(father.son$fheight) <span class="comment">##round to nearest inch</span></div><div class="line">y=round(father.son$sheight)</div><div class="line">hist(y,breaks=seq(min(y),max(y)))</div><div class="line">abline(v=mean(y),col=<span class="string">"red"</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911232411.jpeg">

</div>
<p>在这个案例中，我们也可以使用<span class="math inline">\(Y\)</span>的分布近似服从正态分布来进行预测，那么也就是说，当我们回答平均值的时候，回答对的概率最大。</p>
<p>现在我们再来考虑一些情况，当我们有了更多的信息后，如何进行预测。例如，我们被告之，这个随机选择的这个儿子的父亲身高是71英寸（高于均值1.25个SD）。那么我们如何预测？</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y,xlab=<span class="string">"Father's height in inches"</span>,ylab=<span class="string">"Son's height in inches"</span>,main=paste(<span class="string">"correlation ="</span>,signif(cor(x,y),<span class="number">2</span>)))</div><div class="line">abline(v=c(-<span class="number">0.35</span>,<span class="number">0.35</span>)+<span class="number">71</span>,col=<span class="string">"red"</span>)</div><div class="line">hist(y[x==<span class="number">71</span>],xlab=<span class="string">"Heights"</span>,nc=<span class="number">8</span>,main=<span class="string">""</span>,xlim=range(y))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911232626.jpeg">

</div>
<p>上图的左侧是儿子身高的散点图，其中红色围起来的部分是给定父亲身高是71英寸这个数据后，对应的儿子的身高。条件分布：儿子的身高数据分布就是被父亲71英寸这个数据限定了。</p>
<p>有了父亲身高是71英寸这个数据后，那么我们来猜儿子的身高时，最好的回答还是期望值(expectation)，但是，我们的数据层(strata)已经发生了改变，也就是说，我们来猜测儿子身高<span class="math inline">\(Y\)</span>时，要考虑到限制因素，即<span class="math inline">\(Y=71\)</span>。因此，我们可以在这个条件之上，再来计算均值，这个均值就是条件期望(conditional expectation)，因此我们对于任意<span class="math inline">\(x\)</span>值来预测时，公式如下所示： <span class="math display">\[
f(x) = E(Y \mid X=x)
\]</span></p>
<p>通过微积分我们可以发现，这个结果更加接近于二元正态分布，我们可以换成下面的表示形式： <span class="math display">\[
f(x) = \mu_Y + \rho \frac{\sigma_Y}{\sigma_X} (X-\mu_X)
\]</span></p>
<p>如果我们使用样本的数据来估计这5个参数，那么我们就会得到回归线：</p>
<figure class="highlight plain"><figcaption><span>regression, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mypar(1,2)</div><div class="line">plot(x,y,xlab=&quot;Father&apos;s height in inches&quot;,ylab=&quot;Son&apos;s height in inches&quot;,</div><div class="line">     main=paste(&quot;correlation =&quot;,signif(cor(x,y),2)))</div><div class="line">abline(v=c(-0.35,0.35)+71,col=&quot;red&quot;)</div><div class="line">fit &lt;- lm(y~x)</div><div class="line">abline(fit,col=1)</div><div class="line">hist(y[x==71],xlab=&quot;Heights&quot;,nc=8,main=&quot;&quot;,xlim=range(y))</div><div class="line">abline(v = fit$coef[1] + fit$coef[2]*71, col=1)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911234623.jpeg">

</div>
<p>在这个特殊的案例中，回归线提供了对 <span class="math inline">\(Y\)</span> 更优化的预测函数，但是通常情况下这种情况并不真实，因为在典型的机器学习问题中，优化后的 <span class="math inline">\(f(x)\)</span> 很少是一条直线。</p>
<h2 id="练习">练习</h2>
<p>P379</p>
<h2 id="平滑">平滑</h2>
<p>相关的Rmarkdown文档见作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/smoothing.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在所有的数据分析中，平滑(Smoothing)是一个非常强大的工具。当数据的分布的形状未知时，我们可以假定这些数据是平滑(smooth)的，我们就能够估计 <span class="math inline">\(f(x)\)</span> 。平滑的主要思路就是将那些有着类似期望的数据归类，然后计算这些归类后的平均值，或者是对其进行简单的参数模型拟合。我们使用基因表达数据来介绍两个平滑工具。</p>
<p>下面的数据是源于相同RNA样本的基因表达数据。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##Following three packages are available from Bioconductor</span></div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="comment"># BiocManager::install("SpikeIn")</span></div><div class="line"><span class="keyword">library</span>(SpikeIn)</div><div class="line"><span class="comment"># BiocManager::install("hgu95acdf")</span></div><div class="line"><span class="keyword">library</span>(hgu95acdf)</div><div class="line">data(SpikeIn95)</div></pre></td></tr></table></figure>
<p>我们可以使用MA图 (<span class="math inline">\(Y\)</span> = log ratios and <span class="math inline">\(X\)</span> = averages) 来比较这两个重复样本的质量，我们可能通过一种方式对这些数据进行采样，这些采样方式要能平衡 <span class="math inline">\(X\)</span> 中不同层的数据点的数目，如下所示：</p>
<figure class="highlight plain"><figcaption><span>echo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">##Example with two columns</div><div class="line">i=10;j=9</div><div class="line">##remove the spiked in genes and take random sample</div><div class="line">library(GEOquery)</div><div class="line">siNames&lt;-colnames(pData(SpikeIn95))</div><div class="line">ind &lt;- which(!probeNames(SpikeIn95)%in%siNames)</div><div class="line">pms &lt;- pm(SpikeIn95)[ ind ,c(i,j)]</div><div class="line">##pick a representative sample for A and order A</div><div class="line">Y=log2(pms[,1])-log2(pms[,2])</div><div class="line">X=(log2(pms[,1])+log2(pms[,2]))/2</div><div class="line">set.seed(4)</div><div class="line">ind &lt;- tapply(seq(along=X),round(X*5),function(i)</div><div class="line">  if(length(i)&gt;20) return(sample(i,20)) else return(NULL))</div><div class="line">ind &lt;- unlist(ind)</div><div class="line">X &lt;- X[ind]</div><div class="line">Y &lt;- Y[ind]</div><div class="line">o &lt;-order(X)</div><div class="line">X &lt;- X[o]</div><div class="line">Y &lt;- Y[o]</div></pre></td></tr></table></figure>
<p>采样结束后，我们来绘制散点图，如下所示：</p>
<figure class="highlight plain"><figcaption><span>MAplot, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">plot(X,Y)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912000435.jpeg">

</div>
<p>在上面的MA图中我们可以看到 <span class="math inline">\(Y\)</span> 取决于 <span class="math inline">\(X\)</span>。这种取决关系存在着偏差，因为我们发现，它们在重复性方面有着偏差，这就意味着，如果不考虑 <span class="math inline">\(X\)</span>， 那么 <span class="math inline">\(Y\)</span> 的均值就是0。现在我们想预测 <span class="math inline">\(f(x)=\mbox{E}(Y \mid X=x)\)</span> ，以便于移除假这种偏差。线性回归无法捕捉到表示上图曲线 <span class="math inline">\(f(x)\)</span> 的曲率(curvature)，如下所示：</p>
<figure class="highlight plain"><figcaption><span>MAplot_with_regression_line, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">plot(X,Y)</div><div class="line">fit &lt;- lm(Y~X)</div><div class="line">points(X,Y,pch=21,bg=ifelse(Y&gt;fit$fitted,1,3))</div><div class="line">abline(fit,col=2,lwd=4,lty=2)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912000854.jpeg">

</div>
<h2 id="微区间平滑bin-smoothing">微区间平滑(Bin Smoothing)</h2>
<p>对于上述的数据，我们无法使用直线进行拟合，此时我们就要使用平滑处理的思想，也就是说把这些点分散到不同的组里，计算这些不同组的均值，这就是所谓的<code>微区间平滑</code>处理（我没有找到bin smoothing相应的中文翻译，这里说的<code>微区间平滑</code>是我自己造的词）。这种处理的通常思路就是，我们假定这些数据点分为很多微区间(bin)，这样拟合的曲线是足够”平滑“的，那么在这个微区间中的这个曲线就会近似于常数(approximately constant)。如果我们假设这个曲线是常数(constant)的，那么所有位于某个微区间(bin)中的 <span class="math inline">\(Y\)</span> 就有了相同的期望值。例如，在下面的图形中，如果我们将微区间的宽度设为1，我们标记出了在8.6和12.1处的微区间。我们还显示了，在这两个区间中拟合的 <span class="math inline">\(Y\)</span> 的均值，如下所示：</p>
<figure class="highlight plain"><figcaption><span>binsmoother, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">centers &lt;- seq(min(X),max(X),0.1)</div><div class="line">plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">windowSize &lt;- .5</div><div class="line">i &lt;- 25</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-mean(Y)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">lines(c(min(X[ind]),max(X[ind])),c(fit,fit),col=2,lty=2,lwd=4)</div><div class="line">i &lt;- 60</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-mean(Y[ind])</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">lines(c(min(X[ind]),max(X[ind])),c(fit,fit),col=2,lty=2,lwd=4)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001103.jpeg">

</div>
<p>我们通过计算每一个点附近的小区间，我们就能对构成的曲线的函数 $f(x) $ 进行估计。下图显示了这个计算过程，即我们从最小的 <span class="math inline">\(x\)</span> 值扩展到最大值过程中的这个估计值，同时我们还展示了最小值与最大值之间的10个值，一共是10张图片，如下所示：</p>
<figure class="highlight plain"><figcaption><span>bin_smoothing_demo, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">windowSize&lt;-0.5</div><div class="line">smooth&lt;-rep(NA,length(centers))</div><div class="line">mypar (4,3)</div><div class="line">for(i in seq(along=centers))&#123;</div><div class="line">  center&lt;-centers[i]</div><div class="line">  ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">  smooth[i]&lt;-mean(Y[ind])</div><div class="line">  if(i%%round(length(centers)/12)==1)&#123; ##we show 12</div><div class="line">    plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">    points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">    lines(c(min(X[ind]),max(X[ind])),c(smooth[i],smooth[i]),col=2,lwd=2)</div><div class="line">    lines(centers[1:i],smooth[1:i],col=&quot;black&quot;)</div><div class="line">    points(centers[i],smooth[i],col=&quot;black&quot;,pch=16,cex=1.5)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001146.jpeg">

</div>
<p>最终的结果就如下所示：</p>
<figure class="highlight plain"><figcaption><span>bin_smooth_final, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(centers,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001229.jpeg">

</div>
<p>在R中有许多函数可以进行平滑处理(bin smoothers)，例如<code>ksmooth</code>。但是在实际计算过程中，我们更偏向使用一些稍微复杂的模型来对数据进行拟合。在最后一个案例，也就是最后一张图，这个曲线就不怎么平滑，有一些粗糙。我们后面会介绍<code>loess</code>方法会改善这一点。</p>
<h2 id="loess">Loess</h2>
<p>Loess的全称是Local weighted regression，即局部权重回归，它在原理上类似于微区间平滑处理。但Loess与微区间平滑处理的主要区别就在于，在微区间中我是使用直线，还是抛物线进行拟合。Loess计算会增大微区间的数目，但这会使我们的估计更稳定。下图展示了两个微区间的拟合曲线，这两个区间比较宽，使用宽区间主要是因为拟合曲线提供了更多的灵活性，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">centers &lt;- seq(min(X),max(X),0.1)</div><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">windowSize &lt;- 1.25</div><div class="line">i &lt;- 25</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-lm(Y~X,subset=ind)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lty=2,lwd=3)</div><div class="line">i &lt;- 60</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-lm(Y~X,subset=ind)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lty=2,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912124609.jpeg" alt="当我们">
<p class="caption">当我们</p>
</div>
<p>现在我们展示一下通过12步处理来对这些数据进行loess拟合，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess_demo, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">mypar (4,3)</div><div class="line">windowSize&lt;-1.25</div><div class="line">smooth&lt;-rep(NA,length(centers))</div><div class="line">for(i in seq(along=centers))&#123;</div><div class="line">  center&lt;-centers[i]</div><div class="line">  ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">  fit&lt;-lm(Y~X,subset=ind)</div><div class="line">  smooth[i]&lt;-fit$coef[1]+fit$coef[2]*center</div><div class="line">  if(i%%round(length(centers)/12)==1)&#123; ##we show 12</div><div class="line">    plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">    points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">    a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">    lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lwd=2)</div><div class="line">    </div><div class="line">    lines(centers[1:i],smooth[1:i],col=&quot;black&quot;)</div><div class="line">    points(centers[i],smooth[i],col=&quot;black&quot;,pch=16,cex=1.5)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912124842.jpeg">

</div>
<p>最终的结果就是生成一条更加平滑的拟合曲线用于估计我们的局部参数，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess_final, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(centers,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912125359.jpeg">

</div>
<p>R中的函数<code>loess()</code>可以进行上述的分析，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fit &lt;- loess(Y~X, degree=1, span=1/3)</div><div class="line">newx &lt;- seq(min(X),max(X),len=100) </div><div class="line">smooth &lt;- predict(fit,newdata=data.frame(X=newx))</div><div class="line">mypar ()</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(newx,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912125636.jpeg">

</div>
<p><code>loess()</code>函数与其它的曲线平滑处理函数(bin smoother)还有三点重要的区别：</p>
<p>第一，<code>loess()</code>函数会保持局部拟合中的点数不变，而非保持区间的数目不变。局部拟合中的点数是通过<code>span</code>参数决定的，这是一个比值。例如，如果 <code>N</code> 是数据点的数目，那么 <code>span = 0.5</code> 则表示针对一个确定的 <code>x</code> ， <code>loess()</code>将会使用 <code>0.5*N</code> 个最接近的点对 <code>x</code> 进行拟合。</p>
<p>第二，使用参数模型来对 <span class="math inline">\(f(x)\)</span> 进行拟合时，<code>loess()</code>会使用加权最小平方和来进行计算，那些权重比较大的点就是那些更接近 <code>x</code> 的点。</p>
<p>第三，<code>loess()</code>函数会选择更稳健(robustly)的局部模型来进行拟合。这是一种迭代算法，其中在一次迭代中拟合了模型之后，对于那些检测到的异常值就会在下一次迭代中降低其权重。如果要想使用这个参数，可以设定<code>family = &quot;symmetric&quot;</code>。</p>
<h2 id="练习-1">练习</h2>
<p>P389</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/22/DAL/DALS022_Basic_Machine_Learning01_ Cluster_heatmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/DAL/DALS022_Basic_Machine_Learning01_ Cluster_heatmap/" itemprop="url">DALS022-机器学习01-聚类与热图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:00:00+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,120
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第1小节，这一部分的主要内容涉及聚类与热图，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/clustering_and_heatmaps.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>机器学习是一个非常广泛的主题和高度活跃的研究领域。 在生命科学中，涉及到“精准医学”的大部分内容都是与机器学习在生物医学数据方面的处理有关。 常规的思路就是从检测的指标中预测或发现一些信息。例如，我们能够从基因表达谱中发现新的癌症吗？我们能通过一系列的基因型来预测药物反应吗？在这一部分中，我们主要介绍两个机器学习的方法，即聚类(clustering)和类预测(class prediction)。</p>
<h2 id="聚类">聚类</h2>
<p>我们还使用前面的组织基因表达的数据来深圳一下聚类的概念和思路：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div></pre></td></tr></table></figure>
<p>为了说明聚类在生命科学方面的应用，我们先假设我们并不知道上面的几个样本是不同的组织，我们通过聚类来看一下它们的表达谱情况，第一步就是计算不同的样本之间的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist( t(e) )</div></pre></td></tr></table></figure>
<h3 id="层次聚类">层次聚类</h3>
<p>当我们计算了每对样本之间的距离后，我们需要使用聚类算法将它们聚成不同的组。层次聚类算是众多聚类算法中的一个。每个样本首先会被当作一组(group)，然后不断地通过聚类算法迭代，将两个相似的组结合起来，一直到所有的样本都聚为一组。对于样本之间的距离我们已经了解了，但是，不同组之间的距离我们并不了解。关于组与组之间的距离计算方法有很多种，这些方法的核心都是通过计算组与组之间的成员的距离实现的。具体的可以查看<code>hclust()</code>函数的帮助文档。</p>
<p>我们通过<code>hclust()</code>函数来对不同组之间的距离进行层次聚类分析。这个函数会返回一个<code>hclust</code>对象，它描述的我们通过上述算法进行的组划分(grouping)。随后使用<code>plot()</code>函数绘制出树状图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">hc &lt;- hclust(d)</div><div class="line">hc</div><div class="line">plot(hc,labels=tissue,cex=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(rafalib)</div><div class="line">&gt; mypar()</div><div class="line">&gt; hc &lt;- hclust(d)</div><div class="line">&gt; hc</div><div class="line"></div><div class="line">Call:</div><div class="line">hclust(d = d)</div><div class="line"></div><div class="line">Cluster method   : complete </div><div class="line">Distance         : euclidean </div><div class="line">Number of objects: <span class="number">189</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215025.jpeg">

</div>
<p>使用这种算法能否发现不同组织的簇(clusters)？在上面的这个图形里，我们不太容易发现这些不同的组织，因此我们需要使用<code>myclust()</code>函数来给它们加上颜色，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">myplclust(hc, labels=tissue, lab.col=as.fumeric(tissue), cex=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215224.jpeg">

</div>
<p>从图形上我们可以看出来，似乎聚类算法能够发现这些不同的组织。但是，层次聚类并没有定义特定的簇，而是定义了上在树状图。从树状图上我们可以描述任意两组之间的距离。为了定义一些簇，我们需要将把树在某些距离上”切开“，所有的样本在这个距离以下分成不同的组。我们可以绘制出一条水平线，我们就使用120这个距离来切，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myplclust(hc, labels=tissue, lab.col=as.fumeric(tissue),cex=<span class="number">0.5</span>)</div><div class="line">abline(h=<span class="number">120</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215559.jpeg">

</div>
<p>当我们在高度为120上对树进行切割时，我们可以看一下这个线能够把线以下的样本分为几组，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hclusters &lt;- cutree(hc, h=<span class="number">120</span>)</div><div class="line">table(true=tissue, cluster=hclusters)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=tissue, cluster=hclusters)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span>  <span class="number">0</span> <span class="number">12</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">9</span> <span class="number">18</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>从上面可以看出来，分为了8组，另外通过<code>cutreee()</code>函数，我们可以直接指定返回几组簇，这个函数会自动返回结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hclusters &lt;- cutree(hc, k=<span class="number">8</span>)</div><div class="line">table(true=tissue, cluster=hclusters)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; hclusters &lt;- cutree(hc, k=<span class="number">8</span>)</div><div class="line">&gt; table(true=tissue, cluster=hclusters)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span> <span class="number">12</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney      <span class="number">37</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">6</span></div></pre></td></tr></table></figure>
<p>从上面两组计算方法我们可以看出来，除了个别情况外（例如endometrium和kidney），其余的簇中，基本上每簇代表一个组织。在某些情况下，一个组织有可能存在于两个簇中，这是因为选择的簇太多了。在聚类分析中，关于如何选择簇的个数也是一个很活跃的研究领域。</p>
<h3 id="k-means">K-means</h3>
<p>我们还可以使用<code>kmeans()</code>函数来进行k-means聚类。现在我们来演示一下如何使用这个函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">km &lt;- kmeans(t(e[<span class="number">1</span>:<span class="number">2</span>,]), centers=<span class="number">7</span>)</div><div class="line">names(km)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(e[<span class="number">1</span>,], e[<span class="number">2</span>,], col=as.fumeric(tissue), pch=<span class="number">16</span>)</div><div class="line">plot(e[<span class="number">1</span>,], e[<span class="number">2</span>,], col=km$cluster, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; set.seed(<span class="number">1</span>)</div><div class="line">&gt; km &lt;- kmeans(t(e[<span class="number">1</span>:<span class="number">2</span>,]), centers=<span class="number">7</span>)</div><div class="line">&gt; names(km)</div><div class="line">[<span class="number">1</span>] <span class="string">"cluster"</span>      <span class="string">"centers"</span>      <span class="string">"totss"</span>        <span class="string">"withinss"</span>     <span class="string">"tot.withinss"</span></div><div class="line">[<span class="number">6</span>] <span class="string">"betweenss"</span>    <span class="string">"size"</span>         <span class="string">"iter"</span>         <span class="string">"ifault"</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911220200.jpeg">

</div>
<p>上图我们使用的是不同组织的前2个基因表达情况，其中颜色表示不同的组织。在在图中，颜色表示通过<code>kmeans()</code>函数计算的聚类结果。从下面的这个列表中我们就可以看到，这个聚类效果并不好：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(true=tissue,cluster=km$cluster)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line">&gt; table(true=tissue,cluster=km$cluster)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">0</span> <span class="number">23</span></div><div class="line">  colon        <span class="number">2</span> <span class="number">11</span>  <span class="number">2</span> <span class="number">15</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">8</span></div><div class="line">  hippocampus <span class="number">19</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">7</span>  <span class="number">8</span> <span class="number">20</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">18</span>  <span class="number">8</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>这个结果不太好很有可能就是我们选择的这2个基因信息量不足以将不同组织区分开来，如果我们使用所有的基因进行kmeans计算，那么我们就能极大地改善聚类结果，现在我们使用MDS图来展示这个结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">km &lt;- kmeans(t(e), centers=<span class="number">7</span>)</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(mds[,<span class="number">1</span>], mds[,<span class="number">2</span>])</div><div class="line">plot(mds[,<span class="number">1</span>], mds[,<span class="number">2</span>], col=km$cluster, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911220820.jpeg">

</div>
<p>上图礣是使用前两个PC来绘制的聚类结果，右图是使用所有的基因来绘制的MDS图，使用颜色标明了不同的组织。</p>
<p>通过查看结果中的列表，我们就可以看到聚类的效果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(true=tissue,cluster=km$cluster)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=tissue,cluster=km$cluster)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">2</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span> <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">0</span> <span class="number">37</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div></pre></td></tr></table></figure>
<h2 id="热图">热图</h2>
<p>在遗传学文献中，热图的使用非常广泛。它们能够查看所有样本的不同基因的表达情况，有的时候还会在热图的上面或旁边添加上聚类后的树状图。现在我们来看一下如何创建热图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(RColorBrewer)</div><div class="line">hmcol &lt;- colorRampPalette(brewer.pal(<span class="number">9</span>, <span class="string">"GnBu"</span>))(<span class="number">100</span>)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line"></div><div class="line">rv &lt;- rowVars(e)</div><div class="line"><span class="comment"># We will create heatmp using th e50 most variable genes and the function heatmap.2</span></div><div class="line"></div><div class="line">idx &lt;- order(-rv)[<span class="number">1</span>:<span class="number">40</span>]</div></pre></td></tr></table></figure>
<p>现在我们使用<code>gplots</code>包中的<code>heatmap.2</code>了娄来绘制热图，并在热图的顶部添加组织信息，如下所示</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(gplots) <span class="comment">##Available from CRAN</span></div><div class="line">cols &lt;- palette(brewer.pal(<span class="number">8</span>, <span class="string">"Dark2"</span>))[as.fumeric(tissue)]</div><div class="line">head(cbind(colnames(e),cols))</div><div class="line"></div><div class="line">heatmap.2(e[idx,], labCol=tissue,</div><div class="line">          trace=<span class="string">"none"</span>,</div><div class="line">          ColSideColors=cols,</div><div class="line">          col=hmcol)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(cbind(colnames(e),cols))</div><div class="line">                       cols     </div><div class="line">[<span class="number">1</span>,] <span class="string">"GSM11805.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">2</span>,] <span class="string">"GSM11814.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">3</span>,] <span class="string">"GSM11823.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">4</span>,] <span class="string">"GSM11830.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">5</span>,] <span class="string">"GSM12067.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">6</span>,] <span class="string">"GSM12075.CEL.gz"</span> <span class="string">"#1B9E77"</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911221507.jpeg">

</div>
<p>在热图中我们并没有使用组织信息，我们仅用了最显著的40个基因就发现了不同的组织。</p>
<h2 id="练习">练习</h2>
<p>P374</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/21/DAL/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/DAL/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/" itemprop="url">DALS021-MDS与PCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T12:00:00+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,847
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第2小节，这一部分的主要内容涉及MDS和PCA，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/highdim/mds.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="mds">MDS</h2>
<p>MDS的全称为multi-dimensional scaling，即多维数据缩放。在这 一部分中，我们会使用基因表达的数据来作为案例讲解一下。为了简化说明，我们仅考虑3个组织：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">colind &lt;- tissue%<span class="keyword">in</span>%c(<span class="string">"kidney"</span>,<span class="string">"colon"</span>,<span class="string">"liver"</span>)</div><div class="line">mat &lt;- e[,colind]</div><div class="line">group &lt;- factor(tissue[colind])</div><div class="line">dim(mat)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; dim(mat)</div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>    <span class="number">99</span></div></pre></td></tr></table></figure>
<p>现在我们要研究一下这个数据集，我们想知道，储存在<code>mat</code>列中的基因表达谱的数据在不同的组织间的相似性如何。由于数据很大，无法直接画出相应的多维点图。我们通常只能绘制出二维图形，如果我们要绘制出每两个样本之间的基因表达情况不现实。而MDS图形就是为了解决这个问题而提出来的。</p>
<h3 id="mds背后的数学原理">MDS背后的数学原理</h3>
<p>前面我们已经知道了SVD和矩阵代数，那么我们理解MDS就相对清楚了。为了说明MDS，我们先来看一下SVD分解，如下所示： <span class="math display">\[
\mathbf{Y} = \mathbf{UDV}^\top
\]</span> 我们假设 <span class="math inline">\(\mathbf{U^\top Y=DV^\top}\)</span> 的前两列的平方和剩余列的平方和。因此它们可以写为<span class="math inline">\(d_1+ d_2 \gg d_3 + \dots + d_n\)</span> 其中 <span class="math inline">\(d_i\)</span> 是<span class="math inline">\(\mathbf{D}\)</span> 是第i列（原文是i-th entry）。当出现这种情况时，我们就会得到如下公式：</p>
<p><span class="math display">\[
\mathbf{Y}\approx [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&amp;0\\
    0&amp;d_{2}\\
  \end{pmatrix}
  [\mathbf{V}_1 \mathbf{V}_2]^\top
\]</span></p>
<p>这就表明，第<span class="math inline">\(i\)</span>列近似等于： <span class="math display">\[
\mathbf{Y}_i \approx
[\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&amp;0\\
    0&amp;d_{2}\\
  \end{pmatrix}
  \begin{pmatrix}
    v_{i,1}\\
    v_{i,2}\\
     \end{pmatrix}
    =
    [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}
\]</span> 如果我们们定义下面的二维向量：</p>
<p><span class="math display">\[
\mathbf{Z}_i=\begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}
\]</span></p>
<p>那么： <span class="math display">\[
\begin{align*}
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) &amp;\approx \left\{ [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \right\}^\top \left\{[\mathbf{U}_1 \mathbf{U}_2]  (\mathbf{Z}_i-\mathbf{Z}_j)\right\}\\
&amp;= (\mathbf{Z}_i-\mathbf{Z}_j)^\top [\mathbf{U}_1 \mathbf{U}_2]^\top [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \\
&amp;=(\mathbf{Z}_i-\mathbf{Z}_j)^\top(\mathbf{Z}_i-\mathbf{Z}_j)\\
&amp;=(Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\end{align*}
\]</span> 上面的这个推导告诉我们，在样本<span class="math inline">\(i\)</span>和样本<span class="math inline">\(j\)</span>之最的距离近拟等于下面二维数据点的距离：</p>
<p><span class="math display">\[
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) \approx
 (Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\]</span></p>
<p>因为<span class="math inline">\(Z\)</span>是一个二维向量，因此我们可以通过绘制<span class="math inline">\(\mathbf{Z_{1}}\)</span>和<span class="math inline">\(\mathbf{Z_{2}}\)</span>来发展示这两个样本的距离。现在我们绘制出它们的距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(mat-rowMeans(mat))</div><div class="line">PC1 &lt;- s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 &lt;- s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC1,PC2,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090640.jpeg">

</div>
<p>从图片上我们可以看出，数据点按照相应的组织区分开来了。上面的这种分开的精确近似取决于前两个主成分解释变异的程度。像上面那样所示，我们可以绘制出每个主成分可以解释的变异程度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090819.jpeg">

</div>
<p>虽然前两个主成分解释了超过50%的变异，不过前面的图形还是没有展示出大量的信息。但是这种图已经足够用于进行可视化大量的数据了。此外，我们还可以注意到，我们能够绘制其它的主成分来研究这些数据点，例如我们绘制第3个和第4个主成分：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PC3 &lt;- s$d[<span class="number">3</span>]*s$v[,<span class="number">3</span>]</div><div class="line">PC4 &lt;- s$d[<span class="number">4</span>]*s$v[,<span class="number">4</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC3,PC4,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091057.jpeg">

</div>
<p>从上面图形中我们可以看到，第4个主成分能够将肾脏组织的样本强烈分开。在后面的部分中，我们会讲到批次效应(batch effects)会解释这种情况。</p>
<h3 id="cmdscale函数"><code>cmdscale()</code>函数</h3>
<p>我们在上面使用了<code>svd()</code>函数来进行计算，不过R中有一个专门的函数用于计算MDS，生成MDS图。这个函数就是<code>cmdscale()</code>函数，这个函数将距离对象作为参数，然后使用主成分分析来对这些距离进行近似计算。这个函数比使用<code>svd()</code>函数更高效（因为不可能实现完全的<code>svd()</code>函数计算，那样比较花时间）。此函数默认返回二维的数据，不过我们通过设定参数<code>k</code>（默认情况下，<code>k=2</code>）可以改变结果中的维度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(mat))</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar()</div><div class="line">plot(mds[,<span class="number">1</span>],mds[,<span class="number">2</span>],bg=as.numeric(group),pch=<span class="number">21</span>,</div><div class="line">xlab=<span class="string">"First dimension"</span>,ylab=<span class="string">"Second dimension"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091915.jpeg">

</div>
<p>再看另外一个：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">2</span>)&#123;</div><div class="line">plot(mds[,i],s$d[i]*s$v[,i],main=paste(<span class="string">"PC"</span>,i))</div><div class="line">b = ifelse( cor(mds[,i],s$v[,i]) &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</div><div class="line">abline(<span class="number">0</span>,b) <span class="comment">##b is 1 or -1 depending on the arbitrary sign "flip"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911092010.jpeg">

</div>
<h3 id="任意符号">任意符号</h3>
<p>SVD并非是唯一的，只要我们用<code>-1</code>乘以<span class="math inline">\(\mathbf{U}\)</span>的样本列，我们就能使用<code>-1</code>乘以<span class="math inline">\(\mathbf{V}\)</span>的任意列，通过下面的转换我们就能看出来（这一段不懂）： <span class="math display">\[
\mathbf{-1UD(-1)V}^\top = \mathbf{UDV}^\top
\]</span></p>
<h3 id="扣除平均值">扣除平均值</h3>
<p>在所有的计算中，当我们计算SVD时，都会扣除行(row)的均值。如果我们要试图计算两列之间的近似距离，那么在<span class="math inline">\(\mathbf{Y}_{i}\)</span>和<span class="math inline">\(\mathbf{Y}_{j}\)</span>之间的距离就与<span class="math inline">\(\mathbf{Y}_i - \mathbf{\mu}\)</span>和<span class="math inline">\(\mathbf{Y}_j - \mathbf{\mu}\)</span>之间的距离相同，因为当我们过计算时，中间的<span class="math inline">\(\mu\)</span>就会被消去： <span class="math display">\[
\left\{ ( \mathbf{Y}_i- \mathbf{\mu} ) - ( \mathbf{Y}_j - \mathbf{\mu} ) \right\}^\top \left\{ (\mathbf{Y}_i- \mathbf{\mu}) - (\mathbf{Y}_j - \mathbf{\mu} ) \right\} = \left\{  \mathbf{Y}_i-  \mathbf{Y}_j  \right\}^\top \left\{ \mathbf{Y}_i - \mathbf{Y}_j  \right\}
\]</span> 因为扣除行均值可以降低总的变异，它可以使得SVD的结果近更为逼近。</p>
<h2 id="练习">练习</h2>
<p>P357</p>
<h2 id="pca">PCA</h2>
<p>PCA的相关资料可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/PCA.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经提到了PCA，这里继续深入一步，讲一下PCA背后的数学原理。</p>
<h3 id="案例双胞胎身高">案例：双胞胎身高</h3>
<p>我们先使用模拟数据的案例展示一个旋转，这个旋转与PCA有着很大的有关系：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">Y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(Y[<span class="number">1</span>,], Y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=thelim, ylim=thelim)</div><div class="line">points(Y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], Y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911094030.jpeg">

</div>
<p>这里我们专门来解释一下什么是什么成分（principla components）。</p>
<p>我们使用 <span class="math inline">\(\mathbf{Y}\)</span> 这个 <span class="math inline">\(2 \times N\)</span> 矩阵来表示我们的数据。这个类似于我们检测了两组基因的信息，每列表示1个样本。现在我们的任何就是，找到一个 <span class="math inline">\(2 \times 1\)</span> 向量 <span class="math inline">\(\mathbf{u}_1\)</span> ，使其满足 <span class="math inline">\(\mathbf{u}_1^\top \mathbf{v}_1 = 1\)</span>，它能使 <span class="math inline">\((\mathbf{u}_1^\top\mathbf{Y})^\top (\mathbf{u}_1^\top\mathbf{Y})\)</span> 最大。这个过程可以被视为每个样本，或<span class="math inline">\(\mathbf{Y}\)</span>向子空间 <span class="math inline">\(\mathbf{u}_1\)</span> 的投影。因此，我们需要将坐标系进行置换，使新的坐标系能够显示出最大变异。</p>
<p>我先试一下 <span class="math inline">\(\mathbf{u}=(1,0)^\top\)</span>。这个投影公仅能够给出双胞胎1的身高（橘黄色）。图片标题中显示的是平方和。</p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1, fig.align</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(t(Y), xlim=thelim, ylim=thelim,</div><div class="line">     main=paste(&quot;Sum of squares :&quot;,round(crossprod(Y[1,]),1)))</div><div class="line">abline(h=0)</div><div class="line">apply(Y,2,function(y) segments(y[1],0,y[1],y[2],lty=2))</div><div class="line">points(Y[1,],rep(0,ncol(Y)),col=2,pch=16,cex=0.75)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911160126.jpeg">

</div>
<p>我们能否找到一个方向，使得坐标系旋转后，能够表示更高的变异？例如</p>
<p><span class="math inline">\(\mathbf{u} =\begin{pmatrix}1\\-1\end{pmatrix}\)</span> 这个怎么样？它不满足 <span class="math inline">\(\mathbf{u}^\top\mathbf{u}= 1\)</span> ，因此我们可以使用另外一个向量，即 <span class="math inline">\(\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\-1/\sqrt{2}\end{pmatrix}\)</span></p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1_either, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">u &lt;- matrix(c(1,-1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar(1,1)</div><div class="line">plot(t(Y),</div><div class="line">     main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),xlim=thelim,ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,-1,col=2)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i],Z[2,i],Y[1,i],Y[2,i],lty=2)</div><div class="line">points(t(Z), col=2, pch=16, cex=0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161254.jpeg">

</div>
<p>这个图形与双胞胎的差异有关，我们知道这个差异很少的。通常平方和我们可以确实这一点，最后我们试一下这个向量：</p>
<p><span class="math display">\[
\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\1/\sqrt{2}\end{pmatrix}
\]</span></p>
<figure class="highlight plain"><figcaption><span>PC1, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">u &lt;- matrix(c(1,1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar()</div><div class="line">plot(t(Y), main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),</div><div class="line">     xlim=thelim, ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,1,col=2)</div><div class="line">points(u%*%w, col=2, pch=16, cex=1)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i], Z[2,i], Y[1,i], Y[2,i], lty=2)</div><div class="line">points(t(Z),col=2,pch=16,cex=0.5)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161447.jpeg">

</div>
<p>这个图形与重新缩放(re-scaled)后的平均高度有关，它有着最大的平方和。这是一个数学计算程序，它能够计算出一个 <span class="math inline">\(\mathbf{v}\)</span> ，能够使平方和最大，SVD就是这样的一个程序。</p>
<h4 id="主成分">主成分</h4>
<p>正交向量能够使平方和最大：</p>
<p><span class="math display">\[
(\mathbf{u}_1^\top\mathbf{Y})^\top(\mathbf{u}_1^\top\mathbf{Y})
\]</span></p>
<p><span class="math inline">\(\mathbf{u}_1^\top\mathbf{Y}\)</span> 指的就是第1PC。e用于获得PC的加权(weights) <span class="math inline">\(\mathbf{u}\)</span> 指的就是因子载荷(loadings)。使用旋转这种操作，它指的就是第1PC的旋转方向。</p>
<p>为了获得第2PC，我们可以重复上述操作，但是残差如下：</p>
<p><span class="math display">\[\mathbf{r} = \mathbf{Y} - \mathbf{u}_1^\top \mathbf{Yv}_1 \]</span></p>
<p>第2PC的向量含有以下性质：</p>
<p><span class="math display">\[ \mathbf{v}_2^\top \mathbf{v}_1=0\]</span></p>
<p>它能使 <span class="math inline">\((\mathbf{rv}_2)^\top \mathbf{rv}_2\)</span>最大，</p>
<p>当 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(N \times m\)</span> 时，我们可以重复地找到第3，第4，第5，等主成分。</p>
<h4 id="prcomp"><code>prcomp</code></h4>
<p>我们已经介绍了如何使用SVD来计算PC。介理，R中有一个专门的函数可以用于找到主成分，即<code>prcomp()</code>，在这个案例中，数据默认中心化的，这个函数的使用如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc &lt;- prcomp( t(Y) )</div></pre></td></tr></table></figure>
<p>计算出的结果与SVD相同，直到符号翻转（produces the same results as the SVD up to arbitrary sign flips，实在没理解这句话什么意思）</p>
<figure class="highlight plain"><figcaption><span>pca_svd, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd( Y - rowMeans(Y) )</div><div class="line">mypar(1,2)</div><div class="line">for(i in 1:nrow(Y) )&#123;</div><div class="line">  plot(pc$x[,i], s$d[i]*s$v[,i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911165120.jpeg">

</div>
<p>因子载荷可以通过下面方式计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$rotation</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pc$rotation</div><div class="line">           PC1        PC2</div><div class="line">[<span class="number">1</span>,] <span class="number">0.7072304</span>  <span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.7069831</span> -<span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>它就相当于 (up to a sign flip？这个不懂) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s$u</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; s$u</div><div class="line">           [,<span class="number">1</span>]       [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.7072304</span> -<span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">0.7069831</span>  <span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>解释的方差等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$sdev</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; pc$sdev</div><div class="line">[<span class="number">1</span>] <span class="number">1.2542672</span> <span class="number">0.2141882</span></div></pre></td></tr></table></figure>
<p>现在我们将<code>Y</code>转置一下，因为<code>prcomp()</code>函数与我们平时所用的高通量数据储存有点不太一样，平时我们的数据是列为样本，行为特征值，而<code>prcomp()</code>函数则是正好相反，它处理的数据列是特征值，行是样本名。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/20/DAL/DALS020_Distance_and_Dimension_Reduction1_SVD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/DAL/DALS020_Distance_and_Dimension_Reduction1_SVD/" itemprop="url">DALS020-距离与降维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T12:00:00+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,505
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第1小节，这一部分的主要内容涉及降维分析的一些原理，例如SVD，投影，旋转等，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/distance.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>距离(distance)的概念非常直接，例如，当我们把动物聚为亚群时，我们其实就是隐含地定义了一个距离，从而使我们可以说亚群内的动物彼此“接近”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909115530.png">

</div>
<p>我们使用的分析高通量数据的方法地都直接或间接地与距离有关。许多聚类方法和机器学习方法都需要使用特征值或预测因子来定义距离。例如热图是基因组学与高通量数据领域里使用最为广泛的工具，如果我们要生成热图，就需要明确计算距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130059.png">

</div>
<p>在上面的热图中，每个方格代表的数值储存在一个矩阵里，每具方格的行与列被聚类后（注：热图常用红色与绿色表示，但是对色盲人士来说，这两种颜色是最难分辨的颜色）用不同的颜色表示。在这一部分中，我们将学习必要的数学知识与计算技能来了解和创建热图。我们先来回顾一下数学上对距离的定义。</p>
<h2 id="欧氏距离euclidean-distance">欧氏距离(Euclidean Distance)</h2>
<p>现在我们在一个笛卡尔坐标系(Cartesian plane)中定义A点与B点的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>),pch=<span class="number">16</span>,cex=<span class="number">2</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,bty=<span class="string">"n"</span>,xlim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>),ylim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>))</div><div class="line">lines(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</div><div class="line">text(<span class="number">0</span>,<span class="number">.2</span>,expression(paste(<span class="string">'(A'</span>[x]*<span class="string">',A'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(<span class="number">1</span>,<span class="number">1.2</span>,expression(paste(<span class="string">'(B'</span>[x]*<span class="string">',B'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(-<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">"A"</span>,cex=<span class="number">2</span>)</div><div class="line">text(<span class="number">1.1</span>,<span class="number">1</span>,<span class="string">"B"</span>,cex=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130731.jpeg">

</div>
<p>其中，欧氏距离的定义如下所示： <span class="math display">\[
\sqrt{ (A_x-B_x)^2 + (A_y-B_y)^2}
\]</span></p>
<h2 id="高维数据的距离">高维数据的距离</h2>
<p>现在我们使用一个数据集，这个数据集中含有189个样本，22215个基因，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(devtools)</div><div class="line"><span class="comment"># install_github("genomicsclass/tissuesGeneExpression")</span></div><div class="line"></div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div></pre></td></tr></table></figure>
<p>这些数据代表了8个组织（每个组织中有多个样本）的RNA表达水平，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>   <span class="number">189</span></div><div class="line">&gt; table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们现在描述一下在这个数据集中，不同样本之间的距离。我们也许对在不同样本中表达相似的基因感兴趣。</p>
<p>为了定义这个距离，我们需要知道这些点是什么，因为我们计算数学上的距离需要这些点。由于这个数据集是高维数据集，这些点就无法直接放在笛卡尔坐标系中。相反，我们会把这个数据集放在更高维度的坐标系中。例如样本<span class="math inline">\(i\)</span>是由22215维空间的一个点定义的（这个空间可以写为<span class="math inline">\((Y_{1,i},\dots,Y_{22215,i})^\top\)</span>）。特征值<span class="math inline">\(g\)</span>是由一个189维空间的一个点定义的（这个空间可以写为<span class="math inline">\((Y_{g,1},\dots,Y_{g,189})^\top\)</span>）。</p>
<p>一旦我们定义好了这些点，那么欧氏距离就可以使用我们前面类似的方法进行计算，例如，两个样本<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>的距离为： <span class="math display">\[
\mbox{dist}(i,j) = \sqrt{ \sum_{g=1}^{22215} (Y_{g,i}-Y_{g,j })^2 }
\]</span> 两个特征值<span class="math inline">\(h\)</span>和<span class="math inline">\(g\)</span>的距离为： <span class="math display">\[
\mbox{dist}(h,g) = \sqrt{ \sum_{i=1}^{189} (Y_{h,i}-Y_{g,i})^2 }
\]</span></p>
<h3 id="矩阵代数与距离">矩阵代数与距离</h3>
<p>样本<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之间的距离可以写为： <span class="math display">\[
\mbox{dist}(i,j) = (\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j)
\]</span> 其中，<span class="math inline">\(\mbox{Y}_{i}\)</span>和<span class="math inline">\(\mbox{Y}_{j}\)</span>代表第<span class="math inline">\(i\)</span>列和第<span class="math inline">\(j\)</span>列。这种写法在实际计算中非常方便。</p>
<h3 id="案例">案例</h3>
<p>现在我们使用上面的矩阵代数来计算一下距离。现在我们计算样本1与样本2（它们都是肾脏组织）的距离，然后再过计算样本87的距离（结肠），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x &lt;- e[,<span class="number">1</span>]</div><div class="line">y &lt;- e[,<span class="number">2</span>]</div><div class="line">z &lt;- e[,<span class="number">87</span>]</div><div class="line">sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，肾脏组织之间距离比较近。另外一种计算距离更快的方式就是使用矩阵代数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqrt( crossprod(x-y) )</div><div class="line">sqrt( crossprod(x-z) )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt( crossprod(x-y) )</div><div class="line">        [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">85.8546</span></div><div class="line">&gt; sqrt( crossprod(x-z) )</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>现在我们一次计算出所有的距离，我们可以使用<code>dist()</code>函数，这个函数可以计算出每行之间的距离，现在我们感兴趣的是不同样本之间的相似性，因此我们需要使用<code>t()</code>来转换一下矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(e))</div><div class="line">class(d)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- dist(t(e))</div><div class="line">&gt; class(d)</div><div class="line">[<span class="number">1</span>] <span class="string">"dist"</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，计算结果<code>d</code>是一个<code>dist</code>类，为了得到它的具体数值，我们需要将其强行转换为矩阵，并使用索引操作，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>这里我们需要注意的是，我们对数据集<code>e</code>使用了函数<code>dist()</code>，这个函数计算的是基因之间所有两两矩离，它最终会形成一个<span class="math inline">\(22215\times 22215\)</span>的矩阵。</p>
<h2 id="练习">练习</h2>
<p>P322</p>
<h2 id="降维操作">降维操作</h2>
<p>相应的Rmarkdown见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/pca_motivation.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>可视化数据是分析高通量数据中最重要的步骤之一。正确的可视化方法可能会发现实验数据的问题，这些数据可以呈现标准分析的结果。我们已经展示了可视化数据的全局方法，但是由于数据的高维特性，使得发现列之间或行之间关系的图形变得复杂。例如，如果要比较189个样本之间的特性，我们必不得不创建17766个MA图。创建一个单独的散点图明显不合适，因为数据量太大。</p>
<p>我们将介绍其于降维的探索性数据分析的强大技巧。一般的想法就是将数据集降至较低维度的同时又保留重要的特性，例如样本之间的距离。如果我们能够将数据降低到2维，那么我们就能很容易地画出图形。降维的背后就是奇异值分解(Singular value decomposition, SVD)，这种思路也可以应用于其他情况。在介绍SVD背后的复杂数学原理之前，我们将会使用一个简单的案例来介绍一下它的思路。</p>
<h3 id="案例将2维数据降低至1维">案例：将2维数据降低至1维</h3>
<p>现在我们来看一个案例，这个案例是有关双胞胎身高的。我们来模拟生成100个二维数据点，它们表示每个人与其均值的偏离的标准差的数目，每对数据点表示一对又胞胎，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">plot(y[<span class="number">1</span>,], y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=c(-<span class="number">3</span>,<span class="number">3</span>), ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909151311.jpeg">

</div>
<p>为了辅助说明问题，我们可以将上面的模拟数据视为高通量基因表达数据，其中双胞胎的配对数据表示了N个样本，双胞胎的2个身高表示基因表达数据。我们是对任意2个之间的距离感兴趣。我们可以使用<code>dist()</code>函数来进行计算。例如，上图的2个橙色数据点的距离为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d=dist(t(y))</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d=dist(t(y))</div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">1.140897</span></div></pre></td></tr></table></figure>
<p>如果两维数据太复杂（这里只是假设），我们只想制备一维图，那怎么办呢？例如，我们能否将这些数据减化为一维矩阵，同时保留这些点与点之间的距离信息呢？</p>
<p>如果我们回顾再来看这张图，在任何一对数据点之间画一条线，那么这条线的长度就是这两点这之间的距离。这些线倾向于沿着对角线的方向分布。我们以前到过MA图，这种图就是将原始散点图的对角线“旋转”了一下，将原来的对角线旋转到与x轴平行的位置形成的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">z1 = (y[<span class="number">1</span>,]+y[<span class="number">2</span>,])/<span class="number">2</span> <span class="comment">#the sum</span></div><div class="line">z2 = (y[<span class="number">1</span>,]-y[<span class="number">2</span>,]) <span class="comment">#the difference</span></div><div class="line">z = rbind( z1, z2) <span class="comment">#matrix now same dimensions as y</span></div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized \</span></div><div class="line"><span class="string">height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece \</span></div><div class="line"><span class="string">in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909153046.jpeg">

</div>
<p>上图的左图就是原始的散点图，右图则是MA图。</p>
<p>在后面章节中，我们将会使用线性代数来表示这些数据的变换（也就是旋转）。这里我们可以通过将<code>y</code>的相乘来得到<code>z</code>，如下所示： <span class="math display">\[
A = \,
\begin{pmatrix}
1/2&amp;1/2\\
1&amp;-1\\
\end{pmatrix}
\implies 
z = A y
\]</span> 我们将两侧都乘以<span class="math inline">\(A^{-1}\)</span>，则得到z，如下所示： <span class="math display">\[
A^{-1} = \,
\begin{pmatrix}
1&amp;1/2\\
1&amp;-1/2\\
\end{pmatrix}
\implies 
y = A^{-1} z
\]</span></p>
<h3 id="旋转">旋转</h3>
<p>在上图相，相对于其它点之间的距离，两个橙色上炽之间的距离大致保持一致。所以的点其实都是如此。对上面转换进行简单的重新缩放，将会使前后的距离完全相同。我们要做的就是乘以一个标量，从而保留每个数据点的标准差。如果你认为<code>y</code>的列是一个独立随机变量，其标准差为<span class="math inline">\(\sigma\)</span>，那么我们要注意到<span class="math inline">\(M\)</span>与<span class="math inline">\(A\)</span>的标准差如下所示： <span class="math display">\[
\mbox{sd}[ Z_1 ] = \mbox{sd}[ (Y_1 + Y_2) / 2 ] = \frac{1}{\sqrt{2}} \sigma \mbox{ and } \mbox{sd}[ Z_2] = \mbox{sd}[ Y_1 - Y_2  ] = {\sqrt{2}} \sigma
\]</span> 这就说明，如果我们将上面的转换变为如下形式： <span class="math display">\[
A = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1&amp;1\\
1&amp;-1\\
\end{pmatrix}
\]</span> 那么<span class="math inline">\(Y\)</span>列的SD就会变得与<span class="math inline">\(Z\)</span>列的方差一样。此外，我们要注意到，<span class="math inline">\(A^{-1}A=I\)</span>。我们称这种特性为<code>正交</code>(orthogonal)，并且它保留了上述SD的特性。因此就保留了距离信息：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">A &lt;- <span class="number">1</span>/sqrt(<span class="number">2</span>)*matrix(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z &lt;- A%*%y</div><div class="line">d &lt;- dist(t(y))</div><div class="line">d2 &lt;- dist(t(z))</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d2)) <span class="comment">#as.numeric turns distnaces into long vector</span></div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154417.jpeg">

</div>
<p>我们称这种转换为<code>y</code>的旋转：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154529.jpeg">

</div>
<p>我们之所以优先使用这种转换，是因为我们注意到所有的点是沿着对角线进行分布的，我们将对角线进行转换后，对角线与x轴平行。所以这个旋转实际上就达到了我们最初的要求：我们只需要一个维度就可以保留点与点之间的距离。现在让我们删除了第二个维度<code>z</code>，并重新计算一下距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3 = dist(z[<span class="number">1</span>,]) <span class="comment">##distance computed using just first dimension</span></div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d3))</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909155706.jpeg">

</div>
<p>仅用一维数据进行的距离计算就很接近实际距离，并且降低了维度，将2维降低到了1维。转换后的数据的第1约就是第一主成分。这一思想促进了使用主成分分析(PCA)和奇异值分解(SVD)来实现更广泛的降维。</p>
<h3 id="关于与其他解释区别的重要说明">关于与其他解释区别的重要说明</h3>
<p>如果你在网上搜索PCA的描述，你会注意到网上的描述与我们这里描述在符号上有些出入。这主要是因为在PCA中，通常使用行来表示实验单元（就是样本）。因此，在我们这里的实验中，<span class="math inline">\(Y\)</span>通常会被转换为<span class="math inline">\(N \times 2\)</span>矩阵。在统计学中，这也是最为普遍的表示数据的方式：每行表示一个样本。然而，由于实际原因，在遗传学中，通常使用列表示样本。例如行表示基因，列表示样本。由于这个原因，在这本书中，我们会解释PCA和与之相应的数学计算会与常规的方式有所不同。因此，在网上找到的相关的许多PCA的解释都是先从样本的协方差矩阵开始的，它通常使用<span class="math inline">\(\mathbf{X}^\top\mathbf{X}\)</span>表示，并且每个单元格表示两个实验单元之间的协方差。然而，要做到这一点，我们需要使用<span class="math inline">\(\mbox{X}\)</span>的行表示实验单元。因此，在我们上面的符号中，在经过缩放后，你必须要使用<span class="math inline">\(\mathbf{Y}\mathbf{Y}^\top\)</span>来进行计算。总之，如果你想让我们的解释与其他有关的PCA内容相符，就必须对这本书中使用的矩阵进行转置。</p>
<h2 id="奇异值分解">奇异值分解</h2>
<p>相关的Rmarkdown参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/svd.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在前面的部分中，我们展示了降维分析，以及如何让我们使用一维数据来替代原来的二维数据，近似地表示点与点之间的距离。奇异值分解(SVD)是我们这种方法的推广。在这个案例中，SVD对原始数据进行了转换。这种转换具有一些非常有用的属性。</p>
<p>SVD计算的主要结果就是，我们可以写为一个<span class="math inline">\(m\times n\)</span>矩阵，对于矩阵<span class="math inline">\(\mbox{Y}\)</span>就写为：</p>
<p><span class="math display">\[
\mathbf{U}^\top\mathbf{Y} = \mathbf{DV}^\top
\]</span> 其中， * <span class="math inline">\(\mathbf{U}\)</span> 是一个 <span class="math inline">\(m \times p\)</span> 正交矩阵； * <span class="math inline">\(\mathbf{V}\)</span> 是一个 <span class="math inline">\(p \times p\)</span> 正交矩阵； * <span class="math inline">\(\mathbf{D}\)</span> 是一个 <span class="math inline">\(n \times p\)</span> 对角矩阵。</p>
<p>其中，<span class="math inline">\(p=\mbox{min}(m,n)\)</span>，<span class="math inline">\(\mathbf{U}^\top\)</span>对数据<span class="math inline">\(\mathbf{Y}\)</span>进行旋转，这一步非常有用，因为<span class="math inline">\(\mathbf{U}^\top \mathbf{Y}=\mathbf{VD}\)</span>列的变异（精确的平方和）会下降。因此<span class="math inline">\(\mathbf{U}\)</span>是正交辞职，我们可以将SVD写为如下形式： <span class="math display">\[
\mathbf{Y} = \mathbf{UDV}^\top
\]</span> 实际上这个公式更加普遍，我们也可以将转换写为如下形式： <span class="math display">\[
\mathbf{YV} = \mathbf{UD}
\]</span> <span class="math inline">\(Y\)</span>的这种转换也会生成一个矩阵，这个矩阵的列的乘方和是递减的。</p>
<p>将SVD应用到我们的案例中，就是如下结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y &lt;- t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">s &lt;- svd(y)</div></pre></td></tr></table></figure>
<p>我们可以马上就是看到使用了SVD后生成的转换后的矩阵非常类似于我们前面的案例中的结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div><div class="line">       [,<span class="number">1</span>]   [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.982</span> -<span class="number">1.017</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">1.017</span>  <span class="number">0.982</span></div></pre></td></tr></table></figure>
<p>当我们旋转后，绘制成的图形称为主成分(principal coimponent)：这里只绘制出了第一个主成分和第二个主成分。如果我们想要从SVD中获取主成分，只需要旋转后的<span class="math inline">\(\mathbf{U}^\top\mathbf{Y}\)</span> 即可：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PC1 = s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 = s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">plot(PC1,PC2,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173315.jpeg">

</div>
<h3 id="用途">用途</h3>
<p>使用SVD的用途并不十分明显，我们可以看一些案例。在这个案例中，我们将会极大地降低<span class="math inline">\(V\)</span>的组倒数，并且仍然能够构建<span class="math inline">\(Y\)</span>。</p>
<p>现在我们来对基因表达谱进行SVD的计算，我们可以只使用表达谱中的100个基因的子集，这样计算会快一点，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">ind &lt;- sample(nrow(e),<span class="number">500</span>)</div><div class="line">Y &lt;- t(apply(e[ind,],<span class="number">1</span>,scale)) <span class="comment">#standardize data for illustration</span></div></pre></td></tr></table></figure>
<p>使用<code>svd()</code>函数可以返回3个矩阵（D矩阵仅返回对角线元素），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(Y)</div><div class="line">U &lt;- s$u</div><div class="line">V &lt;- s$v</div><div class="line">D &lt;- diag(s$d) <span class="comment">##turn it into a matrix</span></div></pre></td></tr></table></figure>
<p>我们首选要注意到，我们可以重构<span class="math inline">\(y\)</span>：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Yhat &lt;- U %*% D %*% t(V)</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>如果我们看一下<span class="math inline">\(\mathbf{UD}\)</span>的平方和，我们会看到最后几个非常接近于0（也许我们会有一些重复的列）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173946.jpeg">

</div>
<p>这意味着<span class="math inline">\(V\)</span>的最后一列对于<span class="math inline">\(Y\)</span>的重建非常小。为了说明这一点，我们可以考虑<span class="math inline">\(V\)</span>最后一项为0的这种极端情况。在这个案例中，<span class="math inline">\(V\)</span>的最后一列根本用不到。由于SVD的这种创建方式，<span class="math inline">\(V\)</span>的列对<span class="math inline">\(Y\)</span>的重建影响越来越小。我们通常认为这种描述为“解释了较少的变异”。这就意味着，对于一个大型矩阵，当你到达最后一列时，可能已经没有太多需要“解释”的内容了。例如，当我们把最后4列删除，看一下计算结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- ncol(U)-<span class="number">4</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>最大的残差基本上就等于0了，就意味着<code>Yhat</code>实际上是与<code>Y</code>一样，但是，我们至少需要4个维度来传输信息。</p>
<p>通过查看<span class="math inline">\(d\)</span>，我们可以看到，在这个特定的数据集中，我们能得到一个很好的近似值，它只保留了94列。在下面的图形中，我们可以看到每列能解释的变异程度是多少：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909174959.jpeg">

</div>
<p>还可以看一下累积曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plot(cumsum(s$d^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>,ylim=c(<span class="number">0</span>,\</div><div class="line"><span class="number">100</span>),type=<span class="string">"l"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175047.jpeg">

</div>
<p>虽然刚开始的时候，我们的数据是189维，但是我们可以使用95维来近似表示<span class="math inline">\(Y\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- <span class="number">95</span> <span class="comment">##out a possible 189</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">boxplot(resid,ylim=quantile(Y,c(<span class="number">0.01</span>,<span class="number">0.99</span>)),range=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175150.jpeg">

</div>
<p>因此， 我们只使用了一半的维度就保留了原始数据中的大部分的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var(as.vector(resid))/var(as.vector(Y))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; var(as.vector(resid))/var(as.vector(Y))</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>这个计算结果说明，我们使用了降维后的数据解释了原始95%的变异，我们需要注意的是，我们是通过<span class="math inline">\(D\)</span>来计算的这个比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>因此，<span class="math inline">\(D\)</span>中的元素可以告诉我们每个PC在解释变异方面所贡献的程度大小。</p>
<h3 id="高度相关数据">高度相关数据</h3>
<p>为了辅助理解SVD是如何工作的，我们使用两组高度相关的列来构建一个数据集，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">2</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- cbind(x,x)+e</div><div class="line">cor(Y)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; cor(Y)</div><div class="line">          x         x</div><div class="line">x <span class="number">1.0000000</span> <span class="number">0.9998873</span></div><div class="line">x <span class="number">0.9998873</span> <span class="number">1.0000000</span></div></pre></td></tr></table></figure>
<p>在这个案例中，第2列添加了很少的“信息”，因此所有的<code>Y[,1]-Y[,2]</code>都接近于0。使用<code>rowMeans(Y)</code>计算更加有效，这是因为<code>Y[,1]-rowMeans(Y)</code>和<code>Y[,2]-rowMeans(Y)</code>更接近于0。<code>rowMenas(Y)</code>最终生成的结果在<span class="math inline">\(U\)</span>的第1列中。SVD的计算结果表明，仅使用第1列就能解释大多数的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- svd(Y)$d</div><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999441</span></div></pre></td></tr></table></figure>
<p>在这个案例中，许多列的数据高度相关，我们可以进行更大程度的降维操作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">25</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- replicate(n,x)+e</div><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999065</span></div></pre></td></tr></table></figure>
<h2 id="练习-1">练习</h2>
<p>P338</p>
<h2 id="投影">投影</h2>
<p>原始Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/projections.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经详细地描述了降维的概念，以及SVD和主成分分析的内容，现在我们来谈一下它们背后的数学原理。我们先从投影(projection)开始讲起。投影是一个线性代数的概念，它能帮助我们理解许多关于高通量数据的许多数学操作。如果想要了解更多相关的知识，可以找本线性代数的书来看一下有关投影的内容。在这一部分里，我们会提供一个快速的回顾，然后提供一些数据分析的相关案例。</p>
<p>作为回顾，我们需要注意的是，投影就是点与其子空间之间的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910145026.png">

</div>
<p>在上图中，顶部的点指向空间中的一点。在上图的这个卡通图中，空间是二维的，但是我们可以更加抽象地思考一下。这个空间由笛卡尔平面表示，小人站的这条线是点的一个子空间。将点投影到这个子空间上所对应的位置，就是这个子空间上这个位置距离原点最近的点。几何学告诉我们，我们可以通过从点到子空间一条垂线（虚线）来找到子空间上的这点。小人站在这个子空间上，这个人从原点走到投影点的位置时，就是这个点投影到子空间后的坐标。</p>
<p>为了扩展投影的概念，我们可以使用标准矩阵线性符号来说明这个点， <span class="math inline">\(\vec{y} \in \mathbb{R}^N\)</span>是一个N维空间的点，<span class="math inline">\(L \subset \mathbb{R}^N\)</span>是一个更小的子空间。</p>
<h3 id="案例当n2">案例：当N=2</h3>
<p>先看一个案例，<span class="math inline">\(Y = \begin{pmatrix} 2 \\ 3\end{pmatrix}\)</span>，我们可以画出这个向量的图形：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar (<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">4</span>),c(<span class="number">0</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910151328.jpeg">

</div>
<p>我们可以马上定义一个坐标系统，将这个向量投影到空间中：<span class="math inline">\(\begin{pmatrix} 1\\ 0\end{pmatrix}\)</span> （x轴）和 <span class="math inline">\(\begin{pmatrix} 0\\ 1\end{pmatrix}\)</span> （y轴）。 <span class="math inline">\(Y\)</span> 向子空间的投影可以通过点2和3分别进行定义：</p>
<p><span class="math display">\[
\begin{align*}
Y &amp;= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&amp;=2  \begin{pmatrix} 1\\ 0\end{pmatrix} + 3 \begin{pmatrix} 0\\ 1\end{pmatrix} 
\end{align*}
\]</span> 我们可以说 <span class="math inline">\(2\)</span> 和<span class="math inline">\(3\)</span>是向量<span class="math inline">\(Y\)</span>的坐标，<span class="math inline">\(\begin{pmatrix} 1\\ 0\end{pmatrix} \mbox{and} \begin{pmatrix} 0\\1 \end{pmatrix}\)</span> 是它的基。</p>
<p>现在我们定义一个新的子空间。红线（后面我们会画出这个图形）是一个子集(subset)<span class="math inline">\(L\)</span>，它由满足 <span class="math inline">\(c \vec{v}\)</span> with <span class="math inline">\(\vec{v}=\begin{pmatrix} 2&amp; 1\end{pmatrix}^\top\)</span>的点构成。那么 <span class="math inline">\(\vec{y}\)</span> 在<span class="math inline">\(L\)</span>上的投影就是<span class="math inline">\(L\)</span>上最接近于 <span class="math inline">\(\vec{y}\)</span> 的点。因此我们需要找一个向量<span class="math inline">\(c\)</span>，它是位于 <span class="math inline">\(\vec{y}\)</span> 和<span class="math inline">\(c\vec{v}=(2c,c)\)</span>之间最小的距离。从线性代数的知识我们可知，这些点之间的距离正交于空间：</p>
<p><span class="math display">\[
(\vec{y}-\hat{c}\vec{v}) \cdot \vec{v} = 0
\]</span></p>
<p>上面公式也可以写为：</p>
<p><span class="math display">\[
\vec{y}\cdot\vec{v} - \hat{c}\vec{v}\cdot\vec{v} =  0
\]</span></p>
<p>即： <span class="math display">\[
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}
\]</span> <span class="math display">\[\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}\]</span></p>
<p>这里我们使用点号 <span class="math inline">\(\cdot\)</span> 来表示点积(dot product): <span class="math inline">\(\,\, \vec{x} \cdot \vec{y} = x_1 y_1+\dots x_n y_n\)</span>.</p>
<p>下面我们使用R来演示一下上面的案例：</p>
<figure class="highlight plain"><figcaption><span>projection, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(c(0,4),c(0,4),xlab=&quot;Dimension 1&quot;,ylab=&quot;Dimension 2&quot;,type=&quot;n&quot;)</div><div class="line">arrows(0,0,2,3,lwd=3)</div><div class="line">abline(0,0.5,col=&quot;red&quot;,lwd=3) #if x=2c and y=c then slope is 0.5 (y=0.5x)</div><div class="line">text(2,3,&quot; Y&quot;,pos=4,cex=3)</div><div class="line">y=c(2,3)</div><div class="line">x=c(2,1)</div><div class="line">cc = crossprod(x,y)/crossprod(x)</div><div class="line">segments(x[1]*cc,x[2]*cc,y[1],y[2],lty=2)</div><div class="line">text(x[1]*cc,x[2]*cc,expression(hat(Y)),pos=4,cex=3)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910153202.jpeg">

</div>
<p>我们需要注意的是，如果 <span class="math inline">\(\vec{v}\)</span> 满足 <span class="math inline">\(\vec{v}\cdot \vec{v}=1\)</span>, 那么<span class="math inline">\(\hat{c}\)</span> 就是 <span class="math inline">\(\vec{y} \cdot \vec{v}\)</span> ，空间 <span class="math inline">\(L\)</span>并没有发生改变，这处简化担任就是我们喜欢正交矩阵的一个原因。</p>
<h3 id="案例样本均值就是投影">案例：样本均值就是投影</h3>
<p>设 <span class="math inline">\(\vec{y} \in \mathbb{R}^N\)</span> ，<span class="math inline">\(L \subset \mathbb{R}^N\)</span> 被以下向量张成：</p>
<p><span class="math display">\[
\vec{v}=\begin{pmatrix} 1\\ \vdots \\  1\end{pmatrix};
L = \{ c \vec{v}; c \in \mathbb{R}\}
\]</span> 在这个空间里，向量的分量(components）都是相同的数目，因此我们可以把这个空间看作为常数：在投影中，每个维度都是相同的值。那么<span class="math inline">\(c\)</span>如何才能使得 <span class="math inline">\(c\vec{v}\)</span> 与 <span class="math inline">\(\vec{y}\)</span> 之间的距离最小呢？</p>
<p>当我们谈到这个问题时，我们会使用前面的二维图形。我们可以简单地抽象将<span class="math inline">\(\vec{y}\)</span>视为N维空间上的一个点，将<span class="math inline">\(L\)</span>视为一个更小数目的子空间，在这个案例中就是<span class="math inline">\(c\)</span>。</p>
<p>回到我们的问题，我们知道，投影就是：</p>
<p><span class="math display">\[\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}\]</span></p>
<p>在这个案例中它就是平均值： <span class="math display">\[
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}} = \frac{\sum_{i=1}^N Y_i}{\sum_{i=1}^N 1} = \bar{Y}
\]</span></p>
<p>在这个案例中，它也非常容易使用微积分进行计算：</p>
<p><span class="math display">\[
\frac{\partial}{\partial c}\sum_{i=1}^N (Y_i - c)^2 = 0 \implies 2 \sum_{i=1}^N (Y_i - \hat{c}) = 0 \implies
\]</span> <span class="math display">\[
N c = \sum_{i=1}^N Y_i \implies \hat{c}=\bar{Y
}
\]</span></p>
<h3 id="案例回归也是一种投影">案例：回归也是一种投影</h3>
<p>现在来看一下略微复杂的案例。简单线性回归也能用投影来解释。我们的数据 <span class="math inline">\(\mathbf{Y}\)</span>（这里我们不再使用<span class="math inline">\(\vec{y}\)</span>符号）是一个N维向量，我们使用一个线性方程<span class="math inline">\(\beta_0 + \beta_1 X_i\)</span>来预测<span class="math inline">\(Y_i\)</span> 。此时我要找到能够使<span class="math inline">\(Y\)</span>和由以下向量定义的空间的最小距离时的 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span> ，其中： <span class="math display">\[
\vec{v}_0=
\begin{pmatrix}
1\\
1\\
\vdots \\
1\\
\end{pmatrix} 
\mbox{ and }
\vec{v}_1=
\begin{pmatrix}
X_{1}\\
X_{2}\\
\vdots \\
X_{N}\\
\end{pmatrix} 
\]</span></p>
<p>我们的 <span class="math inline">\(N\times 2\)</span> 矩阵 <span class="math inline">\(\mathbf{X}\)</span> 是 <span class="math inline">\([ \vec{v}_0 \,\, \vec{v}_1]\)</span> ，<span class="math inline">\(L\)</span>中的任何点都可以被写为 <span class="math inline">\(X\vec{\beta}\)</span>.</p>
<p>正交投影的多维形式的方程为：</p>
<p><span class="math display">\[
X^\top (\vec{y}-X\vec{\beta}) = 0
\]</span></p>
<p>我们在之前看到过种形式：</p>
<p><span class="math display">\[
X^\top X \hat{\beta}=  X^\top \vec{y} 
\]</span></p>
<p><span class="math display">\[
\hat{\beta}= (X^\top X)^{-1}X^\top \vec{y}
\]</span></p>
<p>它向<span class="math inline">\(L\)</span>的投影就是：</p>
<p><span class="math display">\[
X (X^\top X)^{-1}X^\top \vec{y}
\]</span></p>
<h2 id="旋转-1">旋转</h2>
<p>相关的Rmarkdown参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/rotations.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>与投影相关的一个最常见的应用就是坐标旋转(coordinate rotations)。在数据分析中，简单的旋转可以很好地对数据进行可视化和解释。我们将会介绍旋转背后的数学原理，并且给出一些简单的数据分析案例。</p>
<p>前面我们使用了下面的例子： <span class="math display">\[
Y = \begin{pmatrix} 2 \\ 
3 
\end{pmatrix} 
= 
2  
\begin{pmatrix} 1\\
0 
\end{pmatrix} + 
3 
\begin{pmatrix} 0\\ 
1 
\end{pmatrix}
\]</span> 我们注意到，<span class="math inline">\(Y\)</span>的坐标是<span class="math inline">\((2,3)\)</span>，现在我们使用如下的代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">segments(<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">segments(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910165242.jpeg">

</div>
<p>但是，我们可以用其它的一些线性组合来表示点<span class="math inline">\((2,3)\)</span>： <span class="math display">\[
\begin{align*}
Y &amp;= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&amp;= 2.5 \begin{pmatrix} 1\\ 1\end{pmatrix} + -1 \begin{pmatrix} \phantom{-}0.5\\ -0.5\end{pmatrix} 
\end{align*}
\]</span> 新的坐标就是： <span class="math display">\[
Z = \begin{pmatrix} 2.5 \\ -1 \end{pmatrix}
\]</span> 从图形上我们可以看出来，这个坐标就是我们由新的基定义的空间的投影</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">abline(<span class="number">0</span>,-<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">y=c(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">x1=c(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">##new basis</span></div><div class="line">x2=c(<span class="number">0.5</span>,-<span class="number">0.5</span>)<span class="comment">##new basis</span></div><div class="line">c1 = crossprod(x1,y)/crossprod(x1)</div><div class="line">c2 = crossprod(x2,y)/crossprod(x2)</div><div class="line">segments(x1[<span class="number">1</span>]*c1,x1[<span class="number">2</span>]*c1,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">segments(x2[<span class="number">1</span>]*c2,x2[<span class="number">2</span>]*c2,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233102.jpeg">

</div>
<p>我们可以使用矩阵乘法在表示<span class="math inline">\((2,3)\)</span>的这两个坐标中进行转换： <span class="math display">\[
Y =   AZ\\
\]</span></p>
<p><span class="math display">\[
 A^{-1} Y =  Z\\
\]</span></p>
<p><span class="math display">\[
A= \begin{pmatrix} 1&amp; \phantom{-}0.5\\ 1 &amp; -0.5\end{pmatrix} \implies 
A^{-1}= \begin{pmatrix} 0.5&amp; 0.5 \\ 1 &amp;-1\end{pmatrix}
\]</span></p>
<p>其中，<span class="math inline">\(Z\)</span>和<span class="math inline">\(Y\)</span>表示了相同的信息，但是它们位于不同的坐标系中。</p>
<h3 id="案例双胞胎身高">案例：双胞胎身高</h3>
<p>我们先来看100个二维数据点<span class="math inline">\(Y\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n = <span class="number">100</span></div><div class="line">mypar()</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>),matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233353.jpeg">

</div>
<p>这里就使用了旋转：<span class="math inline">\(Z = A^{-1} Y\)</span>，图形如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = matrix(c(<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z = A%*%y</div><div class="line">mypar()</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlab=<span class="string">"Average"</span>,ylab=<span class="string">"Difference"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233448.jpeg">

</div>
<p>我们在这里进行的操作就是对数据进行旋转，从而使行新的坐标系<span class="math inline">\(Z\)</span>的第一维是平均身高（就是相当于x轴），崦第二维则是两个双胞胎身高的差值（y轴）。</p>
<p>我们已经使用了奇异值分解计算主成分。有时候将SVD视为应动力非常有用，例如 <span class="math inline">\(\mathbf{U}^\top \mathbf{Y}\)</span> 就会构建出一个新的坐标系 <span class="math inline">\(\mathbf{DV}^\top\)</span> ，在这个新的坐标系中，它们的维度按照维度能够解释变异的程序进行排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/19/DAL/DALS019_StatisticalModels2_Beyes_Hierarchical/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/DAL/DALS019_StatisticalModels2_Beyes_Hierarchical/" itemprop="url">DALS019-统计模型2-贝叶斯分布与层次分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T12:00:00+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,055
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第7章统计模型的第2小节，这一部分的主要内容涉及贝叶斯统计的一些原理。相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/modeling/bayes.Rmd" target="_blank" rel="external">Github</a>，另外，如果想补充一些贝叶斯的相关知识，可以参考这本书《统计学关我什么事：生活中的极简统计学》，这是一本有关贝叶斯统计的科普书，公式不多。</p>
<h2 id="贝叶斯统计">贝叶斯统计</h2>
<p>高通量数据的一个明显特点就是，虽然我们最终会报道一些特定的基因，但是我们还会观察到许多相关的结果。例如，我们检测会数千个基因或者是代表了蛋白结合位点的数千个峰图，或者是一些CpGs的甲基化水平。但是，我们这里使用的多数统计推断方法都是独立地处理每个特征值，并且几乎忽略了来自其它特征的数据。在这一部分里，我们将会了解到，如何通过对特征值的联合建模来进行统计。这里方法中使用最为广泛的就是层次模型(hierachical models)，我们会在后面的贝叶斯统计中进行解释。</p>
<h3 id="贝叶斯定理">贝叶斯定理</h3>
<p>先来看一个案例，如果我们有一种检测手段来检测囊性纤维化(cystic fibrosis)。假设这个检测手段的精确程度为99%，我们可以使用下面的公式来表示： <span class="math display">\[
\mbox{Prob}(+ \mid D=1)=0.99, \mbox{Prob}(- \mid D=0)=0.99
\]</span> 其中，<span class="math inline">\(+\)</span>表示阳性结果，<span class="math inline">\(D\)</span>表示检测的结果，其中<span class="math inline">\(1\)</span>表示得病，，<span class="math inline">\(0\)</span>表示不得病。</p>
<p>现在我们随机选择一个人进行检测，结果如果是阳性，那么这个人患病的概率是多大？也就是说要计算<span class="math inline">\(\mbox{Prb}(D=1|+)\)</span>的结果。囊性纤维化的发病率是每1/3900，也就是说，<span class="math inline">\(\mbox{Prob}(D=1|+)=0.0025\)</span>，为了计算出这个人患病的概率，我们就会使用到贝叶斯定理，贝叶斯定理公式如下所示： <span class="math display">\[
\mbox{Pr}(A \mid B)  =  \frac{\mbox{Pr}(B \mid A)\mbox{Pr}(A)}{\mbox{Pr}(B)}
\]</span> 这个公式就可以应用到我们的案例中，如下所示： <span class="math display">\[
\begin{align*}
\mbox{Prob}(D=1 \mid +) &amp; =  \frac{ P(+ \mid D=1) \cdot P(D=1)} {\mbox{Prob}(+)} \\
&amp; =  \frac{\mbox{Prob}(+ \mid D=1)\cdot P(D=1)} {\mbox{Prob}(+ \mid D=1) \cdot P(D=1) + \mbox{Prob}(+ \mid D=0) \mbox{Prob}( D=0)} 
\end{align*}
\]</span> 换成实际数字，则如下所示： <span class="math display">\[
\frac{0.99 \cdot 0.00025}{0.99 \cdot 0.00025 + 0.01 \cdot (.99975)}  =  0.02
\]</span> 也就是说，虽然这种检测手段有99%的精度，但是一个人的检测结果如果是阳性，那么这个人得病的概率只有0.02。这似乎有点反直觉。其原因就是，我们必须要考虑，当我们随机选择一个人时，这个人患上这种疾病时非常罕见的可能性。为了说明这一个，我们随便使用Monte Carlo模拟来计算一下。</p>
<h3 id="模拟">模拟</h3>
<p>下面的模拟旨在帮助你能够以可视化的形式来理解贝叶斯定理。我们首选从一个总体中随机选择1500人，其中患病的概率是5%，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">3</span>)</div><div class="line">prev &lt;- <span class="number">1</span>/<span class="number">20</span></div><div class="line"><span class="comment">##Later, we are arranging 1000 people in 80 rows and 20 columns</span></div><div class="line">M &lt;- <span class="number">50</span> ; N &lt;- <span class="number">30</span></div><div class="line"><span class="comment">##do they have the disease?</span></div><div class="line">d&lt;-rbinom(N*M,<span class="number">1</span>,p=prev)</div></pre></td></tr></table></figure>
<p>现在进行一项检测，这个检测的准确率是90%，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">accuracy &lt;- <span class="number">0.9</span></div><div class="line">test &lt;- rep(<span class="literal">NA</span>,N*M)</div><div class="line"><span class="comment">##do controls test positive?</span></div><div class="line">test[d==<span class="number">1</span>] &lt;- rbinom(sum(d==<span class="number">1</span>), <span class="number">1</span>, p=accuracy)</div><div class="line"><span class="comment">##do cases test positive?</span></div><div class="line">test[d==<span class="number">0</span>] &lt;- rbinom(sum(d==<span class="number">0</span>), <span class="number">1</span>, p=<span class="number">1</span>-accuracy)</div></pre></td></tr></table></figure>
<p>由于没有患病的人数要远远超过患病的人数，即使存在着极低的假阳性率，那么在检测为阳性的结果中，不患病人的也要多于患病的人，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">cols &lt;- c(<span class="string">"grey"</span>,<span class="string">"red"</span>)</div><div class="line">people &lt;- expand.grid(<span class="number">1</span>:M,N:<span class="number">1</span>)</div><div class="line">allcols &lt;- cols[d+<span class="number">1</span>] <span class="comment">##Cases will be red</span></div><div class="line">positivecols &lt;- allcols</div><div class="line">positivecols[test==<span class="number">0</span>] &lt;- <span class="literal">NA</span> <span class="comment">##remove non-positives</span></div><div class="line">negativecols &lt;- allcols</div><div class="line">negativecols[test==<span class="number">1</span>] &lt;- <span class="literal">NA</span> <span class="comment">##remove non-positives</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">layout(matrix(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>),<span class="number">2</span>,<span class="number">2</span>),width=c(<span class="number">0.35</span>,<span class="number">0.65</span>))</div><div class="line"><span class="comment">###plot of all people</span></div><div class="line">plot(people,col=allcols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste0(<span class="string">"Population: "</span>,round(mean(d)*<span class="number">100</span>),<span class="string">"% are red"</span>))</div><div class="line">plot(people,col=positivecols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste(<span class="string">"Tested Positive:"</span>,round(mean(d[test==<span class="number">1</span>])*<span class="number">100</span>),<span class="string">"% are red"</span>))</div><div class="line">plot(people,col=negativecols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste(<span class="string">"Tested Negative:"</span>,round(mean(d[test==<span class="number">0</span>])*<span class="number">100</span>,<span class="number">1</span>),<span class="string">"% are red"</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908153222.jpeg">

</div>
<p>现在解释一下上面的图：</p>
<p>顶图：红点表示患者。每个人接受检测的话，有90%的可能性结果是准确的。即<span class="math inline">\(\mbox{Pr}(D=1)\)</span>；</p>
<p>下左图：检测结果为阳性（无论结果对不对，这里面含有真阳性与假阳性）的人，即<span class="math inline">\(\mbox{Pr}(D=1|+)\)</span></p>
<p>下右图：检测结果为阴性的人，即<span class="math inline">\(\mbox{Pr}(D=0|+)\)</span></p>
<h3 id="贝叶斯的实际运用">贝叶斯的实际运用</h3>
<p>José Iglesias是一名职业棒球运行员，在2013年4月份，他开始了职业生成，他表表现得很好，成绩如下所示：</p>
<table>
<thead>
<tr class="header">
<th>Month</th>
<th>At Bats</th>
<th>H</th>
<th>AVG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>April</td>
<td>20</td>
<td>9</td>
<td>.450</td>
</tr>
</tbody>
</table>
<p>平均击球率(battingaverage, AVG)统计是一种检测成功的方式。粗略地说，这个指标是告诉我们击球时的成功情况。<code>AVG=0.450</code>就表明，这个运动员在他击球的时间内（对应上面的<code>At Bats</code>）成功了45%，这是一个非常高的水平。为什么水平高呢，因为自1941年Ted Williams的<code>AVG=0.400</code>以来，还没有人能超过这个水平。为了说明层次模型的强大功能，我们将会在后面对Jose的数据进行预测。</p>
<p>在本书的前面部分到此为止，我们所到到的统计学技术可以被称为频率学派技术(frequentist techniques)，使用这种知识做出的结论就是能计算出一个置信区间。我们可以把击打(hitting)这个事件看作是一个二元结果，其成功的概论为<span class="math inline">\(p\)</span>。因此，如果成功率是0.450的话，那么击球次数是20次时，标准误为： <span class="math display">\[
\sqrt{\frac{.450 (1-.450)}{20}}=.111
\]</span> 也就是说，我们计算出的置信区间为<code>.450-.222</code> to <code>.450+.222</code>或<code>.228</code> to <code>.672</code>。</p>
<p>使用这种手段进行预测存在着两个问题。第一，实际用处不大。第二，成功率在0.450之间波动，也就是说这个人打破了Ted William的纪录。如果你自己关注棒球运动的话，打破Ted William纪录这种描述似乎是有问题，这是因为你隐含地使用了一个层次模型，这个模型会影响后面几年棒球的信息。在这里，我们对这种直觉进行量化。</p>
<p>首选，我们来研究一下前三个赛季里所有超过500次击打(at bats)的运动员的击球率的分布情况：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">tmpfile &lt;- tempfile()</div><div class="line">tmpdir &lt;- tempdir()</div><div class="line">download.file(<span class="string">"http://seanlahman.com/files/database/lahman-csv_2014-02-14.zip"</span>,tmpfile)</div><div class="line"><span class="comment">##this shows us files</span></div><div class="line">filenames &lt;- unzip(tmpfile,list=<span class="literal">TRUE</span>)</div><div class="line">players &lt;- read.csv(unzip(tmpfile,files=<span class="string">"Batting.csv"</span>,exdir=tmpdir),as.is=<span class="literal">TRUE</span>)</div><div class="line">unlink(tmpdir)</div><div class="line">file.remove(tmpfile)</div><div class="line"></div><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line"><span class="keyword">for</span>(y <span class="keyword">in</span> <span class="number">2010</span>:<span class="number">2012</span>)&#123;</div><div class="line">  dat &lt;- filter(players,yearID==y) %&gt;% mutate(AVG=H/AB) %&gt;% filter(AB&gt;<span class="number">500</span>)</div><div class="line">  hist(dat$AVG*<span class="number">1000</span>,xlab=<span class="string">"AVG"</span>,freq=<span class="literal">FALSE</span>,main=y,xlim=c(<span class="number">200</span>,<span class="number">360</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908211314.jpeg">

</div>
<p>我们注意到，普通运行员的AVG为0.275，总体运动员的标准差为0.027。所以，我们看到，0.45这个数字与它们假设偏离非常大，因为这个数字离平均值的差距超过了6个标准差。Jose的这个数字是由于运气，还是说他确实是过去50年来最好的运动员？或者是这两者的结合？但是，他有多幸运，以及运动天赋有多高？如果我们确信他是由于运气出现的这个数字，我们应该把他送到相信他确实是0.45这个水平的球队里，并且有可能高估了他的潜力。</p>
<h3 id="层次模型"><strong>层次模型</strong></h3>
<p>层次模型为我们提供了如何观察到0.45的这个数字的数学描述。首先，我们会随机选择一个内在能力为<span class="math inline">\(\theta\)</span>运动员，然后，我们看到成功概率为<span class="math inline">\(\theta\)</span>的20个随机结果（这一段不太懂，原文为：The hierarchical model provides a mathematical description of how we came to see the observation of .450. First, we pick a player at random with an intrinsic ability summarized by, for example, <span class="math inline">\(\theta\)</span>, then we see 20 random outcomes with success probability <span class="math inline">\(\theta\)</span>.），其中： <span class="math display">\[
\begin{align*}
\theta &amp;\sim N(\mu, \tau^2) \mbox{ describes randomness in picking a player}\\
Y \mid \theta &amp;\sim N(\theta, \sigma^2) \mbox{ describes randomness in the performance of this particular player}
\end{align*}
\]</span> 我们要注意2个层次（这就是为什么要称为层次分析的原因）：</p>
<ol style="list-style-type: decimal">
<li>运动员与运动员之间的变异；</li>
<li>击球时，运气因素导致的变异。</li>
</ol>
<p>在贝叶斯框架中，第一个水平称为先验分布(prior distribution)，第二个水平称为采样分布(sampling distribution)。</p>
<p>现在我们使用贝叶斯模型来计算Jose的数据。假设我们想预测构成他真实击球平均水平<span class="math inline">\(\theta\)</span>的内在能力的话。使用层次模型就按下面的方法表示： <span class="math display">\[
\begin{align*}
\theta &amp;\sim N(.275, .027^2) \\
Y \mid \theta &amp;\sim N(\theta, .111^2) 
\end{align*}
\]</span> 我们现在就可以计算出一个后验分布(posterior distribution)来描述我们对<span class="math inline">\(\theta\)</span>的预测。这里我们可以使用贝叶斯规则的连续计算方法推导后验概率，后验概率是对给定观测数据参数<span class="math inline">\(\theta\)</span>的分布： <span class="math display">\[
\begin{align*}
f_{ \theta \mid Y} (\theta\mid Y) &amp;=
\frac{f_{Y\mid \theta}(Y\mid \theta) f_{\theta}(\theta)
}{f_Y(Y)}\\
&amp;= \frac{f_{Y\mid \theta}(Y\mid \theta) f_{\theta}(\theta)}
{\int_{\theta}f_{Y\mid \theta}(Y\mid \theta)f_{\theta}(\theta)}
\end{align*}
\]</span> 我们主要是对能够使后验概率<span class="math inline">\(f_{\theta\mid Y}(\theta\mid Y)\)</span>的值最大的<span class="math inline">\(\theta\)</span>感兴趣。在我们的案例中，我们可以看出后验概率服从正态分布，我们能计算出均值<span class="math inline">\(\mbox{E}(\theta\mid y)\)</span>，方差<span class="math inline">\(\mbox{var}(\theta\mid y)\)</span>，尤其，我们可以计算出这个分布的均值服从以下分布： <span class="math display">\[
\begin{align*}
\mbox{E}(\theta\mid y) &amp;= B \mu + (1-B) Y\\
&amp;= \mu + (1-B)(Y-\mu)\\
B &amp;= \frac{\sigma^2}{\sigma^2+\tau^2}
\end{align*}
\]</span> 这是一个总体均值<span class="math inline">\(\mu\)</span>和观测数据<span class="math inline">\(Y\)</span>的加权均值。其权重取决于总体<span class="math inline">\(\tau\)</span>的SD和我们观测数据<span class="math inline">\(\sigma\)</span>的SD。这个加权均值有时候也会被称为<code>shrinking</code>，因为它缩小(shrink)了对先验均值的估计，在Joes Iglesias的数据中，结果如下所示： <span class="math display">\[
\begin{align*}
\mbox{E}(\theta \mid Y=.450) &amp;= B \times .275 + (1 - B) \times .450 \\
&amp;= .275 + (1 - B)(.450 - .275) \\
B &amp;=\frac{.111^2}{.111^2 + .027^2} = 0.944\\
\mbox{E}(\theta \mid Y=450) &amp;\approx .285
\end{align*}
\]</span> 方差如下所示： <span class="math display">\[
\mbox{var}(\theta\mid y) = \frac{1}{1/\sigma^2+1/\tau^2}
= \frac{1}{1/.111^2 + 1/.027^2} = 0.00069
\]</span> 标准差因此是0.026。我们开始时，使用了传统频率学派的思路计算出的95%置信区间忽略了来自于其他运动员的数据，因此会单纯地认为Joes的数据是0.0450 ± 0.220。我们随后使用了贝叶斯方法，整合了来源于其他运动员的数据，以及前几年的数据，计算出了后验概率。这种计算思路实际上就是经验贝叶斯方法，因此我们使用了数据先构建了先验知识。从后验结果中我们可以知道，通过报告一个以均值为中心的区间来报告所谓的95%的可信区间，其发生的概率为95%，在这个案例中，其结果是0.285 ± 0.052。原文：From the posterior we can report what is called a 95% credible interval by reporting a region, centered at the mean, with a 95% chance of occurring. In our case, this turns out to be: 0.285 ± 0.052.</p>
<p>贝叶斯可信区间表明，如果其他的球队发现了0.45这个数字，我们应该考虑到Joses可能转会到其他球队，因为我们预测到了Jose的水平高于平均不水平。有意思的是，Red Sox在7月份的时候将Jose转会到了Detroit Tigers队。这里是Jose在接下来的5个月内的击球率：</p>
<table>
<thead>
<tr class="header">
<th>Month</th>
<th>At Bat</th>
<th>Hits</th>
<th>AVG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>April</td>
<td>20</td>
<td>9</td>
<td>.450</td>
</tr>
<tr class="even">
<td>May</td>
<td>26</td>
<td>11</td>
<td>.423</td>
</tr>
<tr class="odd">
<td>June</td>
<td>86</td>
<td>34</td>
<td>.395</td>
</tr>
<tr class="even">
<td>July</td>
<td>83</td>
<td>17</td>
<td>.205</td>
</tr>
<tr class="odd">
<td>August</td>
<td>85</td>
<td>25</td>
<td>.294</td>
</tr>
<tr class="even">
<td>September</td>
<td>50</td>
<td>10</td>
<td>.200</td>
</tr>
<tr class="odd">
<td>Total w/o April</td>
<td>330</td>
<td>97</td>
<td>.293</td>
</tr>
</tbody>
</table>
<p>虽然这两个区间都包括了最终的击球平均值，但是贝叶斯可信区间提供了更精确的预测，尤其是，这种方法预测到Jose在本赛季的剩余时间里表现不佳。</p>
<h2 id="练习">练习</h2>
<p>P308</p>
<h2 id="层次模型-1">层次模型</h2>
<p>有关层次模型的内容可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/modeling/hierarchical_models.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在这一部分里，我们会使用数据理论来描述在高通量数据分析中常用的方法。常规的思路就是构建一个两层的层次模型。一层用于描述样本/实验单元之间的变异，另外一层用于描述特征值之间的变异。这种分析方法类似于我们前面讲的棒球案例，即第一层用于描述不同运动员之间的变异，第二层用于描述一个运动员成功的随机性。我们这里𢪮的所有模型与方法都考虑了第一个变异水平，例如构建t检验的醋。第二个水平允许我们通过从所有的特征值里“借用(borrow)”信息用于对特征值进行统计推断，从而提供检验效能。</p>
<p>现在我们来看一个在基因表达数据中使用最为广泛的统计学方法。这个统计学方就是由<code>limma</code>Bioconductor包提供的。这个方法已经被用于改造分析RNAseq数据，例如edgeR<a href="https://www.ncbi.nlm.nih.gov/pubmed/19910308" target="_blank" rel="external">《edgeR: a Bioconductor package for differential expression analysis of digital gene expression data.》</a>和DESeq2<a href="https://www.ncbi.nlm.nih.gov/pubmed/25516281" target="_blank" rel="external">《Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2》</a>。这两个包提供了t检验的替代方案，它们通过对方差进行建模从而极大地改善了统计功效。然而在棒球案例中，我们是对均值进行了建模，这是与那两种方法建模的不同之处。对方差建模需要更深的数学知识，但是思路是一样的。我们以一个案例来说明一下这种方法。</p>
<p>下图是一个火山图，它显示了使用t检验来分析数据的结果，显示了效应大小(effect size)和p值，其中使用了6个重复样本（对照组3个，干预组3个），其中有16个基因是人为设定的差异基因。只有这16个基因的备选假设为真，在火山图上它们标记为蓝色，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(SpikeInSubset) <span class="comment">##Available from Bioconductor</span></div><div class="line">data(rma95)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">fac &lt;- factor(rep(<span class="number">1</span>:<span class="number">2</span>,each=<span class="number">3</span>))</div><div class="line">tt &lt;- rowttests(exprs(rma95),fac)</div><div class="line">smallp &lt;- with(tt, p.value &lt; <span class="number">.01</span>)</div><div class="line">spike &lt;- rownames(rma95) %<span class="keyword">in</span>% colnames(pData(rma95))</div><div class="line">cols &lt;- ifelse(spike,<span class="string">"dodgerblue"</span>,ifelse(smallp,<span class="string">"red"</span>,<span class="string">"black"</span>))</div><div class="line">with(tt, plot(-dm, -log10(p.value), cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">xlim=c(-<span class="number">1</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">4.5</span>),</div><div class="line">xlab=<span class="string">"difference in means"</span>,</div><div class="line">col=cols))</div><div class="line">abline(h=<span class="number">2</span>,v=c(-<span class="number">.2</span>,<span class="number">.2</span>), lty=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908225643.jpeg">

</div>
<p>上图是使用t检验计算了两组样本的差异基因，其中Spiked-in基因使用蓝色。剩下的基因中，p小于的用红色标明。</p>
<p>在上面的火山图中，我们将y轴的截止值(cut-off)设为了4.5，但是有一个蓝点的p值小于<span class="math inline">\(10^{-6}\)</span>。但是，从这张图中我们会发现2点怪异之处。第一，按照5% FDR的标准，只有一个阳性结果是显著的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum( p.adjust(tt$p.value,method = <span class="string">"BH"</span>)[spike] &lt; <span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum( p.adjust(tt$p.value,method = <span class="string">"BH"</span>)[spike] &lt; <span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这个结果与每组3个样本的低统计效能有关。第二，如果我们忽略掉统计推断，仅仅是基于t检验统计量的大小简单地对这些基因进行排序，那么我们会在任何大于1的排序列表中得到很多假阳性结果。例如，按照t检验统计量进行排序，位列前10名的基因中，有6个都是假阳性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table( top50=rank(tt$p.value)&lt;= <span class="number">10</span>, spike) <span class="comment">#t-stat and p-val rank is the same</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table( top50=rank(tt$p.value)&lt;= <span class="number">10</span>, spike) <span class="comment">#t-stat and p-val rank is the same</span></div><div class="line">       spike</div><div class="line">top50   <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line">  <span class="literal">FALSE</span> <span class="number">12604</span>    <span class="number">12</span></div><div class="line">  <span class="literal">TRUE</span>      <span class="number">6</span>     <span class="number">4</span></div></pre></td></tr></table></figure>
<p>在火山图中，我们注意到，大多数基因的效能大小都非常小，这说明，估计的标准误非常小，我们可以通过画图的手段来看一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tt$s &lt;- apply(exprs(rma95), <span class="number">1</span>, <span class="keyword">function</span>(row)</div><div class="line">  sqrt(<span class="number">.5</span> * (var(row[<span class="number">1</span>:<span class="number">3</span>]) + var(row[<span class="number">4</span>:<span class="number">6</span>]) ) ) )</div><div class="line">with(tt, plot(s, -log10(p.value), cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">              log=<span class="string">"x"</span>,xlab=<span class="string">"estimate of standard deviation"</span>,</div><div class="line">              col=cols))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908230650.jpeg">

</div>
<p>在这里我们就可以看到层次模型的用处了。如果我们假设这些变异的分布在所有基因中，然后我们通过分布来“调整”那些“太小”估计值，就可以改善我们的计算结果。在本书的前面部分中，我们提到F分布与观测到的方差分布近似，即： <span class="math display">\[
s^2 \sim s_0^2 F_{d,d_0}
\]</span> 因为我们有数千个数据点，我们实际上可以检验一下这个假设，并且估计出参数<span class="math inline">\(s_{0}\)</span>和<span class="math inline">\(d_{0}\)</span>。这种估计方法指的就是经验贝叶斯统计，因为我们使用现有的数据（经验）就可以构建先验分布（贝叶斯方法）。</p>
<p>现在我们将前面的棒球案例应用到标准误的估计中。像以前一样，我们已经有了每个基因的观测值<span class="math inline">\(s_{g}\)</span>，这是一个采样分布，用它来作为先验分布。我们因此可以计算出方差<span class="math inline">\(\sigma_{g}^2\)</span>的后来又做分布，并且获得一个后验均值，细节可以参考文献<a href="https://www.ncbi.nlm.nih.gov/pubmed/16646809" target="_blank" rel="external">《Linear models and empirical bayes methods for assessing differential expression in microarray experiments.》</a>，均值如下所示： <span class="math display">\[
\mathrm{E}\left[\sigma_{g}^{2} | s_{g}\right]=\frac{d_{0} s_{0}^{2}+d s_{g}^{2}}{d_{0}+d}
\]</span> 与棒球案例一样，后验均值会降低我们观测到的方差<span class="math inline">\(s_{g}^2\)</span>偏向于全局方差<span class="math inline">\(s_{0}^2\)</span>，其权重取决于样本大小，以及含有自由度<span class="math inline">\(d\)</span>的样本数目，在这个案例中，就是取决于通过<span class="math inline">\(d_{0}\)</span>的先验分布形状。（原文：AAs in the baseball example, the posterior mean <em>shrinks</em> the observed variance <span class="math inline">\(s_g^2\)</span> towards the global variance <span class="math inline">\(s_0^2\)</span> and the weights depend on the sample size through the degrees of freedom <span class="math inline">\(d\)</span> and, in this case, the shape of the prior distribution through <span class="math inline">\(d_0\)</span>. ）</p>
<p>在上面的图形中，我们可以看到40个基因的方差估计是如何缩小(shrink)的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">fit &lt;- lmFit(rma95, model.matrix(~ fac))</div><div class="line">ebfit &lt;- ebayes(fit)</div><div class="line">n &lt;- <span class="number">40</span></div><div class="line">qs &lt;- seq(from=<span class="number">0</span>,to=<span class="number">.2</span>,length=n)</div><div class="line">idx &lt;- sapply(seq_len(n),<span class="keyword">function</span>(i) which(as.integer(cut(tt$s^<span class="number">2</span>,qs)) == i)[<span class="number">1</span>])</div><div class="line">idx &lt;- idx[!is.na(idx)]</div><div class="line">par(mar=c(<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">plot(<span class="number">1</span>,<span class="number">1</span>,xlim=c(<span class="number">0</span>,<span class="number">.21</span>),ylim=c(<span class="number">0</span>,<span class="number">1</span>),type=<span class="string">"n"</span>,</div><div class="line">     xlab=<span class="string">"variance estimates"</span>,ylab=<span class="string">""</span>,yaxt=<span class="string">"n"</span>)</div><div class="line">axis(<span class="number">2</span>,at=c(<span class="number">.1</span>,<span class="number">.9</span>),c(<span class="string">"before"</span>,<span class="string">"after"</span>),las=<span class="number">2</span>)</div><div class="line">segments((tt$s^<span class="number">2</span>)[idx],rep(<span class="number">.1</span>,n),</div><div class="line">         ebfit$s2.post[idx],rep(<span class="number">.9</span>,n))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908232355.jpeg">

</div>
<p>上图显示的就是估计值如何向先验期望缩小的，40个基因包括了我们选择值的整个范围。</p>
<p>这种调整的一个重要方面就是使那些样本标准差接近于0的基因的样本偏差不再接近于0（向<span class="math inline">\(s_{0}\)</span>收缩）。我们现在就创建一个t检验的统计模型，用于替代使用这个后验均值或“收缩“(shrunken)后的方差估计值。我们称这种t检验模型为适度t检验（moderated t-test）。当我们使用适应t检验后从火山图上就能明显地看到其改进之处：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">fit &lt;- lmFit(rma95, model.matrix(~ fac))</div><div class="line">ebfit &lt;- ebayes(fit)</div><div class="line">limmares &lt;- data.frame(dm=coef(fit)[,<span class="string">"fac2"</span>], p.value=ebfit$p.value[,<span class="string">"fac2"</span>])</div><div class="line">with(limmares, plot(dm, -log10(p.value),cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">                    col=cols,xlab=<span class="string">"difference in means"</span>,</div><div class="line">                    xlim=c(-<span class="number">1</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">5</span>)))</div><div class="line">abline(h=<span class="number">2</span>,v=c(-<span class="number">.2</span>,<span class="number">.2</span>), lty=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908233029.jpeg">

</div>
<p>这个火山图显示的就是使用适度t检验比较两组的差异基因结果。Spiked-in基因用蓝色进行了标注。剩下的基因中，p值小于的用红色标注。</p>
<p>现在我们来看一下排列前10的基因中假阳性的数目，这个数目就降为了2，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table( top50=rank(limmares$p.value)&lt;= <span class="number">10</span>, spike)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table( top50=rank(limmares$p.value)&lt;= <span class="number">10</span>, spike)</div><div class="line">       spike</div><div class="line">top50   <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line">  <span class="literal">FALSE</span> <span class="number">12608</span>     <span class="number">8</span></div><div class="line">  <span class="literal">TRUE</span>      <span class="number">2</span>     <span class="number">8</span></div></pre></td></tr></table></figure>
<h2 id="练习-1">练习</h2>
<p>P315</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/18/DAL/DALS018_StatisticalModels1_binomal_Possion_MLE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/DAL/DALS018_StatisticalModels1_binomal_Possion_MLE/" itemprop="url">DALS018-统计模型1-二项分布与泊松分布，MLE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T12:00:00+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,870
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第7章统计模型的第1小节，这一部分的主要内容涉及高维数据统计的一些原理，例如二项分布，泊松分布，最大似然估计等。</p>
<p>相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/modeling/modeling.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>当我们在文献中看到p值的时候，它意味着使用某种概率分布来对零假设进行量化。很多时候我们很容易地就能找到使用哪种分布。例如，在女士品茶这个案例中，我们就能使用简单的概率计睡来确定零分布。文献中的大多数p值都是基于线性模型的样本均值或最小二乘估计来进行计算的，并利用CLT近似地救出它们的零分布。</p>
<p>CLT有着理论支持，它能保证这种近似是正确的。但是，我们无法一直使用这种近似法，例如当我们的样本太少时。以前面部分中，我们提到了，当总体数据近似服从正态分布时，样本的平均近似服从t分布。但是这种假设没有理论上的支持。在这一部分里，我们就会对这种情况进行建模。在研究身高时，我们从经验中就知道，这是一个非常好的模型。</p>
<p>但是，这并不意味着我们收集的每个数据集都服从正态分布。我们常见的一些例子，例如掷硬币，中彩票的人数，美国的收入。正态分布不是建模过程中的唯一参数分布。在这一部分里，我们会描述一些最广泛使用的参数分布以及它们在生命科学研究中的作用。我们还会介绍贝叶斯统计相关的知识，以及给出使用分层模型的使用案例。</p>
<h2 id="二项分布">二项分布</h2>
<p>在<span class="math inline">\(N\)</span>次实验中，成功<span class="math inline">\(S=k\)</span>次的概率，公式如下所示： <span class="math display">\[
\mbox{Pr}(S=k) = {N \choose k}p^k (1-p)^{N-k}
\]</span> 其中<span class="math inline">\(p\)</span>是成功的概率，二项分布的一个最有名案例就是掷硬币，当我们掷<span class="math inline">\(N\)</span>次硬币，有<span class="math inline">\(S\)</span>次是正面朝上的概率，在这个案例中，<span class="math inline">\(p=0.5\)</span>。</p>
<p><span class="math inline">\(S/N\)</span>是独立随机变量的均值，因此CLT告诉我们，当<span class="math inline">\(N\)</span>足够大时，<span class="math inline">\(S\)</span>近似地服从正态分布。这种分布在生命科学研究中应用很广，最近，此分布在NGS检测variant callers和表型(genotyper)应用很广，它的一个特殊分布则是泊松分布(poisson distribution)（二顶分布的极限是泊松分布）。</p>
<h2 id="泊松分布">泊松分布</h2>
<p>由于买彩票的结果只有两个，中彩票与不中彩票，因此，那些赢得彩票的人数从理论上服从二项分布（我们是假设每个人只能买一张彩票）的。试验次数<span class="math inline">\(N\)</span>是买彩票的人数，这个数字通常非常大。但是，赢得彩票的的人数通常是0到3之间，这就表明，赢得彩票的人数是不服从正态分布的。那么，为什么CLT在这种情况下不成立呢？从数学上可以对此进行解释，但是直觉又告诉我们，如果成功的总和是如此接近，并且大于1，这种分布就不可能是正态分布，这里我们进行一个快速的模拟：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p=<span class="number">10</span>^-<span class="number">7</span> <span class="comment">##1 in 10,000,0000 chances of winning</span></div><div class="line">N=<span class="number">5</span>*<span class="number">10</span>^<span class="number">6</span> <span class="comment">##5,000,000 tickets bought</span></div><div class="line">winners=rbinom(<span class="number">1000</span>,N,p) <span class="comment">##1000 is the number of different lotto draws</span></div><div class="line">tab=table(winners)</div><div class="line">plot(tab)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190905223653.jpeg">

</div>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; prop.table(tab)</div><div class="line">winners</div><div class="line">    <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span> </div><div class="line"><span class="number">0.617</span> <span class="number">0.294</span> <span class="number">0.080</span> <span class="number">0.009</span></div></pre></td></tr></table></figure>
<p>达种情况下，<span class="math inline">\(N\)</span>会非常大，<span class="math inline">\(p\)</span>会非常小，因此我们可以计算出<span class="math inline">\(N \times p\)</span>（此时我们之为<span class="math inline">\(\lambda\)</span>）的值，例如位于0到10之间，而<span class="math inline">\(S\)</span>此时就服从泊松分布，其简单的公式如下所示： <span class="math display">\[
\mbox{Pr}(S=k)=\frac{\lambda^k \exp{-\lambda}}{k!}
\]</span></p>
<p>RNA-seq分析中常常用到泊松分布。因为我们对数千个分子进行采样，并且多数基因仅仅代表了所有基因中一小部分，因此在RNA-seq分析中使用泊松分布比较合适。</p>
<p>我们知道了泊松分布后，它对我们有什么作用？其中一个方面就是这种分布可以为我们提供实际分析过程中关于统计属性的总结信息。例如我们只从患者组和对照组中各取一个样本进行RNA-seq实验并研究基因的倍数变化。此时，在零假设成立的前提下（也就是这两个样本没有差异），利用泊松分布，我们可以计算出，统计学上的统计变异取决于基因的总丰度。我们可以从数学上来展示一下这个过程，下面是模拟这个过程：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">N=<span class="number">10000</span><span class="comment">##number of genes</span></div><div class="line">lambdas=<span class="number">2</span>^seq(<span class="number">1</span>,<span class="number">16</span>,len=N) <span class="comment">##these are the true abundances of genes</span></div><div class="line">y=rpois(N,lambdas)<span class="comment">##note that the null hypothesis is true for all genes</span></div><div class="line">x=rpois(N,lambdas)</div><div class="line">ind=which(y&gt;<span class="number">0</span> &amp; x&gt;<span class="number">0</span>)<span class="comment">##make sure no 0s due to ratio and log</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">splot(log2(lambdas),log2(y/x),subset=ind)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906202636.jpeg">

</div>
<p>对于低较的<code>lambda</code>的值，存在着更多的变异，如果我们计算出了大于2倍或更高倍数的基因，那些对于低丰度的基因来说，假阳性率也会变大。</p>
<h3 id="ngs与poisson分布">NGS与Poisson分布</h3>
<p>在这一部分里，我们还是要使用公共数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BiocManager::install("parathyroidSE")</span></div><div class="line"><span class="keyword">library</span>(parathyroidSE) <span class="comment">##available from Bioconductor</span></div><div class="line">data(parathyroidGenesSE)</div><div class="line">se &lt;- parathyroidGenesSE</div></pre></td></tr></table></figure>
<p>上述的这个数据包含在<code>SummarizedExperiment</code>对象中，在此不再赘述，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; class(parathyroidGenesSE)</div><div class="line">[<span class="number">1</span>] <span class="string">"RangedSummarizedExperiment"</span></div><div class="line">attr(,<span class="string">"package"</span>)</div><div class="line">[<span class="number">1</span>] <span class="string">"SummarizedExperiment"</span></div></pre></td></tr></table></figure>
<p>我们只需要知道它包含一个数据矩阵，其中每一行都是基因组特征（可以理解为基因），每列都是一个样本。我们可以使用<code>assay()</code>函数提取这个矩阵。对于这个数据集，数据矩阵中每个单元格的数值对应了一个特定样本的一个特定基因的reads数。因此，我们可以绘制出前面类似的图形，从而表明利用实验数据构建的模型的预测行为，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x &lt;- assay(se)[,<span class="number">23</span>]</div><div class="line">y &lt;- assay(se)[,<span class="number">24</span>]</div><div class="line">ind=which(y&gt;<span class="number">0</span> &amp; x&gt;<span class="number">0</span>)<span class="comment">##make sure no 0s due to ratio and log</span></div><div class="line">splot((log2(x)+log2(y))/<span class="number">2</span>,log(x/y),subset=ind)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906203804.jpeg">

</div>
<p>如果我们计算出4个个体的标准差，它要比利用泊松模型预测的要高得多。假设大多数基因在不同的个体之间的表达不同，那么，如果泊松模型适用于此情况，那么此图中应该存在着线性关系：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(matrixStats)</div><div class="line">vars=rowVars(assay(se)[,c(<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">21</span>)]) <span class="comment">##we now these four are 4</span></div><div class="line">means=rowMeans(assay(se)[,c(<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">21</span>)]) <span class="comment">##different individulsa</span></div><div class="line">splot(means,vars,log=<span class="string">"xy"</span>,subset=which(means&gt;<span class="number">0</span>&amp;vars&gt;<span class="number">0</span>)) <span class="comment">##plot a subset of data</span></div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="number">2</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906204226.jpeg">

</div>
<p>上面图中的变异包括生物变异，但是泊松分布则无法对此进行建模。此时，我们需要另外一种分布，即负二项分布（negative binomial distribution)，这种分布整合了服从泊松分布的采样变异(sampling variability)和生物变异(biological variability)，它更适合对这种情况进行建模。负二项分布有两个参数，在处理计数数据(count data)方面有更大的灵活性。有关RNA-seq与负二项分布的内容可以参考这篇文献<a href="https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106" target="_blank" rel="external">《Differential expression analysis for sequence count data》</a>。而泊松分布只是负二项分布的一个特例。</p>
<h2 id="最大似然估计">最大似然估计</h2>
<p>为了说明最大似然估计(Maximum Likelihood Estimation, MLE)的概念，我们使用一个相对简单的数据集来进行演示，这个数据集包含HMCV（人巨细胞病毒，human cytomegalovirus）基因组的回文位置(palindrome location)信息。我们从HMCV基因组每4kb个间隔中读取回文序列的数目，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">datadir=<span class="string">"http://www.biostat.jhsph.edu/bstcourse/bio751/data"</span></div><div class="line">x=read.csv(file.path(datadir,<span class="string">"hcmv.csv"</span>))[,<span class="number">2</span>]</div><div class="line">breaks=seq(<span class="number">0</span>,<span class="number">4000</span>*round(max(x)/<span class="number">4000</span>),<span class="number">4000</span>)</div><div class="line">tmp=cut(x,breaks)</div><div class="line">counts=table(tmp)</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(counts)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190906232857.jpeg">

</div>
<p>上图中的计数数据似乎服从泊松分布，但是，<span class="math inline">\(\lambda\)</span>是多少呢？常见的估计<span class="math inline">\(\lambda\)</span>的方法是最大似然估计(maximum likelihoood estimation)。最了找到最大的MLE，我们要注意这些数据是独立的，我们所观察到这些数据的概率可以用以下公式来表示： <span class="math display">\[
\Pr(X_1=k_1,\dots,X_n=k_n;\lambda) = \prod_{i=1}^n \lambda^{k_i} / k_i! \exp ( -\lambda)
\]</span> 当下面这个公式取最大值时候，MLE就等于<span class="math inline">\(\lambda\)</span>： <span class="math display">\[
\mbox{L}(\lambda; X_1=k_1,\dots,X_n=k_1)=\exp\left\{\sum_{i=1}^n \log \Pr(X_i=k_i;\lambda)\right\}
\]</span> 在实际计算过程中我们通常使用log转换后似然值(log-likehood)。下面我们使用一些代码来计算一下任意的<span class="math inline">\(\lambda\)</span>下的log-likehood，并且我们使用函数<code>optimized()</code>来计睡一下能够值得这个函数值最大的时候的<span class="math inline">\(\lambda\)</span>，最后我们绘制出log-likehood的曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">l&lt;-<span class="keyword">function</span>(lambda) sum(dpois(counts,lambda,log=<span class="literal">TRUE</span>))</div><div class="line">lambdas&lt;-seq(<span class="number">3</span>,<span class="number">7</span>,len=<span class="number">100</span>)</div><div class="line">ls &lt;- exp(sapply(lambdas,l))</div><div class="line">plot(lambdas,ls,type=<span class="string">"l"</span>)</div><div class="line">mle=optimize(l,c(<span class="number">0</span>,<span class="number">10</span>),maximum=<span class="literal">TRUE</span>)</div><div class="line">abline(v=mle$maximum)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907145959.jpeg">

</div>
<p>如果进行一些微积分计算，就会发现计算MLE其实非常简单，就是计算其均值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print( c(mle$maximum, mean(counts) ) )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print( c(mle$maximum, mean(counts) ) )</div><div class="line">[<span class="number">1</span>] <span class="number">5.157894</span> <span class="number">5.157895</span></div></pre></td></tr></table></figure>
<p>我们会注意到，观察到的计数数据与通过泊松分布预测的计算数据非常吻合：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">theoretical&lt;-qpois((seq(<span class="number">0</span>,<span class="number">99</span>)+<span class="number">0.5</span>)/<span class="number">100</span>,mean(counts))</div><div class="line">qqplot(theoretical,counts)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907155849.jpeg">

</div>
<p>因此，我们可以使用泊松分布来计算回文数据，其中<span class="math inline">\(\lambda = 5.16\)</span>。</p>
<h2 id="正连续值的分布">正连续值的分布</h2>
<p>不同的基因在生物学重复中的变化不同。在后面我们会介绍次聚类模型(hierarchical model)，这是在分析基因组学数学中最有影响力的统计学方法之一。该方法以能够极大地改善了分析差异基因的初级方法。它是通过模拟基因变异的分布来进行建模的。在这里我们会介绍这种方法的参数模型。</p>
<p>我们想模拟一下基因特异性标准误(gene-specific standard erros)。这些分布是正态分布吗？这里我们需要记住，我们现在模拟的是总体的标准误，因此CLT在此种情况下并不适用，即使我们我们拥有数几千个基因。</p>
<p>下面就是案例，在这个案例中，我们会使用一个实验数据，这个数据中包含了小鼠基因表达的技术重复和生物学重复，我们会计算出技术重复和生物学重复的基因特异性样本标准误：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(Biobase) <span class="comment">##available from Bioconductor</span></div><div class="line"><span class="comment"># install_github("genomicsclass/maPooling")</span></div><div class="line"><span class="keyword">library</span>(maPooling) <span class="comment">##available from course github repo</span></div><div class="line">data(maPooling)</div><div class="line">pd=pData(maPooling)</div><div class="line"><span class="comment">##determin which samples are bio reps and which are tech reps</span></div><div class="line">strain=factor(as.numeric(grepl(<span class="string">"b"</span>,rownames(pd))))</div><div class="line">pooled=which(rowSums(pd)==<span class="number">12</span> &amp; strain==<span class="number">1</span>)</div><div class="line">techreps=exprs(maPooling[,pooled])</div><div class="line">individuals=which(rowSums(pd)==<span class="number">1</span> &amp; strain==<span class="number">1</span>)</div><div class="line"><span class="comment">##remove replicates</span></div><div class="line">individuals=individuals[-grep(<span class="string">"tr"</span>,names(individuals))]</div><div class="line">bioreps=exprs(maPooling)[,individuals]</div><div class="line"><span class="comment">###now compute the gene specific standard deviations</span></div><div class="line"><span class="keyword">library</span>(matrixStats)</div><div class="line">techsds=rowSds(techreps)</div><div class="line">biosds=rowSds(bioreps)</div></pre></td></tr></table></figure>
<p>下面提研究样本的标准差(sample standard deviation)：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###now plot</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">shist(biosds,unit=<span class="number">0.1</span>,col=<span class="number">1</span>,xlim=c(<span class="number">0</span>,<span class="number">1.5</span>))</div><div class="line">shist(techsds,unit=<span class="number">0.1</span>,col=<span class="number">2</span>,add=<span class="literal">TRUE</span>)</div><div class="line">legend(<span class="string">"topright"</span>,c(<span class="string">"Biological"</span>,<span class="string">"Technical"</span>), col=c(<span class="number">1</span>,<span class="number">2</span>),lty=c(<span class="number">1</span>,<span class="number">1</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907172043.jpeg">

</div>
<p>从上面的图形中我们可以发现，生物学变异(biological variability)远远大于技术变异(technical variability)。这就为我们提供了一个证据，即基因确实具有基因特异性生物学变异。如果我们想要模拟这种变异，我们首先要注意到，这些变异不服从正态分布，因为上面的曲线明显出现了拖尾现象。此外，由于SD为正数，因此上面的分布也存在着一定的限制。现在我们使用qq图来看一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qqnorm(biosds)</div><div class="line">qqline(biosds)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907172353.jpeg">

</div>
<p>一些参数分布可以处理这些情况（例如严格正向右拖尾分布，strictly positive and heavy right tails）。其中比较典型的分布就是gamma分布与F分布，gamma分布的密度函数为： <span class="math display">\[
f(x;\alpha,\beta)=\frac{\beta^\alpha x^{\alpha-1}\exp{-\beta x}}{\Gamma(\alpha)}
\]</span> 这个分布有2个参数，分别是<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>，它们间接控制了曲线的位置(location)与缩放(scale)。它们也控制着曲线的形状，有关这些分布的知识可以参考<a href="https://www.stat.berkeley.edu/~rice/Book3ed/index.html" target="_blank" rel="external">《Mathematical Statistics and Data Analysis》</a>这本书。</p>
<p>gamma分布的两个特例是卡方分布与指数分布，我们前面了解到了可以使用卡方分布来计算二联表。对于卡方分布来说，我们的参数是<span class="math inline">\(\alpha=\nu/2\)</span>，<span class="math inline">\(\beta=2\)</span>，其中<span class="math inline">\(\nu\)</span>表示自由度。对于指数分布来说，<span class="math inline">\(\alpha=1\)</span>，<span class="math inline">\(\beta=\lambda\)</span>。</p>
<p>F分布在ANOVA中使用，它也是一个正向分布，并且存在着严格的右拖尾曲线，它的2个参数影响其曲线形状，，F分布的密度函数为： <span class="math display">\[
f(x,d_1,d_2)=\frac{1}{B\left( \frac{d_1}{2},\frac{d_2}{2}\right)}
  \left(\frac{d_1}{d_2}\right)^{\frac{d_1}{2}}  
  x^{\frac{d_1}{2}-1}\left(1+\frac{d1}{d2}x\right)^{-\frac{d_1+d_2}{2}}
\]</span> 这个函数中含有<span class="math inline">\(B\)</span>函数（即<span class="math inline">\(\beta\)</span>函数），还有2个自由度，即<span class="math inline">\(d_{1}\)</span>和<span class="math inline">\(d_{2}\)</span>。</p>
<h3 id="模拟变异">模拟变异</h3>
<p>在后面部分中，我们会介绍用于改善变异估计的层级模型(hierarchical model)。在这些案例中，从数学上很方便地能模拟出<span class="math inline">\(\sigma^2\)</span>的分布，关于层级模型的内容可以参考<a href="https://www.ncbi.nlm.nih.gov/pubmed/16646809" target="_blank" rel="external">《Linear models and empirical bayes methods for assessing differential expression in microarray experiments.》</a>这篇文献，此文献指出，对基因的标准差进行采样服从校正后的F统计： <span class="math display">\[
s^2 \sim s_0^2 F_{d,d_0}
\]</span> 其中<span class="math inline">\(d\)</span>表示了计算中<span class="math inline">\(s^2\)</span>的自由度。例如，当我们比较两组样本时，每组3个样本，那么自由度就是4（文中后面提到了<code>This leaves two free parameters to adjust to the data</code>，直译就是<code>剩下的2个自由参数用于调整数据</code>，不太理解）。这里的<span class="math inline">\(d\)</span>用于控制位置(location)，<span class="math inline">\(s_{0}\)</span>用于控制缩放(scale)。下面的代码是F分布的一些案例，我们绘制出了相应的图形，并且标注上了样本的方差：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">sds=seq(<span class="number">0</span>,<span class="number">2</span>,len=<span class="number">100</span>)</div><div class="line"><span class="keyword">for</span>(d <span class="keyword">in</span> c(<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>))&#123;</div><div class="line">  <span class="keyword">for</span>(s0 <span class="keyword">in</span> c(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>))&#123;</div><div class="line">    tmp=hist(biosds,main=paste(<span class="string">"s_0 ="</span>,s0,<span class="string">"d ="</span>,d),xlab=<span class="string">"sd"</span>,ylab=<span class="string">"density"</span>,freq = <span class="literal">FALSE</span>,nc=<span class="number">100</span>,xlim=c(<span class="number">0</span>,<span class="number">1</span>))</div><div class="line">    dd=df(sds^<span class="number">2</span>/s0^<span class="number">2</span>,<span class="number">11</span>,d)</div><div class="line">    <span class="comment">##multiply by normalizing constant to assure same range on plot</span></div><div class="line">    k=sum(tmp$density)/sum(dd)</div><div class="line">    lines(sds,dd*k,type=<span class="string">"l"</span>,col=<span class="number">2</span>,lwd=<span class="number">2</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907184007.jpeg">

</div>
<p>从上面的图形我们要找到哪个图形的<span class="math inline">\(s_{0}\)</span>与<span class="math inline">\(d\)</span>最能拟合我们的数据？这是一个比较麻烦的过程，因为MLE并不会计算这个特殊的分布（具体可以参考Wmyth(2004)）。Bioconductor上的<code>limma</code>包提供的估计这些参数的函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">estimates=fitFDist(biosds^<span class="number">2</span>,<span class="number">11</span>)</div><div class="line">theoretical&lt;- sqrt(qf((seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span>, <span class="number">11</span>, estimates$df2)*estimates$scale)</div><div class="line">observed &lt;- biosds</div></pre></td></tr></table></figure>
<p>拟合模型确实提供了一个合理的估计，从qq图和直方图就能看出来：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">qqplot(theoretical,observed)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">tmp=hist(biosds,main=paste(<span class="string">"s_0 ="</span>, signif(estimates[[<span class="number">1</span>]],<span class="number">2</span>), <span class="string">"d ="</span>, signif(estimates[[<span class="number">2</span>]],<span class="number">2</span>)), xlab=<span class="string">"sd"</span>, ylab=<span class="string">"density"</span>, freq=<span class="literal">FALSE</span>, nc=<span class="number">100</span>, xlim=c(<span class="number">0</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">9</span>))</div><div class="line">dd=df(sds^<span class="number">2</span>/estimates$scale,<span class="number">11</span>,estimates$df2)</div><div class="line">k=sum(tmp$density)/sum(dd) <span class="comment">##a normalizing constant to assure same area in plot</span></div><div class="line">lines(sds, dd*k, type=<span class="string">"l"</span>, col=<span class="number">2</span>, lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190907184617.jpeg">

</div>
<h2 id="练习">练习</h2>
<p>P297</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/17/DAL/DALS017_InferenceForHighDimensionalData2_Principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/DAL/DALS017_InferenceForHighDimensionalData2_Principle/" itemprop="url">DALS017-高维数据推断2-统计原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T12:00:00+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,658
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第6章线性模型的第2小节，这一部分的主要内容涉及高维数据统计的一些原理，相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/advinference/multiple_testing.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="高维数据的p值">高维数据的p值</h2>
<p>在前面我们了解了，当我们在分析高维数据时，p值就不再是一个很好的统计指标了。这是因为，我们同一次检测了许多特征值(feature)。这种检测手段被称为多重比较( multiple comparison)，或多重检测(multiple testing)，或多重性问题(multiplicity)。在此情况下，p值就不再适用。另外，当我们同时检测多个假设问题时，仅仅基于一个小p值的阈值，例如0.01，这就很容易导假阳性。针对这种情况，我们需要定义一个新的术语来研究高通量数据。</p>
<p>为了处理多重比较的问题，我们广泛使用的方法就是定义一个程序(procedure，也可以说是一种算法，也可以翻译为<code>校正</code>等等，总之，表达的是一个意思)，然后用它来估计或控制(control)计算过程中的错误率(rate error)。我们这里所说的<code>控制(control)</code>的意思是说，我们会采用这个程序来保证错误率(error rate)低于某个提前设定的值。通过参数或截止值(cutoff)来进行设定的这个程序通常比较灵活，它会让我们能够控制特异性(specificity)和灵敏度(sensitivity)，这种程序的一个典型功能如下所示：</p>
<ul>
<li>计算每个基因的p值；</li>
<li>计算出p值小于<span class="math inline">\(\alpha\)</span>的所有显著性基因。</li>
</ul>
<p>这里需要注意的是，当我们改变<span class="math inline">\(\alpha\)</span>值时，会调整相应的特异性(specificity)和灵敏度(sensitivity)。</p>
<p>接着我们来定义错误率(error rate)，它会让我们对统计过程进行估计和控制。</p>
<h2 id="错误率">错误率</h2>
<p>在这一部分中，我们会了解到I类错误与II类错误，这两类错误分别代表假阳性(false positives)与假阴性(false negatives)。通常，特异性(specificity)与I类错误有关，灵敏性(sensitivity)与II类错误有关。</p>
<p>在一次高通量实验里，我们会犯第I类错误和第II类错误。我们参考了Benjamini-Hochberg的论文，做了以下表格，总结了这些错误，如下所示：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Called significant（真）</th>
<th>Not called significant（假）</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Null True</td>
<td><span class="math inline">\(V\)</span></td>
<td><span class="math inline">\(m_0-V\)</span></td>
<td><span class="math inline">\(m_0\)</span></td>
</tr>
<tr class="even">
<td>Alternative True</td>
<td><span class="math inline">\(S\)</span></td>
<td><span class="math inline">\(m_1-S\)</span></td>
<td><span class="math inline">\(m_1\)</span></td>
</tr>
<tr class="odd">
<td>True</td>
<td><span class="math inline">\(R\)</span></td>
<td><span class="math inline">\(m-R\)</span></td>
<td><span class="math inline">\(m\)</span></td>
</tr>
</tbody>
</table>
<p>为了说明这个表格中的内容，我们来打个比方，假设我们检测了10000个基因，这就意味着我们需要做检测的次数为<span class="math inline">\(m=10000\)</span>。</p>
<p>那些零假设是真的基因数目（多数是我们不感兴趣的基因，零假设为真，也就是说这些基因在对照和实验组中都没有显著性差异）为<span class="math inline">\(m_{0}\)</span>，那些零假设为假的基因数目为<span class="math inline">\(m_{1}\)</span>，零假设为假，也就是说，替代假设(alternative hypothesis)为真（不一定严谨，反正就是说零假设为假）。通常来说，我们感兴趣的是尽可能地检测到那些替代假设为真的基因（真阳性），避免检测到那些零假设为真的基因（假阳性）。对于多数高通量实验来说，我们会假设<span class="math inline">\(m_{0}\)</span>远大于<span class="math inline">\(m_{1}\)</span>（这句话我的理解就是，在一次高通量实验中，没差异基因的数目<span class="math inline">\(m_{0}\)</span>要大于有差异基因的数目<span class="math inline">\(m_{1}\)</span>）。</p>
<p>例如我们检测了10000个基因，对其中约有100个基因感兴趣。这也就是说，<span class="math inline">\(m_1 \leq 100\)</span> 并且 <span class="math inline">\(m_0 \geq 19,900\)</span>。</p>
<p>在这一章中，我们指的特征值(feature)就是我们的检测值。在遗传学中，这些特征值可以是基因(genes)，转录本(transcripts)，结合位点(binding sites)，CpG岛和SNPs。</p>
<p>在上面的那个表格中，<span class="math inline">\(R\)</span>表示的是经过检测后，有显著性差异的特征值的数目总和，而<span class="math inline">\(m-R\)</span>则表示不显著的基因数目。表格中剩下的部分表示的是一些实际上未知的重要的量。</p>
<ul>
<li><span class="math inline">\(V\)</span>表示I类错误或假阳性。更具体地来说就是，<span class="math inline">\(V\)</span>表示了那些零假设为真的特征值的数目。</li>
<li><span class="math inline">\(S\)</span>表示的是真阳性的数目。具体地来说就是，<span class="math inline">\(S\)</span>表示替代假设为真的特征值的数目。</li>
</ul>
<p><span class="math inline">\(m_{1}-S\)</span>表示了II类错误或假阴性，<span class="math inline">\(m_{0}-V\)</span>表示真阴性。</p>
<p>这里需要牢记的是，当我们只做一次检测时，p就仅仅是当<span class="math inline">\(V=1\)</span>，<span class="math inline">\(m=m_{0}=1\)</span>时的概率。功效(power)就是当<span class="math inline">\(S=1\)</span>，<span class="math inline">\(m=m_{1}=1\)</span>时的概率。在这种非常简单的案例里，我们并不制作上面类似的表格，但是我们会说明一下，如何定义表格中的术语，从而帮助我们处理高维数据。</p>
<h2 id="数据案例">数据案例</h2>
<p>现在看一个案例。在这个案例中我们会使用小鼠数据进行Monte Carlo模拟，从而模拟一种情况，在这种情况里，我们会检测10000种对小鼠体重无影响的减肥饲料(fad diets)。这就是说，在零假设下，这些饲料对小鼠体重没影响为真，也就是说<span class="math inline">\(m=m_{0}=10000\)</span>，并且<span class="math inline">\(m_{1}=0\)</span>，现在我们先进行一个样本数目为12的计算，并且我们认为p值小于<span class="math inline">\(\alpha=0.05\)</span>显著，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">population = unlist( read.csv(<span class="string">"femaleControlsPopulation.csv"</span>) )</div><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">N &lt;- <span class="number">12</span></div><div class="line">m &lt;- <span class="number">10000</span></div><div class="line">pvals &lt;- replicate(m,&#123;</div><div class="line">  control = sample(population,N)</div><div class="line">  treatment = sample(population,N)</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div><div class="line">sum(pvals &lt; <span class="number">0.05</span>) <span class="comment">##This is R</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>) <span class="comment">##This is R</span></div><div class="line">[<span class="number">1</span>] <span class="number">462</span></div></pre></td></tr></table></figure>
<p>从结果我们可以看出，这个假阳性（462个）还是比较高的，这是要在多数分析中是要避免的。</p>
<p>下面我们来看一个更加复杂的代码，这段代码会进行人为设定10%的饮食有效，平均效应(average effect size)为<span class="math inline">\(\Delta=3\)</span>盎司（约85克）。仔细研究这段代码可以帮助我们理解上面的那个表格，现在我们先来定义这样的数据，其中10%有效：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">N &lt;- <span class="number">12</span></div><div class="line">m &lt;- <span class="number">10000</span></div><div class="line">p0 &lt;- <span class="number">0.90</span> <span class="comment">##10% of diets work, 90% don't</span></div><div class="line">m0 &lt;- m*p0</div><div class="line">m1 &lt;- m-m0</div><div class="line">nullHypothesis &lt;- c( rep(<span class="literal">TRUE</span>,m0), rep(<span class="literal">FALSE</span>,m1))</div><div class="line">delta &lt;- <span class="number">3</span></div></pre></td></tr></table></figure>
<p>现在我们做10000次模拟统计，每次都采用t检验，并记录下来：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">calls &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,N)</div><div class="line">  treatment &lt;- sample(population,N)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  ifelse( t.test(treatment,control)$p.value &lt; alpha,</div><div class="line">          <span class="string">"Called Significant"</span>,</div><div class="line">          <span class="string">"Not Called Significant"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>由于我们知道哪些是数据是有差异的（毕竟是自己人为生成的，保存在了<code>nullHypothesis</code>中)，我们现在计算一下上面的表格，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">null_hypothesis &lt;- factor( nullHypothesis, levels=c(<span class="string">"TRUE"</span>,<span class="string">"FALSE"</span>))</div><div class="line">table(null_hypothesis,calls)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; null_hypothesis &lt;- factor( nullHypothesis, levels=c(<span class="string">"TRUE"</span>,<span class="string">"FALSE"</span>))</div><div class="line">&gt; table(null_hypothesis,calls)</div><div class="line">               calls</div><div class="line">null_hypothesis Called Significant Not Called Significant</div><div class="line">          <span class="literal">TRUE</span>                 <span class="number">421</span>                   <span class="number">8579</span></div><div class="line">          <span class="literal">FALSE</span>                <span class="number">520</span>                    <span class="number">480</span></div></pre></td></tr></table></figure>
<p>结果中的第1列就是<span class="math inline">\(V\)</span>与<span class="math inline">\(S\)</span>，需要注意的是，<span class="math inline">\(V\)</span>与<span class="math inline">\(S\)</span>是随机变量，如果我们再次运行这段代码以，这些值就会改变，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">B &lt;- <span class="number">10</span> <span class="comment">##number of simulations</span></div><div class="line">VandS &lt;- replicate(B,&#123;</div><div class="line">  calls &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">    control &lt;- sample(population,N)</div><div class="line">    treatment &lt;- sample(population,N)</div><div class="line">    <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">    t.test(treatment,control)$p.val &lt; alpha</div><div class="line">  &#125;)</div><div class="line">  cat(<span class="string">"V ="</span>,sum(nullHypothesis &amp; calls), <span class="string">"S ="</span>,sum(!nullHypothesis &amp; calls),<span class="string">"\n"</span>)</div><div class="line">  c(sum(nullHypothesis &amp; calls),sum(!nullHypothesis &amp; calls))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">V = <span class="number">410</span> S = <span class="number">564</span> </div><div class="line">V = <span class="number">400</span> S = <span class="number">552</span> </div><div class="line">V = <span class="number">366</span> S = <span class="number">546</span> </div><div class="line">V = <span class="number">382</span> S = <span class="number">553</span> </div><div class="line">V = <span class="number">372</span> S = <span class="number">505</span> </div><div class="line">V = <span class="number">382</span> S = <span class="number">530</span> </div><div class="line">V = <span class="number">381</span> S = <span class="number">539</span> </div><div class="line">V = <span class="number">396</span> S = <span class="number">554</span> </div><div class="line">V = <span class="number">380</span> S = <span class="number">550</span> </div><div class="line">V = <span class="number">405</span> S = <span class="number">569</span></div></pre></td></tr></table></figure>
<p>针对这种情况，我们就定义了错误率(error rate)。例如，我们可以估计<span class="math inline">\(V\)</span>大于0的概率。它可以解释为，在10000次检验中，我们出现I类错误的概率。在上述模拟数据中，<span class="math inline">\(V\)</span>在每次模拟中都大于1，因此我们怀疑这个概率实际上就是1（这里的1就是“V大于0”这个事件的概率，换句话讲，就是，在这个检验中，必然会出现假阳性）。</p>
<p>当<span class="math inline">\(m=1\)</span>时，这个概率就等于p值。当我们进行多重检验模拟时，我们称之为多重比较谬误(Family Wide Error Rate,FWER)，它与我们广泛使用的一个检验方法有关，即Bonferroni校正( Bonferroni Correction)。</p>
<h2 id="bonferroni校正">Bonferroni校正</h2>
<p>现在我们了解一下FWER是如何运用的，在实际的分析中，我们会选择一个程序(procedure)来保证FWER小于某个提前设定好的阈值，例如0.05，通常情况下，就使用<span class="math inline">\(\alpha\)</span>来表示。</p>
<p>现在我们来描述一个这样的程序：拒绝所有p值小于0.01的假设。</p>
<p>为了说明这个目的，我们假设所有的检验都是独立的（在10000个饲料检验的实验里，这个假设是成立的；但是在一些遗传学实验里，这个假设有可能不成立，因为某些基因会共同发挥作用）。每次检验得到的p值我们用<span class="math inline">\(p_1,\dots,p_{10000}\)</span>表示。这些独立的随机变量如下所示： <span class="math display">\[
\begin{align*}
\mbox{Pr}(\mbox{at least one rejection}) &amp;= 1 -\mbox{Pr}(\mbox{no rejections}) \\
&amp;= 1 - \prod_{i=1}^{10000} \mbox{Pr}(p_i&gt;0.01) \\
&amp;= 1-0.99^{10000} \approx 1
\end{align*}
\]</span> 如果我们要模拟这个过程，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">B&lt;-<span class="number">10000</span></div><div class="line">minpval &lt;- replicate(B, min(runif(<span class="number">10000</span>,<span class="number">0</span>,<span class="number">1</span>))&lt;<span class="number">0.01</span>)</div><div class="line">mean(minpval&gt;=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(minpval&gt;=<span class="number">1</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div></pre></td></tr></table></figure>
<p>因此，我们计算出来的FWER是1，这并非我们想要的结果。如果我们想要它低于<span class="math inline">\(\alpha=0.05\)</span>，那么我们的统计就是失败的。</p>
<p>我们如何做才能使得一个错误出现的概率低于<span class="math inline">\(\alpha\)</span>呢，我们可以使用上面的公式推导一下，通过选择更严格的截止值(cutoff），之前的是0.01，从而将我们的错误降低至至少5%的水平，如下所示： <span class="math display">\[
\mbox{Pr}(\mbox{at least one rejection}) =  1-(1-k)^{10000}
\]</span> 解这个方程，我们就得到了 <span class="math inline">\(1-(1-k)^{10000}=0.01 \implies k = 1-0.99^{1/10000} \approx 1e-6\)</span></p>
<p>这就是我们给出的一个程序案例。这实际上就是Sikdak过程。尤其是，当我们定义一个说明，例如<code>拒绝所有p值小于 0.000005的零假设</code>。然后，我们知道了p值是一个随机变量，我们会使用统计理论来计算，如果我们遵循这个程序，平均会犯多少错误。更确切地讲就是，我们可以计算出这些错误的边界，也就是说，这些错误小于某些预定值的比例。</p>
<p>Sidak校正的一个问题是，这个校正假设所有的检验都是独立的。因此当这个假设时成立的，它只能控制FWER。百Bonferroini校正则更为通用，因为即使每个检测不独立，它也能控制FWER。。与Sidak校正一样，我们首先来看一下： <span class="math display">\[
FWER = \mbox{Pr}(V&gt;0) \leq \mbox{Pr}(V&gt;0 \mid \mbox{all nulls are true})
\]</span></p>
<p>现在使用前面表格的那种表示方法为： <span class="math display">\[
\mbox{Pr}(V&gt;0) \leq \mbox{Pr}(V&gt;0 \mid m_1=0)
\]</span> Bonferoni校正会设定<span class="math inline">\(k=\alpha/m\)</span>，因此可以写为如下形式： <span class="math display">\[
\begin{align*}
\mbox{Pr}(V&gt;0 \,\mid \, m_1=0) &amp;= \mbox{Pr}\left( \min_i \{p_i\} \leq \frac{\alpha}{m} \mid m_1=0 \right)\\
 &amp;\leq \sum_{i=1}^m \mbox{Pr}\left(p_i \leq \frac{\alpha}{m} \right)\\
 &amp;= m \frac{\alpha}{m}=\alpha
\end{align*}
\]</span> 将FWER控制在0.05水平是一种非常保守的方法，现在我们使用前面计算的p值来计算一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">pvals &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,N)</div><div class="line">  treatment &lt;- sample(population,N)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>只需要关于p值是否小于0.05/10000即可，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">2</span></div></pre></td></tr></table></figure>
<p>当使用了Bonferroni校正后，即使我们进行了10000次饮食实验，却只有发现2个假阳性的结果，Bonferroni是一种非常严格的校正。</p>
<h2 id="错误发现率fdr">错误发现率(FDR)</h2>
<p>在许多情况下，要求FWER是0.05没多大意义，因为它太严格了。例如，我们常见的做法就是先进行初步的小型实验来确定小数候选基因。这种做法被称为之发现驱动的实验或项目。我们也许会寻找一个未知的致病基因，而不仅仅是对候选基因进行采用更多的样本进行后续研究。如果我们开发一个程序，例如一个10个基因列表，从中发现1到2个为重要的基因，这个实验就算非常成功。小样本实验，实现<span class="math inline">\(FWER\leq0.05\)</span>的唯一途径就是使用一个空的基因列表。在前面我们已经看到，虽然只有1000种包含有效，但是最终我们只得到2个饮食有效这样一个结果，如果把样本数目降低到6，这个结果有可能就是0，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">pvals &lt;- sapply(<span class="number">1</span>:m, <span class="keyword">function</span>(i)&#123;</div><div class="line">  control &lt;- sample(population,<span class="number">6</span>)</div><div class="line">  treatment &lt;- sample(population,<span class="number">6</span>)</div><div class="line">  <span class="keyword">if</span>(!nullHypothesis[i]) treatment &lt;- treatment + delta</div><div class="line">  t.test(treatment,control)$p.value</div><div class="line">&#125;)</div><div class="line">sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>/<span class="number">10000</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>由于我们要求<span class="math inline">\(FWER\leq 0.05\)</span>，因此我们实际上就是0功效（灵敏度）。在许多方法中，这种情况称为特异性(specificity)过强(over-kill)。替代FWER的另外一种方法就是FDR，即错误发现率(false discover rate)。FDR背后的思想就是集中关注Q值，即 <span class="math inline">\(Q \equiv V/R\)</span>，当<span class="math inline">\(R=0,V=0\)</span>时，<span class="math inline">\(Q=0\)</span>。其中，当<span class="math inline">\(R=0\)</span>（没有显著性）就表明，<span class="math inline">\(V=0\)</span>（没有假阳性）。因此<span class="math inline">\(Q\)</span>是一个随机变量，它的范围是0到1，通过计算Q的平均值，我们可以定义一个比值(rate)，它所表示的是意思是，在显著的基因里，假阳性的基因占的比例。为了更好地理解这个概含，我们计算Q的程序要求调用所有的p值都小于0.05。</p>
<h2 id="向量化代码">向量化代码</h2>
<p>在R中可以使用<code>sapply()</code>系列函数来加快运行速度，前面已经看到了这个函数的使用方法，现在使用传统的代码来看一下Q值的计算方法，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(genefilter) <span class="comment">##rowttests is here</span></div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line"><span class="comment">##Define groups to be used with rowttests</span></div><div class="line">g &lt;- factor( c(rep(<span class="number">0</span>,N),rep(<span class="number">1</span>,N)) )</div><div class="line">B &lt;- <span class="number">1000</span> <span class="comment">##number of simulations</span></div><div class="line">Qs &lt;- replicate(B,&#123;</div><div class="line">  <span class="comment">##matrix with control data (rows are tests, columns are mice)</span></div><div class="line">  controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  <span class="comment">##matrix with control data (rows are tests, columns are mice)</span></div><div class="line">  treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  <span class="comment">##add effect to 10% of them</span></div><div class="line">  treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">  <span class="comment">##combine to form one matrix</span></div><div class="line">  dat &lt;- cbind(controls,treatments)</div><div class="line">  calls &lt;- rowttests(dat,g)$p.value &lt; alpha</div><div class="line">  R=sum(calls)</div><div class="line">  Q=ifelse(R&gt;<span class="number">0</span>,sum(nullHypothesis &amp; calls)/R,<span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span>(Q)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; head(Qs)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4513274</span> <span class="number">0.4063786</span> <span class="number">0.4568627</span> <span class="number">0.4490414</span> <span class="number">0.4468314</span> <span class="number">0.4315569</span></div><div class="line">&gt; tail(Qs)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4390756</span> <span class="number">0.4718657</span> <span class="number">0.4395373</span> <span class="number">0.4425711</span> <span class="number">0.4536391</span> <span class="number">0.4284284</span></div></pre></td></tr></table></figure>
<h2 id="控制fdr">控制FDR</h2>
<p>上述代码使用Monte Carlo模拟计算了1000次10000个样本的实验，并保存了Q值，现在看一下Q值的直方图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(Qs) <span class="comment">##Q is a random variable, this is its distribution</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831135218.jpeg">

</div>
<p>FDR就是Q值的平均值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FDR=mean(Qs)</div><div class="line">print(FDR)</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(FDR)</div><div class="line">[<span class="number">1</span>] <span class="number">0.4463354</span></div></pre></td></tr></table></figure>
<p>这里的计算结果表明，FDR值比较高。这是因为对于90%的统计检验而言，零假设是真。这就暗示了，由于p值是cutoff值为0.05，100个检验中，大概有4到5个是假阳性。再加上我们没有考虑到替代所设为真时的所有情况，因此FDR值就比较高。那么我们如何控制它呢，如果我们想要更低的FDR值，比如5%怎么办？</p>
<p>为了用图形说明FDR为什么这么高，我们来绘制p值的直方图。我们使用一个较大的<code>m</code>值从直方图中获取更多的数据。再绘制一条水平线，表示当NULL为真时，从<span class="math inline">\(m_{0}\)</span>个案例（指的基因或其它检测值，<span class="math inline">\(m_{0}\)</span>就是没有统计学差异的基因）中到的阳性结果的均匀分布，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">dat &lt;- cbind(controls,treatments)</div><div class="line">pvals &lt;- rowttests(dat,g)$p.value</div><div class="line">h &lt;- hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.05</span>))</div><div class="line">polygon(c(<span class="number">0</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,h$counts[<span class="number">1</span>],h$counts[<span class="number">1</span>]),col=<span class="string">"grey"</span>)</div><div class="line">abline(h=m0/<span class="number">20</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831140759.jpeg">

</div>
<p>第1个柱子（灰色）表示提p值小于0.05的基因的数目，从水平线可知，大概有一半p值小于0.05的基因是假阳性，这与前面提到的FDR=0.5是一致的。我们来看一下当柱子的宽度为0.01时FDR的值会更低，但同时我们的显著性差异数目也会降低。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">h &lt;- hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.01</span>))</div><div class="line">polygon(c(<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0.01</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,h$counts[<span class="number">1</span>],h$counts[<span class="number">1</span>]),col=<span class="string">"grey"</span>)</div><div class="line">abline(h=m0/<span class="number">100</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831142643.jpeg">

</div>
<p>当柱子的宽度变为0.01时，我们可以看到一个更小的p值cutoff，并且检测到到特征值的数目也会下降（降低了灵敏性sensitivity)，但是，FDR也会降低（提高了特异性specificity）。我们如何设定这个cutoff呢？其中一个方法就是设定一个FDR水平<span class="math inline">\(\alpha\)</span>，然后设置控制错误率的程序即可：<span class="math inline">\(FDR \leq \alpha\)</span>。</p>
<h2 id="benjamini-hochberg">Benjamini-Hochberg</h2>
<p>对于任意给定的<span class="math inline">\(\alpha\)</span>，Benjamini-Hochberg方法都非常适用，这种方法可以让使用者地每个检验的p值进行校正，也能很好地定义一个程序。</p>
<p>Benjamini-Hochberg方法的原理是，先按照升序对p值进行排列，即<span class="math inline">\(p_{(1)},\dots,p_{(m)}\)</span>，然后定义一个<span class="math inline">\(k\)</span>用来表示最大的秩<span class="math inline">\(i\)</span>，它所对应的p值为： <span class="math display">\[
p_{(i)} \leq \frac{i}{m}\alpha
\]</span> 这个程序会拒绝那些p值小于或等于<span class="math inline">\(p_{(k)}\)</span>的检验。现在看一个案例，如何选择<span class="math inline">\(k\)</span>来计算p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">i = seq(along=pvals)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(i,sort(pvals))</div><div class="line">abline(<span class="number">0</span>,i/m*alpha)</div><div class="line"><span class="comment">##close-up</span></div><div class="line">plot(i[<span class="number">1</span>:<span class="number">15</span>],sort(pvals)[<span class="number">1</span>:<span class="number">15</span>],main=<span class="string">"Close-up"</span>)</div><div class="line">abline(<span class="number">0</span>,i/m*alpha)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831145524.jpeg">

</div>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">k &lt;- max( which( sort(pvals) &lt; i/m*alpha) )</div><div class="line">cutoff &lt;- sort(pvals)[k]</div><div class="line">cat(<span class="string">"k ="</span>,k,<span class="string">"p-value cutoff="</span>,cutoff)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"k ="</span>,k,<span class="string">"p-value cutoff="</span>,cutoff)</div><div class="line">k = <span class="number">11</span> p-value cutoff= <span class="number">3.763357e-05</span></div></pre></td></tr></table></figure>
<p>我们可以从数学上证明到这个程序可以将FDR控制在5%以下，具体的算法可以参考Benjamini-Hochberg在1995年的论文。这种新的程序计算的结果就是将原来得到的2个有统计学差异的数值提高到了11个。如果我们将FDR的值设为50%，那么这个数字会提高到1063。FWER无法提供这种灵活性，因为只要检测值的数量增加，都会造成FWER的值为1。</p>
<p>这里我们需要注意的是，在R中，已经有了计算FDR的函数，前面的那些复杂代码只是为了说明这种算法，在R中我们可以使用下面的代码进行计算，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fdr &lt;- p.adjust(pvals, method=<span class="string">"fdr"</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(pvals,fdr,log=<span class="string">"xy"</span>)</div><div class="line">abline(h=alpha,v=cutoff) <span class="comment">##cutoff was computed above</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831151618.jpeg">

</div>
<p>我们也可以使用Monte Carlo模拟来确认一下FDR的值实际上小于0.05，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">B &lt;- <span class="number">1000</span> <span class="comment">##number of simulations. We should increase for more precision</span></div><div class="line">res &lt;- replicate(B,&#123;</div><div class="line">  controls &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  treatments &lt;- matrix(sample(population, N*m, replace=<span class="literal">TRUE</span>),nrow=m)</div><div class="line">  treatments[which(!nullHypothesis),]&lt;-treatments[which(!nullHypothesis),]+delta</div><div class="line">  dat &lt;- cbind(controls,treatments)</div><div class="line">  pvals &lt;- rowttests(dat,g)$p.value</div><div class="line">  <span class="comment">##then the FDR</span></div><div class="line">  calls &lt;- p.adjust(pvals,method=<span class="string">"fdr"</span>) &lt; alpha</div><div class="line">  R=sum(calls)</div><div class="line">  Q=ifelse(R&gt;<span class="number">0</span>,sum(nullHypothesis &amp; calls)/R,<span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span>(c(R,Q))</div><div class="line">&#125;)</div><div class="line">Qs &lt;- res[<span class="number">2</span>,]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">hist(Qs) <span class="comment">##Q is a random variable, this is its distribution</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190831180342.jpeg">

</div>
<p>上述是Q值的直方图（假阳性除以显著性特征值的数目），现在看一下FDR值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FDR=mean(Qs)</div><div class="line">print(FDR)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; FDR=mean(Qs)</div><div class="line">&gt; print(FDR)</div><div class="line">[<span class="number">1</span>] <span class="number">0.03813818</span></div></pre></td></tr></table></figure>
<p>这个FDR的值小于0.05，这个结果是符合预期的，因为我们需要保守一点，从而确保任何值的<span class="math inline">\(m_{0}\)</span>的FDR都小于0.05，例如当每个假设检验都是零的极端情况，例如<span class="math inline">\(m=m_{0}\)</span>。如果你重新模拟上述情况，你会发现FDR会增加。</p>
<p>我们需要注意下面的值：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Rs &lt;- res[<span class="number">1</span>,]</div><div class="line">&gt; mean(Rs==<span class="number">0</span>)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">0.7</span></div></pre></td></tr></table></figure>
<p>在模拟中，这个比例是0.7%，我们没有调用任何有显著性差异的基因。</p>
<p>在R中，<code>p.adjust()</code>函数可以选择一些算法来控制FDR，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; p.adjust.methods</div><div class="line">[<span class="number">1</span>] <span class="string">"holm"</span>       <span class="string">"hochberg"</span>   <span class="string">"hommel"</span>     <span class="string">"bonferroni"</span> <span class="string">"BH"</span>         <span class="string">"BY"</span>         <span class="string">"fdr"</span>        <span class="string">"none"</span></div></pre></td></tr></table></figure>
<p>上面的这些方法不仅仅是估计错误率的不同方法，并且它们的估计值也不同，也就是说FWER与FDR不同。</p>
<h2 id="直接fdr与q值">直接FDR与q值</h2>
<p>这里我们先回顾一下由John D.Storey在J. R. Statist. Soc. B(2002)中提到的结果。Storey与Benjamini-Hochberg方法的不同之处在于，前者不再提前设定<span class="math inline">\(\alpha\)</span>水平。因为在一些高通量实验中，我们感兴趣的仅仅是找到一个基因列表用于验证这些基因，我们会事先考虑将那些p值小于0.01的基因都进行验证。我们人随后会考虑估计的错误率。通常使用这些方法，我们会确保我们的<span class="math inline">\(R&gt;0\)</span>。在上述定义的FDR里，当<span class="math inline">\(R=V=0\)</span>时，我们指定<span class="math inline">\(Q=0\)</span>，因此我们可以计算FDR如下所示： <span class="math display">\[
\mbox{FDR} = E\left( \frac{V}{R} \mid R&gt;0\right) \mbox{Pr}(R&gt;0)
\]</span> 在Storey提出的方法里，我们需要构建一个非空列表，也就是说<span class="math inline">\(R&gt;0\)</span>，那么我们计算阳性FDR(positive FDR)的公式如下所示： <span class="math display">\[
\mbox{pFDR} = E\left( \frac{V}{R} \mid R&gt;0\right)
\]</span> 第二点不同之处在于，Benjamini和Hochberg的程度是在最差的情况下进行控制，最差的情况是指零假设都为真（<span class="math inline">\(m=m_{0}\)</span>的情况），Storey的方法则是让我们从数据中估计<span class="math inline">\(m_{0}\)</span>。因为在高通量实验中，我们已经获得了如此多的数据，使Storey的算法成为了可能。这种算法的大致思路就是，挑选一个相对高值的p值cut-off，将它称为<span class="math inline">\(\lambda\)</span>，并且假设那些p值大于<span class="math inline">\(\Lambda\)</span>的检验在多数情况下其零假设是成立的，因此我们可以计算出估计值<span class="math inline">\(\pi_0 = m_0/m\)</span>为： <span class="math display">\[
\hat{\pi}_0 = \frac{\#\left\{p_i &gt; \lambda \right\} }{ (1-\lambda) m }
\]</span> 还有其它比这种算法更复杂的算法，但是它们的思路都是一样的，例如当我们设定<span class="math inline">\(\lambda=0.1\)</span>时，我们计算一下p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hist(pvals,breaks=seq(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.05</span>),freq=<span class="literal">FALSE</span>)</div><div class="line">lambda = <span class="number">0.1</span></div><div class="line">pi0=sum(pvals&gt; lambda) /((<span class="number">1</span>-lambda)*m)</div><div class="line">abline(h= pi0)</div><div class="line">print(pi0) <span class="comment">##this is close to the trye pi0=0.9</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190901144305.jpeg">

</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(pi0) ##this is close to the trye pi0=0.9</div><div class="line">[1] 0.9311111</div></pre></td></tr></table></figure>
<p>根据这个估计，我们可以改变一下Benjamini-Hochberg程序，例如选择一个<span class="math inline">\(k\)</span>作为最大值（<span class="math inline">\(k\)</span>这里是最大的<span class="math inline">\(i\)</span>），因此就有如下公式： <span class="math display">\[
\hat{\pi}_0 p_{(i)} \leq \frac{i}{m}\alpha
\]</span> 我们还有一种方法可以计算校正后的p值，即对每个检验计算q值(q-value)，如果一个特征计算的p值为<span class="math inline">\(p\)</span>，那么q值就是一系列含有最小p值为<span class="math inline">\(p\)</span>的特征值的估计pFDR。</p>
<p>除此之外，我们还有一种方法可以计算校正后的p值，即对每个检验计算q值(<code>q-value</code>)，如果一个特征最终计算的p值为<span class="math inline">\(p\)</span>，那么q值就是一系列含有尽可能最小与<span class="math inline">\(p\)</span>相等的p值的特征值的估计pFDR（原文是：However, instead of doing this, we compute a q-value for each test. If a feature resulted in a p-value of <span class="math inline">\(p\)</span>, the q-value is the estimated pFDR for a list of all the features with a p-value at least as small as <span class="math inline">\(p\)</span>.）。</p>
<p>上面这段我也不理解，后来查中文资料，根据Benjamini-Hochberg的算法，q值的定义如下所示：</p>
<p>对于m个独立的假设检验，它们对就的p值为：<span class="math inline">\(p_{i},i=1,2,\cdots,m\)</span></p>
<ol style="list-style-type: decimal">
<li>按照升序的方法对这些p值进行排序，得到：</li>
</ol>
<p><span class="math display">\[
p_{(1)} \leq p_{(1)} \cdots \leq p_{(m)}
\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>对于给定的统计学检验水平<span class="math inline">\(\alpha in(0,1]\)</span>，找到最大的<span class="math inline">\(k\)</span>，使得：</li>
</ol>
<p><span class="math display">\[
p_{(k)} \leq \frac{a*k}{m}
\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>对于排序靠前的<span class="math inline">\(k\)</span>个假设检验，认为它们是真阳性，看下面的案例：</li>
</ol>
<p>现在我们做了6个基因的检验，它们的p值如下所示：</p>
<table>
<thead>
<tr class="header">
<th>Gene</th>
<th>p-value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>G1</td>
<td>p1=0.053</td>
</tr>
<tr class="even">
<td>G2</td>
<td>p2=0.001</td>
</tr>
<tr class="odd">
<td>G3</td>
<td>p3=0.045</td>
</tr>
<tr class="even">
<td>G4</td>
<td>p4=0.03</td>
</tr>
<tr class="odd">
<td>G5</td>
<td>p5=0.02</td>
</tr>
<tr class="even">
<td>G6</td>
<td>p6=0.01</td>
</tr>
</tbody>
</table>
<p>现在取检测水平<span class="math inline">\(\alpha=0.05\)</span>，先把p值按从小到大的升序排列：</p>
<table>
<thead>
<tr class="header">
<th>Gene</th>
<th>p-value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>G2</td>
<td>p2=0.001</td>
</tr>
<tr class="even">
<td>G6</td>
<td>p6=0.01</td>
</tr>
<tr class="odd">
<td>G5</td>
<td>p5=0.02</td>
</tr>
<tr class="even">
<td>G4</td>
<td>p4=0.03</td>
</tr>
<tr class="odd">
<td>G3</td>
<td>p3=0.045</td>
</tr>
<tr class="even">
<td>G1</td>
<td>p1=0.053</td>
</tr>
</tbody>
</table>
<p>取检测水平<span class="math inline">\(\alpha=0.05\)</span>，现在我们找到一个值<span class="math inline">\(k\)</span>，这个<span class="math inline">\(k\)</span>满足以下公式： <span class="math display">\[
p_{(k)} \leq \frac{a*k}{m}
\]</span> 当<span class="math inline">\(k=1\)</span>时，<span class="math inline">\(p_{(1)}=0.001 &lt; 0.05*1/6=0.008333333\)</span></p>
<p>当<span class="math inline">\(k=2\)</span>时，<span class="math inline">\(p_{(2)}=0.01&lt;0.05*2/6=0.01666667\)</span></p>
<p>当<span class="math inline">\(k=3\)</span>时，<span class="math inline">\(p_{(3)}=0.02&lt;0.05*3/6=0.025\)</span></p>
<p>当<span class="math inline">\(k=4\)</span>时，<span class="math inline">\(p_{(4)}=0.03&lt;0.05*4/6=0.03333333\)</span></p>
<p>当<span class="math inline">\(k=5\)</span>时，<span class="math inline">\(p_{(5)}=0.045&gt;0.05*5/6=0.04166667\)</span></p>
<p>当<span class="math inline">\(k=6\)</span>时，<span class="math inline">\(p_{(6)}=0.053&gt;0.05*6/6=0.05\)</span></p>
<p>从上面的计算过程可以知道，这个<span class="math inline">\(k\)</span>等于4，也就是说，在FDR&lt;0.05的情况下，G2，G6，G5，G4有差异。</p>
<p>到这里，只是说明了，G2，G6，G5，G4是有差异的，但是q值还没有算出来，继续计算：</p>
<p>前面我们已经把原始的p值按照从小到大的顺序排列好了，也就是<code>[1] 0.001 0.010 0.020 0.030 0.045 0.053</code>，其中最大的p值是<code>0.053</code>，它校正后还是这个值，也就是说这个值是校正后的最大p值，次大的p值是<code>0.045</code>，这个值需要校正，它排序是第5，那么校正的公式就是所有p值的数目（一共是6个p值）除以秩（这里是5），再乘以p值大小，也就是<code>0.045*6/5=0.054</code>，但是，这个值已经大于原来最大的p值（0.053）了，因此这个把它校正后的值也作为0.053，再看倒数第3个值，即0.03的校正p值，即<code>0.03*6/4=0.045</code>，它小于0.053，因此它校正后可以是0.045，现在依次校正剩下的值：</p>
<p><code>0.02*6/3=0.04</code>，<code>0.01*6/2=0.03</code>，<code>0.001*6/1=0.006</code>，也就是说校正后的p值（就是q值），按从小到大的顺序排列就是：<code>0.006，0.03，0.04，0.045，0.053，0.053</code>，从结果中我们可以发现，前4个是有差异的，它们都小于0.05，也就是说G2，G6，G5，G4有差异。</p>
<p>其实公式就是： <span class="math display">\[
q^{(i)}=p_{(k)}^{(i)} * \frac{\text {Total Gene } N u m b e r}{\operatorname{rank}\left(p^{(i)}\right)}=p_{(k)}^{(i)} * \frac{m}{k}
\]</span> 以上是BH法进行q值计算的过程，R中可以使用<code>p.adjust()</code>函数计算q值，所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">p1 &lt;- <span class="number">0.053</span></div><div class="line">p2 &lt;- <span class="number">0.001</span></div><div class="line">p3 &lt;- <span class="number">0.045</span></div><div class="line">p4 &lt;- <span class="number">0.03</span></div><div class="line">p5 &lt;- <span class="number">0.02</span></div><div class="line">p6 &lt;- <span class="number">0.01</span></div><div class="line"></div><div class="line">p0 &lt;- c(p1,p2,p3,p4,p5,p6)</div><div class="line">p.adjust(p0,method = <span class="string">"BH"</span>)</div><div class="line">p.adjust(sort(p0),method = <span class="string">"BH"</span>)</div><div class="line">p.adjust(sort(p0),method = <span class="string">"fdr"</span>)</div><div class="line">sort(p.adjust(p0,method = <span class="string">"BH"</span>))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; p.adjust(p0,method = <span class="string">"BH"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.053</span> <span class="number">0.006</span> <span class="number">0.053</span> <span class="number">0.045</span> <span class="number">0.040</span> <span class="number">0.030</span></div><div class="line">&gt; p.adjust(sort(p0),method = <span class="string">"BH"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div><div class="line">&gt; p.adjust(sort(p0),method = <span class="string">"fdr"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div><div class="line">&gt; sort(p.adjust(p0,method = <span class="string">"BH"</span>))</div><div class="line">[<span class="number">1</span>] <span class="number">0.006</span> <span class="number">0.030</span> <span class="number">0.040</span> <span class="number">0.045</span> <span class="number">0.053</span> <span class="number">0.053</span></div></pre></td></tr></table></figure>
<p>从上面的计算结果看来：</p>
<ol style="list-style-type: decimal">
<li><code>method=&quot;BH&quot;</code>等于<code>method=&quot;fdr&quot;</code>，结果没有区别；</li>
<li>在使用<code>p.adjust()</code>函数计算q值时，不用对原始数据进行排序，如果想要结果按从小到大的序列排列，那么就排序原始值，或计算后的值均可。</li>
</ol>
<p>回到原文。</p>
<p>在R中，<code>qvalue</code>包中的<code>qvalue()</code>函数可以用来计算q值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(qvalue)</div><div class="line">res &lt;- qvalue(pvals)</div><div class="line">qvals &lt;- res$qvalues</div><div class="line">plot(pvals,qvals)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902153110.jpeg">

</div>
<p>估计一下<span class="math inline">\(\hat{\pi_{0}}\)</span>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; res$pi0</div><div class="line">[<span class="number">1</span>] <span class="number">0.8813727</span></div></pre></td></tr></table></figure>
<h2 id="练习">练习</h2>
<p>P274</p>
<h2 id="基础探索数据分析">基础探索数据分析</h2>
<p>与低通量数据相比，高通量数据的一个被低估的优点就是它很容易展现数据。例如当我们有了海量的高通量数据后，我们很容易发现那些在少量数据时并不明显的问题。研究这些数据的一个强有力工具就是探索性数据分析(EDA,exploratory data analysis)。这一部分我们就来了解这方面的内容，可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/advinference/eda_for_highthroughput.Rmd" target="_blank" rel="external">Github上的原文</a>。</p>
<h3 id="火山图">火山图</h3>
<p>我们使用前面数据做的t检验结果来看一下火山图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line"><span class="keyword">library</span>(GSE5859Subset)</div><div class="line">data(GSE5859Subset)</div><div class="line">g &lt;- factor(sampleInfo$group)</div><div class="line">results &lt;- rowttests(geneExpression,g)</div><div class="line">pvals &lt;- results$p.value</div></pre></td></tr></table></figure>
<p>我们还可以从一个数据集中生成一些p值，这些数据集中的零假设为真，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">m &lt;- nrow(geneExpression)</div><div class="line">n &lt;- ncol(geneExpression)</div><div class="line">randomData &lt;- matrix(rnorm(n*m),m,n)</div><div class="line">nullpvals &lt;- rowttests(randomData,g)$p.value</div></pre></td></tr></table></figure>
<p>我们前面提到过，当我们报告效应大小(effect size)时，如果仅仅计算p值则会造成一些错误。我们可以通过画一个火山图来展示高通量数据的统计结果。火山图背后的思想是，它能展示出所有的特征值（这里指的是基因表达谱）。火山图的y轴是<code>-log(base 10) p-value</code>，x轴是效应大小(effect size)。当我们经过<code>-log(base 10)</code>转换后，那些有着极显著差异的特征值就会出现在火山图的上方。这里使用log转换是因为，我们可用log转换可以更好地区分一些非常小的数据，例如区分<code>0.01</code>和<span class="math inline">\(10^6\)</span>，此时我们来绘制一个火山图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plot(results$dm,-log10(results$p.value),</div><div class="line">xlab=<span class="string">"Effect size"</span>,ylab=<span class="string">"- log (base 10) p-values"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902194350.jpeg">

</div>
<h3 id="p值直方图">p值直方图</h3>
<p>另外一种看整体数据的思路就是绘制p值的直方图。当我们的数据完全无效时，那么p值的直方图是服从均匀分布的，而我们的数据有效时，我们可以发现较小的p值频率较高，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">hist(nullpvals,ylim=c(<span class="number">0</span>,<span class="number">1400</span>))</div><div class="line">hist(pvals,ylim=c(<span class="number">0</span>,<span class="number">1400</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902194645.jpeg">

</div>
<p>左侧的p值是无效数据产生的p值，它服从均匀分布，右侧的p值则是则是我们基因表达谱的数据。</p>
<p>当我们预期大多数假设都是无效时，我们就不会看到服从均匀分布的p值，它也许是一些异常属性的指标，例如相关的样本。如果我们对结果时行置换检验，并计算出p值后，如果样本是独立的，那么我们应该会看到均匀分布，但是，我们的数据却看不到这个结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">permg &lt;- sample(g)</div><div class="line">permresults &lt;- rowttests(geneExpression,permg)</div><div class="line">hist(permresults$p.value)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902195138.jpeg">

</div>
<p>在后面部分中，我们会了解到这个数据集中的每个检验并不是独立的，因此这里用于检验的假设（我们使用的是t检验，而t检验的前提就是样本独立）是不正确的。</p>
<h3 id="箱线图与直方图">箱线图与直方图</h3>
<p>高通量数据实验中，我们会检测每个实验单元的数千个特征值，我们前面也提到了，使用箱线图可以辅助我们来判断这些数据的质量。例如，如果一个样本的分布完全不同于剩余的样本，那么我们就可以认为，这个样本存在着一定问题。虽然一个完全的完全的变化可能是由于真正的生物学差异引起的，但是多数情况下，这就是技术因素造成的。这里我们使用Bioconductor中的基因表达数据，为了模拟出一组异常的数据，我们会对其中的一个样本进行log2转换，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#BiocManager::install("Biobase")</span></div><div class="line"><span class="comment">#devtools::install_github("genomicsclass/GSE5859")</span></div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">load(<span class="string">"GSE5859.rda"</span>)</div><div class="line">data(GSE5859)</div><div class="line">ge &lt;- exprs(e) <span class="comment">##ge for gene expression</span></div><div class="line">ge[,<span class="number">49</span>] &lt;- ge[,<span class="number">49</span>]/log2(exp(<span class="number">1</span>)) <span class="comment">##immitate error</span></div><div class="line"></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">boxplot(ge,range=<span class="number">0</span>,names=<span class="number">1</span>:ncol(e),col=ifelse(<span class="number">1</span>:ncol(ge)==<span class="number">49</span>,<span class="number">1</span>,<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>运行过重中发现，<code>GSE5859</code>这个包无法安装，因此可以去官网下载原始文件，直接加载到RStudio中，另外在加载<code>data(GSE5859)</code>时会出错，不用管，运行就行，图形如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202117.jpeg">

</div>
<p>从上图我们可以看到，样本数据大，很难看清楚中间的箱子形状，但是我们很容易发现有一个样本异常，除此之外，我们可以用另外一种方式来展示一下数据，这个数据不画箱子，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qs &lt;- t(apply(ge,<span class="number">2</span>,quantile,prob=c(<span class="number">0.05</span>,<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.75</span>,<span class="number">0.95</span>)))</div><div class="line">matplot(qs,type=<span class="string">"l"</span>,lty=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202322.jpeg">

</div>
<p>这种图形可以称为<code>kaboxplot</code>，因为这是由Karl Broman首次使用的，它绘制的是0.05，0.25，0.5，0.75和0.95分位数的图形。</p>
<p>我们也可以绘制直方图。因为我们的数据很多，因此可以使用很窄的间隔(bin)与柱子，然后将这些柱子进行平滑处理，最终绘制成平滑直方图(smooth histogram)。我们重新再校正这些平滑曲线的高度，那么在<span class="math inline">\(x_{0}\)</span>处的高度与基本单元构成的面积内，它们的点的数目就都比较接近，如下所示：</p>
<p>元区域内的点的数目就与这个基本单元的面积接近积，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">shist(ge,unit=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902202859.jpeg">

</div>
<h3 id="ma图">MA图</h3>
<p>散点图(scatterplot)与相关性(correlation)不是检测重复性问题的最佳工具。检测重复性更好的工作就是检测两次之间的差值，如果重复性好，那么这些差值应该是一样的。因此，一种更好的绘图工具就是将散点图旋转一下，这个散点图的y轴上差值，x轴是平均值。这种图最初被叫做Bland-Altman图，但在遗传学中它经常被称为MA图。MA的名称来源于图形的内容，M表示减(minus)，表示两值之差（有的时候是log值之差），A表示平均(Average)，现在绘制一下MA图</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x &lt;- ge[,<span class="number">1</span>]</div><div class="line">y &lt;- ge[,<span class="number">2</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y)</div><div class="line">plot((x+y)/<span class="number">2</span>,x-y)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190902215832.jpeg">

</div>
<p>左图是常规的相关图，右图是MA图，需要注意的是，当我们把左图进行旋转后，这些数据的差异的SD就非常直观了：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sd(y-x)</div><div class="line">[<span class="number">1</span>] <span class="number">0.2025465</span></div></pre></td></tr></table></figure>
<p>左图的散点图显示这两个样本的相关性很强，但是显示的信息有限。</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://www.jianshu.com/p/d86823ecd3ac" target="_blank" rel="external">如何理解与计算FDR？（第二版）</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/16/DAL/DALS016_InferenceForHighDimensionalData1_Basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/DAL/DALS016_InferenceForHighDimensionalData1_Basic/" itemprop="url">DALS016-高维数据推断1-背景介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T12:00:00+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,781
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第6章线性高维数据推断(Inference For High Dimensional Data)的第1小节，这一部分的主要内容涉及高通量数据的介绍，统计学的一些注意事项，相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/advinference/intro_to_highthroughput_data.Rmd" target="_blank" rel="external">Github</a>。</p>
<h3 id="高通量技术">高通量技术</h3>
<p>高通量技术已经将基础生物学和生物学从数据贫乏型学科尾成了数据密集型学科。一个典型的例子就是那些对基因表达有兴趣的研究领域。基因表达是这样一个过程，将生命蓝图DNA复制到RNA，而RNA是蛋白质合成的模板，是构成生命的基石。在20世纪90年代，对基因表达数据的分析相当于在一张纸上画了几个点，或从标准曲线上提取了几个数字。随着微阵列等高通量技术的发展，这几个数据就突然变成了筛选成千上万的数字。最近，RNA测序技术又进一步增加了数据的复杂性。生物学家们从使用他们的肉眼或简单的方法来分析结果到每个样本有数千（现在则是数百万个）个数据的分析。在这一篇中，我们佬双重点关注高通量数量的统计推断。具体来说就是，我们会使用统计检验来检测不同组之间的差异，以及使用有意义的方法来量化不确定性问题。我们还公介绍探索性数据分析方法，这些方法会结合高通量数据进行使用。在后面的章节中，我们会研究聚类，机器学习，因子分析和多层级建模(multi-level)。</p>
<p>由于现在有大量可用的公共数据集，我们会使用这些公共数据集来作为我们的学习案例。尽量使用的是公共数据，但是当你学习了这些方法后，在使用了高通量数据技术的其它领域也会派上用场。这些高通量技术包括微阵列，NGS，fRMI与蛋白质谱等。</p>
<h3 id="数据包">数据包</h3>
<p>我们这里使用的数据文件已经在作者的Github上分享了，因此使用<code>devtools</code>包就可以直接下载，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(devtools)</div><div class="line">install_github(<span class="string">"genomicsclass/GSE5859Subset"</span>)</div></pre></td></tr></table></figure>
<h3 id="张表">3张表</h3>
<p>我们用来做为案例学习的这些数据多数都是使用高通量技术生成的。这些技术会检测数千个特征值(feature)。这些特征值可以是基因，可以是基因组的单碱基位置，基因区域，以及图像的像素密度（芯片数据）。每个特定的检测产品被都会被相应地一组特定的功能所定义（我的理解就是，某公司的特定产品，例如检测miRNA的芯片，它的检测结果就是一些表达值，而这些表达值代表了哪些miRNA，就还需要另外一个miRNA名称的数据文件），例如特定基因表达的微阵列数据被一组其检测的基因所定义。一个特定的研究通常会使用一种产品对几个实验单元进行检验，例如几个人的样本。最常见的就是人，不过实验产单元也可以是其它的东西，例如肿瘤组织的一部分。按照实验术语，我们通常称实验单元为样本，这个样本与前面讲的随机样本不是一个东西，后者是统计学术语。</p>
<p>因此，一个高能被实验通常由3张表定义：一个是高通量数据的检测值，第二与第三表是关于列与行的信息。由于这些数据集通常是由一系列的实验单元，以及一些固定的特征构成，因此，高通量数据可以储存为<span class="math inline">\(n \times m\)</span>的形式，其中<span class="math inline">\(n\)</span>表示实验单元（样本），而<span class="math inline">\(m\)</span>表示特征值（通常就是基因），现在 我们来看一个案例：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(GSE5859Subset)</div><div class="line">data(GSE5859Subset) <span class="comment">##this loads the three tables</span></div><div class="line">dim(geneExpression)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; dim(geneExpression)</div><div class="line">[<span class="number">1</span>] <span class="number">8793</span>   <span class="number">24</span></div></pre></td></tr></table></figure>
<p>这个数据是RNA表达谱数据，它检测了24个人（实验单元）的8793个基因。对于大多数的统计分析来说，我们还需要实验样本的一些信息。例如，在这个案例中，最初收集的数据是用于比较不同种族群体的基因表达情况。但是，我们已经创建了这个数据集的一个子集用于说明样本的信息情况，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dim(sampleInfo)</div><div class="line">head(sampleInfo)</div><div class="line">sampleInfo$group</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; dim(sampleInfo)</div><div class="line">[<span class="number">1</span>] <span class="number">24</span>  <span class="number">4</span></div><div class="line">&gt; head(sampleInfo)</div><div class="line">    ethnicity       date         filename group</div><div class="line"><span class="number">107</span>       ASN <span class="number">2005</span>-<span class="number">06</span>-<span class="number">23</span> GSM136508.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">122</span>       ASN <span class="number">2005</span>-<span class="number">06</span>-<span class="number">27</span> GSM136530.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">113</span>       ASN <span class="number">2005</span>-<span class="number">06</span>-<span class="number">27</span> GSM136517.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">163</span>       ASN <span class="number">2005</span>-<span class="number">10</span>-<span class="number">28</span> GSM136576.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">153</span>       ASN <span class="number">2005</span>-<span class="number">10</span>-<span class="number">07</span> GSM136566.CEL.gz     <span class="number">1</span></div><div class="line"><span class="number">161</span>       ASN <span class="number">2005</span>-<span class="number">10</span>-<span class="number">07</span> GSM136574.CEL.gz     <span class="number">1</span></div><div class="line">&gt; sampleInfo$group</div><div class="line"> [<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>关于样本信息中的一列是文件名，它可以让我们把这个表的行与表达谱的列连接起来，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match(sampleInfo$filename,colnames(geneExpression))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; match(sampleInfo$filename,colnames(geneExpression))</div><div class="line"> [<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span></div></pre></td></tr></table></figure>
<p>最后，我们还有一张描述特征值的表格，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dim(geneAnnotation)</div><div class="line">head(geneAnnotation)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; dim(geneAnnotation)</div><div class="line">[<span class="number">1</span>] <span class="number">8793</span>    <span class="number">4</span></div><div class="line">&gt; head(geneAnnotation)</div><div class="line">     PROBEID  CHR     CHRLOC SYMBOL</div><div class="line"><span class="number">1</span>  1007_s_at chr6   <span class="number">30852327</span>   DDR1</div><div class="line"><span class="number">30</span>   1053_at chr7  -<span class="number">73645832</span>   RFC2</div><div class="line"><span class="number">31</span>    117_at chr1  <span class="number">161494036</span>  HSPA6</div><div class="line"><span class="number">32</span>    121_at chr2 -<span class="number">113973574</span>   PAX8</div><div class="line"><span class="number">33</span> 1255_g_at chr6   <span class="number">42123144</span> GUCA1A</div><div class="line"><span class="number">34</span>   1294_at chr3  -<span class="number">49842638</span>   UBA7</div></pre></td></tr></table></figure>
<p>从上面的信息知道，<code>geneAnnotation</code>这个文件里含有ID，这个表的行可以与表达谱的行连接起来，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">head(match(geneAnnotation$PROBEID,rownames(geneExpression)))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; head(match(geneAnnotation$PROBEID,rownames(geneExpression)))</div><div class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></div></pre></td></tr></table></figure>
<h2 id="实际应用">实际应用</h2>
<p>现在假设我们已经拥有了一批高通量数据，这个数据是检测了两组中一些人的基因表达情况。现在我们的问题是：在这两组人中，哪些基因的表达均值存在差异？如果是一个基因，计算起来很简单，我们手工计算就行，但是，高通常数量通常都是几千个基因，显然手工算不太现实，但是寻找差异基因的方法跟前面我们提到的统计推断原理一样。例如，我们可以使用t检验或其它检验来寻找差异基因。</p>
<h3 id="随机变量的p值">随机变量的p值</h3>
<p>这里我们要强调的一个概念就是，p值是一个随机变量。为了能说明这一点，我们来看一个案例。在这个案例中，我们会使用CLT近似的原来生成大量的样本，并通过t检验来计算其p值。然后我们的p值被定义为，正态分布的随机变量的绝对值大于观察到的t检验r值的概率，被称为<span class="math inline">\(Z\)</span>（书中原话是：Then our p-value is defined as the probability that a normally distributed random variable is larger, in absolute value, than the observed t-test, call it Z.），因此，双尾检验的p值公式如下所示： <span class="math display">\[
p = 2 \{ 1 - \Phi(\mid Z \mid)\}
\]</span> 在R中则为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>*(<span class="number">1</span>-pnorm(Z))</div></pre></td></tr></table></figure>
<p>因为<span class="math inline">\(Z\)</span>是一个随机变量，并且<span class="math inline">\(\Phi\)</span>是一个确定的函数，<span class="math inline">\(p\)</span>因此也是一个随机变量。我们现在使用Monte Carlo模拟来显示一下<span class="math inline">\(p\)</span>值的变化，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line"></div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/femaleControlsPopulation.csv"</span>)</div><div class="line">population &lt;- read.csv(filename)</div><div class="line">population &lt;- unlist(population) <span class="comment"># turn it into a numeric</span></div><div class="line">N &lt;- <span class="number">12</span></div><div class="line">B &lt;- <span class="number">10000</span></div><div class="line">pvals &lt;- replicate(B,&#123;</div><div class="line">  control = sample(population,N)</div><div class="line">  treatment = sample(population,N)</div><div class="line">  t.test(treatment,control)$p.val</div><div class="line">&#125;)</div><div class="line">hist(pvals)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190828112405.jpeg">

</div>
<p>从直方图中我们可以看到，p值属于均匀分布。事实上，我们可以从理论上证明，当零假设为真是，情况确实如此。当我们使用CLT时，我们的零假设<span class="math inline">\(H_{0}\)</span>意味着我们的检验统计量Z服从均值为0，SD为1的正态分布，因此： <span class="math display">\[
p_a = \mbox{Pr}(Z &lt; a \mid H_0) = \Phi(a)
\]</span> 这也说明： <span class="math display">\[
\begin{align*}
\mbox{Pr}(p &lt; p_a) &amp;= \mbox{Pr}[ \Phi^{-1}(p) &lt; \Phi^{-1}(p_a) ] \\
  &amp; = \mbox{Pr}(Z &lt; a) = p_a
\end{align*}
\]</span> 这其实就是均匀分布(uniform distribution)的定义。</p>
<h3 id="千次检验">千次检验</h3>
<p>在上面的案例中，我们有两组数据，分别用0和1表示，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(GSE5859Subset)</div><div class="line">data(GSE5859Subset)</div><div class="line">g &lt;- sampleInfo$group</div><div class="line">g</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(GSE5859Subset)</div><div class="line">&gt; data(GSE5859Subset)</div><div class="line">&gt; g &lt;- sampleInfo$group</div><div class="line">&gt; g</div><div class="line"> [<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<p>如果我们对某个特定的基因感兴趣，例如第25行的那个基因，那么我们就可以简单地使用t检验就行，为了计算p值，我们需要先看一下这个基因数据是否服从t分布，因此我们可以使用qq图来绘制，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">e &lt;- geneExpression[<span class="number">25</span>,]</div><div class="line">e</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">qqnorm(e[g==<span class="number">1</span>])</div><div class="line">qqline(e[g==<span class="number">1</span>])</div><div class="line">qqnorm(e[g==<span class="number">0</span>])</div><div class="line">qqline(e[g==<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; e</div><div class="line">GSM136508.CEL.gz GSM136530.CEL.gz GSM136517.CEL.gz GSM136576.CEL.gz GSM136566.CEL.gz GSM136574.CEL.gz GSM136575.CEL.gz </div><div class="line">        <span class="number">10.34172</span>         <span class="number">10.64662</span>         <span class="number">10.69198</span>         <span class="number">10.96155</span>         <span class="number">10.24889</span>         <span class="number">10.74414</span>         <span class="number">10.22206</span> </div><div class="line">GSM136569.CEL.gz GSM136568.CEL.gz GSM136559.CEL.gz GSM136565.CEL.gz GSM136573.CEL.gz GSM136523.CEL.gz GSM136509.CEL.gz </div><div class="line">        <span class="number">10.49094</span>         <span class="number">10.57574</span>         <span class="number">10.47758</span>         <span class="number">10.43493</span>         <span class="number">10.46440</span>         <span class="number">10.58358</span>         <span class="number">10.39607</span> </div><div class="line">GSM136727.CEL.gz GSM136510.CEL.gz GSM136515.CEL.gz GSM136522.CEL.gz GSM136507.CEL.gz GSM136524.CEL.gz GSM136514.CEL.gz </div><div class="line">        <span class="number">10.75837</span>         <span class="number">10.37383</span>         <span class="number">10.57540</span>         <span class="number">10.51203</span>         <span class="number">10.39952</span>         <span class="number">10.70539</span>         <span class="number">10.77077</span> </div><div class="line">GSM136563.CEL.gz GSM136564.CEL.gz GSM136572.CEL.gz </div><div class="line">        <span class="number">10.38333</span>         <span class="number">10.31405</span>         <span class="number">10.25655</span></div></pre></td></tr></table></figure></p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190828180606.jpeg">

</div>
<p>qq显示，这个数据比较接近于正态分布，但是t检验发现，这个基因在两组之间并无差异，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.test(e[g==<span class="number">1</span>],e[g==<span class="number">0</span>])$p.value</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; t.test(e[g==<span class="number">1</span>],e[g==<span class="number">0</span>])$p.value</div><div class="line">[<span class="number">1</span>] <span class="number">0.779303</span></div></pre></td></tr></table></figure>
<p>上面是只计算1个基因的情况，如果要计算所有的基因，那么就需要对每个基因进行t检验，我们来构建一个函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myttest &lt;- <span class="keyword">function</span>(x) t.test(x[g==<span class="number">1</span>],x[g==<span class="number">0</span>],var.equal=<span class="literal">TRUE</span>)$p.value</div><div class="line">pvals &lt;- apply(geneExpression,<span class="number">1</span>,myttest)</div><div class="line">head(pvals)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; head(pvals)</div><div class="line"> 1007_s_at    1053_at     117_at     121_at  1255_g_at    1294_at </div><div class="line"><span class="number">0.04553344</span> <span class="number">0.03370683</span> <span class="number">0.13604026</span> <span class="number">0.59413846</span> <span class="number">0.96849102</span> <span class="number">0.08489586</span></div></pre></td></tr></table></figure>
<p>现在我们来看一下，p值小于0.05的基因有多少个，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(pvals&lt;<span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals&lt;<span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1383</span></div></pre></td></tr></table></figure>
<p>也就是说，有1383个基因有差异。</p>
<p>但是，正如我们随后即将详细描述的那样，对于这个结果，我们要谨慎对待。因为这个结果是我们经过8000多次比较后得到的结果（数据集里一共有个8793基因）。如果我们对一批随机数据执行相同的计算过程，在零假设成立的前提下，我们也能计算出一批p值，并且这批p值小于0.05的数目为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">m &lt;- nrow(geneExpression)</div><div class="line">n &lt;- ncol(geneExpression)</div><div class="line">randomData &lt;- matrix(rnorm(n*m),m,n)</div><div class="line">nullpvals &lt;- apply(randomData,<span class="number">1</span>,myttest)</div><div class="line">sum(nullpvals&lt;<span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(nullpvals&lt;<span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">419</span></div></pre></td></tr></table></figure>
<p>随后，我们会解释一下这个数值是怎么一回事，实际上，这个数字大概就是8192*0.05的结果（大约为409.6），后面会详细介绍这个原理。</p>
<h3 id="加快t检验的计算">加快t检验的计算</h3>
<p>在我们开始之前，我们需要知道，前面我们构建了一个做t检验的函数，虽然它能计算出相应的p值，但是这种方法比较低效。我们还有其它更快的方法实现这一目的，在Bioconductor项目中就有这样的函数，此时我们要用到<code>rafalib</code>包中的<code>install_bioc()</code>函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install_bioc(<span class="string">"genefilter"</span>)</div></pre></td></tr></table></figure>
<p>现在我们使用<code>rowttests()</code>函数来计算一下p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">results &lt;- rowttests(geneExpression,factor(g))</div><div class="line">max(abs(pvals-results$p))</div><div class="line">sum(results$p&lt;<span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(pvals-results$p))</div><div class="line">[<span class="number">1</span>] <span class="number">6.528111e-14</span></div><div class="line">&gt; sum(results$p&lt;<span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1383</span></div></pre></td></tr></table></figure>
<h2 id="p值计算练习">p值计算练习</h2>
<p>为了更好地理解p值是一个随机变量，现在我们再来看一些案例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line"><span class="keyword">library</span>(downloader)</div><div class="line">url = <span class="string">"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extda\</span></div><div class="line"><span class="string">ta/femaleControlsPopulation.csv"</span></div><div class="line">filename = <span class="string">"femaleControlsPopulation.csv"</span></div><div class="line"><span class="keyword">if</span> (!file.exists(filename)) download(url,destfile=filename)</div><div class="line">population = read.csv(filename)</div><div class="line"></div><div class="line">pvals &lt;- replicate(<span class="number">1000</span>,&#123;</div><div class="line">  control = sample(population,<span class="number">12</span>)</div><div class="line">  treatment = sample(population,<span class="number">12</span>)</div><div class="line">  t.test(treatment,control)$p.val&#125;)</div><div class="line">head(pvals)</div><div class="line">hist(pvals)</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; head(pvals)</div><div class="line">[<span class="number">1</span>] <span class="number">0.76454370</span> <span class="number">0.60237592</span> <span class="number">0.49679830</span> <span class="number">0.23518016</span> <span class="number">0.20882028</span> <span class="number">0.06812489</span></div></pre></td></tr></table></figure></p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190828191526.jpeg">

</div>
<p>现在回答以下几个问题：</p>
<p><strong>问题一</strong>：小于0.05的p值所占的比例是多少？</p>
<p>答：4.1%，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">4.1</span></div></pre></td></tr></table></figure>
<p><strong>问题二</strong>：小于0.01的p值所占的比例是多少？</p>
<p>答：0.8%，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals &lt; <span class="number">0.01</span>)/length(pvals)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">0.8</span></div></pre></td></tr></table></figure>
<p><strong>问题三</strong>：假设你正在测试20种饮食对小鼠体重影响的效应。对于20种饮食中的每一种，我们都使用10只对照小鼠和10只实验小鼠。在零假设成立时，也就是说饮食对小鼠的体重没有影响，另外，小鼠的体重是服从正态分布的（均值为30g，SD为2g）。我们对其中的一项进行Monte Carlo模拟：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cases = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">controls = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">t.test(cases,controls)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; cases = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">&gt; controls = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">&gt; t.test(cases,controls)</div><div class="line"></div><div class="line">	Welch Two Sample t-test</div><div class="line"></div><div class="line">data:  cases and controls</div><div class="line">t = <span class="number">0.16473</span>, df = <span class="number">17.934</span>, p-value = <span class="number">0.871</span></div><div class="line">alternative hypothesis: true difference <span class="keyword">in</span> means is not equal to <span class="number">0</span></div><div class="line"><span class="number">95</span> percent confidence interval:</div><div class="line"> -<span class="number">1.708669</span>  <span class="number">1.999327</span></div><div class="line">sample estimates:</div><div class="line">mean of x mean of y </div><div class="line"> <span class="number">30.23172</span>  <span class="number">30.08639</span></div></pre></td></tr></table></figure>
<p>问题：现在进行Monte Carlo模拟，模拟所有20种包含的实验结果，如果我们将种子设置为<code>set.seed(100)</code>，那么有多少值低于0.05？</p>
<p>答案是：5%，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">100</span>)</div><div class="line">pvals &lt;- replicate(<span class="number">20</span>,&#123;</div><div class="line">  cases = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">  controls = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">  t.test(cases,controls)$p.val&#125;)</div><div class="line">sum(pvals&lt;<span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals&lt;<span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">5</span></div></pre></td></tr></table></figure>
<p><strong>问题四</strong>：现在我们通过模拟数据了解了p值的分布情况，也就是说了解了小于0.05的p值的比例。在问题三中，我们一次运行了20种饮食的实验。现在我们运行1000次实验，并且每次保存下那些p值小于0.05的数目。</p>
<p>操作如下：</p>
<p>随机种子数设为100，即<code>set.seed(100)</code>，运行问题三中的代码1000次，并保存p值小于0.05的次数，计算一下这些数字的平均值，这就是我们拒绝零假设为真时的次数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">100</span>)</div><div class="line">pvals &lt;- replicate(<span class="number">1000</span>,&#123;</div><div class="line">  cases = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">  controls = rnorm(<span class="number">10</span>,<span class="number">30</span>,<span class="number">2</span>)</div><div class="line">  t.test(cases,controls)$p.val&#125;)</div><div class="line">sum(pvals&lt;<span class="number">0.05</span>)</div><div class="line">sum(pvals&lt;<span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; sum(pvals&lt;<span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">40</span></div><div class="line">&gt; sum(pvals&lt;<span class="number">0.05</span>)/length(pvals)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">4</span></div></pre></td></tr></table></figure>
<p><strong>问题五</strong>：这说明，就平均数而言，即使所有的饮食对小鼠的体重都没有影响，我们还能得到一些小于0.05的p值。使用相同的模拟数据来做1000次计算，我们能得到多少假阳性的比例？</p>
<p>答：大概是5%。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">226</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共915.6k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
