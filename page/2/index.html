<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/2/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/2/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/17/DAL/DALS011_Linear_Models01MatrixDescription/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/DAL/DALS011_Linear_Models01MatrixDescription/" itemprop="url">DALS011-Linear Models线性模型01MatrixDescription</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T12:00:00+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,766
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第5章线性模型的第1小节。这一部分的主要内容涉及矩阵的表示方法。</p>
<h2 id="背景知识">背景知识</h2>
<p>数据分析中的很多模型都可以用矩阵代数来表示。我们指的这些模型都是线性模型(linear models)。线性(Linear)并不是说它们是直线，而是说是线性组合。使用矩阵代数来描述线性模型非常方便，因为我们可以更好地构建这些模型，并使用数学工具来方便计算。在这一部分中，我们将详细地描述我们如何使用矩阵代数来构建并拟合线性模型。</p>
<p>在本书中，我们关注的线性模型是基于二分法的线性模型：例如治疗组与对照组。在前面提到的小鼠饲料的案例中就是这种线性模型的一个典型案例。在这一部分中，我们会描述一些比较复杂的案例，不过还会继续关注二分法变量的线性模型。</p>
<p>当我们学习线性模型时，需要记住，我们使用的变量仍然是随机变量。这就意味着，我们使用线性模型获得的估计值也是随机变量。虽然数学上这理解起来比较复杂，但是我们前面学到的一些概念在这里仍然适用。现在可以先做一些练习，在线性模型的练习中复习一些随机变量的概念。</p>
<h2 id="练习">练习</h2>
<p>P172</p>
<h2 id="设计矩阵the-design-matrix">设计矩阵(The Design Matrix)</h2>
<p>R中的<code>formual()</code>和<code>model.matrix()</code>可以用于生成各种线性模型的设计矩阵(design matrices)（也被称为模型矩阵，即model matrices)。例如，在小鼠的饲料实验中，我们可以这样构建模型，如下所示： <span class="math display">\[
Y_{i}=\beta_{0}+\beta_{1} x_{i}+\varepsilon, i=1, \ldots, N
\]</span> 其中，<span class="math inline">\(Y_{i}\)</span>表示体重，而<span class="math inline">\(x_{i}\)</span>等于1的时候，表示小鼠<span class="math inline">\(i\)</span>吃的是高脂饲料(hf)。我们可以使用实验单位(Experimental unit)来表示N个不同的实验动物，这里的实验单位是小鼠。我们称这类变量为指示变量(indicator variables)，因此这类变量仅用于标明实验单位，表示某种干预的有无。现在用矩阵代数来描述就是以下形式： <span class="math display">\[
\mathbf{Y}=\left(\begin{array}{c}{Y_{1}} \\ {Y_{2}} \\ {\vdots} \\ {Y_{N}}\end{array}\right), \mathbf{X}=\left(\begin{array}{cc}{1} &amp; {x_{1}} \\ {1} &amp; {x_{2}} \\ {\vdots} &amp; {} \\ {1} &amp; {x_{N}}\end{array}\right), \beta=\left(\begin{array}{c}{\beta_{0}} \\ {\beta_{1}}\end{array}\right) \text { and } \varepsilon=\left(\begin{array}{c}{\varepsilon_{1}} \\ {\varepsilon_{2}} \\ {\vdots} \\ {\varepsilon_{N}}\end{array}\right)
\]</span> 或为： <span class="math display">\[
\left(\begin{array}{c}{Y_{1}} \\ {Y_{2}} \\ {\vdots} \\ {Y_{N}}\end{array}\right)=\left(\begin{array}{cc}{1} &amp; {x_{1}} \\ {1} &amp; {x_{2}} \\ {\vdots} &amp; {} \\ {1} &amp; {x_{N}}\end{array}\right)\left(\begin{array}{c}{\beta_{0}} \\ {\beta_{1}}\end{array}\right)+\left(\begin{array}{c}{\varepsilon_{1}} \\ {\varepsilon_{2}} \\ {\vdots} \\ {\varepsilon_{N}}\end{array}\right)
\]</span> 简化形式为： <span class="math display">\[
\mathrm{Y}=\mathrm{X} \boldsymbol{\beta}+\varepsilon
\]</span> 其中<span class="math inline">\(\mathbf{X}\)</span>是设计矩阵，一旦我们定义了设计矩阵，那么我们就能计算出最小二乘估计。这个过程称为拟合模型(fitting the model)。在R中，我们可以直接在<code>lm()</code>函数中输入一个公式(formula)直接进行拟合。在后面的一个脚本中，我们会使用<code>model.matrix()</code>函数，这个函数是在<code>lm()</code>函数内部使用的。这种使用方式哦可以方便地让我们将R的formula与矩阵<span class="math inline">\(\mathbf{X}\)</span>连接起来，有助于我们对<code>lm()</code>的结果进行解释。</p>
<h2 id="设计方案">设计方案</h2>
<p>设计矩阵的选择是线性模型中的关键步骤，因为它编码了哪些系数将适合用于建模，以及样本之间的相互关系。一个常见的误解就是，选择实验设计要遵循简单明了的原则，即要在描述中直接标明样本。事实并非如此。关于每个样本（无论是对照组还是处理组，实验批次等）的基础信息里并不意味着这是一个“正确”的设计矩阵。设计矩阵还应该对<span class="math inline">\(X\)</span>中的变量是如何解释<span class="math inline">\(Y\)</span>的值这些信息进行编码，这是研究者们必须要考虑的。</p>
<p>在这一部分的案例中，我们使用线性模型来比较不同组之间的差异。因此，最终进行计算的设计矩阵应该至少包含两列，即截矩(intercept)列，截矩列是第1列，另外就是第2列，第2列指定样本。在这种情况下，线性模型中的两个系数(coefficient)分别为：第1个系数是截矩(interccept)，它代表了第1组的总体均数，第2个系数是差值，这个差值表示的是第2组与第1组总体的差值。当我们进行统计学分析时，往往第2个系数是我们最感兴趣的，因为我们想知道这两组数据是否有差异。</p>
<p>我们可以在R中通过2行代码来编制实验设计。我们先是使用波浪线<code>~</code>来构建一个公式。这种形式的公式意味着，我们想使用波浪线右侧的变量的观测值来构建统计模型。然后我们再放进一个变量的名称，就能知道样本来源于哪些组。</p>
<p>看一个案例。 现在我们有两组数据，分别是对照组和高脂饲料组(hf)小鼠的体重数据。现在我们用1来表示对照组小鼠，2来表示hf组。我们首先要告诉R，这些值不能被当成数值，而是应该当成因子。然后使用公式<code>~group</code>来构建模型，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group &lt;- factor( c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>) )</div><div class="line">model.matrix(~ group)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; group &lt;- factor( c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>) )</div><div class="line">&gt; model.matrix(~ group)</div><div class="line">  (Intercept) group2</div><div class="line"><span class="number">1</span>           <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>      <span class="number">1</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>      <span class="number">1</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$group</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<p>这里面有很多信息，<code>attr</code>后面的信息不用管。</p>
<p>其实上面的计算过程也可以使用<code>model.matrix()</code>来构建，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group &lt;- factor( c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>) )</div><div class="line">model.matrix(formula(~ group))</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; group &lt;- factor( c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>) )</div><div class="line">&gt; model.matrix(formula(~ group))</div><div class="line">  (Intercept) group2</div><div class="line"><span class="number">1</span>           <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>      <span class="number">1</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>      <span class="number">1</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$group</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<p>如果我们不对组别(<code>group</code>)进行因子转换，那么就会出现下面的情况：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group &lt;- c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">model.matrix(~ group)</div></pre></td></tr></table></figure>
<p>即：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; model.matrix(~ group)</div><div class="line">  (Intercept) group</div><div class="line"><span class="number">1</span>           <span class="number">1</span>     <span class="number">1</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>     <span class="number">1</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>     <span class="number">2</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>     <span class="number">2</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这种形式不是设计矩阵。因为没有经过factor转换的数值就是单纯的数值，而非指示变量(indicator variable)，因子类型变量的数值与具体的数字无关，字符串也能生成这些变量，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group &lt;- factor(c(<span class="string">"control"</span>,<span class="string">"control"</span>,<span class="string">"highfat"</span>,<span class="string">"highfat"</span>))</div><div class="line">model.matrix(~ group)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; group &lt;- factor(c(<span class="string">"control"</span>,<span class="string">"control"</span>,<span class="string">"highfat"</span>,<span class="string">"highfat"</span>))</div><div class="line">&gt; model.matrix(~ group)</div><div class="line">  (Intercept) grouphighfat</div><div class="line"><span class="number">1</span>           <span class="number">1</span>            <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>            <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>            <span class="number">1</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>            <span class="number">1</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$group</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<h2 id="多组设计">多组设计</h2>
<p>现在我们设计了3组数据，如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">model.matrix(~ group)</div></pre></td></tr></table></figure></p>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; group &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">&gt; model.matrix(~ group)</div><div class="line">  (Intercept) group2 group3</div><div class="line"><span class="number">1</span>           <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">5</span>           <span class="number">1</span>      <span class="number">0</span>      <span class="number">1</span></div><div class="line"><span class="number">6</span>           <span class="number">1</span>      <span class="number">0</span>      <span class="number">1</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$group</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<p>现在我们的设计矩阵中有了第3列，这个第3列属于第3组。另外一种方法就是通过在公式中指定<code>+0</code>来添加第3组，如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">model.matrix(~ group + <span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; group &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">&gt; model.matrix(~ group + <span class="number">0</span>)</div><div class="line">  group1 group2 group3</div><div class="line"><span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></div><div class="line"><span class="number">2</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></div><div class="line"><span class="number">3</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">4</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">5</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></div><div class="line"><span class="number">6</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$group</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<p>注：在这一处我不太理解，原文是<code>This group now fits a separate coefficient for each group.</code>翻译为汉语则是<code>这一组现在适用于每组的单独系数</code>，等后文中有介绍的时候再补上，以下是其它的参考书（数学建模：基于R.薛毅 著）对这一内容的理解：</p>
<p><code>lm()</code>中的参数<code>formula</code>是模型公式：</p>
<ol style="list-style-type: decimal">
<li><code>y ~ 1+x1 + x2</code>这种形式，表示常数项，<span class="math inline">\(X_{1}\)</span>，<span class="math inline">\(X_{2}\)</span>的系数；</li>
<li><code>y ~ x1 + x2</code>这种形式，去掉了1，其意义与原来加1的一样。</li>
<li><code>y ~ 0 + x1 + x2</code>这种形式，添加了0，表示拟合成就齐次线性模型（或者是改为<code>y ~ -1 + x1 + x2</code>）。</li>
</ol>
<h2 id="多变量设计">多变量设计</h2>
<p>前面我们构建的线性模型只有1个变量，即饲料。而在生命科学中，在一次实验中，往往会涉及多个变量，例如我们也许会研究饲料与性别这两个因素对体重的影响，在这种情况下，我们也许就会设计4组，如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">diet &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">sex &lt;- factor(c(<span class="string">"f"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>,<span class="string">"f"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>))</div><div class="line">table(diet,sex)</div></pre></td></tr></table></figure></p>
<p>组别如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table(diet,sex)</div><div class="line">    sex</div><div class="line">diet f m</div><div class="line">   <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></div><div class="line">   <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></div></pre></td></tr></table></figure>
<p>假如我们认为饲料对体重的影响和性别对体重的影响（这只是假设）是相同的，那么我们就可以构建一个线性模型，如下所示： <span class="math display">\[
Y_{i}=\beta_{0}+\beta_{1} x_{i, 1}+\beta_{2} x_{i, 2}+\varepsilon_{i}
\]</span> 现在我们在R中对这个模型进行拟合，此时我们需要添加另外一个变量来构建一个设计矩阵，如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">diet &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">sex &lt;- factor(c(<span class="string">"f"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>,<span class="string">"f"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>))</div><div class="line">model.matrix(~ diet + sex)</div></pre></td></tr></table></figure></p>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; diet &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">&gt; sex &lt;- factor(c(<span class="string">"f"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>,<span class="string">"f"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>))</div><div class="line">&gt; model.matrix(~ diet + sex)</div><div class="line">  (Intercept) diet2 sexm</div><div class="line"><span class="number">1</span>           <span class="number">1</span>     <span class="number">0</span>    <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>     <span class="number">0</span>    <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>     <span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>     <span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">5</span>           <span class="number">1</span>     <span class="number">1</span>    <span class="number">0</span></div><div class="line"><span class="number">6</span>           <span class="number">1</span>     <span class="number">1</span>    <span class="number">0</span></div><div class="line"><span class="number">7</span>           <span class="number">1</span>     <span class="number">1</span>    <span class="number">1</span></div><div class="line"><span class="number">8</span>           <span class="number">1</span>     <span class="number">1</span>    <span class="number">1</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$diet</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div><div class="line"></div><div class="line">attr(,<span class="string">"contrasts"</span>)$sex</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<p>这个设计矩阵包含一个截矩(intercept)，一个饲料变量(diet)，一个性别变量(sex)。我们可以说这个线性模型解释了组间差异与条件变量的差异。但是，如上所述，这个模型成立的前提是，我们假设了饮食和性别的差异会对小鼠的体重产生相同的影响。我们称这些情况为累加效应(additive effect)。对于每一个变量，我们添加一个效应时，不用考虑其它的变量是什么。针对这种情况，还有一种线性模型，这种线性模型里还会考虑两个变量之间的潜在交互作用。</p>
<p>如果我们要考虑交互作用的话，模型的构建如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">model.matrix(~ diet + sex + diet:sex)</div><div class="line"><span class="comment"># OR</span></div><div class="line"><span class="comment"># model.matrix(~ diet*sex)</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line">&gt; model.matrix(~ diet + sex + diet:sex)</div><div class="line">  (Intercept) diet2 sexm diet2:sexm</div><div class="line"><span class="number">1</span>           <span class="number">1</span>     <span class="number">0</span>    <span class="number">0</span>          <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>     <span class="number">0</span>    <span class="number">0</span>          <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>     <span class="number">0</span>    <span class="number">1</span>          <span class="number">0</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>     <span class="number">0</span>    <span class="number">1</span>          <span class="number">0</span></div><div class="line"><span class="number">5</span>           <span class="number">1</span>     <span class="number">1</span>    <span class="number">0</span>          <span class="number">0</span></div><div class="line"><span class="number">6</span>           <span class="number">1</span>     <span class="number">1</span>    <span class="number">0</span>          <span class="number">0</span></div><div class="line"><span class="number">7</span>           <span class="number">1</span>     <span class="number">1</span>    <span class="number">1</span>          <span class="number">1</span></div><div class="line"><span class="number">8</span>           <span class="number">1</span>     <span class="number">1</span>    <span class="number">1</span>          <span class="number">1</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$diet</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div><div class="line"></div><div class="line">attr(,<span class="string">"contrasts"</span>)$sex</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<h2 id="指定比较水平relevel">指定比较水平relevel()</h2>
<p>在构建设计矩阵时，我们所选水平的参考水平用于比较。默认情况下，我们都是按照第1个水平因素进行比较，但是我们可以使用<code>relevel()</code>函数来指定哪个水平因素作用为对照，例如我们选择第2组作为参考水平，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">group &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">group &lt;- relevel(group, <span class="string">"2"</span>)</div><div class="line">model.matrix(~ group)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; model.matrix(~ group)</div><div class="line">  (Intercept) group1</div><div class="line"><span class="number">1</span>           <span class="number">1</span>      <span class="number">1</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>      <span class="number">1</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>      <span class="number">0</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$group</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<p>这里涉及了<code>relevel</code>函数，此函数信息如下所示：</p>
<h3 id="relevel函数">relevel()函数</h3>
<p>全称reorder levels of factor，函数的功能是：对一个因子的水平重新排序，以通过指定<code>ref</code>来指定第1个水平作为参考水平（例如在回归中使用二元解释变量，可以指定哪个水平作为参考水平），其余的往后移。在<code>contr.treatment</code>对照中非常有用，<code>contr.treatment</code>通常会将第1个水平当作参考水平。 用法： <code>relevel(x,ref,...)</code>，其中x是一个未排序的因子，ref：指定的参考水平，通常是一个字符串。</p>
<p>或者是在<code>factor()</code>中直接明确地指出，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">group &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">group &lt;- factor(group, levels=c(<span class="string">"1"</span>,<span class="string">"2"</span>))</div><div class="line">model.matrix(~ group)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; group &lt;- factor(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">&gt; group &lt;- factor(group, levels=c(<span class="string">"1"</span>,<span class="string">"2"</span>))</div><div class="line">&gt; model.matrix(~ group)</div><div class="line">  (Intercept) group2</div><div class="line"><span class="number">1</span>           <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>      <span class="number">0</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>      <span class="number">1</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>      <span class="number">1</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></div><div class="line">attr(,<span class="string">"contrasts"</span>)</div><div class="line">attr(,<span class="string">"contrasts"</span>)$group</div><div class="line">[<span class="number">1</span>] <span class="string">"contr.treatment"</span></div></pre></td></tr></table></figure>
<h2 id="model.matrix的计算"><code>model.matrix</code>的计算</h2>
<p><code>model.matrix()</code>函数会捕获R全局环境中的变量，除非这些数据已经作为数据框的形式提供给到<code>model.matrix()</code>函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group &lt;- <span class="number">1</span>:<span class="number">4</span></div><div class="line">model.matrix(~ group, data=data.frame(group=<span class="number">5</span>:<span class="number">8</span>))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; group &lt;- <span class="number">1</span>:<span class="number">4</span></div><div class="line">&gt; model.matrix(~ group, data=data.frame(group=<span class="number">5</span>:<span class="number">8</span>))</div><div class="line">  (Intercept) group</div><div class="line"><span class="number">1</span>           <span class="number">1</span>     <span class="number">5</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span>     <span class="number">6</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span>     <span class="number">7</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span>     <span class="number">8</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="连续型变量">连续型变量</h2>
<p>前面内容中的变量都是指示数据（有的统计学书中指的是分类变量，哑变量），而在一些实验设计中，我们研究的是数值型变量（连续型变量），不需要将它们转换到第1列。例如在自由落体实验中，时间是一个连续型变量，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=<span class="number">4</span>)</div><div class="line">model.matrix(~ tt + I(tt^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=<span class="number">4</span>)</div><div class="line">&gt; model.matrix(~ tt + I(tt^<span class="number">2</span>))</div><div class="line">  (Intercept)       tt   I(tt^<span class="number">2</span>)</div><div class="line"><span class="number">1</span>           <span class="number">1</span> <span class="number">0.000000</span>  <span class="number">0.000000</span></div><div class="line"><span class="number">2</span>           <span class="number">1</span> <span class="number">1.133333</span>  <span class="number">1.284444</span></div><div class="line"><span class="number">3</span>           <span class="number">1</span> <span class="number">2.266667</span>  <span class="number">5.137778</span></div><div class="line"><span class="number">4</span>           <span class="number">1</span> <span class="number">3.400000</span> <span class="number">11.560000</span></div><div class="line">attr(,<span class="string">"assign"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></div></pre></td></tr></table></figure>
<p>在这个模型里，我们用到了<code>I()</code>函数，<code>I()</code>的功能是，对一个变量进行数学变换，在上面的公式里，<code>I(tt^2)</code>的意思是就是，通过<code>I()</code>，将<code>tt^2</code>这个变量当作是一个变量，如果不加<code>I()</code>，则是单纯地计算<code>tt^2</code>的值。查看<code>I()</code>的文档就可以发现，这个函数的全称是<code>Inhibit Interpretation/Conversion of Objects</code>。</p>
<p>在生命科学中，我们还有可能会涉及这样一种情况，例如我们想研究一个药物的量效关系，例如研究这个药物在0mg，10mg和20mg时的效果。 将连续型数据强制作为变量很难进行分析。这就是为什么指示变量只是假设2组的均值不同，而连续型变量会假设预测测变量和结果之间存在着某种特定的关系。</p>
<p>在自由落体实验中，我们有重力加速度这个理论的支持。而在父子身高案例中，由于这些数据是二元正态分布变量，如果我们加上一些条件的话，父子之间的身高存在着线性关系。但是，我们发现，如果不对年龄等这类变量进行“调整(adjust)”的话，并将它们包含在线性模型中，其统计结果就值得商榷。我们不支持将这样的变量加到线性模型中，除非已经有支持这种数据的模型出现。</p>
<h2 id="练习-1">练习</h2>
<p>P183</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/16/DAL/DALS010_Matrix_Algebra02_Matrix_Notation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/DAL/DALS010_Matrix_Algebra02_Matrix_Notation/" itemprop="url">DALS010-Matrix Algebra(矩阵代数)02-Matrix Notation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T12:00:00+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,386
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这一部分是《Data Analysis for the life sciences》的第4章：矩阵代数的第2小节，这一部分的主要内容涉及矩阵的表示方法。</p>
<h2 id="线性模型语言">线性模型语言</h2>
<p>线性代数的符号化实际上简化了线性模型的数学描述和操作，以及R中的代码。这一部分的练习主要是通过使用矩阵符号来表示线性模型，并使用它来解最小二乘方程。</p>
<h2 id="解方程组">解方程组</h2>
<p>数学家创建线性代数是为了解以下这样的线性方程组： <span class="math display">\[
\begin{array}{r}{a+b+c=6} \\ {3 a-2 b+c=2} \\ {2 a+b-c=1}\end{array}
\]</span> 它提供了非常有用的机制来解决这些常见问题。我们将会学习如何使用矩阵代数来表示以及求解这些方程组，如下所示： <span class="math display">\[
\left(\begin{array}{ccc}{1} &amp; {1} &amp; {1} \\ {3} &amp; {-2} &amp; {1} \\ {2} &amp; {1} &amp; {-1}\end{array}\right)\left(\begin{array}{l}{a} \\ {b} \\ {c}\end{array}\right)=\left(\begin{array}{l}{6} \\ {2} \\ {1}\end{array}\right) \Rightarrow\left(\begin{array}{l}{a} \\ {b} \\ {c}\end{array}\right)=\left(\begin{array}{ccc}{1} &amp; {1} &amp; {1} \\ {3} &amp; {-2} &amp; {1} \\ {2} &amp; {1} &amp; {-1}\end{array}\right)^{-1}\left(\begin{array}{l}{6} \\ {2} \\ {1}\end{array}\right)
\]</span> 这一部分就是要解释上面的这些符号是什么意思，以及在统计学中如何用这些符号来计算线性方程。</p>
<h2 id="向量矩阵与标量">向量，矩阵与标量</h2>
<p>线性代数中的基本元素包括向量(vector)，矩阵(matrix)和标题(scalar)。</p>
<h3 id="向量">向量</h3>
<p>在自由落体运行，父子身高以及小鼠体重实验中，与这些数据有关的随机变量我们通常用<span class="math inline">\(Y_{1}, \ldots, Y_{n}\)</span>来表示，我们可以将它们视为一个向量(Vector)，其实R中就是这么干的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">y=father.son$fheight</div><div class="line">head(y)</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; head(y)</div><div class="line">[<span class="number">1</span>] <span class="number">65.04851</span> <span class="number">63.25094</span> <span class="number">64.95532</span> <span class="number">65.75250</span> <span class="number">61.13723</span> <span class="number">63.02254</span></div></pre></td></tr></table></figure>
<h3 id="矩阵">矩阵</h3>
<p>在数学中，我们可以只用一个符号来表示向量，我们通常用一个加粗的黑体字母，即<span class="math inline">\(\mathbf{Y}\)</span>来表示向量，从而将它与<span class="math inline">\(Y\)</span>区分开来，如下所示： <span class="math display">\[
\mathbf{Y}=\left(\begin{array}{c}{Y_{1}} \\ {Y_{2}} \\ {\vdots} \\ {Y_{N}}\end{array}\right)
\]</span> 因此，我们知道，一个数据向量的默认就是<span class="math inline">\(N \times 1\)</span>维，而不是<span class="math inline">\(1 \times N\)</span>维。这里不使用加粗字母是因为，在文中通常会告诉我们这是一个矩阵，而不是一个向量。类似的，我们可以使用数学符合来表示协方差(covariates)或预测因子(predictors)，如果我们有两个预测因子，那么就可以按以下形式表示： <span class="math display">\[
\mathrm{X}_{1}=\left(\begin{array}{c}{x_{1,1}} \\ {\vdots} \\ {x_{N, 1}}\end{array}\right) \text { and } \mathrm{X}_{2}=\left(\begin{array}{c}{x_{1,2}} \\ {\vdots} \\ {x_{N, 2}}\end{array}\right)
\]</span> 在自由落体案例中，<span class="math inline">\(x_{1,1}=t_{i}\)</span>，<span class="math inline">\(x_{i, 1}=t_{i}^{2}\)</span>，其中，<span class="math inline">\(t_{i}\)</span>表示的是第i次的观测值，这里再强调一次，向量可以被视为<span class="math inline">\(N \times 1\)</span>矩阵。因此上面的两个预测因子可以转换为矩阵，如下所示： <span class="math display">\[
\mathbf{X}=\left[\mathbf{X}_{1} \mathbf{X}_{2}\right]=\left(\begin{array}{cc}{x_{1,1}} &amp; {x_{1,2}} \\ {\vdots} \\ {x_{N, 1}} &amp; {x_{N, 2}}\end{array}\right)
\]</span> 此时，这个矩阵就是<span class="math inline">\(N \times 2\)</span>维，在R中，我们可以创建这个矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n &lt;- <span class="number">25</span></div><div class="line">tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n) <span class="comment">##time in secs, t is a base function</span></div><div class="line">X &lt;- cbind(X1=tt,X2=tt^<span class="number">2</span>)</div><div class="line">head(X)</div><div class="line">dim(X)</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; head(X)</div><div class="line">            X1         X2</div><div class="line">[<span class="number">1</span>,] <span class="number">0.0000000</span> <span class="number">0.00000000</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.1416667</span> <span class="number">0.02006944</span></div><div class="line">[<span class="number">3</span>,] <span class="number">0.2833333</span> <span class="number">0.08027778</span></div><div class="line">[<span class="number">4</span>,] <span class="number">0.4250000</span> <span class="number">0.18062500</span></div><div class="line">[<span class="number">5</span>,] <span class="number">0.5666667</span> <span class="number">0.32111111</span></div><div class="line">[<span class="number">6</span>,] <span class="number">0.7083333</span> <span class="number">0.50173611</span></div><div class="line">&gt; dim(X)</div><div class="line">[<span class="number">1</span>] <span class="number">25</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>我们也可以使用这些符号来表示任意<span class="math inline">\(N \times p\)</span>维的矩阵，如下所示： <span class="math display">\[
\mathbf{X}=\left(\begin{array}{ccc}{x_{1,1}} &amp; {\dots} &amp; {x_{1, p}} \\ {x_{2,1}} &amp; {\dots} &amp; {x_{2, p}} \\ {} &amp; {\vdots} \\ {x_{N, 1}} &amp; {\dots} &amp; {x_{N, p}}\end{array}\right)
\]</span> 在R中，可以使用<code>matrix()</code>函数来创建矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">100</span>; p &lt;- <span class="number">5</span></div><div class="line">X &lt;- matrix(<span class="number">1</span>:(N*p),N,p)</div><div class="line">head(X)</div><div class="line">dim(X)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; head(X)</div><div class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span>  <span class="number">101</span>  <span class="number">201</span>  <span class="number">301</span>  <span class="number">401</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">2</span>  <span class="number">102</span>  <span class="number">202</span>  <span class="number">302</span>  <span class="number">402</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">3</span>  <span class="number">103</span>  <span class="number">203</span>  <span class="number">303</span>  <span class="number">403</span></div><div class="line">[<span class="number">4</span>,]    <span class="number">4</span>  <span class="number">104</span>  <span class="number">204</span>  <span class="number">304</span>  <span class="number">404</span></div><div class="line">[<span class="number">5</span>,]    <span class="number">5</span>  <span class="number">105</span>  <span class="number">205</span>  <span class="number">305</span>  <span class="number">405</span></div><div class="line">[<span class="number">6</span>,]    <span class="number">6</span>  <span class="number">106</span>  <span class="number">206</span>  <span class="number">306</span>  <span class="number">406</span></div><div class="line">&gt; dim(X)</div><div class="line">[<span class="number">1</span>] <span class="number">100</span>   <span class="number">5</span></div></pre></td></tr></table></figure>
<p>默认情况下，在R中，矩阵是按照列的顺序进行填充的，如果加上参数<code>byrow=TRUE</code>，则矩阵会按照行进行填充，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">100</span>; p &lt;- <span class="number">5</span></div><div class="line">X &lt;- matrix(<span class="number">1</span>:(N*p),N,p,byrow=<span class="literal">TRUE</span>)</div><div class="line">head(X)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(X)</div><div class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span>    <span class="number">5</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">6</span>    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span></div><div class="line">[<span class="number">3</span>,]   <span class="number">11</span>   <span class="number">12</span>   <span class="number">13</span>   <span class="number">14</span>   <span class="number">15</span></div><div class="line">[<span class="number">4</span>,]   <span class="number">16</span>   <span class="number">17</span>   <span class="number">18</span>   <span class="number">19</span>   <span class="number">20</span></div><div class="line">[<span class="number">5</span>,]   <span class="number">21</span>   <span class="number">22</span>   <span class="number">23</span>   <span class="number">24</span>   <span class="number">25</span></div><div class="line">[<span class="number">6</span>,]   <span class="number">26</span>   <span class="number">27</span>   <span class="number">28</span>   <span class="number">29</span>   <span class="number">30</span></div></pre></td></tr></table></figure>
<h3 id="标量">标量</h3>
<p>标量仅仅是一个数字，通常使用小写字母来表示标量，并且不加粗。</p>
<h2 id="练习">练习</h2>
<p>P157</p>
<h2 id="数学运算">数学运算</h2>
<p>前面我们提到了一个方程组，如下所示： <span class="math display">\[
\begin{aligned} a+b+c &amp;=6 \\ 3 a-2 b+c &amp;=2 \\ 2 a+b-c &amp;=1 \end{aligned}
\]</span> 如果用矩阵代数来表示，就是下面的形式： <span class="math display">\[
\left(\begin{array}{ccc}{1} &amp; {1} &amp; {1} \\ {3} &amp; {-2} &amp; {1} \\ {2} &amp; {1} &amp; {-1}\end{array}\right)\left(\begin{array}{l}{a} \\ {b} \\ {c}\end{array}\right)=\left(\begin{array}{l}{6} \\ {2} \\ {1}\end{array}\right) \Rightarrow\left(\begin{array}{l}{a} \\ {b} \\ {c}\end{array}\right)=\left(\begin{array}{ccc}{1} &amp; {1} &amp; {1} \\ {3} &amp; {-2} &amp; {1} \\ {2} &amp; {1} &amp; {-1}\end{array}\right)^{-1}\left(\begin{array}{l}{6} \\ {2} \\ {1}\end{array}\right)
\]</span></p>
<h2 id="矩阵与标量相乘">矩阵与标量相乘</h2>
<p>这是矩阵运算中最简单的操作，一个矩阵<span class="math inline">\(\mathbf{X}\)</span>与一个标量<span class="math inline">\(a\)</span>相乘，矩阵的每一个元素都与这个标量相乘，如下所示： <span class="math display">\[
\mathbf{X}=\left(\begin{array}{ccc}{x_{1,1}} &amp; {\dots} &amp; {x_{1, p}} \\ {x_{2,1}} &amp; {\dots} &amp; {x_{2, p}} \\ {} &amp; {\vdots} &amp; {} \\ {x_{N, 1}} &amp; {\dots} &amp; {x_{N, p}}\end{array}\right) \Rightarrow a \mathbf{X}=\left(\begin{array}{ccc}{a x_{1,1}} &amp; {\dots} &amp; {a x_{1, p}} \\ {a x_{2,1}} &amp; {\dots} &amp; {a x_{2, p}} \\ {} &amp; {\vdots} \\ {a_{N, 1}} &amp; {\dots} &amp; {a x_{N, p}}\end{array}\right)
\]</span> R中的运算会自动遵循这个规则，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">X &lt;- matrix(<span class="number">1</span>:<span class="number">12</span>,<span class="number">4</span>,<span class="number">3</span>)</div><div class="line">print(X)</div><div class="line">a &lt;- <span class="number">2</span></div><div class="line">print(a*X)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; X &lt;- matrix(<span class="number">1</span>:<span class="number">12</span>,<span class="number">4</span>,<span class="number">3</span>)</div><div class="line">&gt; print(X)</div><div class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">5</span>    <span class="number">9</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">6</span>   <span class="number">10</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">7</span>   <span class="number">11</span></div><div class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">8</span>   <span class="number">12</span></div><div class="line">&gt; a &lt;- <span class="number">2</span></div><div class="line">&gt; print(a*X)</div><div class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">2</span>   <span class="number">10</span>   <span class="number">18</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">4</span>   <span class="number">12</span>   <span class="number">20</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">6</span>   <span class="number">14</span>   <span class="number">22</span></div><div class="line">[<span class="number">4</span>,]    <span class="number">8</span>   <span class="number">16</span>   <span class="number">24</span></div></pre></td></tr></table></figure>
<h2 id="转置transpose">转置(Transpose)</h2>
<p>矩阵的转置就是将矩阵的行与列颠倒，通常使用<span class="math inline">\(T\)</span>这个符号表示矩阵的转置运算，如下所示： <span class="math display">\[
\mathbf{X}=\left(\begin{array}{ccc}{x_{1,1}} &amp; {\ldots} &amp; {x_{1, p}} \\ {x_{2,1}} &amp; {\ldots} &amp; {x_{2, p}} \\ {} &amp; {\vdots} &amp; {} \\ {x_{N, 1}} &amp; {\ldots} &amp; {x_{N, p}}\end{array}\right) \Rightarrow \mathbf{X}^{\top}=\left(\begin{array}{ccc}{x_{1,1}} &amp; {\ldots} &amp; {x_{p, 1}} \\ {x_{1,2}} &amp; {\ldots} &amp; {x_{p, 2}} \\ {} &amp; {\vdots} &amp; {} \\ {x_{1, N}} &amp; {\ldots} &amp; {x_{p, N}}\end{array}\right)
\]</span> 在R中，直接使用<code>t()</code>函数就行，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X &lt;- matrix(<span class="number">1</span>:<span class="number">12</span>,<span class="number">4</span>,<span class="number">3</span>)</div><div class="line">X</div><div class="line">t(X)</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; X &lt;- matrix(<span class="number">1</span>:<span class="number">12</span>,<span class="number">4</span>,<span class="number">3</span>)</div><div class="line">&gt; X</div><div class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">5</span>    <span class="number">9</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">6</span>   <span class="number">10</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">7</span>   <span class="number">11</span></div><div class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">8</span>   <span class="number">12</span></div><div class="line">&gt; t(X)</div><div class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">5</span>    <span class="number">6</span>    <span class="number">7</span>    <span class="number">8</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">9</span>   <span class="number">10</span>   <span class="number">11</span>   <span class="number">12</span></div></pre></td></tr></table></figure>
<h2 id="矩阵的相乘">矩阵的相乘</h2>
<p>还以开始三元一次方程组为例说明一下，如下所示： <span class="math display">\[
\begin{array}{r}{a+b+c=6} \\ {3 a-2 b+c=2} \\ {2 a+b-c=1}\end{array}
\]</span></p>
<p>两个矩阵相乘的运算法则是，第1个矩阵的行乘以第2个矩阵的列（第1个矩阵的列数与第2个矩阵的行数相同）。由于第2个矩阵只有1列，因此相乘的结果如下所示： <span class="math display">\[
\left(\begin{array}{ccc}{1} &amp; {1} &amp; {1} \\ {3} &amp; {-2} &amp; {1} \\ {2} &amp; {1} &amp; {-1}\end{array}\right)\left(\begin{array}{l}{a} \\ {b} \\ {c}\end{array}\right)=\left(\begin{array}{c}{a+b+c} \\ {3 a-2 b+c} \\ {2 a+b-c}\end{array}\right)
\]</span> 下面我们在R中计算一下，我们来看一下<code>abc=c(3,2,1)</code>是否是上述方程组的一个解，计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X &lt;- matrix(c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>),<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">abc &lt;- c(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>) <span class="comment">#use as an example</span></div><div class="line">rbind( sum(X[<span class="number">1</span>,]*abc), sum(X[<span class="number">2</span>,]*abc), sum(X[<span class="number">3</span>,]%*%abc))</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; rbind( sum(X[<span class="number">1</span>,]*abc), sum(X[<span class="number">2</span>,]*abc), sum(X[<span class="number">3</span>,]%*%abc))</div><div class="line">     [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">6</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">6</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">7</span></div></pre></td></tr></table></figure>
<p>使用<code>%*%</code>可以进行矩阵相乘，这种方法很简单，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X%*%abc</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; X%*%abc</div><div class="line">     [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">6</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">6</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">7</span></div></pre></td></tr></table></figure>
<p>从上面结果我们可以知道，<code>c(3,2,1)</code>不是方程组的解。为了求解方程组，我们需要逆转(inverse)左边的矩阵（后面要学习的内容）。在这里，我们定义矩阵<span class="math inline">\(A\)</span>与<span class="math inline">\(X\)</span>相乘的一般规则，如下所示： <span class="math display">\[
\mathbf{A X}=\left(\begin{array}{cccc}{a_{1,1}} &amp; {a_{1,2}} &amp; {\dots} &amp; {a_{1, N}} \\ {a_{2,1}} &amp; {a_{2,2}} &amp; {\dots} &amp; {a_{2, N}} \\ {} &amp; {} &amp; {\vdots} \\ {a_{M, 1}} &amp; {a_{M, 2}} &amp; {\dots} &amp; {a_{M, N}}\end{array}\right)\left(\begin{array}{ccc}{x_{1,1}} &amp; {\dots} &amp; {x_{1, p}} \\ {x_{2,1}} &amp; {\dots} &amp; {x_{2, p}} \\ {} &amp; {\vdots} \\ {x_{N, 1}} &amp; {\dots} &amp; {x_{N, p}}\end{array}\right)\\=\left(\begin{array}{ccc}{\sum_{i=1}^{N} a_{1, i} x_{i, 1}} &amp; {\ldots} &amp; {\sum_{i=1}^{N} a_{1, i} x_{i, p}} \\ {} &amp; {\vdots} &amp; {} \\ {\sum_{i=1}^{N} a_{M, i} x_{i, 1}} &amp; {\ldots} &amp; {\sum_{i=1}^{N} a_{M, i} x_{i, p}}\end{array}\right)
\]</span> 只有当矩阵<span class="math inline">\(A\)</span>的列数与矩阵<span class="math inline">\(X\)</span>的行数相等时，才能得到两个矩阵相乘的结果。</p>
<h2 id="单位矩阵the-identity-matrix">单位矩阵(The identity matrix)</h2>
<p>在矩阵代数中，单位矩阵的意义与1类似，一个矩阵乘以单位矩阵，还是其本身，单位矩阵的定义如下所示： <span class="math display">\[
\mathbf{I}=\left(\begin{array}{cccccc}{1} &amp; {0} &amp; {0} &amp; {\ldots} &amp; {0} &amp; {0} \\ {0} &amp; {1} &amp; {0} &amp; {\ldots} &amp; {0} &amp; {0} \\ {0} &amp; {0} &amp; {1} &amp; {\ldots} &amp; {0} &amp; {0} \\ {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} &amp; {\vdots} \\ {0} &amp; {0} &amp; {0} &amp; {\ldots} &amp; {1} &amp; {0} \\ {0} &amp; {0} &amp; {0} &amp; {\ldots} &amp; {0} &amp; {1}\end{array}\right)
\]</span> 单位矩阵的行与列数目相等，从左上解到右下解的元素都为1，其余都为0。现在我们看一下一个矩阵与单位矩阵的相乘结果，如下所示： <span class="math display">\[
\mathbf{X I}=\left(\begin{array}{ccc}{x_{1,1}} &amp; {\dots} &amp; {x_{1, p}} \\ {} &amp; {\vdots} &amp; {} \\ {x_{N, 1}} &amp; {\dots} &amp; {x_{N, p}}\end{array}\right)\left(\begin{array}{cccccc}{1} &amp; {0} &amp; {0} &amp; {\dots} &amp; {0} &amp; {0} \\ {0} &amp; {1} &amp; {0} &amp; {\dots} &amp; {0} &amp; {0} \\ {0} &amp; {0} &amp; {1} &amp; {\dots} &amp; {0} &amp; {0} \\ {} &amp; {} &amp; {} &amp; {\vdots} &amp; {} \\ {0} &amp; {0} &amp; {0} &amp; {\dots} &amp; {1} &amp; {0} \\ {0} &amp; {0} &amp; {0} &amp; {\dots} &amp; {0} &amp; {1}\end{array}\right)=\left(\begin{array}{ccc}{x_{1,1}} &amp; {\dots} &amp; {x_{1, p}} \\ {} &amp; {\vdots} &amp; {} \\ {x_{N, 1}} &amp; {\dots} &amp; {x_{N, p}}\end{array}\right)
\]</span> R中可以通过<code>diag()</code>函数来生成单位矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n &lt;- <span class="number">5</span> <span class="comment">#pick dimensions</span></div><div class="line">diag(n)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; n &lt;- <span class="number">5</span> <span class="comment">#pick dimensions</span></div><div class="line">&gt; diag(n)</div><div class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span></div><div class="line">[<span class="number">4</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span></div><div class="line">[<span class="number">5</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="矩阵的逆转inverse">矩阵的逆转(inverse)</h2>
<p>矩阵<span class="math inline">\(X\)</span>的逆转可以表示为<span class="math inline">\(X^{-1}\)</span>，逆转后的矩阵与原矩阵相乘，会得到单位矩阵，即<span class="math inline">\(X^{-1} X=I\)</span>，但是，并非所有的矩阵都可以逆转（逆转后的矩阵称为逆矩阵）。</p>
<p>当我们计算一个线性模型时，就要用到逆矩阵。在R中可以使用<code>solve()</code>函数来进行运算，<code>solve()</code>函数就是计算一个矩阵的逆矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">X &lt;- matrix(c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>),<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">y &lt;- matrix(c(<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>),<span class="number">3</span>,<span class="number">1</span>)</div><div class="line">solve(X)</div><div class="line">solve(X)%*%y <span class="comment">#equivalent to solve(X,y)</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; solve(X)</div><div class="line">           [,<span class="number">1</span>]        [,<span class="number">2</span>]       [,<span class="number">3</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">0.07692308</span>  <span class="number">0.15384615</span>  <span class="number">0.2307692</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.38461538</span> -<span class="number">0.23076923</span>  <span class="number">0.1538462</span></div><div class="line">[<span class="number">3</span>,] <span class="number">0.53846154</span>  <span class="number">0.07692308</span> -<span class="number">0.3846154</span></div><div class="line">&gt; solve(X)%*%y <span class="comment">#equivalent to solve(X,y)</span></div><div class="line">     [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">2</span></div><div class="line">[<span class="number">3</span>,]    <span class="number">3</span></div></pre></td></tr></table></figure>
<h2 id="练习-1">练习</h2>
<p>P163</p>
<h2 id="矩阵案例">矩阵案例</h2>
<p>前面内容是关于矩阵的简单案例，以及它们在数据分析过程中的重要作用。我们最终要达到的目标是：如何使用矩阵代数符号来描述线性模型以及求解最小二乘问题。</p>
<h3 id="均值">均值</h3>
<p>为了计算样本的均值和方差，例如我们使用<span class="math inline">\(\overline{Y}=\frac{1}{N} Y_{i}\)</span>来计算均值，使用<span class="math inline">\(\operatorname{var}(Y)=\frac{1}{N} \sum_{i=1}^{N}\left(Y_{i}-\overline{Y}\right)^{2}\)</span>来计算方差。我们也可以使用矩阵乘法来计睡这些结果。</p>
<p>第一步：定义一个<span class="math inline">\(N\times1\)</span>矩阵，它只有1列，如下所示： <span class="math display">\[
A=\left(\begin{array}{l}{1} \\ {1} \\ {\vdots} \\ {1}\end{array}\right)
\]</span> 我们可以使用下面的公式来计算均值： <span class="math display">\[
\frac{1}{N} \mathbf{A}^{\top} Y=\frac{1}{N}\left(\begin{array}{llll}{1} &amp; {1} &amp; {\ldots} &amp; {1}\end{array}\right)\left(\begin{array}{l}{Y_{1}} \\ {Y_{2}} \\ {\vdots} \\ {Y_{N}}\end{array}\right)=\frac{1}{N} \sum_{i=1}^{N} Y_{i}=\overline{Y}
\]</span> 从上面的公式我们可以看到，里面乘了一个标量，即<span class="math inline">\(1/N\)</span>，在R中，可以使用<code>%*%</code>来实现，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">y &lt;- father.son$sheight</div><div class="line">print(mean(y))</div><div class="line">N &lt;- length(y)</div><div class="line">Y&lt;- matrix(y,N,<span class="number">1</span>)</div><div class="line">A &lt;- matrix(<span class="number">1</span>,N,<span class="number">1</span>)</div><div class="line">barY=t(A)%*%Y / N</div><div class="line">print(barY)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(UsingR)</div><div class="line">&gt; y &lt;- father.son$sheight</div><div class="line">&gt; print(mean(y))</div><div class="line">[<span class="number">1</span>] <span class="number">68.68407</span></div><div class="line">&gt; N &lt;- length(y)</div><div class="line">&gt; Y&lt;- matrix(y,N,<span class="number">1</span>)</div><div class="line">&gt; A &lt;- matrix(<span class="number">1</span>,N,<span class="number">1</span>)</div><div class="line">&gt; barY=t(A)%*%Y / N</div><div class="line">&gt; print(barY)</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">68.68407</span></div></pre></td></tr></table></figure>
<h3 id="方差">方差</h3>
<p>在统计学中，常常会用到矩阵转置后的相乘，而在R中，可以直接进行运算，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">barY=crossprod(A,Y) / N</div><div class="line">print(barY)</div><div class="line">barY2 &lt;- t(A)%*%Y/N</div><div class="line">print(barY2)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; print(barY)</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">68.68407</span></div><div class="line">&gt; barY2 &lt;- t(A)%*%Y/N</div><div class="line">&gt; print(barY2)</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">68.68407</span></div></pre></td></tr></table></figure>
<p>在计算方差时，公式如下所示： <span class="math display">\[
\mathbf{r} \equiv\left(\begin{array}{c}{Y_{1}-\overline{Y}} \\ {\vdots} \\ {Y_{N}-\overline{Y}}\end{array}\right), \frac{1}{N} \mathbf{r}^{\top} \mathbf{r}=\frac{1}{N} \sum_{i=1}^{N}\left(Y_{i}-\overline{Y}\right)^{2}
\]</span> 在R中，如果<code>crossprod()</code>函数只有一个矩阵参数，那么计算的就是<span class="math inline">\(r^{\top} r\)</span>，可以简单地写为以下形式：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r &lt;- y - barY</div><div class="line">crossprod(r)/N</div><div class="line">t(r)%*%r/N</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; crossprod(r)/N</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">7.915196</span></div><div class="line">&gt; t(r)%*%r/N</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">7.915196</span></div></pre></td></tr></table></figure>
<p>上述计算过程也等于以下形式：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">popvar(y)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; popvar(y)</div><div class="line">[<span class="number">1</span>] <span class="number">7.915196</span></div></pre></td></tr></table></figure>
<h2 id="线性模型">线性模型</h2>
<p>现在我们应用一下线性模型，还以Galton的案例为例说明一下，我们先定义以下矩阵： <span class="math display">\[
\mathbf{Y}=\left(\begin{array}{c}{Y_{1}} \\ {Y_{2}} \\ {\vdots} \\ {Y_{N}}\end{array}\right), \mathbf{X}=\left(\begin{array}{cc}{1} &amp; {x_{1}} \\ {1} &amp; {x_{2}} \\ {\vdots} &amp; {} \\ {1} &amp; {x_{N}}\end{array}\right), \beta=\left(\begin{array}{c}{\beta_{0}} \\ {\beta_{1}}\end{array}\right) \text { and } \varepsilon=\left(\begin{array}{c}{\varepsilon_{1}} \\ {\varepsilon_{2}} \\ {\vdots} \\ {\varepsilon_{N}}\end{array}\right)
\]</span> 然后写出线性模型，如下所示： <span class="math display">\[
Y_{i}=\beta_{0}+\beta_{1} x_{i}+\varepsilon, i=1, \ldots, N
\]</span> 它等于以下形式： <span class="math display">\[
\left(\begin{array}{c}{Y_{1}} \\ {Y_{2}} \\ {\vdots} \\ {Y_{N}}\end{array}\right)=\left(\begin{array}{cc}{1} &amp; {x_{1}} \\ {1} &amp; {x_{2}} \\ {\vdots} &amp; {} \\ {1} &amp; {x_{N}}\end{array}\right)\left(\begin{array}{c}{\beta_{0}} \\ {\beta_{1}}\end{array}\right)+\left(\begin{array}{c}{\varepsilon_{1}} \\ {\varepsilon_{2}} \\ {\vdots} \\ {\varepsilon_{N}}\end{array}\right)
\]</span> 简化一下，就是下面的形式： <span class="math display">\[
\mathrm{Y}=\mathrm{X} \beta+\varepsilon
\]</span> 那么最小二乘方程就变得比较简单，如下所示： <span class="math display">\[
(\mathrm{Y}-\mathrm{X} \boldsymbol{\beta})^{\top}(\mathrm{Y}-\mathrm{X} \boldsymbol{\beta})
\]</span> 现在我们计算的目标就是，找到<span class="math inline">\(\beta\)</span>的值，使得上述方程的值最小，我们可以使用微积分的手段来进行计算。</p>
<h2 id="线性模型的微积分计算">线性模型的微积分计算</h2>
<p>在使用矩阵符号来计算偏微分方程(partial derivative equation)时，需要遵循几个规则。通过当微分方程为0时，计算出<span class="math inline">\(\beta\)</span>，这个就是我们要求的解。在这里，我们上述的微分方程是以下形式： <span class="math display">\[
\begin{array}{c}{2 \mathbf{X}^{\top}(\mathbf{Y}-\mathbf{X} \hat{\boldsymbol{\beta}})=0} \\ {\mathbf{X}^{\top} \mathbf{X} \hat{\boldsymbol{\beta}}=\mathbf{X}^{\top} \mathbf{Y}} \\ {\hat{\boldsymbol{\beta}}=\left(\mathbf{X}^{\top} \mathbf{X}\right)^{-1} \mathbf{X}^{\top} \mathbf{Y}}\end{array}
\]</span> 对于求出的解，也就是<span class="math inline">\(\beta\)</span>，通常在上面加一个帽子结构，即<span class="math inline">\(\hat{\beta}\)</span>，这个表示是对真实的<span class="math inline">\(\beta\)</span>值的估计。这里我们需要记住的是，最小二乘类似于一个幂运算，这个公式类似于<span class="math inline">\(f(x)^{2}\)</span>的导数2<span class="math inline">\(f(x) f^{\prime}(x)\)</span>。</p>
<h2 id="在r中计算lse">在R中计算LSE</h2>
<p>代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">x=father.son$fheight</div><div class="line">y=father.son$sheight</div><div class="line">X &lt;- cbind(<span class="number">1</span>,x)</div><div class="line">betahat &lt;- solve( t(X) %*% X ) %*% t(X) %*% y</div><div class="line"><span class="comment">###or</span></div><div class="line">betahat &lt;- solve( crossprod(X) ) %*% crossprod( X, y )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; betahat</div><div class="line">       [,<span class="number">1</span>]</div><div class="line">  <span class="number">33.886604</span></div><div class="line">x  <span class="number">0.514093</span></div></pre></td></tr></table></figure>
<p>通过计算估计的<span class="math inline">\(\hat{\beta_{0}}+\hat{\beta_{1}}x\)</span>就能计算出相应的<span class="math inline">\(x\)</span>的值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">newx &lt;- seq(min(x),max(x),len=<span class="number">100</span>)</div><div class="line">X &lt;- cbind(<span class="number">1</span>,newx)</div><div class="line">fitted &lt;- X%*%betahat</div><div class="line">plot(x,y,xlab=<span class="string">"Father's height"</span>,ylab=<span class="string">"Son's height"</span>)</div><div class="line">lines(newx,fitted,col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816192553.jpeg">

</div>
<p>其中，<span class="math inline">\(\hat{\boldsymbol{\beta}}=\left(\mathbf{X}^{\top} \mathbf{X}\right)^{-1} \mathbf{X}^{\top} \mathbf{Y}\)</span>是数据分析中最常用的公式之一，它的一大优势就是可以应用于多种情况，例如在自由落体运算中：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">g &lt;- <span class="number">9.8</span> <span class="comment">#meters per second</span></div><div class="line">n &lt;- <span class="number">25</span></div><div class="line">tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n) <span class="comment">#time in secs, t is a base function</span></div><div class="line">d &lt;- <span class="number">56.67</span> - <span class="number">0.5</span>*g*tt^<span class="number">2</span> + rnorm(n,sd=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>我们几乎用了与前面相同的代码，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">X &lt;- cbind(<span class="number">1</span>,tt,tt^<span class="number">2</span>)</div><div class="line">y &lt;- d</div><div class="line">betahat &lt;- solve(crossprod(X))%*%crossprod(X,y)</div><div class="line">newtt &lt;- seq(min(tt),max(tt),len=<span class="number">100</span>)</div><div class="line">X &lt;- cbind(<span class="number">1</span>,newtt,newtt^<span class="number">2</span>)</div><div class="line">fitted &lt;- X%*%betahat</div><div class="line">plot(tt,y,xlab=<span class="string">"Time"</span>,ylab=<span class="string">"Height"</span>)</div><div class="line">lines(newtt,fitted,col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816192833.jpeg">

</div>
<p>最终的估计值为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; betahat</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">   <span class="number">56.5317368</span></div><div class="line">tt  <span class="number">0.5013565</span></div><div class="line">   -<span class="number">5.0386455</span></div></pre></td></tr></table></figure>
<h2 id="lm函数"><code>lm()</code>函数</h2>
<p>现在我们使用<code>lm()</code>函数来计算一下自由落体运动，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X &lt;- cbind(tt,tt^<span class="number">2</span>)</div><div class="line">fit=lm(y~X)</div><div class="line">summary(fit)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; summary(fit)</div><div class="line"></div><div class="line">Call:</div><div class="line">lm(formula = y ~ X)</div><div class="line"></div><div class="line">Residuals:</div><div class="line">    Min      1Q  Median      3Q     Max </div><div class="line">-<span class="number">2.5295</span> -<span class="number">0.4882</span>  <span class="number">0.2537</span>  <span class="number">0.6560</span>  <span class="number">1.5455</span> </div><div class="line"></div><div class="line">Coefficients:</div><div class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </div><div class="line">(Intercept)  <span class="number">56.5317</span>     <span class="number">0.5451</span> <span class="number">103.701</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">Xtt           <span class="number">0.5014</span>     <span class="number">0.7426</span>   <span class="number">0.675</span>    <span class="number">0.507</span>    </div><div class="line">X            -<span class="number">5.0386</span>     <span class="number">0.2110</span> -<span class="number">23.884</span>   &lt;<span class="number">2e-16</span> ***</div><div class="line">---</div><div class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></div><div class="line"></div><div class="line">Residual standard error: <span class="number">0.9822</span> on <span class="number">22</span> degrees of freedom</div><div class="line">Multiple R-squared:  <span class="number">0.9973</span>,	Adjusted R-squared:  <span class="number">0.997</span> </div><div class="line"><span class="literal">F</span>-statistic:  <span class="number">4025</span> on <span class="number">2</span> and <span class="number">22</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></div></pre></td></tr></table></figure>
<p>这个结果与前面的计算结果一致。</p>
<h2 id="总结">总结</h2>
<p>在这一部分中，我们学习了如何使用线性代数来描述线性模型。随后我们研究了几个案例，其中的一些是与实验设计有有。我们还演示了最小二乘估计。但是，我们需要记住，由于y是一个随机变量，这些估计也是随机的。在后面的章节中，我们将学习如何计算这些随机变量，以及随机变量的标准误以及统计推断。</p>
<h2 id="练习-2">练习</h2>
<p>P171</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/16/DAL/DALS009_Matrix_Algebra01_Motivating_Examples/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/DAL/DALS009_Matrix_Algebra01_Motivating_Examples/" itemprop="url">DALS009-Matrix Algebra(矩阵代数)01-简单线性回归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T12:00:00+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,982
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是《Data Analysis for the Life Sciences》的第4章：矩阵代数的第1部分。这一部分的主要内容涉及线性方程的简单理解。</p>
<h2 id="简单案例">简单案例</h2>
<p>在这一部分中，我们将会提到3个例子，第1个来源于物理学(physics)，一个来源于遗传学(genetics)，一具是来源于小鼠实验(mouse experiment)。这3个例子明显不同，但是在分析数据中却都用了相同的统计学方法：拟合线性模型(fitting linear models)。在学习线性模型时，通常使用矩阵代数(Matrix Algebra)来进行讲解和描述。</p>
<h2 id="第1案例-自由落体">第1案例-自由落体</h2>
<p>先来看第1个案例，这个案例是与物理学有关。</p>
<p>试想，你是16世纪的伽里略(Galileo)，你想要描述一个自由落体物体的速度(velocity)。此时，一个助手爬上比萨斜塔，并在上面松开手，落下一个球，同时其他的助手记录一下球在不同时间点的位置。此时，我们就来模拟一下这个过程，在模拟的这个过程里，由于我们已经知道了自由落体运动的公式，因此我们会向这个模拟数据里添加一些检测误差，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">g &lt;- <span class="number">9.8</span> <span class="comment">##meters per second</span></div><div class="line">n &lt;- <span class="number">25</span></div><div class="line">tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n) <span class="comment">##time in secs, note: we use tt because t is a base function</span></div><div class="line">d &lt;- <span class="number">56.67</span> - <span class="number">0.5</span>*g*tt^<span class="number">2</span> + rnorm(n,sd=<span class="number">1</span>) <span class="comment">##meters</span></div></pre></td></tr></table></figure>
<p>现在绘制出助手们记录的不同时间点的球的位置，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">plot(tt,d,ylab=<span class="string">"Distance in meters"</span>,xlab=<span class="string">"Time in seconds"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816133037.jpeg">

</div>
<p>假如助手不知道准确的自由落体运行，但是通过观察这个图形，他大致可以推导出这个位置-时间关系应该遵循抛物线，因此可以对上述的数据进行建模，如下所示：</p>
<p><span class="math display">\[
Y_i = \beta_0 + \beta_1 x_i + \beta_2 x_i^2 + \varepsilon_i, i=1,\dots,n
\]</span></p>
<p>其中， <span class="math inline">\(Y_i\)</span> 代表了球的位置， <span class="math inline">\(x_i\)</span> 代表了时间， <span class="math inline">\(\varepsilon_i\)</span> 表示测量误差。这是一个线性模型，因为这个方程是一个已知量（也就是一系列的<span class="math inline">\(x\)</span>，即预测因子(predictors)或协变量(covariates)）和一个未知量（即一系列的<span class="math inline">\(\beta\)</span>）的线性组合。</p>
<h2 id="第2案例-父子身高">第2案例-父子身高</h2>
<p>再来看第2个案例， 这个案例与遗传学有关。</p>
<p>试想，你是19世纪的Francis Galton，你收集了很多对父子的身高，你怀疑身高与遗传因素有关，你的数据如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">x=father.son$fheight</div><div class="line">y=father.son$sheight</div><div class="line">plot(x,y,xlab=<span class="string">"Father's height"</span>,ylab=<span class="string">"Son's height"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816134929.png">

</div>
<p>从这个张图上我们大概能觉得，父亲身高在一定程度上影响了儿子的身高，此时我们就可以构建一个模型来描述这种情况，如下所示： <span class="math display">\[
Y_{i}=\beta_{0}+\beta_{1} x_{i}+\varepsilon, i=1, \ldots, N
\]</span></p>
<p>这也是一个线性模型，其中<span class="math inline">\(x_i\)</span> 表示了第<span class="math inline">\(i\)</span>对父亲的身高，<span class="math inline">\(Y_i\)</span>表示了第<span class="math inline">\(i\)</span>对儿子的身高。而 <span class="math inline">\(\varepsilon_i\)</span>表示其余变量。在这个案例中，我们认为父亲的身高是预测因素，并且是固定的（不是随机的），因此我们使用小写字母来表示父亲的身高。仅仅用测量误差是无法完全解释 <span class="math inline">\(\varepsilon_i\)</span>代表的变异程度，因为这个模型中并没有包含其它的变量，例如母亲的身高，遗传的随机因素以及环境因素也有可能影响儿子的身高。</p>
<h2 id="第3案例-多个总体的抽样">第3案例-多个总体的抽样</h2>
<p>第3个案例有是关小鼠实验的。还以这本书刚开始的案例说明一下，我们有两类小鼠的体重，这两类小鼠分别使用正常饲料(chow)和高脂饲料(high fat, hf)进行饲喂。现在我们从这两个种群的小鼠中各随机抽取12个样本。我们的研究重点在于，饲料的不同是否会影响小鼠的体重，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># library(devtools)</span></div><div class="line"><span class="comment"># install_github("genomicsclass/dagdata")</span></div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">list.files(dir)</div><div class="line">dir</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/femaleMiceWeights.csv"</span>)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line"><span class="comment"># input raw data</span></div><div class="line">head(dat)</div><div class="line">str(dat)</div></pre></td></tr></table></figure>
<p>数据如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; list.files(dir)</div><div class="line">[<span class="number">1</span>] <span class="string">"data"</span>        <span class="string">"DESCRIPTION"</span> <span class="string">"extdata"</span>     <span class="string">"help"</span>        <span class="string">"html"</span>       </div><div class="line">[<span class="number">6</span>] <span class="string">"Meta"</span>        <span class="string">"NAMESPACE"</span>   <span class="string">"script"</span>     </div><div class="line">&gt; dir</div><div class="line">[<span class="number">1</span>] <span class="string">"C:/Users/20161111/Documents/R/win-library/3.5/dagdata"</span></div><div class="line">&gt; filename &lt;- file.path(dir,<span class="string">"extdata/femaleMiceWeights.csv"</span>)</div><div class="line">&gt; dat &lt;- read.csv(filename)</div><div class="line">&gt; <span class="comment"># input raw data</span></div><div class="line">&gt; head(dat)</div><div class="line">  Diet Bodyweight</div><div class="line"><span class="number">1</span> chow      <span class="number">21.51</span></div><div class="line"><span class="number">2</span> chow      <span class="number">28.14</span></div><div class="line"><span class="number">3</span> chow      <span class="number">24.04</span></div><div class="line"><span class="number">4</span> chow      <span class="number">23.45</span></div><div class="line"><span class="number">5</span> chow      <span class="number">23.68</span></div><div class="line"><span class="number">6</span> chow      <span class="number">19.79</span></div><div class="line">&gt; str(dat)</div><div class="line"><span class="string">'data.frame'</span>:	<span class="number">24</span> obs. of  <span class="number">2</span> variables:</div><div class="line"> $ Diet      : Factor w/ <span class="number">2</span> levels <span class="string">"chow"</span>,<span class="string">"hf"</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ Bodyweight: num  <span class="number">21.5</span> <span class="number">28.1</span> <span class="number">24</span> <span class="number">23.4</span> <span class="number">23.7</span> <span class="keyword">...</span></div></pre></td></tr></table></figure>
<p>查看一下小鼠的体重抽样结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stripchart(Bodyweight~Diet,data=dat,vertical=<span class="literal">TRUE</span>,method=<span class="string">"jitter"</span>,pch=<span class="number">1</span>,main=<span class="string">"Mi\</span></div><div class="line"><span class="string">ce weights"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816143047.png">

</div>
<p>假如我们想要判断一下这饮食是否对小鼠的平均体重有所影响。我们可以使用t检验和置信区间来进行统计。同时我们也可以使用一个线性模型来进行精确的检验，如下所示： <span class="math display">\[
Y_{i}=\beta_{0}+\beta_{1} x_{i}+\varepsilon_{i}
\]</span> 其中<span class="math inline">\(\beta_0\)</span>表示了正常饲料饲喂的小鼠平均体重，而<span class="math inline">\(\beta_1\)</span>则表示了高脂饲料(hf)饲喂的小鼠平均体重与正常饲料饲喂小鼠体重的差值，其中 <span class="math inline">\(x_i = 1\)</span> 表示第<span class="math inline">\(i\)</span>只小鼠吃的hf饲料，<span class="math inline">\(x_i = 0\)</span> 表示小鼠吃的是正常饲料，而<span class="math inline">\(\varepsilon_i\)</span>则是说明，源于相同总体的小鼠个体差异。</p>
<p>## 线性模型的一般形式</p>
<p>通过前面的3个案例我们知道了线性模型，包含了上述统计模型的线性模型的一般形式可以写为如下公式： <span class="math display">\[
Y_{i}=\beta_{0}+\beta_{1} x_{i, 1}+\beta_{2} x_{i, 2}+\cdots+\beta_{2} x_{i, p}+\varepsilon_{i}, i=1, \ldots, n
\]</span> 即： <span class="math display">\[
Y_{i}=\beta_{0}+\sum_{j=1}^{p} \beta_{j} x_{i, j}+\varepsilon_{i}, i=1, \ldots, n
\]</span> 在这个公式里，我们使用了一个预测量<span class="math inline">\(p\)</span>，矩阵代数提供了一种精练的语言和数学框架来计算以及推导那些满足上述框架的任何线性模型。</p>
<h2 id="估计参数estimating-parameters">估计参数(Estimating parameters)</h2>
<p>当我们用上述的模型来估计未知量<span class="math inline">\(\beta\)</span>时非常有用。例如，在第1个案例中，我们通过线性模型来计算其中的未知的参数。在第2个案例中，通过估计其中的未知参数，我们可以更好地理解遗传因素(inheritance)在父子身高方面的影响。在第3个案例中，我们想研究饲料是否对小鼠的体重有影响，也就是说我们要计算出<span class="math inline">\(\beta_{1} \neq 0\)</span>。</p>
<p>在科学研究中，标准的做法就是找出能拟合这些数据的线性模型中的那些数值（也就是上面的<span class="math inline">\(\beta_{j}\)</span>），找到的这个线性方向与这些点的距离最小。这个过程通常是通过最小二乘(Least Squares, LS)的思想来实现的，下面的这个公式被称为最小平方(Least squares)方程： <span class="math display">\[
\sum_{i=1}^{n}\left\{Y_{i}-\left(\beta_{0}+\sum_{j=1}^{p} \beta_{j} x_{i, j}\right)\right\}^{2}
\]</span></p>
<p>一旦我们找到了这些值，我们就称这些值为最小二乘估计(Least Squares Estimates, LSE)，并将其命名为<span class="math inline">\(\hat{\beta}\)</span>。当我们在估计值处计算出了最小二乘方程后，上面的那个公式就称为残差平方和(Residual Sum of Squares, RSS)。由于RSS所有的量都是取决于Y，因此这个值是随机变量。</p>
<h2 id="自由落体案例回顾">自由落体案例回顾</h2>
<p>在高中物理课本中我们就知道，自由落体运行的方程为： <span class="math display">\[
d=h_{0}+v_{0} t-0.5 \times 9.8 t^{2}
\]</span> 其中，<span class="math inline">\(h_{0}\)</span>和<span class="math inline">\(v_{0}\)</span>分别是起始的高度与速度。在我们模拟的自由落体运行方程中，<span class="math inline">\(v_{0}=0\)</span>，<span class="math inline">\(h_{0}=56.67\)</span>，R代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">g &lt;- <span class="number">9.8</span> <span class="comment">##meters per second</span></div><div class="line">n &lt;- <span class="number">25</span></div><div class="line">tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n) <span class="comment">##time in secs, t is a base function</span></div><div class="line">f &lt;- <span class="number">56.67</span> - <span class="number">0.5</span>*g*tt^<span class="number">2</span></div><div class="line">y &lt;- f + rnorm(n,sd=<span class="number">1</span>)</div><div class="line"></div><div class="line">png(file=<span class="string">"../Figs/falling.png"</span>, width=<span class="number">1200</span>, height=<span class="number">1200</span>, res=<span class="number">300</span>,</div><div class="line">    pointsize=<span class="number">10</span>)</div><div class="line">plot(tt,y,ylab=<span class="string">"Distance in meters"</span>,xlab=<span class="string">"Time in seconds"</span>)</div><div class="line">lines(tt,f,col=<span class="number">2</span>)</div><div class="line">dev.off()</div></pre></td></tr></table></figure>
<p>我们模拟的自由落体运行图形如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816152214.png">

</div>
<p>但是，当我们假设自己是伽利略时，这个方程还没有被推导出来，因此我们并不知道其中相应的参数，这些数据只是表现得像一条抛物线，因此我们可以对这些数据进行建模，如下所示： <span class="math display">\[
Y_{i}=\beta_{0}+\beta_{1} x_{i}+\beta_{2} x_{i}^{2}+\varepsilon, i=1, \ldots, n
\]</span> 此时，我们如何找到LSE？</p>
<h2 id="lm函数">lm()函数</h2>
<p>R中的<code>lm()</code>函数可以很好地计算线性方程，现在我们先来简单计算一下这个方程，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">g &lt;- <span class="number">9.8</span> <span class="comment">##meters per second</span></div><div class="line">tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n) <span class="comment">##time in secs, t is a base function</span></div><div class="line">y &lt;- f + rnorm(n,sd=<span class="number">1</span>)</div><div class="line">tt2 &lt;-tt^<span class="number">2</span></div><div class="line">fit &lt;- lm(y~tt+tt2)</div><div class="line">summary(fit)$coef</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; summary(fit)$coef</div><div class="line">              Estimate Std. Error     t value     Pr(&gt;|t|)</div><div class="line">(Intercept) <span class="number">57.1399311</span>  <span class="number">0.5484054</span> <span class="number">104.1928697</span> <span class="number">3.897090e-31</span></div><div class="line">tt          -<span class="number">0.1997275</span>  <span class="number">0.7470438</span>  -<span class="number">0.2673572</span> <span class="number">7.916846e-01</span></div><div class="line">tt2         -<span class="number">4.9193723</span>  <span class="number">0.2122243</span> -<span class="number">23.1800643</span> <span class="number">5.973048e-17</span></div></pre></td></tr></table></figure>
<p>这样就计算出了LSE，以及标准误，p值。</p>
<h2 id="最小二乘估计the-least-squares-estimate-lse">最小二乘估计(The Least squares estimate, LSE)</h2>
<p>现在我们写一个函数，这个函数的功能在于计算任任<span class="math inline">\(\beta\)</span>的RSS，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rss &lt;- <span class="keyword">function</span>(Beta0,Beta1,Beta2)&#123;</div><div class="line">    r &lt;- y - (Beta0+Beta1*tt+Beta2*tt^<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span>(sum(r^<span class="number">2</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以对于任何三维向量，我们得到一个RSS。下图是当我们保持另外两个<span class="math inline">\(\beta\)</span>固定时，关于<span class="math inline">\(\beta_{2}\)</span>的函数的RSS的曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rss &lt;- <span class="keyword">function</span>(Beta0,Beta1,Beta2)&#123;</div><div class="line">    r &lt;- y - (Beta0+Beta1*tt+Beta2*tt^<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span>(sum(r^<span class="number">2</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line">Beta2s&lt;- seq(-<span class="number">10</span>,<span class="number">0</span>,len=<span class="number">100</span>)</div><div class="line">plot(Beta2s,sapply(Beta2s,rss,Beta0=<span class="number">55</span>,Beta1=<span class="number">0</span>),</div><div class="line">     ylab=<span class="string">"RSS"</span>,xlab=<span class="string">"Beta2"</span>,type=<span class="string">"l"</span>)</div><div class="line"><span class="comment">##Let's add another curve fixing another pair:</span></div><div class="line">Beta2s&lt;- seq(-<span class="number">10</span>,<span class="number">0</span>,len=<span class="number">100</span>)</div><div class="line">lines(Beta2s,sapply(Beta2s,rss,Beta0=<span class="number">65</span>,Beta1=<span class="number">0</span>),col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816155010.png">

</div>
<p>反复计算在这里行不通，相反，我们会使用微积分(calculus)的方法来进行计算，通过取偏导数(partial derivatives)，将它们设为0，然后求解。当然，如果我们有很多参数，这些方程会变得相当复杂。线性代数为这个问题提供了精练且通用的方法。</p>
<h2 id="galton拓展">Galton拓展</h2>
<p>Galton在研究父子身高问题时，他通过探索性数据分析有了一个新颖的发现，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816155451.png">

</div>
<p>Galton发现，如果他将父子的身高数据制成表格，然后将那些x和y值的和都相同的点连接起来，就构成了一个椭圆。通过计算还会进一步发现，这些数据服从二元正态分布（具体的高尔顿图可以参考《于忠义, YUZhong-yi. 高尔顿发现相关与回归的历史回顾与反思[J]. 统计与信息论坛, 2009, 24(9):17-25.》）如下所示： <span class="math display">\[
\operatorname{Pr}(X&lt;a, Y&lt;b)=\\ \int_{-\infty}^{a} \int_{-\infty}^{b} \frac{1}{2 \pi \sigma_{x} \sigma_{y} \sqrt{1-\rho^{2}}} \exp \left\{\frac{1}{2\left(1-\rho^{2}\right)}\left[\left(\frac{x-\mu_{x}}{\sigma_{x}}\right)^{2}-2 \rho\left(\frac{x-\mu_{x}}{\sigma_{x}}\right)\left(\frac{y-\mu_{y}}{\sigma_{y}}\right)+\left(\frac{y-\mu_{y}}{\sigma_{y}}\right)^{2}\right]\right\}
\]</span> 从上面的公式我们知道，当我们保持<span class="math inline">\(X\)</span>不变时（也就是设定好<span class="math inline">\(x\)</span>），<span class="math inline">\(Y\)</span>的分布是服从正态分布的，即服从均值为<span class="math inline">\(\mu_{x}+\sigma_{y} \rho\left(\frac{x-\mu_{x}}{\sigma_{x}}\right)\)</span>，标准差为<span class="math inline">\(\sigma_{y} \sqrt{1-\rho^{2}}\)</span>的正态分布。<span class="math inline">\(\rho\)</span>是<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>的相关系数，这就说明，如果我们设定<span class="math inline">\(X=x\)</span>，<span class="math inline">\(Y\)</span>实际上是一个线性模型。在我们的这个简单线性模型中，<span class="math inline">\(\beta_{0}\)</span>和<span class="math inline">\(\beta_{1}\)</span>参数表示为<span class="math inline">\(\mu_{x}, \mu_{y}, \sigma_{x}, \sigma_{y}\)</span>和<span class="math inline">\(\rho\)</span>。</p>
<h2 id="练习">练习</h2>
<p>P152</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>Rafael A Irizarry and Michael I Love.Data Analysis for the Life Sciences.This book is for sale at http://leanpub.com/dataanalysisforthelifesciences</li>
<li>于忠义, YUZhong-yi. 高尔顿发现相关与回归的历史回顾与反思[J]. 统计与信息论坛, 2009, 24(9):17-25.</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/08/DAL/DALS008_Exploratory_Data_Analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/08/DAL/DALS008_Exploratory_Data_Analysis/" itemprop="url">DALS008-数据探索(Exploratory Data Analysis)01-图表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T12:00:00+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,250
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是《Data Analysis for the Life Sciences》的第3章：探索性数据分析，主要内容涉及常见图表的解读，数据的描述，秩和检验。</p>
<blockquote>
<p>图片的最大价值就在于能够强迫我们发现一些我们预料不到的东西——John W.Tukey</p>
</blockquote>
<p>生命科学的研究，由于检测存在的误差，会导致一些异常值的出现。如果不没有发现这些问题，那么就会导致错误的分析结果以及假的发现。例如，有时候实验失败，或者是说在分析流程中，对涉及到的所有实验数据都进行检验，也无法发现它们，例如使用R中的<code>t.test()</code>函数。但是，这些分析流程仍然会给我们一些启示。此外，仅仅通过实验报告中的结果，也很难或者是几乎无法发现一些错误。</p>
<p>图表就是一种发现这些问题的强大工具，这一章节的内容就是探索性数据分析(Exploratory Data Analysis,EDA)。现存很多数据分析方法都是通过EDA来得到启示的。此外，EDA还能发现一些有意思的物理物现象，如果使用其它常规的统计学方法，这些现象有可能就会错失。在这本书中，我们会使用探索性数据来选择合适的统计学方法。</p>
<h2 id="qq图">QQ图</h2>
<p>qq图的全称为quantile quantile Plots，它经常用于验证一批数据是否服从正态分布。我们通过一些具体的案例来说明一下什么是分位数。</p>
<p>在一批数据中，第p个百分位数被定义为这个数大于p%的数，具体的定义可以参考以前的笔记<a href="https://www.jianshu.com/p/dd372640b146" target="_blank" rel="external">《StatQuest学习笔记06——分位数及其应用》</a>，再比如中间的50%百分位数就是中位数。</p>
<p>我们可以计算出一批身高的百分位数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(UsingR) <span class="comment">##available from CRAN</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">x &lt;- father.son$fheight</div><div class="line">head(x)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; head(x)</div><div class="line">[<span class="number">1</span>] <span class="number">65.04851</span> <span class="number">63.25094</span> <span class="number">64.95532</span> <span class="number">65.75250</span> <span class="number">61.13723</span> <span class="number">63.02254</span></div></pre></td></tr></table></figure>
<p>现在我们计算一批服合正态分布的数据：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ps &lt;- (seq(<span class="number">0</span>,<span class="number">99</span>) + <span class="number">0.5</span> )/<span class="number">100</span></div><div class="line"><span class="comment"># Calculate standard quantile</span></div><div class="line">qs &lt;- quantile(x, ps)</div><div class="line"><span class="comment"># produces sample quantiles corresponding to the given probabilitie</span></div><div class="line"><span class="comment"># For example</span></div><div class="line"><span class="comment"># ps2 &lt;- c(0.005,0.515,0.995)</span></div><div class="line"><span class="comment"># quantile(x,ps2)</span></div><div class="line"><span class="comment"># &gt; quantile(x,ps2)</span></div><div class="line"><span class="comment"># 0.5%    51.5%    99.5% </span></div><div class="line"><span class="comment"># 60.29272 67.84169 74.58332 </span></div><div class="line">normalqs &lt;- qnorm(ps, mean(x), popsd(x))</div><div class="line">plot(normalqs,qs,xlab=<span class="string">"Normal percentiles"</span>,ylab=<span class="string">"Height percentiles"</span>)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">##identity line</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190810131549.jpeg">

</div>
<p>上图显示的是，(<code>mean(x)</code>)为均值，总体方差为（<code>pposd(x)</code>）的正态分布数据集的qq图，这里的x指的是前文提到的father.son中fheight的身高，也就是父亲的身高，这里的qq图是理论上的qq图，代码中的<code>qnorm()</code>函数用于计算正态分布中的第p个分位一数的Z-score，具体的可以参考这篇笔记<a href="https://www.jianshu.com/p/a24eb1b94177" target="_blank" rel="external">《R语言中dnorm, pnorm, qnorm与rnorm以及随机数》</a>，现在看一下实际的qq图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qqnorm(x)</div><div class="line">qqline(x)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190810134743.jpeg">

</div>
<p><code>qqnorm()</code>函数绘制的图形都是按照标准正态分布来进行绘制，因此，上图中的直接斜率为<code>popas(x)</code>，截矩为<code>mean(x)</code>。</p>
<p>在前面的案例中，多数点与直线的匹配程度都非常好，实际上，我们可以使用Monte Carlo来模拟一下已知数据是否符合正态分布，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n &lt;-1000</div><div class="line">x &lt;- rnorm(n)</div><div class="line">qqnorm(x)</div><div class="line">qqline(x)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190810135337.jpeg">

</div>
<p>现在我们来模拟一下不符合正态分布的数据在qq图中是什么样子的，我们从不同自由度的t分布的数据中来抽取一些数据来画图，服从t分布的数据有这么一个特点：自由度越低，t分布的尾部就越平坦，自由度越高，尾部越高，整体越接近正态分布。在qq图中，我们可以看到，在qq图的左侧，这些数据点低于直线，而在右侧，这些点高于直线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dfs &lt;- c(<span class="number">3</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">30</span>)</div><div class="line">mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(df <span class="keyword">in</span> dfs)&#123;</div><div class="line">x &lt;- rt(<span class="number">1000</span>,df)</div><div class="line">qqnorm(x,xlab=<span class="string">"t quantiles"</span>,main=paste0(<span class="string">"d.f="</span>,df),ylim=c(-<span class="number">6</span>,<span class="number">6</span>))</div><div class="line">qqline(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190810140047.jpeg">

</div>
<h2 id="箱线图boxplot">箱线图(boxplot)</h2>
<p>我们获取的数据并非总是符合正态分布的，例如收入(income)就不符合正态分布，对于那些不符合正态分布的数据来说，谈论均值与标准差就没有多大意义，因为我们无法从均值与标准差中推测出相应的总体信息，只有数据符合正态时，谈论均值与标准差才有意义，现在我们来看一下2000年美国CEO的收入，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">hist(exec.pay)</div><div class="line">qqnorm(exec.pay)</div><div class="line">qqline(exec.pay)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190812153606.jpeg">

</div>
<p>除了使用QQ外，另外一种估计数据的实用手段就是计算一组数据的25%，50%与75%分位数。箱线图就能展示这3个计算值，以及这些数据的范围，即中位数±1.5（75%百分位数-25%百分位数）。超过这个范围的数据点有时候称为异常值(outliers)。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boxplot(exec.pay, ylab=<span class="string">"10,000s of dollars"</span>,ylim=c(<span class="number">0</span>,<span class="number">400</span>))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190812154457.png">

</div>
<h2 id="散点图与相关scatterplots-and-correlation">散点图与相关(Scatterplots And Correlation)</h2>
<p>前面提到的方法都是单变量(univariate variables)。而在生物学研究中，我们往往关注两个变量或多个变量之间的关系。一个典型的案例就是Francis Galton通过计算父亲与儿子身高的关系来理解遗传学。如果我们想要计算一下这些数据，我们就能利用这两组数据（也就是父亲的身高这一组数据与儿子的身高这一组数据）的均值与标准差来描述这些数据，因为身高这种数据是符合正态分布的。但是，我们通常这种常规方法无法找出这两组数据的关系，先来看一下散点图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">data(<span class="string">"father.son"</span>)</div><div class="line">x &lt;- father.son$fheight</div><div class="line">y &lt;- father.son$sheight</div><div class="line">plot(x,y, xlab=<span class="string">"Father's height in inches"</span>,ylab=<span class="string">"Son's height in inches"</span>,main=paste(<span class="string">"Correlation="</span>, signif(cor(x,y),<span class="number">2</span>)))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190812155537.png">

</div>
<p>这个散点图展示出了一个趋势：父亲越高，儿子就越高。这个趋势可以使用相关系数(correlation coefficient)来表示，这个案例中的相关系数是0.5。也就是说我们可以使用父亲的身高来预测儿子的身高。</p>
<h2 id="分层stratification">分层(Stratification)</h2>
<p>现在我们假设一种场景，比如我们随机地选取一个儿子来猜测他的身高，其中儿子这一组数据的平均身高是68.7英寸（），这个身高所占的比例是最大的（可以看直方图），因此我们可以根据这个预测一个儿子的身高。但是，如果我们被告知，这个选中的儿子的父亲身高是72英寸，那么我们还会猜测这个儿子身高是68.7英寸么？</p>
<p>父亲的身高是高于平均值的，尤其是当这个父亲的身高还高于父亲这一组数据均值的1.75个标准差时。我们有可能会预测，这个父亲的儿子身高是否也高于1.75个标准差？结果发现，这个结果是高估了。为了验证这个结果，我们来看一下，那些身高约为72英寸的父亲的儿子的身高，我们可以对父亲这一组数据进行分层(stratifying)。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">groups &lt;- split(y, round(x))</div><div class="line">boxplot(groups)</div><div class="line">print(mean(y[ round(x) == <span class="number">72</span>]))</div><div class="line"><span class="comment"># [1] 70.67719</span></div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190812161555.png">

</div>
<p>对数据进行分层后，再绘制箱线图，我们就可以看到每组数据的分布。身高约为72英寸父亲的平均身高是70.7英寸。我们还能看到，分层后的数据的中位数大概是一条直接（箱线图中间的线是中位数值，而非均值）。中位数构成的这条直线比较类似于回归线(regression line)，而回归线的斜率与相关有关。</p>
<h2 id="二元正态分布bi-variate-normal-distribution">二元正态分布(Bi-variate Normal Distribution)</h2>
<p>一对随机变量，例如(X,Y)，当它们值的比例可以按照以下公式来表示时，例如a和b，就可以认为它们接近二元正态分布：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190812164350.png">

</div>
<p>上面的这个公式看起来很复杂，但是背后的原理非常简单。另外一种比较简单的理解就是：先固定一个值x，然后观察当X=x时，所有的点(X,Y)。通常来说，在统计学中我们把这一过程称为设定条件(conditioning)。我们可以根据X来设定Y。如果一对随机变量接近双变量正态分布，那么X=x时，Y的分布也就服从一个正态分布，而x的值可以是任意的，现在我们来看一下身高数据，看一下上述的思路是否符合，身高数据一共分为4层，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">groups &lt;- split(y, round(x))</div><div class="line">mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> c(<span class="number">5</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>))&#123;</div><div class="line">  qqnorm(groups[[i]], main = paste0(<span class="string">"X="</span>, names(groups)[i],<span class="string">" strate"</span>),</div><div class="line">         ylim=range(y), xlim=c(-<span class="number">2.5</span>, <span class="number">2.5</span>))</div><div class="line">  qqline(groups[[i]])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190812180851.png">

</div>
<p>当两个变量服从双变量正态分布时，从数学统计学的公式就可以知道，对于给定的x值，相对应的Y（与X=x配对）平均值为： <span class="math display">\[
\mu_{Y}+\rho \frac{X-\mu_{X}}{\sigma_{X}} \sigma_{Y}
\]</span> 从上面公式我们可以知道，这个直线的斜率为<span class="math inline">\(\rho \frac{\sigma_{Y}}{\sigma_{X}}\)</span>，这个直线就是回归直线(regression line)。如果SD一样，那么这个回归线的斜率就是<span class="math inline">\(\rho\)</span>。因此，如果我们对X和Y进行标准化后，那么相关(correlation)就是这个回归直线的斜率。</p>
<p>这个公式的另外一种表示就是我们可以构建一个预测值<span class="math inline">\(\hat{Y}\)</span>：即对于距离x均值1个SD的x值，我们可以预测相应Y的值，是远离y均值的<span class="math inline">\(\rho\)</span>个SD的值，如下所示： <span class="math display">\[
\frac{\hat{Y}-\mu_{Y}}{\sigma_{Y}}=\rho \frac{x-\mu_{X}}{\sigma_{X}}
\]</span> 如果两个变量，即X和Y存在着很好的相关性，那么我们可以预测出相同的SD数目。如果相关性为0，那么我们就无法根据x的值来预测y的值。现在我们在计算一下每层的均值，进而确定回归直线：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x=( x-mean(x) )/sd(x)</div><div class="line">y=( y-mean(y) )/sd(y)</div><div class="line">means=tapply(y, round(x*<span class="number">4</span>)/<span class="number">4</span>, mean)</div><div class="line">fatherheights=as.numeric(names(means))</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(fatherheights, means, ylab=<span class="string">"average of strata of son heights"</span>, ylim=range(fatherheights))</div><div class="line">abline(<span class="number">0</span>, cor(x,y))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190812201906.png">

</div>
<h2 id="方差解释variance-explained">方差解释(Variance explained)</h2>
<p>前面提到的条件分布(conditional distribution)的标准差如下所示： <span class="math display">\[
\sqrt{1-\rho^{2}} \sigma_{Y}
\]</span> 这个公式与X能够解释Y的多少方差类似，这个解释程度是<span class="math inline">\(\rho^{2} \times 100 \%\)</span>。而上述的那个公式中：Y的方差是<span class="math inline">\(\rho^{2}\)</span>，如果给定X的值，那么Y自身能够解释Y值波动的程度就是$ (1-^{2}) _{Y}^{2} $。这个里我们只需要记住，方差解释(variance explained)这种表述只有在两组数据接近双变量正态分布(bivariate normal distribution)的情况下才有意义（注：对于书中的这段话我没太明白，按照自己的理解来记的笔记）。</p>
<h2 id="绘图原则">绘图原则</h2>
<p>优秀数据图主要是为了能够准确清楚地展示你的数据，Karl Broman（注：此人是华盛顿大学生物统计与医学信息学系教授，主要研究统计遗传学）提出了几点绘图中要避开以下操作：</p>
<ul>
<li>展示信息太少(Display as little information as possible)；</li>
<li>阅读体验不好（乱堆图表）(Obscure what you do show (with chart junk))；</li>
<li>使用伪3D图形，瞎用颜色(Use pseudo-3D and color gratuitously)；</li>
<li>随意使用饼图（尤其是各种颜色与3D饼图）(Make a pie chart (preferably in color and 3D))；</li>
<li>没有图例(Use a poorly chosen scale)；</li>
<li>没有展示有效数字(Ignore significant figures)。</li>
</ul>
<h2 id="常见各种图形">常见各种图形</h2>
<p>这一部分涉及常见的各种图形，例如饼图，柱状图等。</p>
<h3 id="饼图pie-charts">饼图(pie charts)</h3>
<p>现在我们来看一个数据，这个数据是2013年的调查的各个浏览器的使用率，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">browsers &lt;- c(Opera=<span class="number">1</span>,Safari=<span class="number">9</span>,Firefox=<span class="number">20</span>,IE=<span class="number">26</span>,Chrome=<span class="number">44</span>)</div><div class="line">pie(browsers,main=<span class="string">"Browser Usage (August 2013)"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813090542.png">

</div>
<p>但是饼图有很大局限，在R中，我们查看一下<code>pie()</code>函数的说明，如下所示： &gt; “Pie charts are a very bad way of displaying information. The eye is good at judging &gt; linear measures and bad at judging relative areas. A bar chart or dot chart is a preferable &gt; way of displaying this type of data.”</p>
<p>上述就提到了，饼图展示的信息有限。人眼善于判断线性度量，不善于判断面积度量。因此，使用条形图来展示相关的信息比饼图更好。</p>
<p>从饼图中我们只能看出每个浏览器的占有率，但是，除非这些占有率接近25%，50%或75%，否则也不太容易看出来，此时如果直接展示数字反而好一些。为了更好地展示数据，现在使用柱状图(barplot)来看一下这些数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">barplot(browsers, main=<span class="string">"Browser Usage (August 2013)"</span>, ylim=c(<span class="number">0</span>,<span class="number">55</span>))</div><div class="line">abline(h=<span class="number">1</span>:<span class="number">5</span> * <span class="number">10</span>)</div><div class="line">barplot(browsers, add=<span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813091355.png">

</div>
<p>从柱状图上的柱子，以及平行于x轴的几条水平线我们就很容易看到每个浏览器的市场占有率。不过在画柱状图的时候，要避免画成3D的，因为3D图很直观地看到其顶部对应的数字，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813092149.png">

</div>
<p>更差的是画环形图(donut plot)，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813092246.png">

</div>
<h3 id="柱状图barplot">柱状图(barplot)</h3>
<p>这里注明一下，barplot有的翻译为柱状图，有的翻译为条形图，我觉得是一样的，这两种图形的x轴（或y轴）上都是分类变量，而不是连续变量。需要与柱状图进行区分的则是直方图(histogram)，直方图的x轴上是连续变量。</p>
<p>虽然柱状图在展示百分比方面很有用，但是柱状图经常被错误地用于比较两组数据，在这类应用中，常常用均值作为柱子的高度，使用误差棒来表示标准误，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813093556.png">

</div>
<p>这种图展示的信息很少，例如没有说明数据的分布情况。其实针对这种情况，使用箱线图(boxplot)更合适，如果数据点比较少，可以直接在箱线图上添加上数据点。如果数据点很多，只用画箱线图，不加数据点注行。如果在箱线图函数<code>boxplot()</code>中添加上<code>range=0</code>参数的话，也可以不绘制离群点(outlier)，现在我们绘制箱线图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x &lt;- rnorm(<span class="number">8</span>,<span class="number">30</span>,<span class="number">5</span>)</div><div class="line">y &lt;- rnorm(<span class="number">8</span>,<span class="number">38</span>,<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">dat &lt;- list(Treatment=x,Control=y)</div><div class="line">boxplot(dat,xlab=<span class="string">"Group"</span>,ylab=<span class="string">"Response"</span>,cex=<span class="number">0</span>)</div><div class="line">stripchart(dat,vertical=<span class="literal">TRUE</span>,method=<span class="string">"jitter"</span>,pch=<span class="number">16</span>,add=<span class="literal">TRUE</span>,col=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813094533.jpeg">

</div>
<p>从上面的箱线图我们可以看到以下信息： - 数据的中心； - 数据的分布，范围； - 所有的数据点。</p>
<p>而在柱状图中，我们仅能看到均值与SE，况且SE还与样本的数目(sample size)有关，无法发现数据的分布规律。当我们的数据有离群点或者是有很大拖尾时(very large tails)时，柱状图的一些局限就会更加明显，在下面的图形中我们会觉得这两组数据的差异非常大：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813095001.png">

</div>
<p>但是，如果我们仔细研究一下这两组数据，就会发现，这两组数据的差异主要是由第二数据的两个离群值导致的，为了解决这个问题，现在我们分别绘制一下常规的箱线图以及经过log转换后的箱线图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"></div><div class="line">x &lt;- <span class="number">10</span>^rnorm(<span class="number">10</span>,<span class="number">0.2</span>)</div><div class="line">y &lt;- <span class="number">10</span>^rnorm(<span class="number">10</span>,<span class="number">1.2</span>)</div><div class="line"></div><div class="line">dat &lt;- list(Treatment=x,Control=y)</div><div class="line">boxplot(dat,xlab=<span class="string">"Group"</span>,ylab=<span class="string">"Response"</span>,cex=<span class="number">0</span>)</div><div class="line">stripchart(dat,vertical=<span class="literal">TRUE</span>,method=<span class="string">"jitter"</span>,pch=<span class="number">16</span>,add=<span class="literal">TRUE</span>,col=<span class="number">1</span>)</div><div class="line">boxplot(dat,xlab=<span class="string">"Group"</span>,ylab=<span class="string">"Response"</span>,log=<span class="string">"y"</span>,cex=<span class="number">0</span>)</div><div class="line">stripchart(dat,vertical=<span class="literal">TRUE</span>,method=<span class="string">"jitter"</span>,pch=<span class="number">16</span>,add=<span class="literal">TRUE</span>,col=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813095508.png">

</div>
<h3 id="散点图scatter-plot">散点图(scatter plot)</h3>
<p>许多统计分析研究的目标就是找到两个变量的关系。在这些统计结果中通常会报告简单的相关性(correlation)，有时候还会画出相应的图形。但是，仅仅展示出一个回归直线(regression line)还不够，因为直线无法显示出背后的数据，此时最好还要加上数据点，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">x &lt;- rnorm(<span class="number">100</span>,<span class="number">100</span>,<span class="number">10</span>)</div><div class="line">y &lt;- <span class="number">100</span>+<span class="number">10</span>*sqrt(<span class="number">2</span>*(x-min(x)))+rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">10</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y,lwd=<span class="number">2</span>,type=<span class="string">"n"</span>)</div><div class="line">fit &lt;- lm(y~x)</div><div class="line">abline(fit$coef,lwd=<span class="number">2</span>)</div><div class="line">b &lt;- round(fit$coef,<span class="number">4</span>)</div><div class="line">text(<span class="number">78</span>, <span class="number">200</span>, paste(<span class="string">"y ="</span>, b[<span class="number">1</span>], <span class="string">"+"</span>, b[<span class="number">2</span>], <span class="string">"x"</span>), adj=c(<span class="number">0</span>,<span class="number">0.5</span>))</div><div class="line">rho &lt;- round(cor(x,y),<span class="number">4</span>)</div><div class="line">text(<span class="number">78</span>, <span class="number">187</span>,expression(paste(rho,<span class="string">" = 0.8567"</span>)),adj=c(<span class="number">0</span>,<span class="number">0.5</span>))</div><div class="line">plot(x,y,lwd=<span class="number">2</span>)</div><div class="line">fit &lt;- lm(y~x)</div><div class="line">abline(fit$coef,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813100648.jpeg">

</div>
<h3 id="高度的相关性并不意味着相同high-correlation-does-not-imply-replication">高度的相关性并不意味着相同(High correlation does not imply replication)</h3>
<p>当出现一个新的技术，或者是在实验室中引入一项新技术时，我们通常会用这些技术来检测相同的样本(replicated sample)，进而绘制出散点图来看一下它们的相关性。高度的相关性(high correlation)用于评估这项新技术是否有重现性(reproducible)。</p>
<p>但是，相关性有时候也会误导人(misleading)，下面的散点图展示的是一项高通量技术对相同样本的检测结果。这项技术同时输出12626个检测值。在下图的左侧中，我们可以看到原始数据显示出很高的相关性。但是这组数据拖尾严重(very fat tails)，其中有95%的数据是在绿线以下，另外，下图的右侧是经过log转换后的图：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813105226.png">

</div>
<p>虽然上面两张图都显示出了高度的相关性（都接近1）。这是否就意味着这些数据能够重复？为了研究第二次检测的结果能否重现第一次的检测，我们需要研究这两组数据的差值。为此，我们可以绘制差值与均值的图型，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813112113.png">

</div>
<p>上面的这种分析方法叫Bland-Altman绘图法，也叫MA图。MA的意思是minus与average，因为在这种图中上，y轴表示了两个样本数据经过log转换后，取的差值，x轴表示的是两个样本的数据经过log转换后，两个数据的平均值。在这张图形中，我们使用的是log2转换，从y轴上可以看到，两次测量后的差值多数情况下是1。这意味着当测量应该相同时，我们将平均观察到2倍的差异。我们现在可以将这种可变性(variability)与检测的差值(differences)进行比较，从而决定这项技术是否达到了我们想要的精度。</p>
<h3 id="配对数据的柱状图">配对数据的柱状图</h3>
<p>数据分析的一项常规任务就是比较两组数据。当数据集比较小，并且是配对数据（例如治疗前与治疗后），可以使用两种颜色的柱状图来展示结果，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813165133.png">

</div>
<p>除此之外，还有更好的展示数据的方式，这些展示方式能够看到治疗效果。第一种就是简单地绘制散点图，从散点图中我们可以发现，多数点都在直线上方。另外一种就是绘制箱线图。 先看散点图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">12201970</span>)</div><div class="line">before &lt;- runif(<span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>)</div><div class="line">after &lt;- rnorm(<span class="number">6</span>, before*<span class="number">1.05</span>, <span class="number">2</span>)</div><div class="line">li &lt;- range(c(before, after))</div><div class="line">ymx &lt;- max(abs(after-before))</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(before, after, xlab=<span class="string">"Before"</span>, ylab=<span class="string">"After"</span>,</div><div class="line">     ylim=li, xlim=li)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>, lty=<span class="number">2</span>, col=<span class="number">1</span>)</div><div class="line">plot(before, after-before, xlab=<span class="string">"Before"</span>, ylim=c(-ymx, ymx),</div><div class="line">     ylab=<span class="string">"Change (After - Before)"</span>, lwd=<span class="number">2</span>)</div><div class="line">abline(h=<span class="number">0</span>, lty=<span class="number">2</span>, col=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813165425.png">

</div>
<p>从上图可以看出来，右侧的图比较像MA图，其实就是相当于把左侧的散点图旋转了一下。</p>
<p>散点图中的直线并不直观，而箱线图则能很好地显示变化的效果，但是会丧失配对信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">z &lt;- rep(c(<span class="number">0</span>,<span class="number">1</span>), rep(<span class="number">6</span>,<span class="number">2</span>))</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(z, c(before, after),</div><div class="line">xaxt=<span class="string">"n"</span>, ylab=<span class="string">"Response"</span>,</div><div class="line">xlab=<span class="string">""</span>, xlim=c(-<span class="number">0.5</span>, <span class="number">1.5</span>))</div><div class="line">axis(side=<span class="number">1</span>, at=c(<span class="number">0</span>,<span class="number">1</span>), c(<span class="string">"Before"</span>,<span class="string">"After"</span>))</div><div class="line">segments(rep(<span class="number">0</span>,<span class="number">6</span>), before, rep(<span class="number">1</span>,<span class="number">6</span>), after, col=<span class="number">1</span>)</div><div class="line">boxplot(before,after,names=c(<span class="string">"Before"</span>,<span class="string">"After"</span>),ylab=<span class="string">"Response"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813170145.png">

</div>
<h3 id="折线图line-chart">折线图(line chart)</h3>
<p>先看一个反面典型：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813172337.png">

</div>
<p>这个折线图是一个伪3D图，它表示的信息不清楚，也许是为了区分这三条曲线，但是，从这3条曲线上的点很难找到对应的数值，这种图不推荐使用。</p>
<p>现在来看一个比较正常的图表，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">log_dose &lt;- <span class="number">1</span>:<span class="number">10</span></div><div class="line">Drug_A &lt;- c(<span class="number">0.8</span>, <span class="number">0.75</span>, <span class="number">0.76</span>, <span class="number">0.71</span>, <span class="number">0.73</span>, <span class="number">0.7</span>,<span class="number">0.67</span>,<span class="number">0.66</span>,<span class="number">0.68</span>,<span class="number">0.65</span>)</div><div class="line">Drug_B &lt;- c(<span class="number">0.75</span>,<span class="number">0.73</span>,<span class="number">0.7</span>,<span class="number">0.65</span>,<span class="number">0.62</span>,<span class="number">0.5</span>,<span class="number">0.3</span>,<span class="number">0.28</span>,<span class="number">0.27</span>,<span class="number">0.29</span>)</div><div class="line">Drug_C &lt;- c(<span class="number">0.92</span>,<span class="number">0.9</span>,<span class="number">0.87</span>,<span class="number">0.75</span>,<span class="number">0.74</span>,<span class="number">0.73</span>,<span class="number">0.64</span>,<span class="number">0.6</span>,<span class="number">0.58</span>,<span class="number">0.52</span>)</div><div class="line">x &lt;- data.frame(log_dose,Drug_A,Drug_B,Drug_C)</div><div class="line">plot(x[,<span class="number">1</span>],x[,<span class="number">2</span>],xlab=<span class="string">"log Dose"</span>,ylab=<span class="string">"Proportion survived"</span>,ylim=c(<span class="number">0</span>,<span class="number">1</span>),</div><div class="line">     type=<span class="string">"l"</span>,lwd=<span class="number">2</span>,col=<span class="number">1</span>)</div><div class="line">lines(x[,<span class="number">1</span>],x[,<span class="number">3</span>],lwd=<span class="number">2</span>,col=<span class="number">2</span>)</div><div class="line">lines(x[,<span class="number">1</span>],x[,<span class="number">4</span>],lwd=<span class="number">2</span>,col=<span class="number">3</span>)</div><div class="line">legend(<span class="number">1</span>,<span class="number">0.3</span>,c(<span class="string">"Drug A"</span>,<span class="string">"Drug B"</span>,<span class="string">"Drug C"</span>),lwd=<span class="number">2</span>, col=<span class="number">1</span>:<span class="number">3</span>,horiz=<span class="literal">T</span>,bty = <span class="string">"n"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813174434.jpeg">

</div>
<h3 id="添加重要信息">添加重要信息</h3>
<p>在下面的案例中，我们会模拟生成一批数据来研究两组之间的关系：对照组与治疗组。每组分别有3次实验，现在我们使用普通的柱状图来描述一下这两种干预结果，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813182210.png">

</div>
<p>这类图形并没有很好地展示不同药物剂量的治疗效果，也就是没有展示出量效关系这种重要信息，现在我们使用折线图来展示一下这些信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">x &lt;- <span class="number">1</span>:<span class="number">8</span></div><div class="line">y1 &lt;- <span class="number">0.9</span> - x/<span class="number">80</span> + rnorm(length(x), <span class="number">0</span>, <span class="number">0.02</span>)</div><div class="line">y2 &lt;- <span class="number">0.9</span> - x/<span class="number">40</span> + rnorm(length(x), <span class="number">0</span>, <span class="number">0.02</span>)</div><div class="line">y3 &lt;- <span class="number">0.85</span> - x/<span class="number">30</span> + rnorm(length(x), <span class="number">0</span>, <span class="number">0.02</span>)</div><div class="line">y &lt;- cbind(y1, y2, y3)</div><div class="line"></div><div class="line">z1 &lt;- <span class="number">0.95</span> - x/<span class="number">40</span> + rnorm(length(x), <span class="number">0</span>, <span class="number">0.02</span>)</div><div class="line">z2 &lt;- ilogit(-<span class="number">0.4</span>*(x-<span class="number">4.5</span>) + rnorm(length(x), <span class="number">0</span>, <span class="number">0.04</span>))</div><div class="line">z3 &lt;- ilogit(-<span class="number">0.5</span>*(x-<span class="number">4.5</span>) + rnorm(length(x), <span class="number">0</span>, <span class="number">0.04</span>))</div><div class="line">z1[<span class="number">6</span>:<span class="number">8</span>] &lt;- z1[<span class="number">6</span>:<span class="number">8</span>] - <span class="number">0.18</span>*<span class="number">3</span></div><div class="line">z &lt;- cbind(z1, z2, z3)</div><div class="line">ym &lt;- apply(y, <span class="number">1</span>, mean)</div><div class="line">zm &lt;- apply(z, <span class="number">1</span>, mean)</div><div class="line"></div><div class="line">dev.off()</div><div class="line">png(file=<span class="string">"../fig9b.png"</span>, width=<span class="number">1200</span>, height=<span class="number">1000</span>, res=<span class="number">288</span>,pointsize=<span class="number">12</span>)</div><div class="line">bgcolor &lt;- rgb(<span class="number">0</span>, <span class="number">0</span>, <span class="number">98</span>, maxColorValue=<span class="number">255</span>)</div><div class="line">par(las=<span class="number">1</span>,fg=<span class="string">"white"</span>,col=<span class="string">"white"</span>,col.axis=<span class="string">"white"</span>,col.lab=<span class="string">"white"</span>,</div><div class="line">    bg=bgcolor,mar=c(<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>))</div><div class="line">plot(x, y1, ylim=c(<span class="number">0</span>,<span class="number">1</span>), type=<span class="string">"n"</span>, xlab=<span class="string">"Dose"</span>, ylab=<span class="string">"Response"</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">3</span>) lines(x, y[,i], col=<span class="number">1</span>, lwd=<span class="number">1</span>, lty=<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">3</span>) lines(x, z[,i], col=<span class="number">2</span>, lwd=<span class="number">1</span>, lty=<span class="number">2</span>)</div><div class="line">lines(x, ym, col=<span class="number">1</span>, lwd=<span class="number">2</span>)</div><div class="line">lines(x, zm, col=<span class="number">2</span>, lwd=<span class="number">2</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>, lwd=<span class="number">2</span>, col=c(<span class="number">1</span>, <span class="number">2</span>), c(<span class="string">"Control"</span>, <span class="string">"Treated"</span>))</div><div class="line">dev.off()</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190813182044.png">

</div>
<h2 id="有效数字">有效数字</h2>
<p>R的统计结果的小数点数位很多，有的时候直接粘贴比较麻烦，此时就可以减少一些小数位，先来看一批数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">heights &lt;- cbind(rnorm(<span class="number">8</span>,<span class="number">73</span>,<span class="number">3</span>),rnorm(<span class="number">8</span>,<span class="number">73</span>,<span class="number">3</span>),rnorm(<span class="number">8</span>,<span class="number">80</span>,<span class="number">3</span>),</div><div class="line">                 rnorm(<span class="number">8</span>,<span class="number">78</span>,<span class="number">3</span>),rnorm(<span class="number">8</span>,<span class="number">78</span>,<span class="number">3</span>))</div><div class="line">colnames(heights)&lt;-c(<span class="string">"SG"</span>,<span class="string">"PG"</span>,<span class="string">"C"</span>,<span class="string">"PF"</span>,<span class="string">"SF"</span>)</div><div class="line">rownames(heights)&lt;- paste(<span class="string">"team"</span>,<span class="number">1</span>:<span class="number">8</span>)</div><div class="line">heights</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; heights</div><div class="line">             SG       PG        C       PF       SF</div><div class="line">team <span class="number">1</span> <span class="number">70.28569</span> <span class="number">73.53063</span> <span class="number">77.97624</span> <span class="number">75.53098</span> <span class="number">79.91438</span></div><div class="line">team <span class="number">2</span> <span class="number">69.13691</span> <span class="number">72.98393</span> <span class="number">79.53870</span> <span class="number">77.05309</span> <span class="number">73.23242</span></div><div class="line">team <span class="number">3</span> <span class="number">69.66017</span> <span class="number">70.11667</span> <span class="number">80.43766</span> <span class="number">80.39365</span> <span class="number">76.69519</span></div><div class="line">team <span class="number">4</span> <span class="number">73.95542</span> <span class="number">72.61165</span> <span class="number">77.36032</span> <span class="number">79.48383</span> <span class="number">75.00610</span></div><div class="line">team <span class="number">5</span> <span class="number">73.36905</span> <span class="number">77.19182</span> <span class="number">78.59511</span> <span class="number">78.28309</span> <span class="number">81.98515</span></div><div class="line">team <span class="number">6</span> <span class="number">74.03342</span> <span class="number">67.47227</span> <span class="number">79.25801</span> <span class="number">70.24398</span> <span class="number">77.07891</span></div><div class="line">team <span class="number">7</span> <span class="number">74.14659</span> <span class="number">76.21967</span> <span class="number">81.25641</span> <span class="number">74.01896</span> <span class="number">80.90877</span></div><div class="line">team <span class="number">8</span> <span class="number">70.57122</span> <span class="number">68.65044</span> <span class="number">84.30345</span> <span class="number">76.18054</span> <span class="number">77.83099</span></div></pre></td></tr></table></figure>
<p>上述的这些数字精确到小点第5位，很多时候在写实验结果时根本没必要，此时使用<code>round()</code>函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; round(heights,<span class="number">1</span>)</div><div class="line">         SG   PG    C   PF   SF</div><div class="line">team <span class="number">1</span> <span class="number">70.3</span> <span class="number">73.5</span> <span class="number">78.0</span> <span class="number">75.5</span> <span class="number">79.9</span></div><div class="line">team <span class="number">2</span> <span class="number">69.1</span> <span class="number">73.0</span> <span class="number">79.5</span> <span class="number">77.1</span> <span class="number">73.2</span></div><div class="line">team <span class="number">3</span> <span class="number">69.7</span> <span class="number">70.1</span> <span class="number">80.4</span> <span class="number">80.4</span> <span class="number">76.7</span></div><div class="line">team <span class="number">4</span> <span class="number">74.0</span> <span class="number">72.6</span> <span class="number">77.4</span> <span class="number">79.5</span> <span class="number">75.0</span></div><div class="line">team <span class="number">5</span> <span class="number">73.4</span> <span class="number">77.2</span> <span class="number">78.6</span> <span class="number">78.3</span> <span class="number">82.0</span></div><div class="line">team <span class="number">6</span> <span class="number">74.0</span> <span class="number">67.5</span> <span class="number">79.3</span> <span class="number">70.2</span> <span class="number">77.1</span></div><div class="line">team <span class="number">7</span> <span class="number">74.1</span> <span class="number">76.2</span> <span class="number">81.3</span> <span class="number">74.0</span> <span class="number">80.9</span></div><div class="line">team <span class="number">8</span> <span class="number">70.6</span> <span class="number">68.7</span> <span class="number">84.3</span> <span class="number">76.2</span> <span class="number">77.8</span></div></pre></td></tr></table></figure>
<h2 id="相关的误解misunderstanding-correlation">相关的误解(Misunderstanding Correlation)</h2>
<p>相关性(correlation)广泛用于表示数据的重现性(reproducibility)，例如在基因组学(genomics)常会用到。但在数学角度来看，相关性与重现性关系不大，这里简单描述三个关于相关性的问题。</p>
<p>关于相关性最大的误用就是计算那些不服从双变量正态分布数据的相关性。前面提到，如果两组数据服从双变量正态分布，那么使用均值、标准差以及相关性来描述这些数据是合适的。但是，还有很多数据不是双变量正态分布。例如基因表达的数据就不服从双变量正态分布，这种数据的右侧有着扁平的尾巴(with a very fat right tail)。</p>
<p>研究两个重复检测数据重现性(reproducibility)的标准做法是先计算一下这两组数据的距离，如下所示： <span class="math display">\[
\sqrt{\sum_{i=1}^{n} d_{i}^{2}} \text { with } d_{i}=x_{i}-y_{i}
\]</span> 当两次检测的数值重复性很好的时候，这个度量(metric)是降低的，当这个值是0的时候（其实就相当于两次检测的结果完全一样），结果最完美（这只是理想情况）。使用这种度量的另外一个好处就是，如果我们将它除以N，那么得到的数值就是就是作为<span class="math inline">\(d_{1},\dots,d_{N}\)</span>的标准差（此时我们假设d是大于0的）（原文是if we assume the d average out to 0，我的理解是，我们假设d的平均值为0，或者是d的平均值大于0）。如果将d视为残差(residuals)，那么这个统计量（已经除以N了）就相当于RMSE（全称为Root Mean Squared Error，译为均方根误差），我们称为<code>距离度量(distance metric)</code>。此外，这个统计量的单位与检测值的单位是一样的，因此能很好地解释结果。</p>
<p>使用相关性(correlation)是另外一个局限是，相关性计算无法检测到由于平均值改变而导致的不可重复性（原文是：Another limitation of the correlation is that it does not detect cases that are not reproducible due to average changes.），而距离度量则能检测到这些差异，因此前面的公式可以写为下面的形式： <span class="math display">\[
\frac{1}{n} \sum_{i=1}^{n}\left(x_{i}-y_{i}\right)^{2}=\frac{1}{n} \sum_{i=1}^{n}\left[\left(x_{i}-\mu_{x}\right)-\left(y_{i}-\mu_{y}\right)+\left(\mu_{x}-\mu_{y}\right)\right]^{2}
\]</span> 其中<span class="math inline">\(\mu_{x}\)</span>和<span class="math inline">\(\mu_{y}\)</span>表示的是两次检测的均值，因此上面的公式还可以写为如下形式： <span class="math display">\[
\frac{1}{n} \sum_{i=1}^{n}\left(x_{i}-y_{i}\right)^{2}=\frac{1}{n} \sum_{i=1}^{n}\left(x_{i}-\mu_{x}\right)^{2}+\frac{1}{n} \sum_{i=1}^{n}\left(y_{i}-\mu_{y}\right)^{2}+\left(\mu_{x}-\mu_{y}\right)^{2}+\frac{1}{n} \sum_{i=1}^{n}\left(x_{i}-\mu_{x}\right)\left(y_{i}-\mu_{y}\right)
\]</span> 如果我们假设前后两次检测的结果的方差都是1，那么上面的公式就可以简化为如下形式： <span class="math display">\[
\frac{1}{n} \sum_{i=1}^{n}\left(x_{i}-y_{i}\right)^{2}=2+\left(\mu_{x}-\mu_{y}\right)^{2}-2 \rho
\]</span> 其中<span class="math inline">\(\rho\)</span>表示相关性，因此我们可以直接看到距离度量(distance metric)与相关性(correlation)的关系，但是，距离度量与相关性的一个重要差异就是距离度量含有<span class="math inline">\(\left(\mu_{x}-\mu_{y}\right)^{2}\)</span>，因此，它可以检测到那些由于大量均值变化而导致的无法重复。</p>
<p>相关性不能当成重复性(reproducibility)指标的另外一个因素就是，相关性没有单位(units)。我们使用一个公式就能看到这种局限，假如我们有两个变量，分别为<code>x</code>和<code>y</code>，其中<code>y=x+d</code>。如果<code>d</code>的方差越大，那么<code>x+d</code>就越无法重现<code>x</code>，也就是说，如果<code>d</code>这个数值波动越大，表示的就是第二次检测与第一次检测的数值偏差越大，进而可以得出结果：两次检测数据之间的重复性越差。而<code>距离度量(distrance metric)</code>仅取决于<code>d</code>的方差，也就是说它只取决于前后两次检测的偏差程度，它表示的是就是重复性的好坏，而相关性还依赖于<code>x</code>的方差，如果<code>d</code>与<code>x</code>是独立的，那么相关性的公式就如下所示： <span class="math display">\[
\operatorname{cor}(x, y)=\frac{1}{\sqrt{1+\operatorname{var}(d) / \operatorname{var}(x)}}
\]</span> 从上面的公式我们就可以看出来，相关性取决于<code>d</code>的方差与<code>x</code>的方差，这就说明了，即使相关性接近于1，也无法说明重复性很好。具体来说就是，无论<code>d</code>的方差怎么样，我们通过增加<code>x</code>的方差，就可以使相关系数随意地接近于1。</p>
<h2 id="练习">练习</h2>
<p>P131</p>
<h2 id="异常值的总结">异常值的总结</h2>
<p>正态分布在分析生命科学相关数据中有着重要作用，但是，由于相关检测仪器的复杂性，也会偶尔观察到一些异常值。例如某些扫描仪的缺陷会出现几个异常值的点，或者说是PCR过程中会产生一些偏倚。</p>
<p>因此我们往往会遇到一些情况，即在一群数据中，除了某个异常值外，其余的数据符合正态分布，如下所示： <figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">x &lt;- c(rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1</span>))</div><div class="line">x[<span class="number">23</span>] &lt;- <span class="number">100</span></div><div class="line">boxplot(x)</div></pre></td></tr></table></figure></p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190815184258.png">

</div>
<p>例如在上面的图形中，有一个点的数值是100，在统计学中，我们将这种点称为异常值(outliers)。一小部分的异常值会严重误导我们的数据分析，例如，这组数据中的均值与方差差就会远远偏离实际值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"The average is"</span>,mean(x),<span class="string">"and the SD is"</span>,sd(x))</div><div class="line">The average is <span class="number">1.108142</span> and the SD is <span class="number">10.02938</span></div></pre></td></tr></table></figure>
<p>我们生成的数据是标准正态分布，也就是均值为1，标准差为0，而加了一个异常值后，均值就变成了1.108142，标准差就变成了10.02938。</p>
<h3 id="中位数">中位数</h3>
<p>中位数的定义就是，将一组数据按从小到大的顺序排列，这个数字位于中间，有50%的数字大于它，有50%的数字小于它，对于含有异常值的一组数据来说，中位数比较稳健(robust)，现在我们来看一下我们前面数据的中位数（理论上应该比较接近于0），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">median(x)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; median(x)</div><div class="line">[<span class="number">1</span>] <span class="number">0.1684483</span></div></pre></td></tr></table></figure>
<h3 id="中位数绝对偏差the-median-absolute-deviationmad">中位数绝对偏差(The median absolute deviation,MAD)</h3>
<p>中位数绝对偏差，即The median absolute deviation，缩写为MAD，它是对标准差的稳健性描述。它的计算方法为：</p>
<p>第一步：计算每个数据点与中位数的差值；</p>
<p>第二步：取第一步中的绝对值；</p>
<p>第三步：取第二步中绝对值的中位数，再乘以1.4826。</p>
<p>其中，1.4826是一个比例因子(scaling factor )，MAD是一个无偏估计，现在我们使用MAD来估计前面的那组数据（就是服从标准正态分布的那组数据），那么它的值就非常接近于1了，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mad(x)</div><div class="line">[<span class="number">1</span>] <span class="number">0.8857141</span></div></pre></td></tr></table></figure>
<h3 id="spearman相关系数">Spearman相关系数</h3>
<p>前面我们提到，相关性对异常值比较敏感，这里我们构建了两组独立的数据，基中它们都含有以前面类似的异常值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">x=c(rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1</span>)) <span class="comment">##real distribution</span></div><div class="line">x[<span class="number">23</span>] &lt;- <span class="number">100</span> <span class="comment">##mistake made in 23th measurement</span></div><div class="line">y=c(rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1</span>)) <span class="comment">##real distribution</span></div><div class="line">y[<span class="number">23</span>] &lt;- <span class="number">84</span> <span class="comment">##similar mistake made in 23th measurement</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(x,y,main=paste0(<span class="string">"correlation="</span>,round(cor(x,y),<span class="number">3</span>)),pch=<span class="number">21</span>,bg=<span class="number">1</span>,xlim=c(-<span class="number">3</span>,<span class="number">100</span>),ylim=c(-<span class="number">3</span>,<span class="number">100</span>))</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190815190642.jpeg">

</div>
<p>Spearman相关系数遵循中位数与MAD的基本思想，也就是使用了分位数(quantiles)的原理。这个原理很简单：我们将每个数据集转换为秩(rank)，然后计算它们的相关性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y,main=paste0(<span class="string">"correlation="</span>,round(cor(x,y),<span class="number">3</span>)),pch=<span class="number">21</span>,bg=<span class="number">1</span>,xlim=c(-<span class="number">3</span>,<span class="number">100</span>),ylim=c(-<span class="number">3</span>,<span class="number">100</span>))</div><div class="line">plot(rank(x),rank(y),main=paste0(<span class="string">"correlation="</span>,round(cor(x,y,method=<span class="string">"spearman"</span>),<span class="number">3</span>)),pch=<span class="number">21</span>,bg=<span class="number">1</span>,xlim=c(-<span class="number">3</span>,<span class="number">100</span>),ylim=c(-<span class="number">3</span>,<span class="number">100</span>))</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190815190916.jpeg">

</div>
<p>从上面的结果我们可以知道，这些统计量对异常值很稳健，但为什么我们会使用那些不稳健的相关性计算方法呢？通常来说，如果我们知道异常值，那么我们最好使用中位数和MAD来替代均值与标准差来描述一组数据。但是，与非稳健性的相关性计算方法相比，这些稳健的统计方法的功效比较低。</p>
<h3 id="对数比的对称性symmetry-of-log-ratio">对数比的对称性(Symmetry of log ratio)</h3>
<p>比值(ratio)通常并不对称，现在我们来模拟一组比值来看一下，这组比值表示的是两个样本中100个基因的比值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x &lt;- <span class="number">2</span>^(rnorm(<span class="number">100</span>))</div><div class="line">y &lt;- <span class="number">2</span>^(rnorm(<span class="number">100</span>))</div><div class="line">ratios &lt;- x / y</div></pre></td></tr></table></figure>
<p>在生命科学中，我们经常使用比值或表达倍数(fold changes, FC)。假设现在们就在研究某个因素干预前后基因的变化的比值。因此在这些数据中，有些比值大于1，就表示经过干预后，基因表达上升。如果干预没有效果，那么这些比值小于1和大于1的数目是差不多的，通过直方图我们就可以看到干预后的基因变化量，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">hist(ratios)</div><div class="line">logratios &lt;- log2(ratios)</div><div class="line">hist(logratios)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190815192005.jpeg">

</div>
<p>从上面的这两张图我们可以看到，这些数据并不关于1对称。例如，1/32比32/1更接近于1，其实这两个数字表示的比值意义其实是相反的，一个是降低了32倍，一个是升高了32倍，但是它们不对称。如果我们经过了log转换，这两个数值就会关于0对称，转换的过程如下所示： <span class="math display">\[
\log (x / y)=\log (x)-\log (y)=-(\log (y)-\log (x))=\log (y / x)
\]</span> 现在我们看一下这些数据点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190815192411.png">

</div>
<p>在生命科学中，经常使用log转换，这是因为100倍的变化可能是100/1或1/100，但是1/100比100/1更接近于1。</p>
<h2 id="wilcoxon秩和检测wilcoxon-rank-sum-test">Wilcoxon秩和检测(Wilcoxon Rank Sum Test)</h2>
<p>从前面内容我们可以知道，样本的均值(mean)和SD对异常值(outlier)敏感。t检验的计算原理就是均值与SD。因此在有异常值存在的情况下，Wilcoxon秩和检验（其本质与Mann-Whitney检验）就成了一种替代选择。</p>
<p>在下面的代码中，我们进行了t检验（其零假设为真）。当使用这些原始数据进行计算时，t检验与Wilcoxon检验的p值都大于0.05，但是，当我们在每个样本中故意错误地更改了一个观测值后，并将其输入计算过程，此时，t检验就会计算出一个小p值，而Wilcoxon检验则不会这样，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">779</span>) </div><div class="line"><span class="comment">##779 picked for illustration purposes</span></div><div class="line">N=<span class="number">25</span></div><div class="line">x&lt;- rnorm(N,<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">y&lt;- rnorm(N,<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">cat(<span class="string">"t-test pval:"</span>,t.test(x,y)$p.value,<span class="string">"\n"</span>)</div><div class="line">cat(<span class="string">"Wilcox test pval:"</span>,wilcox.test(x,y)$p.value,<span class="string">"\n"</span>)</div><div class="line">x[<span class="number">1</span>] &lt;- <span class="number">5</span></div><div class="line">x[<span class="number">2</span>] &lt;- <span class="number">7</span></div><div class="line">cat(<span class="string">"t-test pval:"</span>,t.test(x,y)$p.value,<span class="string">"\n"</span>)</div><div class="line"></div><div class="line">cat(<span class="string">"Wilcox test pval:"</span>,wilcox.test(x,y)$p.value,<span class="string">"\n"</span>)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"t-test pval:"</span>,t.test(x,y)$p.value,<span class="string">"\n"</span>)</div><div class="line">t-test pval: <span class="number">0.1589672</span> </div><div class="line">&gt; cat(<span class="string">"Wilcox test pval:"</span>,wilcox.test(x,y)$p.value,<span class="string">"\n"</span>)</div><div class="line">Wilcox test pval: <span class="number">0.3066718</span> </div><div class="line">&gt; x[<span class="number">1</span>] &lt;- <span class="number">5</span></div><div class="line">&gt; x[<span class="number">2</span>] &lt;- <span class="number">7</span></div><div class="line">&gt; cat(<span class="string">"t-test pval:"</span>,t.test(x,y)$p.value,<span class="string">"\n"</span>)</div><div class="line">t-test pval: <span class="number">0.04439948</span> </div><div class="line">&gt; </div><div class="line">&gt; cat(<span class="string">"Wilcox test pval:"</span>,wilcox.test(x,y)$p.value,<span class="string">"\n"</span>)</div><div class="line">Wilcox test pval: <span class="number">0.1310212</span></div></pre></td></tr></table></figure>
<h3 id="wilcoxon检验的基本思想">Wilcoxon检验的基本思想</h3>
<p>Wilcoxon检验的基本思想如下所示：</p>
<ol style="list-style-type: decimal">
<li>汇总所有数据；</li>
<li>将数据的值转换为秩(rank)，也就是排序；</li>
<li>然后将这些秩再按原来的组别分开；</li>
<li>计算出每组秩的总和，进行检验。</li>
</ol>
<p>检验的过程如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">stripchart(list(x,y),vertical=<span class="literal">TRUE</span>,ylim=c(-<span class="number">7</span>,<span class="number">7</span>),ylab=<span class="string">"Observations"</span>,pch=<span class="number">21</span>,bg=<span class="number">1</span>)</div><div class="line">abline(h=<span class="number">0</span>)</div><div class="line">xrank&lt;-rank(c(x,y))[seq(along=x)]</div><div class="line">yrank&lt;-rank(c(x,y))[-seq(along=y)]</div><div class="line">stripchart(list(xrank,yrank),vertical=<span class="literal">TRUE</span>,ylab=<span class="string">"Ranks"</span>,pch=<span class="number">21</span>,bg=<span class="number">1</span>,cex=<span class="number">1.25</span>)</div><div class="line">ws &lt;- sapply(x,<span class="keyword">function</span>(z) rank(c(z,y))[<span class="number">1</span>]-<span class="number">1</span>)</div><div class="line">text( rep(<span class="number">1.05</span>,length(ws)), xrank, ws, cex=<span class="number">0.8</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190816082005.jpeg">

</div>
<p>上图是含有异常值的两个图表，左侧是原始图形，它含有的异常值，右则是将数值点转换为秩后的图形，可以发现右侧的数据分布就比较正常了，没有异常值。</p>
<p>秩和检验中的W值是对第一组相对于第二组的秩。通过排列组合(combinatorics)，我们可以精确地计算出W的p值。我们也可以使用CLT来计算，因为W是近拉于正态分布的，下面我们构建了z-score来进行计算，如下所示；</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">W &lt;-sum(ws)</div><div class="line">W</div><div class="line">n1&lt;-length(x);n2&lt;-length(y)</div><div class="line">Z &lt;- (mean(ws)-n2/<span class="number">2</span>)/ sqrt(n2*(n1+n2+<span class="number">1</span>)/<span class="number">12</span>/n1)</div><div class="line">print(Z)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; W &lt;-sum(ws)</div><div class="line">&gt; W</div><div class="line">[<span class="number">1</span>] <span class="number">391</span></div><div class="line">&gt; n1&lt;-length(x);n2&lt;-length(y)</div><div class="line">&gt; Z &lt;- (mean(ws)-n2/<span class="number">2</span>)/ sqrt(n2*(n1+n2+<span class="number">1</span>)/<span class="number">12</span>/n1)</div><div class="line">&gt; print(Z)</div><div class="line">[<span class="number">1</span>] <span class="number">1.523124</span></div></pre></td></tr></table></figure>
<p>在这个计算过程中，我们得到了Z值，这个Z值对应的p值大于0.05。</p>
<h2 id="练习-1">练习</h2>
<p>P140</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/07/DAL/DALS007_Inference06_AssociationTests/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/07/DAL/DALS007_Inference06_AssociationTests/" itemprop="url">DALS007-统计推断(Inference)06-关联检验(Association Tests)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-07T12:00:00+08:00">
                2019-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,707
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是《Data Analysis for the Life Sciences》的第2章：统计推断(Inference)的第6部分。这一部分的主要内容涉及卡方检验。</p>
<h2 id="关联检验">关联检验</h2>
<p>前面所提到的案例都是普通的统计学案例，这些普通案例指的是，它们的数据是二元的(binary)，分类的(categorical)或有序的(ordinal)。现在我们考虑一种特殊的案例，例如基因型数据，现在我们有两组基因型数据，一组基因是AA/Aa，另外一组是aa（某个特定疾病的对照）。现在我们的问题是，这个基因型(genotype)是否与疾病相关。这个案例与我们前面提到的案例就有点像了，我们有两个总体，即AA/Aa与aa，我们使用1或0来表示它们对应的疾病状态，其中0是不患病，1是患病的。此时我们不能使用t检验，因为这种数据明显不符合正态分布，无法使用t检验。如果样本足够大的话，可以使用CLT，否则，可以使用关联检验(association test)。</p>
<h2 id="女士品茶">女士品茶</h2>
<p>关于假设检验最有名的一个案例就是Fisher提出的。这个案例大概是这个样子的，一名女士声称，如果牛奶与红茶加入的先后顺序不同，得到的奶茶口味也不同，并且她自己能品尝出来。Fisher就给了4杯奶茶，这4杯奶茶加入的花与牛奶顺序是不同的，是随机的。后来这个女士品尝对了3个，此时，我们能认为这个女士确实有这种能力么，她品尝出的这3杯奶茶是否是出于偶然因素？假设检验就能回答这个问题，并且能够对这种偶然因素进行定量。</p>
<p>现在我们提出我们的基础问题：假如这个女士品尝出的这3杯奶茶是她自己瞎猜（瞎猜说明她没有品尝出奶茶这种能力），并且猜对了，那么她瞎猜对3杯，或者是比3杯更难发生的事件（例如猜对4杯）的概率是多少？现在我们做一个零假设，假设她能猜对4杯，这个事件的概率是多少？</p>
<p>现在我们就把这个事件再简化一下，我们做一个零假设，我们可以把女士品尝这个特殊案例看作是从一个含有4个绿球（正确答案）和4个红球（错误答案）的瓮中挑出4个小球的试验。</p>
<p>零假设就是：这个女士品尝出正确奶茶的结果纯粹是她自己瞎猜的，也就是说，每个小球有着相同的机会被挑中。现在计算一下每个事件的概率，那么挑中3个绿球的概率就是： <span class="math display">\[
\left(\begin{array}{l}{4} \\ {3}\end{array}\right)\left(\begin{array}{l}{4} \\ {1}\end{array}\right) /\left(\begin{array}{l}{8} \\ {4}\end{array}\right)=16 / 70
\]</span> 挑中4个绿球的概率是： <span class="math display">\[
\left(\begin{array}{l}{4} \\ {4}\end{array}\right)\left(\begin{array}{l}{4} \\ {0}\end{array}\right) /\left(\begin{array}{l}{8} \\ {4}\end{array}\right)=1 / 70
\]</span> 现在我们把这两个数值相应，就是约等于0.24，这个数字表示，这个女士能够品尝对3杯奶茶，甚至比3杯奶茶这个事件更加极端的概率（例如4杯奶茶），这就是p值。这个p值产生的过程就是Fisher精确检验(<code>Fisher's exact test</code>)，这类数据服从超几何分布(<code>hypergeometric distribution</code>)。</p>
<h2 id="二联表">二联表</h2>
<p>前面提到的数据我们可以使用二联表来创建，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tab &lt;- matrix(c(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">rownames(tab)&lt;-c(<span class="string">"Poured Before"</span>,<span class="string">"Poured After"</span>)</div><div class="line">colnames(tab)&lt;-c(<span class="string">"Guessed before"</span>,<span class="string">"Guessed after"</span>)</div><div class="line">tab</div></pre></td></tr></table></figure>
<p>数据如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; tab</div><div class="line">              Guessed before Guessed after</div><div class="line">Poured Before              <span class="number">3</span>             <span class="number">1</span></div><div class="line">Poured After               <span class="number">1</span>             <span class="number">3</span></div></pre></td></tr></table></figure>
<p>使用<code>fisher.test()</code>这个函数就能计算出p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fisher.test(tab,alternative=<span class="string">"greater"</span>)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; fisher.test(tab,alternative=<span class="string">"greater"</span>)</div><div class="line"></div><div class="line">	Fisher<span class="string">'s Exact Test for Count Data</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">data:  tab</span></div><div class="line"><span class="string">p-value = 0.2429</span></div><div class="line"><span class="string">alternative hypothesis: true odds ratio is greater than 1</span></div><div class="line"><span class="string">95 percent confidence interval:</span></div><div class="line"><span class="string"> 0.3135693       Inf</span></div><div class="line"><span class="string">sample estimates:</span></div><div class="line"><span class="string">odds ratio </span></div><div class="line"><span class="string">  6.408309</span></div></pre></td></tr></table></figure>
<h2 id="卡方检验">卡方检验</h2>
<p>GWAS全称是Genome-wide association studies，即全基因组关联分析。这种分析的统计结果常用曼哈顿图(Manhattan)图来表示。曼哈顿图的y轴是p值的负的log值（底为10），这个p值则是通过计算数百万个SNP的关联检验得到的。x轴通常是染色体的位置（例如chromosome 1 to 22, X,Y等）。这引起p值的计算类似于前面提到的女士品茶的计算过程。但是，在女士品茶那个案例中，绿球与红球的数目是固定的，针对每种事件的发生次数也是固定的，换句话讲，在列联表中，行与列的中的数字之和是固定的。这种限定条件就对二联表中所有的可能性进行了约束，并且还可以使用超几何分布来计算p值。但是，实际情况并非如此，这时，可以使用另外一种方法，即卡方检验(Chi-squared test)。</p>
<p>假如我们有250个人，他们中有一些人患有某种疾病，剩下的则不患。在这些人中，纯合子(aa)有50人，这些纯合子中又有20%的人患病，即有10名患有该病，而非纯合子(AA/Aa)的人中则有10%患有该病。如果我们再挑250个人，那么又是什么情况呢？</p>
<p>现在我们先根据既有的数据来过计算一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">disease=factor(c(rep(<span class="number">0</span>,<span class="number">180</span>),rep(<span class="number">1</span>,<span class="number">20</span>),rep(<span class="number">0</span>,<span class="number">40</span>),rep(<span class="number">1</span>,<span class="number">10</span>)),</div><div class="line">labels=c(<span class="string">"control"</span>,<span class="string">"cases"</span>))</div><div class="line">genotype=factor(c(rep(<span class="string">"AA/Aa"</span>,<span class="number">200</span>),rep(<span class="string">"aa"</span>,<span class="number">50</span>)),</div><div class="line">levels=c(<span class="string">"AA/Aa"</span>,<span class="string">"aa"</span>))</div><div class="line">dat &lt;- data.frame(disease, genotype)</div><div class="line">dat &lt;- dat[sample(nrow(dat)),] <span class="comment">#shuffle them up</span></div><div class="line">head(dat)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(dat)</div><div class="line">    disease genotype</div><div class="line"><span class="number">130</span> control    AA/Aa</div><div class="line"><span class="number">191</span>   cases    AA/Aa</div><div class="line"><span class="number">187</span>   cases    AA/Aa</div><div class="line"><span class="number">233</span> control       aa</div><div class="line"><span class="number">144</span> control    AA/Aa</div><div class="line"><span class="number">91</span>  control    AA/Aa</div></pre></td></tr></table></figure>
<p>使用<code>table()</code>函数可以创建一个列联表，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(genotype)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; table(genotype)</div><div class="line">genotype</div><div class="line">AA/Aa    aa </div><div class="line">  <span class="number">200</span>    <span class="number">50</span></div></pre></td></tr></table></figure>
<p>查看一下疾病的列联表，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(disease)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; table(disease)</div><div class="line">disease</div><div class="line">control   cases </div><div class="line">    <span class="number">220</span>      <span class="number">30</span></div></pre></td></tr></table></figure>
<p>现在把基因型与疾病关联起来，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tab &lt;- table(genotype,disease)</div><div class="line">tab</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; tab</div><div class="line">        disease</div><div class="line">genotype control cases</div><div class="line">   AA/Aa     <span class="number">180</span>    <span class="number">20</span></div><div class="line">   aa         <span class="number">40</span>    <span class="number">10</span></div></pre></td></tr></table></figure>
<p>从上面结果可以看出来，我们使用了2个因素，即基因型，疾病，函数<code>table()</code>返回了<code>2X2</code>列联表。</p>
<p>对于上述的这种数据，我们通常会使用比数比(OR, odds ratio)来表示。现在我们计算一下<code>aa</code>的比数(odd)，即<code>10/40</code>，也就是说在50个纯合子(aa)中，有10名患病，40名不患病，这个数值是患病与不患病的比值。那么AA/Aa这种基因型患病的比数为20/180，这两个比值再进行比，就是比数比(odd ratio)，即：<code>(10/40)/(20/180)</code>，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(tab[<span class="number">2</span>,<span class="number">2</span>]/tab[<span class="number">2</span>,<span class="number">1</span>]) / (tab[<span class="number">1</span>,<span class="number">2</span>]/tab[<span class="number">1</span>,<span class="number">1</span>])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; (tab[<span class="number">2</span>,<span class="number">2</span>]/tab[<span class="number">2</span>,<span class="number">1</span>]) / (tab[<span class="number">1</span>,<span class="number">2</span>]/tab[<span class="number">1</span>,<span class="number">1</span>])</div><div class="line">[<span class="number">1</span>] <span class="number">2.25</span></div></pre></td></tr></table></figure>
<p>我们并不使用OR来直接计算p值。相反，我们会先假设基因型与疾病没有关联，然后计算出表格中每个单元格的期望数值。在零假设下，含有200个人的AA/Aa和含有50个人的aa都被计算出相应的患病数，把他们都当成一个总体，那么患病率是：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p=mean(disease==<span class="string">"cases"</span>)</div><div class="line">p</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; p</div><div class="line">[<span class="number">1</span>] <span class="number">0.12</span></div></pre></td></tr></table></figure>
<p>那么这个表格的期望值是（期望值是使用每组的人数乘以发病率）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">expected &lt;- rbind(c(<span class="number">1</span>-p,p)*sum(genotype==<span class="string">"AA/Aa"</span>),</div><div class="line">c(<span class="number">1</span>-p,p)*sum(genotype==<span class="string">"aa"</span>))</div><div class="line">dimnames(expected)&lt;-dimnames(tab)</div><div class="line">expected</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; expected</div><div class="line">        disease</div><div class="line">genotype control cases</div><div class="line">   AA/Aa     <span class="number">176</span>    <span class="number">24</span></div><div class="line">   aa         <span class="number">44</span>     <span class="number">6</span></div></pre></td></tr></table></figure>
<p>卡方检验的p值计算结果如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chisq.test(tab)$p.value</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; chisq.test(tab)$p.value</div><div class="line">[<span class="number">1</span>] <span class="number">0.08857435</span></div></pre></td></tr></table></figure>
<h2 id="大样本小p值">大样本，小p值</h2>
<p>前面提到，在报道一项发现时，仅报道p值是不合适。许多遗传学关联研究似乎过于强调p值，在这些研究中，研究者们使用了大量的样本，因此他们报道的p值非常人低。但是，如果我们仔细看一下他们的结果就会发现，比数比(odd ratio)则表现得很一般：很少有大于1的。在这种情况下，基因型为AA/Aa或aa的差异也许并不改变个体的疾病风险，虽然这有着实际意义(practically significant)，但是，一个人不可能根据这些基因型与疾病的关系而对自己的行为进行改变。</p>
<p>比数比(odds ration)与p值之间并非是一对一的关系。为了说明这一点，我们在保证所有比例相同的前提下来重新计算一下p值。现在我们把样本数目扩大10倍，这就会明显地降低p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tab &lt;- tab*<span class="number">10</span></div><div class="line">chisq.test(tab)$p.value</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; tab &lt;- tab*<span class="number">10</span></div><div class="line">&gt; chisq.test(tab)$p.value</div><div class="line">[<span class="number">1</span>] <span class="number">1.219624e-09</span></div></pre></td></tr></table></figure>
<h2 id="比数比的置信区间confidence-intervals-for-the-odd-ratio">比数比的置信区间(Confidence Intervals For The Odd Ratio)</h2>
<p>在数学上计算OR的置信区间并不简单明了。在计算其它统计量时，我们可以推导出那些统计量的近似，但是OR的计算与之不同，OR不仅是一个比值，而是一个比值的比值。因此，没有简单的方法（例如CLT）来计算OR。</p>
<p>一种方法是使用广义线性模型(generalized linear models )的理论，这种理论可以对比数比的log值(log odds ratio)进行估计。经过log转换的比数比就可以被证明是接近正态分布的，如下所示（具体的理论可以参考文献）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fit &lt;- glm(disease~genotype,family=<span class="string">"binomial"</span>,data=dat)</div><div class="line">coeftab&lt;- summary(fit)$coef</div><div class="line">coeftab</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; fit &lt;- glm(disease~genotype,family=<span class="string">"binomial"</span>,data=dat)</div><div class="line">&gt; coeftab&lt;- summary(fit)$coef</div><div class="line">&gt; coeftab</div><div class="line">              Estimate Std. Error   z value     Pr(&gt;|z|)</div><div class="line">(Intercept) -<span class="number">2.1972246</span>  <span class="number">0.2356828</span> -<span class="number">9.322803</span> <span class="number">1.133070e-20</span></div><div class="line">genotypeaa   <span class="number">0.8109302</span>  <span class="number">0.4249074</span>  <span class="number">1.908487</span> <span class="number">5.632834e-02</span></div></pre></td></tr></table></figure>
<p>数据的表格中的第2行就是估计值与log(odds ratio)的值。数学理论告诉我们，这个估计值是接近于正态分布的。因此我们可以构建一个置信区间，然后再化为正常值，就能计算出OR的置信区间，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ci &lt;- coeftab[<span class="number">2</span>,<span class="number">1</span>] + c(-<span class="number">2</span>,<span class="number">2</span>)*coeftab[<span class="number">2</span>,<span class="number">2</span>]</div><div class="line">exp(ci)</div></pre></td></tr></table></figure>
<p>计算结果为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; ci &lt;- coeftab[<span class="number">2</span>,<span class="number">1</span>] + c(-<span class="number">2</span>,<span class="number">2</span>)*coeftab[<span class="number">2</span>,<span class="number">2</span>]</div><div class="line">&gt; exp(ci)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9618616</span> <span class="number">5.2632310</span></div></pre></td></tr></table></figure>
<p>这个置信区间包括1，这与p值大于于0.05的结果是一致的。需要注意的是，这里的p值是基于另一种不同方法计算的，它以前面使用卡方检验得到的p值计算过程不一样。</p>
<h2 id="练习">练习</h2>
<p>P91</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/06/DAL/DALS006_Inference05_PermutationTest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/06/DAL/DALS006_Inference05_PermutationTest/" itemprop="url">DALS006-统计推断(Inference)05-置换检验(Permutation Test)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-06T12:00:00+08:00">
                2019-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,515
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是《Data Analysis for the Life Sciences》的第2章：统计推断(Inference)的第5部分。这一部分的主要内容涉及置换检验。</p>
<p>置换检验英文是Permutation test，这是Fisher于20世纪30年代提出的一种基于大量计算（computationally intensive），利用样本数据的全（或随机）排列，进行统计推断的方法，因其对总体分布自由，应用较为广泛，特别适用于总体分布未知的小样本资料，以及某些难以用常规方法分析资料的假设检验问题。在具体使用上它和Bootstrap Methods类似，通过对样本进行顺序上的置换，重新计算统计检验量，构造经验分布，然后在此基础上求出P-value进行推断。</p>
<p>置换检验的根本原理就是<strong>重新采样增加小样本的整体样本量，然后看其的概率分布来预测假设是否成立</strong>。这个基于t-test的，类似于与t-test，但是我觉的在样本量非常少的情况下，用置换检验可以更好的说明问题。这个p-value主要是sobs值在置换经验中均值的分布概率，最终也是利用p-value的值来判断假设是否成立的，看p值的大小，p值小于0.05时，是说明拒绝H0，大于0.05.则是说明服从0假设。</p>
<h2 id="置换检验permutation-test">置换检验(Permutation Test)</h2>
<p>现在考虑一种情况，在这种情况下，标准的数理统计近拟(standard mathematical statistical approximation)都不适用。但是，我们已经计算出了一个总结性的统计，例如均值的差值，但是，我们的这些数据不符合一些即定分布，也没有办法得到总体，也就是说无法进行一些数据模拟，例如Monte Carlo模拟，面对这种情况，我们可以采用置换检验(Permutation test)。</p>
<h2 id="置换检验过程">置换检验过程</h2>
<p>在前面部分中，我们描述了参数模拟，这种方法有助于我们计算出观察到的差值是否有统计学的意义。而置换检验则会使用另外一种计算方法，也是利用了两组的差值。在这种方法中，我们会随机置换干预组与对照组的分组标签。当我们置换了干预组与对照组的分级标签后，得到的新数据我们会假设它们服从零分布，现在我们通过置换这两组数据来计算一下零分布（这里假设置换1000次）。</p>
<p>第一步，是先计算出两组（这里是treatment组与control组） 的均值差值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/femaleMiceWeights.csv"</span>)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">control &lt;- filter(dat, Diet == <span class="string">"chow"</span>) %&gt;% dplyr::select(Bodyweight) %&gt;% unlist</div><div class="line">treatment &lt;- filter(dat, Diet == <span class="string">"hf"</span>) %&gt;% dplyr::select(Bodyweight) %&gt;% unlist</div><div class="line">obsdiff &lt;- mean(treatment) - mean(control)</div></pre></td></tr></table></figure>
<p>第二步，对样本重新进行分组，也就是将上述的两组的所有数据（每组都是12个样本，一共是24个数据）重新进行分组，每组12个数值，每组重新分组时，都计算出均数差，24个数据随机等分为2组，一共是2704156个均数差（使用<code>choose(24,12)</code>就能计算出来，不过我们这里只置换1000次，现在我们通过置换这两组数据来计算一下零分布（置换1000次），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">12</span></div><div class="line">avgdiff &lt;- replicate(<span class="number">1000</span>, &#123;</div><div class="line">  all &lt;- sample(c(control, treatment))</div><div class="line">  newcontrols &lt;- all[<span class="number">1</span>:N]</div><div class="line">  newtreatments &lt;- all[(N+<span class="number">1</span>):(<span class="number">2</span>*N)]</div><div class="line">  <span class="keyword">return</span>(mean(newtreatments)-mean(newcontrols))</div><div class="line">&#125;)</div><div class="line">hist(avgdiff)</div><div class="line">abline(v=obsdiff,col=<span class="string">"red"</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728170314.jpeg">

</div>
<p>第三步：计算出上面那1000个均数差中大于<code>obsdiff</code>的个数。</p>
<p>现在我们考虑一下，有多少个零均值(null means，结合上下文，这里的零均值应该是在零假设成立的前面下的均值）大于观察值呢？这个比值就是零假设成立下的p值。我们向分子与分母都加1，用于校正一下p值（书中列出的参考文献，这里不解释），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># the proportion of permutations with larger difference</span></div><div class="line">(sum(abs(avgdiff) &gt; abs(obsdiff))+<span class="number">1</span>)/(length(avgdiff)+<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment"># the proportion of permutations with larger difference</span></div><div class="line">&gt; (sum(abs(avgdiff) &gt; abs(obsdiff))+<span class="number">1</span>)/(length(avgdiff)+<span class="number">1</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.04795205</span></div></pre></td></tr></table></figure>
<p>第四步：就是根据第三步中的计算结果（上面的计算结果是0.04795205）来下结论。</p>
<p>如果p&gt;0.05，说明在两样本来自同一总体的假设下，当前样本的出现是很平常的，不能拒绝H0假设，认为两样本的差异无统计学意义；如果p&lt;0.05，则认为两样本的差异有统计学意义，不过考虑到这里的p值基本上就是在0.05附近，因此下结论也应该慎重。</p>
<p>现在我们使用小样本数据来重复一下这个实验，我们通过抽样的方式来创建一个小样本数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">5</span></div><div class="line">control &lt;- sample(control, N)</div><div class="line">treatment &lt;- sample(treatment, N)</div><div class="line">obsdiff &lt;- mean(treatment) - mean(control)</div><div class="line"></div><div class="line">avgdiff &lt;- replicate(<span class="number">1000</span>,&#123;</div><div class="line">  all &lt;- sample(c(control, treatment))</div><div class="line">  newcontrols &lt;- all[<span class="number">1</span>:N]</div><div class="line">  newtreatments &lt;- all[(N+<span class="number">1</span>):(<span class="number">2</span>*N)]</div><div class="line">  <span class="keyword">return</span>(mean(newtreatments) - mean(newcontrols))</div><div class="line">&#125;)</div><div class="line">hist(avgdiff)</div><div class="line">abline(v=obsdiff, col=<span class="string">"red"</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728173556.jpeg">

</div>
<p>上面的直方图显示的是使用置换检验计算出来的小样本数据的均值之差，红线表示的是观察值的差异。</p>
<p>现在我们发现，使用这种方法得到的观察差值并不显著，这里需要记住，没有理论能保证，置换的结果接近于实际的零分布。例如，如果不同的总体之间确实存在着差异，一些置换检验的结果可能就计算不出差异，也有一些能计算出差异。这说明，在置换检验中，零分布比实际的零分布有着一个更扁平的尾部。这也就说明了，为什么置换检验会得到一个比较保守的p值。出于这种原因，当我们的样本数目比较少时通常不做置换检验。</p>
<h2 id="练习">练习</h2>
<p>P91</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="https://blog.csdn.net/u011467621/article/details/47971917" target="_blank" rel="external">Permutation Test 置换检验(转）</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/05/DAL/DALS005_Inference04_MonteCarlo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/DAL/DALS005_Inference04_MonteCarlo/" itemprop="url">DALS005-统计推断(Inference)04-Monte Carlo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T12:00:00+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,152
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是《Data Analysis for the Life Sciences》的第2章：统计推断(Inference)的第4部分。这一部分的主要内容涉及Monte Carlo模拟。</p>
<h2 id="随机数">随机数</h2>
<p>计算机可以生成伪随机数(pseudo-random numbers)，使用这些伪随机数可以用于模拟来自真实世界的随机变量。这可以让我们利用计算机来，而不是理论分析或推导来研究一些随机变量的特异。使用这种概念的一个非常有用的地方就在于，我们可以创建一些模拟数据来测试来验证我们的一些想法，而不必在实验室中做一些实验。</p>
<p>模拟数据也可以用于检测一些理论或分析结果的可靠性。此外，在统计学中，我们使用的很多结果是渐时性的：只当样本达到无穷大时它们才有可能成立。在实际中，我们无法收集所有的样本来验证理论与实际的关系如何。有时候我们就需要一些模拟数据。</p>
<h2 id="monte-carlo模拟">Monte Carlo模拟</h2>
<p>现在我们使用Mote Carlo模拟来比较一下在不同样本数目中，CLT与t分布的接近程度，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/mice_pheno.csv"</span>)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">controlPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"chow"</span>) %&gt;% dplyr::select(Bodyweight) %&gt;% unlist</div></pre></td></tr></table></figure>
<p>现在构建一个函数，这个函数用于生成零假设下，样本数目<code>n</code>的t统计量，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/mice_pheno.csv"</span>)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">controlPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"chow"</span>) %&gt;% dplyr::select(Bodyweight) %&gt;% unlist</div><div class="line"></div><div class="line">ttestgenerator &lt;- <span class="keyword">function</span>(n)&#123;</div><div class="line">  <span class="comment"># note that here we have a false "high fat" group where we actually</span></div><div class="line">  <span class="comment"># sample from the nonsmokers. this is because we are modeling the *null*</span></div><div class="line">  cases &lt;- sample(controlPopulation, n)</div><div class="line">  controls &lt;- sample(controlPopulation,n)</div><div class="line">  tstat &lt;- (mean(cases) - mean(controls))/</div><div class="line">    sqrt(var(cases)/n + var(controls)/n)</div><div class="line">  <span class="keyword">return</span>(tstat)</div><div class="line">&#125;</div><div class="line">ttests &lt;- replicate(<span class="number">1000</span>,ttestgenerator(<span class="number">10</span>))</div><div class="line">hist(ttests)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728144306.jpeg">

</div>
<p>这个t分布是否非常接近于正态分布？我们可以使用qq图(quantile-quantile)来看一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qqnorm(ttests)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728144406.jpeg">

</div>
<p>从上图我们可以看出来，这个数据集非常接近于正态分布。如果现在我们将样本数改为3，qq图如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ttests &lt;- replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">3</span>))</div><div class="line">qqnorm(ttests)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728144516.jpeg">

</div>
<p>从上图可以看出来，数据的高分位数(large quantiles)区，也就是统计学家称的尾部(tails)，比较大，这个尾部区就是上图中直线左侧的下方数据，以及右侧直线上方的数据。在前面的部分我们提到，即使总体服从正态分布，那么小样本则是更加近似地服从t分布，下面我们来的模拟一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ps &lt;- (seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span></div><div class="line">qqplot(qt(ps,df=<span class="number">2</span>*<span class="number">3</span>-<span class="number">2</span>),ttests,xlim=c(-<span class="number">6</span>,<span class="number">6</span>),ylim=c(-<span class="number">6</span>,<span class="number">6</span>))</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728155402.jpeg">

</div>
<p>从上面两张图可以看出来，数据更接近于t分布，而不是正态分布，不过虽然接近于t分布，但是这种接近也并非完全，这是由于原始数据也并不是完美的服从正态分布，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qqnorm(controlPopulation)</div><div class="line">qqline(controlPopulation)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728155539.jpeg">

</div>
<h3 id="观测值的参数化模拟parametric-simulations-for-the-observations">观测值的参数化模拟(Parametric Simulations for the Observations)</h3>
<p>上述我们模拟随机变量的方法叫Monte Carlo模拟。我们利用既有的总体数据，随机抽取了一些样本。在实际分析中，我们无法获取整个总体。但是，当我们想在实际分析过程中使用Monte Carlo模拟时，一种比较典型的做法是，假设一个参数分布(parametric distribution)，并根据此分布生成一个总体，这种手段叫参数模拟(parametric simulation)。这就意味着，我们从真实的数据（这里指的是样本的均值与标准差）中提取参数，将这些参数添加一个模型（这里指的是正态分布）。这是Monte Carlo模拟最普遍的手段。</p>
<p>回到小鼠的体重案例上来，我们可以利用我们现在有的知识，例如小鼠的体重通常是24g，SD为3.5g，小鼠的体重用了近服从正态分布，我们可以产生一个总体：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">controls&lt;- rnorm(<span class="number">5000</span>, mean=<span class="number">24</span>, sd=<span class="number">3.5</span>)</div></pre></td></tr></table></figure>
<p>当我们生成了这批数据后，我们可以重复再生成几次。此时，我们并不使用<code>sample()</code>函数来进行抽样，而是使用随机数来生成一些服从正态分布的数据，前面提到的<code>ttestgenerator()</code>函数更改如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ttestgenerator &lt;- <span class="keyword">function</span>(n, mean=<span class="number">24</span>, sd=<span class="number">3.5</span>)&#123;</div><div class="line">  cases &lt;- rnorm(n, mean,sd)</div><div class="line">  controls &lt;- rnorm(n, mean, sd)</div><div class="line">  tstat &lt;- (mean(cases)-mean(controls))/</div><div class="line">    sqrt(var(cases)/n + var(controls)/n)</div><div class="line">  <span class="keyword">return</span>(tstat)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="练习">练习</h2>
<p>P88</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/05/Literature/文献笔记-RNA sequencing the teenage years/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/Literature/文献笔记-RNA sequencing the teenage years/" itemprop="url">文献笔记-RNA sequencing the teenage years</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T12:00:00+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/文献笔记/" itemprop="url" rel="index">
                    <span itemprop="name">文献笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  29,502
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  105
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文献信息">文献信息</h2>
<p>本文是2019年7月份发表在《Nature Reviews Genetics》上的有关RNA-seq的综述文章。</p>
<p>文献信息如下所示：</p>
<p>Stark, R., et al. (2019). “RNA sequencing: the teenage years.” Nature Reviews Genetics.</p>
<h2 id="摘要">摘要</h2>
<p>在过去的十年中，RNA测序(RNA-seq)已经成为在全转录组范围内分析差异基因表达和mRNAs差异剪接的重要工具。然而，随着下一代测序技术的发展，RNA-seq技术也在不断发展。现在，RNA-seq用于研究RNA生物学的许多方面，其中包括单细胞基因表达、翻译（翻译组,translatome）和RNA结构（结构组，structurome）。RNA-seq的其它应用也在开发中，例如空间转录学(spatialomics)。加上新的长读长 （long-read，**注：在本文中，RNA-seq测序生成的read统一译为“读长“**）和直接RNA-seq(direct RNA-seq)技术以及用于数据分析的更好的计算工具的整合，RNA-seq技术的创新有助于人们更全面地理解RNA生物学，例如从何时何地转录发生到控制RNA功能的折叠和分子间相互作用等问题。</p>
<h2 id="前言">前言</h2>
<p>RNA-seq技术出现于十年之前，自其诞生之日起，RNA-seq就成了研究分子生物学的普遍工具，这项技术几乎构成了我们对基因组功能的认知基础 。RNA-seq中最常用的分析方法就是找出<strong>差异基因表达(Differential gene expression, DGE)</strong>。从最早的出版期刊开始，DGE分析的基本阶段就未发生实质性的改变。在实验室中，其标准流程就分为三步：</p>
<p>第一步是构建测序文库，这一步骤包括提取RNA，富集mRNA或清除核糖体RNA，合成 cDNA，加上接头。</p>
<p>第二步，在高通量平台（通常是Illumina平台）上对文库进行测序，每个样本的测序深度为10-30M读长数（读长这里就是前面说的reads）。</p>
<p>第三步是数据分析，具体的工作是：对测序得到的读长进行<strong>比对(aligning)</strong>和/或组装到转录组上，对这些覆盖了转录组的读长进行过滤，归一化(Normalization)，根据统计模型找出那些在不同样本之间有差异的转录本。早期的RNA-seq从大量的实验样本中产生了DGE数据，这充分说明了RNA-seq在广泛的生物体以及系统中的使用，这些生物体包括玉米(Zea mays), 拟南芥(Arabiodopsis thaliana), 酿酒酵母（Saccharomyces cerevisae），小鼠(Mus musculus)以及人类。虽然RNA-seq这个术语经常被用于那些完全不同的方法学方法和/或生物学，但是DGE分析仍然是RNA-seq（补充材料中的表1）的主要应用，并被视为常规研究工具。</p>
<p>RNA-seq的更广泛应用已经促进了我们对生物学多方面的理解 ，例如通过提示mRNA剪接和非编码RNAs和增强子RNAs对基因表达的调控。RNA-seq的应用和进步是由技术发展（湿实验室和计算生物学）驱动的，相对于以前的基因芯片，RNA-seq这种方法对RNA生物学和转录组产生更丰富并且偏见更小的信息。到目前为止，从标准的RNA-seq方法衍生而来的各种RNA-seq方法几乎有100种。Illumina的短读长(short-read)测序平台能对这些由大部分不同方法的RNA-seq构建的文库进行测序，但是最近长读长(long-read)RNA-seq的与直接RNA-seq测序(direct RNA sequencing, dRNA-seq)的进步已经能够解决以前研究人员使用短序列手段无法解决的一些问题。</p>
<p>在这篇综述中，我们首先会介绍一些最基本的短读长RNA-seq中的DGE方法，再将这种基础方法与最近新兴的长读长RNA-seq和dRNA-seq进行比较。我们会介绍短读长测序方法在文库制备方面的进展，以及实验设计和DGE的数据分析方法。随后我们会拓展这些常规的RNA-seq方法，介绍一些单细胞测序和空间转录组学的分析。我们会提供一些案例，介绍RNA-seq在RNA生物学方面的关键应用，包括转录组分析，翻译动力学，RNA结构，RNA-RNA之间相互作用和RNA-蛋白质的相互作用。最后，我们会简单描述一下RNA-seq的未来，以及单细胞和空间RNA-seq方法是否会像DGE分析一样成为常规工具，长读长测序方法是否会取代短读长测序方法。由于篇幅限制，我们无法介绍所有的RNA-seq方法，在这些方法中，值得注意的是非编码转录组学，原核转录组学(prokaryotic transcriptomes)和表观转录组学(epitranscriptome)。</p>
<h2 id="rna-seq技术的发展历史">RNA-seq技术的发展历史</h2>
<p>Illumina的短序列读长测序技术生成了<strong>SRA(Short Read Archive)</strong>中95%已表达的数据（附件表2）。由于cDNA的短序列读长测序方法几乎是一种常规的方法，因此 我们认为这是一种最基础的 RNA-seq技术，我们先来讨论这种测序主要流程与局限。不过，长读长cDNA测序与dRNA-seq已经兴起，随着研究人员对能提供更丰富转录本水平方面(isoform-level)数据需求增大，这两种新的测序方法有望对常规的短读长测序方法提出挑战(FIG1, TABLE1)。</p>
<h3 id="table1-短读长与长读长rna-seq平台">Table1-短读长与长读长RNA-seq平台</h3>
<table style="width:100%;">
<colgroup>
<col width="4%">
<col width="12%">
<col width="27%">
<col width="27%">
<col width="27%">
</colgroup>
<thead>
<tr class="header">
<th>测序技术</th>
<th>平台</th>
<th>优势</th>
<th>劣势</th>
<th>重要应用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>短读长cDNA</td>
<td>Illumina， Ion Torrent</td>
<td>①高通量，一次运行产生的读长是长读长平台的100倍到1000倍。②偏倚与错误明确（对Ion Torrent平台来说，聚合物(homopolymers)仍是一个问题）。③ 现在有大量可兼容的方法和计算流程； 4． 可对降解的RNA进行分析。</td>
<td>①样本制备包括逆转录，PCR与片段大小选择，所有的这些操作增加了测序偏倚。②针对异构体检测与定量的能力有限。③转录本发现分析需要从头对转录本进行比对和/或组装步骤。</td>
<td>几乎所有的RNA-seq方法都已经是针对短读长cDNA测序而开发的：DGE，WETA，smallRNA， 半日细胞，空间转录组，nascent RNA，翻译组，结构和RNA-蛋白质相互作用分析等等。</td>
</tr>
<tr class="even">
<td>长读长cDNA</td>
<td>PacBio， ONT</td>
<td>①可捕获1-50kb的长读长； ②从头转录组分析方法简单。</td>
<td>①中低通量：目前一次运行只能生成0.5M到10M的读长；②样本制备包括逆转录，PCR和片段选择，增加了偏倚；③针对降解的RNA分析能力有限。</td>
<td>用于研究新异构体，从头转录组分析，融合转录本发现，MHC，HAL或其它复杂的转录本分析。</td>
</tr>
<tr class="odd">
<td>长读长RNA</td>
<td>ONT</td>
<td>①可捕获许多1-50kb的全长转录组；②从头转录组分析方法简单； ③样本制备并不需要进行逆转录或PCR，从而降低了PCR导致的偏倚；④ 可检测RNA的修饰；⑤ 直接在单细胞水平上对poly(A)进行估计。 ①</td>
<td>低通量，目前一次运行只能生成0.5M到1M的读长；②样本制备与测序偏倚不明；③无法对降解的RNA进行分析。</td>
<td>①用于研究新异构体，从头转录本分析，融合转录本，MHC，HLA或其它的复杂转录本分析。②检测核糖核酸修饰。</td>
</tr>
</tbody>
</table>
<h3 id="figure-1-短读长长读长和直接rna-seq技术与工作流程">Figure 1-短读长，长读长和直接RNA-seq技术与工作流程</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805185923.png">

</div>
<p><strong>Figure 1-短读长，长读长和直接RNA-seq技术与工作流程。</strong></p>
<p><strong>(a)不同RNA-se方法的文库制备，这些方法可以分为3种，分别是短读长测序（黑色），长读长测序（绿色），或长读长直接RNA-seq（蓝色）。根据使用的文库制备方法不同，文库制备会表现出相应的复杂性和偏倚。短读长与长读长cDNA文库在制备时有一些步骤是相同的，不过所有的方法都需要一个接头连接步骤，并且它们都受到样本质量和文库上下游计算问题的影响。</strong></p>
<p><strong>(b)三种主流的RNA-seq测序方法。</strong></p>
<p><strong>Illumina的工作流程（左边）：文库制备好后，每个cDNA就会在一个泳道(flowcell)上通过合成来聚集成簇，其中合成的过程使用3’阻断的荧光标记的核苷酸。在每一轮测序的过程中，新合成的DNA链就会被成像，从而检测出参与合成的是哪种核苷酸，这种测序方法产生的读长是50-500bp。</strong></p>
<p><strong>Pacific Biosciences工作流程（中间）：文库制备好后，每个分子被加载到一个测序芯片上，在芯片上这些分子与固定到纳米孔(nanowell)底部的聚合酶进行结合。随着每一个荧光标记的核苷酸被整合到新合成的链上，这些核苷酸发出的荧光就会被检测到，这种方法产生的读长为50kb。</strong></p>
<p><strong>Oxford纳米孔工作流程（右边）：文库制备好后，每个分子被加载到流动室(flowccell)中，流式室中含有马达蛋白，马达蛋白固定在流动室中，它可以与文库的接头结合。马达蛋白控制RNA链通过纳米孔，从而造成纳米孔中电流的改变，这种技术产生的读长为1-10kb。</strong></p>
<p>**(c) 短读长、长读长与直接RNA-seq分析的比较。超过90%的人类基因(gene n)存在可变剪接，它们会形成两个或更多的可表达异构体（转录本x与y）。短读长cDNA测序中就增加了捕获信息的复杂性，短读长对异构体的检测会受到其读长的限制，在这种技术里，短读长无法精确地回贴（注：测序分析方法中的术语“map“在本文中都译为”回贴“）到转录组上，而长读长测序方法则能直接鉴定异构体。在短读长cDNA测序中，有很大比例的读长会不明确地回贴到不同异构相同的外显子上；而那些跨越了外显子-外显子连接处的读长可以提高对异构体的分析效果，但是当不同的异构体都含有这个连接处时，这种操作意义不大。这些问题都加剧了数据分析的复杂性，以及无法对结果进行明确地解释。长读长cDNA方法能够产生全长的异构体读长，从而去除或大幅度降低这些不精确的结果，并改进差异异构表达的分析结果。然而这些方法依赖于cDNA的转换，它去除了RNA碱基的修饰信息，并且只能粗略地估计多聚腺苷酸(poly(A))尾巴长度。直接RNA-seq可以进行全长导构体分析，碱基修饰检测（例如N6-甲基腺苷(M6A)）和poly(A)尾巴长度估计。**</p>
<h3 id="短读长cdna测序">短读长cDNA测序</h3>
<p>短读长已经成了在整个转录组范围内对基因进行检测和定量的事实方法(de facto method)，部分原因是这种方法比芯片成本更低，操作更方便，但是其主要原因还是因为这种方法能生成更全面，更高质量的数据，这种方法能够 对整个转录组中的基因表达水平进行定量。使用Illumina短读长测序平台进行DGE分析的核心步骤包括： RNA提取、cDNA合成、接头连接、PCR扩增、测序和数据分析(FIG1)。在这个过程中，存在打断片段，片段长度选择和基于磁珠的文库纯化这些操作，因此这种方法产生的cDNA片段通常都是在200bp以下。RNA-seq文库的测序读长分配到每个样本上的话，每个样本会测到平均20-30 million条读长(reads)（也就是常说的20-30M条读长），数据经过处理后，使用这些读长对每个基因或转录本进行定量，最后再用统计学方法来统计基因的差异。短读长RNA-seq方法很稳健，并且通过对短读长测序技术的大范围比较发现，这种技术在平台内和平台间的相关性很好。但是，在样本制备和数据分析这两个阶段会引入一些干扰和偏倚。这种局限可能会影响通过实验来解决特定生物学问题的能力，例如准确识别和量化多个异构体中的哪个来源于一个基因。对于研究那些非常长，高度可变的转录本异构的人来说，这种局限表现得尤为明显，例如在人类转录组研究中；人类转录本的长度范围是109bp到186kb，其中50%转录本长度大于2500bp。尽管短读长RNA-seq可以对最长的转录本进行详细的分析，但是涉及的实验方法不能扩展到全转录组分析。其他的偏倚与局限来源于那些大量的计算方法，这些方法包括例如如何处理模糊或多个回贴的读长(multi-mapped reads)。现在出现了一种<strong>合成长读长(synthetic long reads)</strong>的新方法，这种方法可以实现全长的mRNA测序，并试图解决其中的一些局限。这种方法使用了<strong>唯一分子标识符(unique molecular identifiers,UMI)</strong>来标记全长的cDNA，在制备短读长RNA文库之前，加入的UMI会随着单个cDNA分子而进行复制。转录本异构体可以在高达4kd的contigs中重建，用于发现异构体和表达分析。但是，对于从根本上解决短读长cDNA测序固有局限的最可能解决方案则是长读长cDNA测序和dRNA-seq测序 。</p>
<h3 id="长读长cdna测序">长读长cDNA测序</h3>
<p>虽然Illumina测序目前是占主导地位的RNA-seq平台，但PacBio和Oxford Nanopore(ONT)公司都提供了可供选择的长读长技术，能够对完整的单个RNA分子进行单分子水平级的测序。通过消除短RNA-seq测序数据的组装这一步，这些新方法克服了短读长测序方法相关的一些问题。例如，减少了测序读长回贴过程中的歧义，并且可以识别更长的转录本，这样就能获取更完整的异构体多样性信息。这些方法还能降低许多短读长RNA-seq计算工具中关于剪接连接的假阳性。</p>
<p>PacBio的Iso-Seq技术可以读取最高可达15kb的转录本的全长cDNA，这就有利于发现大量以前未注释的转录本，并通过检测物种的全长同源序列证实了早期的基因预测。在标准的Iso-Seq操作流程中，高质量的RNA被一个模板切换凝聚力转录酶(a template-switching reverse transcriptase)反转录为全长的cDNA。生成的cDNAs再经过PCR扩增，加入到PacBio的单分子实时(single-molecule, real-time)文库制备系统中。制备好的短转录本序列可以很快地扩散到测序芯片的活性表面，但由于短转录本的测序存在偏倚，因此在对转录本进行测序时，建议选择片段的长度是1到4kb，这样就能在此范围对长转录本和短转录本进行更加均匀地采样。由于PacBio测序方法需要大量的模板，因此需要进行多轮PCR，不过这一操作还需要进行优化，从而降低扩增导致的偏倚。经过PCR的末端修复和PacBio SMRT接头连接后，就可以进行长读长测序了；通过修改测序芯片的上样条件，就可以在这一步骤进一步控制测序片段长度。</p>
<p>ONT cDNA测序方法也能产生全长的转录本读长，甚至还能在单细胞水平上产生该读长。模板转录逆转录酶也在这种方法中用于制备全长cDNA，制备好的cDNA可以选择使用PCR来进行扩增，随后在产物上加上接头，形成测序文库。直接cDNA测序会消除PCR偏倚，从而形成高质量的测序结果；但是，如果使用PCR来制备测序文库的话，需要的RNA数量更少。ONT cDNA测序法尚未报道过在PacBio测序仪上观察到的片段长度偏倚。</p>
<p>这两种长读长cDNA方法都受到标准模板切换逆转录酶使用的限制，这种逆转录酶能用全长RNA以及截短的RNA来生成cDNA。逆转录酶可以将那些只含5ʹ帽子结构的mRNA置换为cDNA，这样的话，那些由于RNA降解，RNA剪接或不完全cDNA合成而生成的短转录本就不会被反转录为cDNA，从而提高数据质量。但是，有报道指出，逆转录酶会对ONT平台的读长产生不良影响。</p>
<h3 id="长读长直接rna测序">长读长直接RNA测序</h3>
<p>前面我们提到了长读长测序方法，这种测序方法与短读长测序平台一样，它们都依赖于将mRNA转换为cDNA。而最近Oxford Nanopore指出，他们的纳米孔测序技术可以直接对RNA进行测序，也就是说，这种测序手段不需要常规测建库过程中的的cDNA的合成和/或PCR扩增操作。这种方法称为dRNA-seq，这种方法就消除了常规建库过程中的偏倚，并且能够保留表观遗传学信息。这种方法可以从RNA直接进行两个接头的连接来制备文库。首先，带有一个oligo(dT)悬臂的双链核酸接头退火并连接到RNA的多聚腺苷酸(PolyA)尾部，随后就是可选（但不推荐的）的逆转录操作，这一步用于提高测序的通量。第二个连接操作就是添加测序接头，这个测序接头上已经提前安装有驱动测序的马达蛋白。文库随后进行MinION测序，其中RNA直接从3ʹpoly(A)尾部向5ʹcap端进行测序。最初的研究表明，dRNA-seq的测序长度过超过1000bp，最大测序长度过超过10kb。与短读长测序相比，这种长读长测序的几个优势在于：长读长测序可以提高对异构体的检测，并且它们还可以用于下方代码poly(A)尾巴的长度，这对于可变poly(A)分析（ alternative poly(A) analysis）来说非常重要。Nanopolish-polya这个工具可以对那些用纳米孔测序得到的数据进行分析，计算出poly(A)尾的长度，这就包括基因之间的长度，也包括转录亚型之间的长度。这种分析证实了，保留内含子的转录本比完全剪接的转录本具有略长的poly(A)尾巴。虽然dRNA-seq还处于起步阶段，但是它具有检测RNA碱基修饰的潜力，因此它的应用潜力巨大，尤其是能够对表观遗传学转录进行新的分析。</p>
<h3 id="长读长与短读长技术的比较">长读长与短读长技术的比较</h3>
<p>虽然长读长技术在评估转录本方面比短读长技术有一些明显的优势，但是长读长技术也有一些明显的局限。尤其是与短读长技术相比，长读长技术的测序通量更低，错误率更多。但长读长技术的主要优势在于，它们能够捕获更多的单个转录本，不过这依赖于高质量的RNA文库。总体来说，这些局限影响了那些完全依赖于长读长测序实验的灵敏性(sensitivity)与特异性(specificity)。</p>
<p>长读长测序方法的主要局限就是当前的通量。在Illumina平台上，运行单次的RNA-seq可以生成10E9-10E10条短读长，但是在PacBio和ONT平台上，一次RNA-seq则只能产生10E6-10E7条读长。这种低通量限制了应用长读长测序技术进行实验的规模，并降低了对差异基因表达检测的灵敏性。然而，并非所有的实验都需要高深度测序。对于那些主要研究异构体的发现以及其特征的研究者们来说，测序长度比测序深度更重要。例如1百万个PacBio环形一致性测序(circular consensus-sequencing, CCS)的读长几乎就可以保证产生那些大于1kb的高表达基因的检测，ONT测序技术也是如此。因此，对于那些低到中等水平表达的基因来说，测序深度确实是一个主要问题。当进行同期功能基因组学分析(contemporary functional genomics analysis)大规模的DGE实验时，这种低通量测序技术的局限就会表现得明显。在这些研究中，必须对多个样本组进行分析，每组就是由多个生物学重复构成的，这样就能够实现充分的统计功效来有确认那些在整个转录组水平上发生的精确变化。对于这种需求，长读长技术不太可能取代短读长技术，除非长读长的测序读长的生成量能提高2个数量级。随着全长RNA-seq读长数目的增加，转录本检测的灵敏度将会增加到类似于Illumina平台上的这种水平，并同时具有更高的特异性。与此同时，通过将Illumina 的短读长RNA-Seq与PacBio的长读长Iso-Seq结合(并且可能还与ONT方法结合)，可以增加全长RefSeq注释的异构体检测的数量、灵敏性和特异性，同时保留转录本量化的质量。虽然长读长RNA-seq方法目前的实验成本较高，但它们可以检测到短读长方法遗漏的异构体，尤其是那些难以测序但与临床相关的区域，例如高度多态的人类MHC或雄激素受体。</p>
<p>长读长测序平台的第二个主要局限就是其更高的错误率，它比成熟的Illumina测序仪要高出一到两个数量级。长读长测序平台上生成的数据还包含更多的插入-删除错误。虽然这些错误与识别变化(variant calling)有关，但在RNA-seq中，每个碱基都被正确识别并非那么重要而长读长测序的目标是要阐明转录本和异构体（While these error rates are of concern for variant calling, in RNA- seq it is less crucial that every base be called correctly, as the goal is only to disambiguate transcripts and isoforms）。这种错误率对于其应用来说确实是一个值得观注的问题，现在正在解决这一问题。PacBio SMRT测序平台上出现的随机错误通常可以通过使用CCS增加测序深度来进行解决，在这种技术里，cDNA经过长度选择和接头进行环化后，每个分子就可以被多次测序，从而产生长度范围是10-60kb的连续长读长，并且包含许多原始cDNA的拷贝。这些长读长经过数据分析后就被处理为单个cDNA子子读长(subreads)，这些子读长被组合后就可以产生一致的序列。分子测序的次数越多，产生的错误率就越低；CCS已经被证明可以将错误率降低到与短读长相当的水平，甚至更低。但是，将更多的这个平台的测序能力用于重新读取相同的分子，就又加剧了其测序通量的问题，因为可以读取的唯一转录本变得更少了。</p>
<p>长读长RNA-seq方法的灵敏度还受到其他几个因素的限制。首先，它们依赖于长RNA分子以全长转录本的形式进行测序，但是要达到这种情况并非总能实现，因为在样品处理和RNA提取过程中RNA会发生降解或剪接。这种情况在短读长RNA-seq中也存在（3ʹ端的偏倚），但这种问题在短读长中是可控的，对于全长转录组分析进行研究的研究者们来说，即使是低水平的RNA降解，也能限制长读长的RNA-seq效果。因此，对于那些即将使用长读长进行测序的研究者来说，需要仔细地对提取的RNA进行质控。其次，中位数的读长长度会进一步受到文库制备中的技术问题与偏倚的限制，例如有些cDNA合成的截断或某些cDNA是由降解的mRNA合成的，最近开发的高效逆转录酶对此有所改进，这些酶有着更高的链特异性，甚至能够产生更多的3ʹ-5ʹ转录本的覆盖。虽然这些酶还未被广泛使用，但是这些高效逆转录酶也提高了结构稳定的RNAs，例如tRNAs的覆盖率，在oligo-dT和全转录组分析(WTA)方法中使用的逆转录酶很难处理这些结构稳定的RNAs。第三，长读长测序平台固有的偏倚（例如长文库分子在测序芯片表面上的低扩散）会降低更长转录本的覆盖率。</p>
<p>长读长方法(使用cDNA或dRNA-seq)解决了用于异构体分析的短读长测序方法中的一个基本问题，即它们的读长长度。长读长方法可以生成从Poly(A)尾部到5ʹcap的跨异构体的全长转录本读长。因此，这些方法使得分析转录本及其异构体成为可能，从而无需从短的读长中重构它们或推断它们的存在；每个测序的读长仅仅代表了它的起始RNA分子。全长cDNA测序或dRNA-seq用于分析DGE的未来应用将依赖于PacBio和ONT技术的更高通量。长读长RNA-seq分析正被研究者们迅速采用，并与深度短读长RNA-seq数据结合起来，用于更全面的分析，这非常类似于基因组组装所采取的混合方法。随着时间的推移，长读长和dRNA-seq方法可能会用于证明已经鉴定的基因和转录本的列表，即使在研究很透的生物中，对于基因和转录本的研究也还远远不够。随着方法的成熟，以及测序通量的增加，差异转录本分析将会成为常规方法。合成长读长RNA-seq或其它技术的发展将对这个领域产生什么样的影响，还有待观察。然而从目前来看，Illumina短读长RNA-seq依然占据了主导地位，在这篇综述的剩下部分中我们将会集中讨论短读长测序。</p>
<h2 id="改良rna-seq建库方法">改良RNA-seq建库方法</h2>
<p>RNA-seq最初用于分析多聚腺苷酸化的转录本，使用的方法源于早期的表达序列标签(expressed-sequence tag)和芯片研究。然而，下一代测序的使用指出了这些方法的局限性，而这些局限性在芯片数据中并不明显。因此，在RNA-seq首次报道后不久，就有研究报道了文库制备方法的一些重大进展。例如，在cDNA合成之前，对RNA进行片段化可以产生3ʹ:5ʹ偏倚，链特异性文库制备方法能够更好的区分正义链与反义链，这些改进都能够对转录本丰度进行更准确的估计。RNA片段化和链特异性文的制备很快就成了RNA-seq文库制备试剂盒中的标准方法。这里我们简要描述了其它RNA-seq方法的改良，使用这些改进方法的可以让研究者们根据他们的生物学问题以及特定样本进行选择。这些改进的方法包括在选择RNA进行测序时，取代dligo-dT富集的替代方法，或者是那些专门选择转录本的3ʹ或5ʹ末端的方法，或者是使用UMIs进行区分技术重复和生物重复的方法，以及针对RNA易降解特性改良的文库制备方法。这些方法的组合可以使研究者们阐明由可变poly(A)(alternative poly(A),APA)，或替代启动子(alternative promoter)使用和可变剪接(alternative splicing)生成的复杂转录本。</p>
<h3 id="polya富集的替代方法">Poly(A)富集的替代方法</h3>
<p>大多数发表的RNA-seq数据都是基于oligo-dT富集的mRNA方法，这种方法会选择包含poly(A)尾的转录本，并将集中测序测序那些在转录组的蛋白质编码区上。不过这种方法除了产生3ʹ偏倚外，RNA中还有许多非编码RNA，例如miRNA和增强子RNA，这些RNA不含有poly(A)，因此不能使用这种方法进行研究。如果不进行poly(A)富集也无法达到目的，因为这会导致高达95%的读长来源于rRNA。因此，研究者们可以选择使用oligo-dT用于mRNA-seq，或者是剔除rRNA后进行WTA。短的非编码RNAs无法被oligo-dT方法捕获，使用WTA也很难对其进行研究，因此在研究非编码短RNA时需要特定的小RNA方法，这些方法主要是通过顺序RNA连接(sequential RNA ligation)实现的（通常小RNA建库试剂盒中就有相应的说明）。</p>
<p>WTA生成的RNA-seq数据来源于编码和一些非编码RNA。RNA的部分降解也能使用这种方法进行测序，RNA的降解会导致一些poly(A)从转录的末端分离。rRNA的去除有两种方法，一种是将rRNAs从其它RNA中剔除掉（所谓的pull-out法），另一种就是使用RNAse H酶来对rRNA进行降解。这两种方法都是使用序列特异性和物种特异性寡核苷酸探索来实现的，这些探针能与细胞质rRNA(5S rRNA，5.8S rRNA，18S rRNA和28S rRNA)和线粒体rRNA(12S rRNA和16S rRNA)互补。为了简化人类，大鼠，小鼠或细菌(16S和23S rRNA)样本的处理，通常将预先混合的寡核苷酸添加到RNA中，然后让它们与rRNA进行杂交，以便进行下一步的清除。其它高丰度的转录本，例如珠蛋白(globin)或线粒体RNA也可以按照类似的方法去除。pull-out方法结合了生物素化的探针和链霉素包裹的磁珠，它们可以用于除去寡聚的rRNA复合物，留下剩余的RNA用于建库例如Ribo-Zero(Illumina，USA)和RiboMinus(Thermo Fisher，USA)。RNase H酶降解法可以降低那些生成的loigo-DNA:RNA复合物，例如，NEBNext RNA depletion(NEB，USA)和RiboErase(Kapa Biossystems，USA)。最近对这些方法的比较说明，在高质量的RNA中，这两种方法都可以将rRNA降低至后续RNA-seq读长的20%以下。但是，作者说明了，RNase H方法比pull-out法的稳定性要强，并且比较不同试剂盒时，最后得到的DGE长度的偏倚比较明显。作者还描述了另外一种类似于RNase H的方法，这种方法表现不错，并且以前没有报道过。ZapR方法是Takara Bio的一项专有技术，它使用一种酶来降解RNA-seq文中的rRNA片段。rRNA剔除方法的一个局限是，相比对oligo-dT RNA测序方法，rRNA剔除方法需要更高的测序深度，主要是因为里面还会存有一定的rRNA。</p>
<p>Oligo-dT和rRNA剔除法都可以用于后续实验的DGE分析，研究者们可能会默认使用以前在他们的实验室中使用的方法或最容易使用的方法。然而，对于这些方法的使用应该考虑一些因素，尤其是那些易降解的样本，另外，WTA方法会检测到更多的转录本，但是其实验成本要高于oligo-dT方法。</p>
<h3 id="富集的rna-3ʹ末端用于tag-rna-seq以及可变多聚腺苷酸分析enriching-rna-3ʹends-for-tag-rna--seq-and-alternative-polyadenylation-analysis.">富集的RNA 3ʹ末端用于Tag RNA-seq以及可变多聚腺苷酸分析(Enriching RNA 3ʹends for Tag RNA- seq and alternative polyadenylation analysis.)</h3>
<p>标准的短读长Illumina方法需要对每个样本生成1000万到3000万条（10M到30M条）读长用于高质量的DGE分析。对于那些专注于基因水平表达，并从事大型或高度重复实验的研究者们，或资源受限的研究者来说，可以选择使用3ʹtag计数。由于测序集中在转录本的3ʹ末端，因此需要的读长(reads)更少，这就降低了成本，并且一次测序的样本数目也可以更多。富集的3ʹ末端也可以用于确定单个转录本的poly(A)位点，而由于mRNA前体上存在的APA，其3‘末端可能会发生变化。</p>
<p>3ʹ mRNA-seq方法会产生每个转录本的单个标签读长(tag read)，这些读长来源于3ʹ末端，这个标签(tag)丰度与转录本的丰度是成正比的。标签测序法(tag-sequencing protocols)，例如QuantSeq(Lexogen, Austria)通常比标准RNA-seq法流程更为简单。标签测序法已经进行了优化，这种方法使随机引物或锚定的oligo-dT-primed来进行cDNA合成，从而并不需要poly(A)富集这一步骤，并在cDNA合成后立即进行PCR，从而取代了接头连接步骤。这种方法可以在低测序深度上实现与标准RNA-seq类似的灵敏度水平，因此，这种方法可以使用多路复用的形式实现多个文库的同步测序。这种建库方法的数据分析也进行了简化，因为不需要外显子连接检测和基因长度测序读长的归一化。但是，3ʹ mRNA-seq方法可能会被受到转录本同聚区(homopolymeric regions0的影响，这会导致错误标签；这种方法只能提供非常有限的异构体分析，这就会抵消它们较低测序深度带来的任何成本收益，尤其是对于那些仅够一次使用的样本来说。</p>
<p>mRNAs的APA化会产生3ʹ UTR长度不等的异构体。对于一个特定的基因来说，它不仅产生了这个基因的多个亚型，而且由于3ʹUTR中存在着顺式调控元件，这也会影响该转录本的调控。这种方法可以使用那些研究APA的研究者们更详细地研究miRNA的调控作用，mRNA的稳定和定位，以及mRNA的翻译。APA法指在富集转录本的3ʹ末端，从而提升信号与灵敏度，而前面提到的标签测序法非常适合此目的。其它方法多聚腺苷酸位点测序(polyadenylation site sequencing,PAS-seq)，这种方法可以将mRNA打断为150bp左右的片段，并且使用oligo-dT标记的模板转换来生成cDNA用于测序，其中的80%读长就来源于3ʹUTR。TAIL-seq方法能不使用oligo-dT，在对RNA进行打断之前，这种方法会剔除rRNA，并将3ʹ-RNA接头连到的poly(A)的尾部。当片段化后，再加上5ʹ-RNA接头就完成了RNA-seq文库的制备。在RNA-蛋白分析方法中也能评估APA，例如紫外交联免疫沉淀(cross- linking immunoprecipitation, CLIP)测序。</p>
<h3 id="富集的rna-5ʹ末端用于起始位点回贴enriching-rna-5ʹends-for-transcription-start--site-mapping">富集的RNA 5ʹ末端用于起始位点回贴(Enriching RNA 5ʹends for transcription start- site mapping)</h3>
<p>使用富集7-甲基鸟苷5ʹ加帽RNA(7-methylguanosine 5ʹ-capped RNA)也可以进行DGE分析，这种方法可以用来鉴定启动子和转录起始位点(TSSs)。现存有几种方法都可以实现这个目的，但是这些方法很少作为常规手段来进行使用。在对基因表达的加帽分析(CAGE, cap analysis of gene expression)，以及用于基因表达分析的启动子的RNA注释和定位(RAMPAGE, RNA annotation and mapping of promoters for analysis of gene expression)分析中，当使用随机引物生成第一链cDNA后，mRNA 5ʹ的帽子结构就被生物素化，这就可以将5ʹ cDNA通过链霉亲和素进行富集。CAGE使用II型限制性内切酶来生成短的cDNA标签，这种酶会从5ʹ端的接头下游切割21-27p的核核苷酸。相比之下，RAMPAGE操作则使用模板转换(template switching)来生成较长的cDNA，这个cDNAs随后被富集起来，用于测序。单细胞标签逆转录测序技术(single-cell-tagged reverse transcription sequencing, STRT-seq)能够在单细胞水平上实现TSS的回贴(mapping)。STRT-seq技术使用生物素化的模板转换oligos来生成cDNA，被磁珠捕获后，就在5ʹ末端进行片段化，产生短的cDNA标签。作为CAGE基础的5ʹ末端的加帽技术是由日本理化所(Riken)开发的，这种技术用于早期功能基因组学实验中，使全长cDNA克隆数量最大化。日本理化所主导的小鼠功能注释(FANTOM, Functional Annotation of the Mouse)协会通过阐明了1300多个人类和小鼠原代细胞，组织和细胞系的TSS，这充分显示了CAGE的强大。在最近一些方法比较中，CAGE也表示不俗。但是作者却报道说，仅使用5ʹ末端测序产生的假阳性TSS峰也是最多的，他们建议使用正交方法进一步来确认阳性，例如DNase I的回贴或H3K4me3染色质免疫沉淀测序(ChIP-seq)。</p>
<h3 id="使用唯一分子标识符来检测pcr重复">使用唯一分子标识符来检测PCR重复</h3>
<p>RNA-seq数据通常具有较高的重复率(duplication rates)，也就是说许多测序读长会回贴到转录组的相同位置。与全基因组测序不同的是，在全基因组测序中，重复的读长被以认为是PCR这一步中出现的技术偏倚导致的，它会被移除，而在RNA-seq中，这些重复的读长则被认为是真正的生物学信号并被保留。在一个样本中，数百万个起始RNA分子也许代表了高表达的转录本，当对cDNA进行测序时，就会发现很多片段是相同的。因此，在比对(alignment)过程中，并不建议通过计算去除那些不必要的重复，因为这些重复中很多是真正的生物信号。当使用单端测序(single-end sequencing)时更是如此，因为一对片段中只要一端相同，就可以被认为是一个重复(duplicate)，至于双端测序(paired-end sequencing)，两端必须在同一位置时才能被认为是一个重复，但这种情况很少。但是，由于PCR偏倚，在制备cDNA文库时，还会存在着某种程度上技术重复，并且PCR复制偏倚是一种质控问题，它有可能对RNA-seq实验结果造成影响时，很难区分出这些技术重复与生物重复的程度。</p>
<p>现在已经提到将UMIs作为一种解释扩增偏倚的方法。在扩增前将随机UMIs添加到cDNA分子中，使得能够确认PCR重复，并且可以在后续的数据分析中将其除去，同时保护真正的生物学重复，从而改善基因表达的量化和等位基因频率估计的效果。当一对测序读长被确认为一个技术重复时，它们应该包括相同的UMI，并且被回贴到转录组中相同的位置（一端或两端，这取决于使用的是单端测序还是双端测序）。</p>
<p>UMIs已经被证明能够降低变异和错误发现率来提升RNA-seq中的DGE数据分析，并且这种方法在单细胞数据分析方面也有着重要作用，单细胞数据中的扩增偏倚可能更为严重。当试图在RNA-seq数据中进行变异检测(variant calling)时，UMIs也非常有用。 虽然高表达的转录本可以产生适合这种变异检测的高覆盖率，尤其是包含了了这种重复时，但UMIs可以用于去他可能导致第二位基因频率错误计算的扩增假象。UMIs正在成为单细胞RNA-seq(scRNA-seq)的文库制备试剂盒中的标准，同时它也日益频繁地用于常规RNA-seq。</p>
<h3 id="提高降解rna的分析">提高降解RNA的分析</h3>
<p>RNA-seq文库制备方法的发展也改进了低质量或降解RNA的分析，例如从临床相关获得的那些用福尔马林固定石蜡包埋(FFPE)块存储的样本中的RNA。低质量的RNA会导致不均匀的基因覆盖率，更高的DGE假阳性率和更高的重复率，它们与文库的复杂性呈负相关。但是，文库的制备方法已经被改良，改良后的方法能降低RNA降解的影响。这些方法可能在基于RNA-seq的诊断技术的发展中显得尤为重要，例如将来有可能出现的类似于OncotypeDX（目前并不是测序分析）的诊断，这种试剂盒基于21个基因RNA的标签来预测乳腺癌的复发。虽然现在有几种方法可以使用，但是比较后发现两种方法表现最好，即RNase H与RNA exome。我们前面提到，RNase H法使用核酸本科来降低RNA:DNA复合物中的rRNA，但是它却能阻止mRNA的降解。RNA exome方法使用类似于外显子测序(exome sequencing)那样的方法，使用寡核苷酸探针来捕获RNA-seq文库分子。这两种方法都能通过减少rRNA，同时不影响mRNA的手段来产生高质量和高度一致的基因表达数据。3ʹ末端标记测序技术与扩增子测序（在PCR扩增中能产生超过2万个外显子扩增子）方法也可以用于分析降低的RNA，但是这两种方法并没有RNase H方法使用广泛。</p>
<h2 id="设计更好的rna-seq实验">设计更好的RNA-seq实验</h2>
<p>仔细设计DGE RNA-seq实验对于获取高质量和生物意义数据有着非常重要的意义。尤其是要考虑到复制的层次，测序深度以及单端还是双端测序。</p>
<h3 id="重复与实验功效replication-and-experimental-power">重复与实验功效(replication and experimental power)</h3>
<p>在一个实验中，足够的生物学重复(biological replicates)能够捕获不同样本之间的生物学变异；在定量分析中的置信度依赖于测序深度与读长长度。虽然RNA-seq比芯片表现了更低的技术偏倚，但是生物系统中固有的随机变化都要求任何RNA-seq实验要做生物学重复。使用额外的重复能够确定异常样本，在必要情况下，在进行生物学分析之前，移除这些异常样本或降低这些异常样本的权重。确定生物学重复需要考虑几个因素，包括效应大小(effect size)，组内变异，可接受的假阳性和假阴性阈值，以及最大样本数目，有的时候还需要RNA-seq实验设计工具或功效(power)计算工具的辅助。</p>
<p>在一个实验中要想确定一个合适的生物学重复并非是一件简单的事情。一项48个重复的酵母研究表明，当使用3个生物学重复时，计算样本用于DGE分析的工具只能检测出20-40%的差异表达基因。研究表明，至少应该使用6个生物学重复，这个数量要超过文献中常用的3到4个生物重复的数量。最近的一项研究表明，4个生物学重复可能足够的，但是研究指出，在确定合适的重复数目之前，需要做一个预实验来确定生物样本的方差。对于高度多样化的样本，例如来自癌症患者肿瘤的临床组织，可能需要更多的重复，以便能以更高的置信度来确定基因的变化。</p>
<h3 id="确定合适的读取深度determining-the-optimal-read-depth">确定合适的读取深度(Determining the optimal read depth)</h3>
<p>一旦文制备好，就需要决定对它们进行多深的测序。读取深度指的是，每个样本获得的测序读长的目标数目。对于真核基因组中的常规RNA-seq DGE分析来说，一般认为每个样本需要100万-300万条读长（也就是我们常说的10M到30M数量）。但是，在多个物种中的实验结果显示当每个样本的测序读长数量为1M时，那么这个数量级的测序读长提供的转录本丰度信息与转录组中表达最高表达量的一半的转录本30M测序提供的丰度信息类似。如果实验的重点是关注那些最高表达相对较大变化的基因，并且如果有足够的生物学重复，那么就可以使用较低深度的测序就能解决驱动实验的假设。测序完成后，通过检查读长在样本之间的分布以及检查饱和曲线就能评估进一步的测序能够增加实验的灵敏度。随着测序通量的增加，为了控制技术偏倚，可以将一个实验的所有样本都添加一个“混合”文库中进行测序，这已经成了标准做法。一次测序所需要读长总数则是样本数乘以读取深度；然后根据生成所需的读长总数来对这个混合文库进行多次测序。这种合并需要严格检测每个样本RNA-seq文库的浓度，并假设每个文库中的cDNA量相对均值（低方差），因此总的读长数目就会平均地分布在每个样本上。在进行一次昂贵的，多泳道(lane)测序之前，运行单个泳道以验证样本之间的低方差通常是值得的。</p>
<h3 id="选择参数测序长度单端测序或双端测序">选择参数：测序长度，单端测序或双端测序</h3>
<p>最终的测序参数包括测序长度，单端测序还是双端测序。在许多测序应用中，测序读长的长度对于数据的利用有着重要的影响，因此更长的读长可以使测序的DNA覆盖率更高。当使用RNA-seq来进行DGE分析时这种方法并不适用，其中重要的原因则是，确定每个读长来源于转录组的哪个位置的能力有限。一旦一个读长能够明确其回贴位置，那么较长的读长在基于量化的分析中就不会再提供太多的价值。对于那些更定性的RNA-seq分析来说，例如特定异构体的鉴定，更长的读长可能更有用。</p>
<p>单端测序与双端测面临的问题是类似的。在单端测序中，每个cDNA片段只有一个末端(3ʹ端或5ʹ端)用于产生测序读长，但双端测序则是一个片段产生2条读长（一个是3ʹ端，一个是5ʹ端）。在那些需要尽可能高的核苷酸覆盖率的分析实验中，长读长双端测序可能更好。然后，DGE分析不需要对转录本片段的每个碱基都进行测序，在DGE分析中，研究者只需要比对后，统计出那些回贴到转录本上的读长数目即可。例如，通过比较测序读长发现，“短”的50bp单端测序与“长”的100bp双端测序所产生的DGE结果没有区别。这是因为单端测序足以鉴定出大多数测序片段来源的基因。同样的研究表明，使用短的单端测序降低了检测出异构体的能力，因为跨越剪接连接的读长较少。双端测序还有助于消除读长回贴的歧义，并对可变外显子量化(alternative-exon quantification)，融合转录本检测和从头开始(de novo)的转录本发现，尤其是处理那些没有很好注释的转录本来说，双端测序更是首选。</p>
<p>在实际应用中，单端测序或双端测序之间的选择通常基于成本或研究者们可用的测序技术。在Illumina NovaSeq发布之前，在多数情况下，每M读长的单端测序的成本要低于双端测序，因此，在相同实验成本的前提下，单端测序能够实现更高的复制或读长深度。</p>
<p>在Illumina NovaSeq发布之前，在大多数情况下，单端测序的每百万次读取的成本低于成对末端测序，因此允许以相同的实验成本进行更高的复制或读取深度。当选择了更多的短单端测序读长和产生更长的双端测序读长后，那么增加读取深度将对提高DGE实验的灵敏度产生更大的影响。</p>
<h2 id="rna-seq数据分析">RNA-seq数据分析</h2>
<p>用于分析测序读长以确定差异表达的计算方法的数量在过去10年里大量增加，并且即使对于最简单的DGE分析来说，在分析实践中，每个步骤也存在着大量的差异。然而，每个步骤都可以使用不同方法，这些方法的不同组合会对从数据中得到的生物学结论产生重要的影响。 这些工具的最佳组织取决于正在研究的特定生物学问题，以及可用的计算机资源。虽然有着尽可能多的排列组合，但是我们的重点在于研究，每个世界大在样本之间的差异表达的可能性的工具和技术。针对这个目标，我们可以将分析过程划分为4个阶段（FIG 2；TABLE 2）。</p>
<p>第1阶段是将一个测序平台产生的原始测序读长导入工具，并将这些读长回贴到转录组上。</p>
<p>第2阶段，是对每个基因或转录本相关的读长数目进行定量（表达矩阵）。这一过程涉及一个或多个不同的比对(alignment)，组装(assembly)与定量(quantification)亚过程，或者是可以在单个步骤中从读长计数中，整体地生成表达矩阵。</p>
<p>第3阶段是通过过滤低表达特征来改变表达矩阵，这一步的关键步骤是对原始读长计数进行归一化，用于解释样本之间的技术差异。</p>
<p>第4阶段是样本组之间的统计建模与协变量(covariates)，以及计算与差异表达相关的置信统计量。</p>
<h3 id="figure2-差异基因表达的rna-seq数据分析流程">Figure2-差异基因表达的RNA-seq数据分析流程</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805190015.png">

</div>
<p><strong>Figure 2-差异基因表达的RNA-seq数据分析流程。差异基因表达(DGE)分析的第一步是原始RNA测序读长的FASTQ格式的数据，DGE的分析有多种方式。主流的分析流程有三种（用实线划的三个方框，分别用A，B和C表示），并且图上还列出了许多替代工具（用虚线表示）。</strong></p>
<p><strong>在A分析流程中，比对工具例如TopHat，STAR或HISAT2使用一个参考基因组来将读长回贴到基因组的位置上，然后使用一些定量工具，例如HTSeq和featureCounts，来将读长比对于基因的特征上。在归一化后（通常归一化的方式都内嵌到了一些分析工具，例如TMM），基因表达就通过一些计建模工具，例如edgeR，DESeq2和limma+voom进行计算，计算结果是一些差异表达基因或转录本的列表，这数据用于下一步的可视化和生物学解释。</strong></p>
<p><strong>在B分析流程中，使用一些较新的免比对工具，例如Kallisto与Salmon，这些工具会在一步操作中组装转录组并对相应的转录本进行定量。这些工具的输出结果通常是转录本定量的一些估计值（例如tximport，TXI），然后通过与A分析流程中相同的归一化和统计建模，产生出差异基因或转录本列表。</strong></p>
<p><strong>在C分析流程中，第一步是比对读长（这一步的工具通常是TopHat，虽然有些分析方法也会用STAR与HISAT），接头使用CuffLinks来处理原始读长，再然后是使用CuffDiff2包来输出转录本丰度的估计值，以及一个差异表达基因或转录本的列表。</strong></p>
<p><strong>其它常用的工具还包括StringTie，这个工具使用TopHat（或类似工具）的输出结果来组装一个转录本模型，然后将结果输出到RSEM或MMSEQ中，用于估计转录本的丰度值，最后将转录本的丰度值输出给Ballgown来计算差异表达基因或转录本。而SOAPdenovo-trans这个工具则能同时对读长进行比和组装，其结果用于输入给RSEM或MMSEQ。</strong></p>
<h3 id="table2-rna-seq数据分析工具">TABLE2-RNA-seq数据分析工具</h3>
<table>
<colgroup>
<col width="8%">
<col width="24%">
<col width="31%">
<col width="4%">
<col width="31%">
</colgroup>
<thead>
<tr class="header">
<th>工具名称</th>
<th>组装</th>
<th>定量</th>
<th>均一化</th>
<th>差异表达</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TopHat</td>
<td>参考基因组+注释 Reference genome+ annotation</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>STAR</td>
<td>参考基因组+注释 Reference genome+ annotation</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>HISAT</td>
<td>参考基因组+注释 Reference genome+ annotation</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>SOAPdevovo-Trans</td>
<td>De novo assembly</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>StringTie</td>
<td>De novo assembly</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>Kallisto</td>
<td>Alignment-free assembly</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>Salmon</td>
<td>Alignment-free assembly</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>Cufflinks</td>
<td>Transcript assembly</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>RSEM</td>
<td>NA</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>MMSeq</td>
<td>NA</td>
<td>Transcript estimates</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>HTseq</td>
<td>NA</td>
<td>Read counts from non- overlapping annotated features</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>FeatureCounts</td>
<td>NA</td>
<td>Read counts from non- overlapping annotated features</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="odd">
<td>Tximport</td>
<td>NA</td>
<td>Transcript estimates converted to read counts</td>
<td>NA</td>
<td>NA</td>
</tr>
<tr class="even">
<td>edgeR</td>
<td>NA</td>
<td>NA</td>
<td>TMM</td>
<td>Negative binomial distribution + GLM</td>
</tr>
<tr class="odd">
<td>limma+voom</td>
<td>NA</td>
<td>NA</td>
<td>TMM</td>
<td>Mean–variance transform + GLM</td>
</tr>
<tr class="even">
<td>DESeq2</td>
<td>NA</td>
<td>NA</td>
<td></td>
<td>Negative binomial distribution + GLM</td>
</tr>
<tr class="odd">
<td>Ballgown</td>
<td>NA</td>
<td>NA</td>
<td>Various</td>
<td>Input from StringTie, RSEM or alignment- free quantification, + GLM</td>
</tr>
<tr class="even">
<td>CuffDiff</td>
<td>NA</td>
<td>NA</td>
<td>NA</td>
<td>DE from Cufflinks estimates</td>
</tr>
</tbody>
</table>
<h3 id="第1阶段-测序读长的比对alignment与组装assembly">第1阶段-测序读长的比对(alignment)与组装(assembly)</h3>
<p>测序完成后，分析的起点就是数据文件，这个数据文件包含了测序计数的碱基，这些数据文件通常是以FASTQ文件的格式存在。处理这些FASTQ文件最常见的第一步操作就是将测序读长回贴到已知的转录组上（或已经注释的基因组上），将每个测序读长转换为一个或多个基因组坐标。这一过程可以使用多个不同的比对工具，例如TopHat，STAR或HISAT，它们都依赖于一个参考基因组。由于测序的cDNA都源于RNA，而RNA有可能跨外显子边界，因此当与参考基因组（含有内含子与外显子）进行比对时，这些工具进行一个剪接比对后，测序读长之间会出现一些间隙。</p>
<p>如果测序的物种没有一个可用的高质量基因组注释（含有已经知的外显子边界），或者说如果希望将测序读长与转录本（而不是基因）关联起来，那么可以使用比对的读长进行转录组的组装。一些组装工具，例如StringTie，SOAPdenovo-Trans使用利用那些已经比对好的结果中的空隙来推测其外显子边界，以及可能的剪接位点。当参考基因组注释没有或者是不完整时，或者是你感兴趣的组织（例如在肿瘤组织）中转录本异常的情况下，这些从头组装转录本的工具尤其好用。当使用的是双端测序和/或更长的测序技术时，这种转录组组装方法效果更好，因为这些测序技术有更大的可能性跨越了剪接位点。但是，从RNA-seq数据中进行转录本的完整组装对于计算DGE来说，并不是一个必需的步骤。</p>
<p>最近，已经开发出了计算高效的“免比对”(alignment-free)工具，例如Sailfish，Kallisto与Salmon，这些工具可以直接将测序读长与转录本进行关联，从而无需单独的定量步骤（参考后面的第2阶段部分）。这些工具在那些表征更高丰度（以及更长的）转录本方面表现得非常良好；然后它们在那些定量低丰度或短转录本方面表现不佳。</p>
<p>用于将测序读长回贴到转录本的不同的工具在它们如何对测序的子集进行分配方面有着显著的差异，这会影响最终的表达估计值。当有来自一个不同基因，伪基因或转录本的多个读长时，这种效果尤为明显。一项比对12个基因表达估计方法的比较显示，一些比对方法低估了许多与临床相关的基因的表达，这主要是由于其并不精确的回贴读长所导致的。在RNA-seq数据的计算分析中，如何将多个回贴的读长合理进行分析仍然是一个值得研究的方向。通常的做法是将这些读长排除在下一步的分析之外，但这可能会使结果产生偏（参考阶段2-转录本丰度的量化）。其它的估计包括生成“合并“表达特征，这些特征包含了那些共同回贴后的读长的重叠区域，以及要在随后的置信度计算中，对每个估计的基因的回贴的不确定性进行估计。</p>
<h3 id="第2阶段-转录本丰度的量化">第2阶段-转录本丰度的量化</h3>
<p>一旦读长被回贴到基因组的位置或转录组的位置，接下来的步骤就是将这些读长分配到基因或转录本上，以确定它们的丰度。不同的比较研究表明，在量化步骤中采用的不同的方法对最终的结果影响最大，这种影响甚至超过了第1步中比对工具的选择。对每个基因(即该基因所有转录本的亚型)测序读长丰度的量化依赖于转录组注释来对那些重叠到已知基因上的测序读长进行量化。但是，使用短读长对测序读长进行特定异构体分配来说还需要一个估计步骤，因为许多读长并不能跨越剪接位点，因此它们无法精确地分配给特定的异构体。当一个基因的主要表达形式是在不同长度的转录本之间进行转换时，那么即使在仅研究基因层面的差异表达分析的前提下，对这些转录本进行定量则会产生一个更加精确的结果。例如，在一个样本中，一个主要的转录本也许只有另外一个样本中同样转录本的一半长度，但是前者的表达量是后者的2倍，那么单纯地基因基因定量的工具无法区分这个转录本的差异表达。</p>
<p>常用的量化工具包括RSEM，CuffLinks，MMSeq与HTSeq以及前面提到的那些免比对工具。一些基于读长计算的工具，例如HTSeq（或者是R equivalent，featureCounts）通常会丢弃许多比对好的读长，包括那些回贴到多个位置的读长，或者是重叠多个表达特征的读长。其结果就是，在随后的分析中清除了那些同源和重叠的转录本。RSEM会使用期望最大化的方法来分配那些比对不明的读长，Kallisto这个无参比对工具会将比对不明的读长包括在它们相应的转录本计数中，从而导致结果偏倚。使用tximport包可以将转录本丰度估计转化为读长计数值(read count equivalents)。量化步骤中产生的结果通常会合并为一个表达矩阵，在这个矩阵中，每一行是表达特征（基因或转录本），每一列是样本名，表达矩阵中的值要和是实际的读长值，要么是一种估计丰度。</p>
<h3 id="第3阶段-过滤和归一化">第3阶段-过滤和归一化</h3>
<p>通常来说，定量后的基因或转录本计数结果还需要过滤和归一化，从而用于解释读长深度，表达模式以及技术偏倚。过滤用于去除那些不均一的低读长丰度特征的值，从而提高对那些真正差异表达值的检测能力。而对表达矩阵进行归一化则更加复杂。直接转换可以调整丰度值，以便能更加说明GC含量的差异以及读长深度。早期用于归一化的方法就是RPKM，但这种方法现在已经淘汰，它已经被那些能够校正样本之间更细微差异的方法所取代，例如四分位数法或中位数归一法。</p>
<p>广泛的研究表明，归一化方法的选择会对最终的结果以及生物学结论产生重要的影响。大多数进行归一化的算法依赖于两个重要的假设：第一，大多数基因的表达水平在重复的样本组之间保持不变；第二，不同的样本组在总体的mRNA水平上不表现出显著差异。当这些基础假设不成立时，那么就需要慎重考虑是否进行归一化，以及如何进行归一化。例如，如果一些基因在一个样本中高表达，同时相同的基因，以及另外的一些基因在同一组中的另外一个样本里正常表达，如果对读长深度进行简单的归一化则明显不够，因为相同数目的测序读长会分配到第二个样本里更多的基因上面。归一化过程，例如截断均值化M值(The Trimmed Mean of M-values,TMM)方法（它已经整合到的edgeR包中）就能解决这个问题。选择一个合适的归一化方法或许很困难；一种做法就是深度使用多种方法进行分析，然后比较它们结果的一致性。如果结果对于归一化方法高度敏度，则应该对数据进行进一步的探索，以确定差异来源。但是，比较不同的归一化方法时，要谨慎确保这种归一化方法的比较不是为了选择与原始假设最兼容的归一化方法。</p>
<p>处理这些问题的一种方法的spike-in control RNAs，这种方法会引入一些外源已知的RNA序列，这些外源已知的RNA序列已知，浓度已知，在建库的过程中，将它们添加到样本中。RNA-seq中的Spike-ins方法包括外部RNA控制协会混合物(External RNA Controls Consortium mix, ERCCs)，spike-in RNA突变物(spike-in RNA variants, SIRVs)与测序spike-ins(sequencing spike-ins, Sequins)。由于预先知道spike-in的浓度，这些浓度直接与生成的读长数相关，因为就可以对这些来自样本转录的表达水平进行校正。也有人指出，如果不进行spike-in控制时，那么就不能对那些有强烈倍数变化基因的实验进行分析。然后在实践中，很难在预设水平上一致地整合spike-ins，并且它们在基因水平上对测序读长数目进行归一化比转录本更加可靠，因为在一个样本中，每个异构体的表达水平不同。目前，spike-in控制法并没有在发表RNA-seq DGE实验中得到广泛使用，如果这种方法被进一步改进，提高其一致性的话，则这种方法会得到广泛使用，但现在很多研究者们在他们的单细胞实验（这种实验里会更加广泛地使用spike-in）使用了这种方法。</p>
<h3 id="第4阶段-差异表达的统计建模">第4阶段-差异表达的统计建模</h3>
<p>一旦测序读长被处理为表达矩阵，那么就可以对实验进行统计建模，从而确定哪些转录本发生了改变。一些工具可以达到这些目的；其中一些工具会对基因水平的读长数目进行统计建模，而一些则依赖于转录本水平的估计。基因水平的工具通常依赖于比对好的读长数目，使用广义线性模型(Generalized Linear Models)处理这些数据，从而能够评估复杂的实验设计。这些工具包括edgeR，DESeq2以及limma+voom，这些工具能够进行有效地计算，并提供比较结果。对差异异构体表达进行统计建模的工具包括CuffDiff，MMSEQ与Ballgown，这些工具通常需要更多的算力(computational power)，并且不同工具的结果中的信息量更大。但是，在进行选择差异表达工具之前做的那些工作，例如比对，定量或过滤以及归一化这些操作对最终结果的总体方差会产生更大的影响。</p>
<h2 id="常规rna-seq进阶">常规RNA-seq进阶</h2>
<p>源于整块组织和/或大量细胞的RNA-seq数据已经彻底改变了我们对生物学的理解，但是这种常规的RNA-seq无法轻易地分辨出特定的细胞类型，也无法保存空间信息，而这两个信息都是理解生物系统复杂性的关键因素。促进研究者们从常规的RNA-seq走出去的情形与常规RNA-seq当初出现的理由类似，但这种进阶能够能够解决很多不同的问题。单细胞测序让人们发现了，即使在被认为研究透彻的疾病背后，还存在着一些未知细胞类型，例如发现了离子细胞(ionocyte cell)，这类细胞可能与囊性纤维化疾病有关。空间分辨RNA-seq则提示了在实体组织中细胞与细胞之间的相互作用，例如发现了成年心脏组织中一小群胎儿标记基因表达的细胞。虽然在可预见的未来，常规RNA-seq仍然是一个占据主导地位的工具。但是，单细胞测序与分析方法正在快速地被研究者利用，并且随着空间RNA-seq方法的成熟，它们有可能成为常规RNA-seq分析中的一部分。这两种方法都将提高我们对多细胞生物体复杂性的理解，它们都有可能与常规RNA-seq方法结合使用。在这里我们简单描述一下主要的单细胞测序以及空间RNA-seq方法，以及它们与常规RNA-seq的不同之处，以及新的研究者们如何着手。</p>
<h3 id="单细胞分析">单细胞分析</h3>
<p>scRNA-seq于2009年首次报道，当时的研究者在含有裂解缓冲液的EP管中分离了单个卵母细胞。单细胞测序对生物学新问题的解释，以及现有的实验室和计算方法以极快的速度发展，甚至最近几年综述都已经过时了。每种scRNA-seq方法都需要将实体组织进行分离，分离出单个细胞（使用不同的方法），以及标记上每个细胞的RNA，对RAN扩增后进行测序，所有的这些方法都来源于早期常规RNA-seq的方法。</p>
<p>机械裂解和胶原酶加DNAase的酶解会生成单细胞悬液，从而产生大量可用的细胞，但是这种产生是高度组织特异性的，比较依赖于经验，其过程也需要非常小心。一旦制备好了单细胞悬液，就可以通过各种方法分离单细胞（FIG 3a）；大多数的实验都是使用流式细胞仪来进行单细胞分选，这种方法是最容易，它可以将单个细胞直接分选到含有裂解液的微孔板中。对于更高通量的实验，现存有大量分离单细胞的专门仪器，这些仪器需要自己构建或购买。单个细胞可以通过物理手段被捕获到微流控芯片中，或者是通过Poisson分布的原理被分配到加载到含有纳米孔(nanowell)的芯片中，随后这些单细胞被分离后就被液滴微流分离技术合并到含有试剂的液滴中（例如Drop-Seq与InDrop），或者是单细胞被原位标记上标签（例如单细胞混合索引RNA测序技术, single-cell combinatorial indexing RNA sequencing, sci-RNA-seq以及分离-混合-连接转录组测序技术，split- pool ligation- based transcriptome sequencing,SPLiT-seq）。单细胞分离后，它们就被裂解，将RNA释放到溶解中用于cDNA合成，并将cDNA用于RNA-seq文库制备。在文库制备过程中，来源于每个细胞的RNA会通过PCR进行扩增。这种扩增就引入了PCR偏倚，但是UMIs可以用于校正这种偏倚。由于Poisson采样，一个细胞中只有10-20%的转录本会被逆转录，这就限制了转录本检测的灵敏度，以及各种方法产生的可用数据。在湿实验之外，计算方法也在迅速发展，最近已经出现了关于scRNA-seq的实验设计指南。方法学的快速发展意味着scRNA-seq方法的技术已经快速过时了。然而Ziegenhain等人提供了scRNA-seq方法的详细概述，他着重强调了UMIs的在数据分析方面 的重要性，并报道了提到了的6种方法中哪一种最为灵敏。然而他们的研究范围并不包括现在被广泛使用的10X Geneomics方法。</p>
<h3 id="figure3-单细胞rna-seq与空间rna-seq的概念">Figure3-单细胞RNA-seq与空间RNA-seq的概念</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805190056.png">

</div>
<p><strong>Figure 3-单细胞RNA-seq与空间RNA-seq的概念。(a)单细胞RNA-seq(scRNA-seq)工作流程概述。scRNA-seq的第一步就是从样本中分离单个细胞（例如从解离的皮肤组织），分离单细胞的方式有多种，其中包括微移液管将细胞转移到单独的微管中，或者是使用流式细胞仪将单细胞分选到含有裂解液的96孔板或384孔板中，或者是将细胞捕获到微流控芯片中，或者是将细胞分布到纳米孔(nanowells)中，或者是使用含有试剂的液滴分离系统，或者是使用原位条形码技术。细胞进行逆转录以产生cDNA（通常使用UMIs来对这些cDNA进行标记），用于制备RNA-seq文库和测序。质控(QC)，差异基因表达(DGE)与2D可视化(t-distributed stochastic neighbour embedding, tSNE)以及无监督聚类在和网络分析来对scRNA-seq的数据进行分析，用于区分不同的细胞种群。这些技术通常会标明细胞数据，以及与RNA-seq的策略一样，还会标明测序技术是3’末端还是5’末端还是全长cDNA。(b)空间转录组学工作流程概述。空间编码需要将冷冻组织切片加到含有寡聚核苷酸微阵列的载玻片上，或者是加载到密集包装的被寡核苷酸包被的pucks上。mRNA扩散到载玻片表面，然后与oligo-dT合成引物杂交，这些引物中含有UMIs与空间编码序列。随后mRNA逆转录成cDNA，cDNA汇集起来用于文库制备和测序。空间转录本组学的计算方法以能够将测序读长回贴到它们的空间坐标上，随后是DGE分析与差异空间表达分析的可视化。scRNA-seq与空间RNA-seq数据通常是用短读长测序仪进行测序的。上述图片(a)源于Springer Nature Limited。</strong></p>
<p>当研究者们在选择scRNA-seq方法，需要考虑的主要因素包括：他们是否需要全长转录本的读长，在分析更多细胞表达谱（宽度, breadth）或每个细胞更多转录本（深度，depth）之间进行权衡，以及总体实验成本。全长scRNA-seq系统的通量比较低，因此每个细胞需要单独地处理，直到最终生成scRNA-seq文库。但是，此系统可以让研究者们研究可变剪接与等位基因特异性表达。非全长系统则会从转录本的3’或5’末端生成序列，但这就限制了异构体表达的分析，但是当细胞cDNA合成被混合后，细胞所加工的数量会比前一种高出2到3个数量级。单细胞测序宽度与细胞，组织或样本的数量有关，而深度则是与测序读长数目固定下，要分析的转录组有关。虽然实验中测序的细胞数量是由选择的方法决定的，但是这也允许一些灵活性，不过随着分析的细胞数目的增多，测序成本的增加，往往限制了转录组分析的深度。因此，可以使用宽度和深度两个维度来评估不同的scRNA-seq系统。单细胞测序典型的做法是基于孔板或微流控方法来捕获尽量少的细胞，但同时对每个细胞检测出更多的基因，而基于液滴的系统可以用于分析最大数目的细胞，它已经能从超过一百万个细胞中产生单独的数据集。</p>
<p>scRNA-seq的力量正在推动着大规模的细胞图谱项目，这些项目指在确定生物体或组织中完整的细胞类型。 人类细胞地图集(Human Cell Atlas)与NIH大脑计划(NIH Brain Initiative)项目分别是为了对人体以及大脑中的所有细胞类型进行测序。人类细胞地图集的第1阶段目标是对3000万到1亿个细胞进行测序，并将随着技术的发展在广度和深度上进行增加。这个项目的最新成本包括发现了离子细胞，以及发现肾癌是在儿童和成年人中是由不同的细胞类型发展而来的。不过，scRNA-seq的研究者们应该意识到，这些技术可以用于几乎所有的生物。最近，对A. thaliana根细胞原生质的分析表明，即使是植物的坚韧细胞壁这种障碍也能被解决，能产生用于测序的单细胞。scRNA-seq正在迅速成为生物学家们工具包的标准配置，并有可能在10年后被广泛使用，就像今天的常规RNA-seq一样。</p>
<h3 id="空间分辨rna-seq法">空间分辨RNA-seq法</h3>
<p>当前的常规RNA-seq和scRNA-seq方法为研究者们提供了关于组织或细胞群体的高度详细的数据，但是没有捕获空间信息，就是会降低细胞环境与基因表达之间关系的分析能力。空间转录组学(spatialomics)的两种方法是空间编码(spatial encoding)与原位转录组学(in situ transcriptomics)。在RNA-seq文库制备过重中，空间编码方法能够记录其空间信息，或者是通过分离空间受限的细胞（例如，通过激光捕获显微解剖， laser-capture micro-dissection, LCM）， 或者是通过分离前的位置对RNA加上条形码（通过从组织切片中直接捕获mRNA）(FIG. 3b)。原位转录组学能够在组织切片中，通过对细胞中的RNA进行测序或成像来生成数据。我们建议感兴趣的读者是阅读最近的深度评论，从而对这一领域进行更全面的理解。</p>
<p>LCM已经成功地用于从组织切片中的特定区域分离和分析单个细胞用于RNA-seq。虽然LCM需要专门的设备，但是许多机构已经广泛使用了这种技术。但是，虽然这种技术可能实现高度空间分辨率，但是它消耗人力，并且难以批量使用。使用空间转录学 (Spatial Transcriptomics，10X Genomics)与Slide-seq方法可以直接从冰冻组织切片中直接捕获mRNAs，然后将这些mRNAs直接加载到寡核苷酸微阵列玻片(oligo- arrayed microarray slides)或严密包装寡核苷酸的pucks上。寡核苷酸包括空间条形码、UMI和oligo-dT引物，它们能唯一地识别每个转录本及其位置。测序读长被回贴到玻片的坐标上，用于生成空间基因表达信息。空间转录学方法已经被证明能够在一系列物种的组织中能发挥作用，其中就包括小鼠大脑和人类乳腺癌组织，人类心脏组织和拟南芥(A. thaliana)花序组织。Slide- seq是最近开发的一种技术，它已经被证明能够对小鼠大脑的冰冻切片进行测序。这些直接 mRNA捕获方法并不需要特殊的设备，且有相对简单的分析方法，并有可能大规模地应用于许多组织。然而，还有两个局限需要解决。首先，该技术只能应用于新鲜的冷冻组织。其次，分辨率受到到阵列大小和捕获寡核苷酸点和珠子的间距的限制；目前的分析只能使用6.5x7 mm和3x3mm这两种规格，这就限制了组织切片的尺寸。空间转录组学斑点的直径为100µm，间距为100µm，这意味着它们不够小或不够密集，无法实现单细胞级分辨率。Slide- seq珠子则要小的多，直径只有10µm，而且非常密集，比相对前者具有十倍的空间分辨率，并且测序中的大约一半的珠子似乎是从单个细胞层面产生的数据。从分解的组织和空间编码的数据与scRNA-seq混合起来的计算方法可以改善分辨率，但是需要基础技术的进一步发展，以使其成为更常规的RNA-seq工具。</p>
<p>上述空间分辨RNA-seq方法的替代方案包括原位测序和使用单分子荧光原位杂交的基于成像的方法。这些方法能够产生比RNA-seq方法更窄的转录组信息，但它们能直接检测RNA，并且能够对低丰度的转录本进行分析。同时，它们还能提供组组织结构和微环境的信息，并能产生亚细胞数据。这种方法目前正取得了巨大进步，但是成像方法的一个主要局限就是需要高分辨率或超分辨率显微镜与自动流体技术结合，并且这种技术的成像时间可能要花上数小时，甚至是几天。测序成本的下降比摩尔定律预测的速度更快，与测序成本相比，高通量成规模的成像系统的机会似乎更有限。</p>
<p>上述提到的空间转录组学都受到无法产生深度转录组学数据的限制，以及受到细胞分辨率和/或高成本（时间和/或资金）的限制，但是这些方法正在迅速改进，并且已经应用于临床样本。空间转录组学的具体计算方法开始出现。此外，原位RNA测序和成像方法的进步已经使得10E3到10E5个细胞生成的转录组数据成为可能，这与基于液滴的单细胞方法获得的数据量相近。未来的发展有可能使得空间转录组学让更普通的研究者们使用。然而，大多数的研究们者并不太可能需要真正的单细胞或亚细胞级分辨率。因此，转录组表达谱的宽度和对广泛的组织或样本的应用性可能会推动这些技术在特定小众领域被采用。如果空间转录组学的这些技术限制能够被解决，那么它才有可能被广泛使用。</p>
<h3 id="动态rna-seq分析beyond-steady-state-rna-analysis">动态RNA-seq分析(Beyond steady-state RNA analysis)</h3>
<p>DGE分析是使用RNA-seq来检测稳态下的mRNA表达水平，这一表达水平是通过mRNA的转录，加工和降解速度来决定的。但是，RNA-seq也可以用于研究涉及转录，翻译所涉及的过程与动力学特征，这些研究为基因表达提供了新的思路。</p>
<h3 id="使用新生rnanascent-rna方法来研究活性转录">使用新生RNA(nascent RNA)方法来研究活性转录</h3>
<p>基因表达是一个内在的动态过程，但是在检测复杂转录应答的细微以及快速变化或确定不稳定的非编码RNAs，例如增强子RNAs方面，常规的DGE分析方法就比较受限。RNA-seq可以用于绘制TSSs以及定量新合成的新生RNA，这就可以用来研究RNA动力学。但是，与DGE分析相比，nascent RNA的分析则比较难，因为它们半衰期短，丰度低。因此，为了研究这些动态的重要性，研究者们就开发了多种方法来分析nascent RNA；这些方法揭示了在启动子处的差异转录程度，表明RNA聚合酶II(Pol II)在启动子附近的暂停是基因表达的关键调节步骤，证明了nascent RNA有直接调节转录的作用，并表明其序列和结构影响转录的延伸，暂停和停顿，以及发挥染色体修饰结合和增强了子的作用。nascent RNA- seq方法旨在区分新近转录的RNA和其它RNAs，这些方法可以分为3类：run-on方法，Pol II免疫沉淀法，代谢标记法(FIG. 4)。</p>
<h3 id="figure4-nascent-rna与翻译组分析的关键概念">Figure4-nascent RNA与翻译组分析的关键概念</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805185641.png">

</div>
<p><strong>Figure 4- nascent RNA与翻译组分析的关键概念。nascent RNA分析方法是将那些在一个细胞中新转录的RNAs从其它的RNAs中富集出来，并将它们与未富集的RNA（成熟的RNA）进行比较，富集nascent RNAs的方法主要有三种。(a)Run-on方法是利用一个限时脉冲的方法将修饰过的核糖核酸添加到细胞培养基中，对细胞的RNA进行标记；这一过程可以用使用各种修饰的核苷酸，但是，图中的GRO-seq使用的是Bru修饰的核苷酸。当修饰过的核苷酸整合到RNA后，利用抗BrU的抗体，通过IP的手段将nascent-RNA链富集起来，并用于文库制备以及测序分析。(b)RNA聚合酶II(Pol II)的IP方法则是利用了微球菌核酸酶(micrococcal nuclease)消化了染色质后，使用相应的抗体拉下了与Pol II结合的RNA。在染色质消化过程中，nascent RNA通过其Pol II足迹保护而不受核酸酶活性的影响，并不会被降解。(c)代谢标记方法标记RNA的方法类似于Run-on方法，但前者使用的是核苷酸类似物4 sU。提取RNA后，烷基化4 sU，在逆转录过重中，就会产生G核苷酸的错配，从而通过在碱基对级分辨率的突变分析中直接确定4 sU的整合位点。制备3’末端RNA文库会通过降低未标记的RNA数量来增加测序过程中的信号强度。图片参考文献为214。</strong></p>
<p>Run-on法是将核酸类似物添加到样品中，从而使nascent RNA能够从总的RNA混合物中进行富集，并能够检测瞬时RNA的转录(FIG. 4a)。全局run-on测序(Global run-on sequencing, GRO-seq)与精确核酸run-on测序(Precision nuclear run-on sequencing, PRO-seq)是分别将Bru或生物素修饰的核酸在RNA的转录期整合到nascent RNA中来实现的。其过程大致为，分离细胞核，并通过洗涤除去内源性核苷酸，再添加外源生物素标记的核苷酸，随后恢复转录。通过免疫沉淀或亲和纯化的方法，对富集的新转录RNA进行测序，从而检测参与转录的RNA聚合酶的位置和活性。由于run-on过程中标记的核苷酸的数据，GRO-seq只能测到10-50bp的长度，这就降低的TSS检测的精度。PRO-seq能够实现单个碱基级的分辨率，因为生物素标记的核苷酸掺入后转录就停止，可以识别出转录位点。Run-on方法理解起来很简单，就是RNA分子整合了修饰的核苷酸，并对其进行富集，用于测序，但是在实践中，背景中存在有non-nascent RNA，这就需要增加读长深度。利用这些方法，提示了启动子处，启动子处差异或双向转录本起始的程度，确定了增强子RNA在调节基因表达方面的作用。通过特定富集5’加帽的RNAs，GRO-cap，PRO-cap或small 5’capped RNA测序(small 5ʹ-capped RNA sequencing, START-seq)增加了检测转录起始和捕获RNAs的灵敏度和特异性，这种处理还会降低源于转录后加帽的RNAs的背景信号。</p>
<p>Pol II的免疫共沉淀方法包括，天然延长转录测序(native elongating transcription sequencing, NET-seq)和哺乳动物染色质天然转录测序法(native elongating transcript sequencing for mammalian chromatin, mNET-seq)，使用抗FLAG（用FLAG标记的Pol II）抗体进行沉淀的方法，或各种针对Pol II C末端结构域(CTD)的沉淀方法(FIG. 4b)。与这些染色质复合物结合的nascent RNA的RNA-seq方法用于检测TSSs，虽然non-nascent Pol II结合的RNA与背景mRNA会对读长浓度产生负面影响，影响分析。NET-seq缺乏特异性，因为任何与Pol II强烈结合的RNA都会污染nascent RNA的富集效果，例如在NET-seq数据中就存在有tRNA和small nucleolar RNA。在mNRET-seq中使用多个CTD抗体提示了VTD修饰是如何影响转录的，检测到了RNA加工的中间体，并能能够将特定的Pol II nascent RNAs定位于TSSs。然而，这些检测能力是以更复杂的实验，更多的细胞数量和更高的测序成本为代价的。</p>
<p>使用核苷酸类似物硫代吡啶(4-thiouridine, 4 sU)进行代谢脉冲标记(Metabolic pulse- labelling)的方法可以识别nascent RNA(FIG. 4c)。但是，在那些需要长标记时间的方法中，大多数的转录本都会被标记，这就限制了这种方法的灵敏度。通过专门针对RNAs的3’末端（仅最近拉RNA聚合酶的新转录的RNA）的方法，瞬时转录组测序(transient transcriptome sequence, TT-seq)与硫醇(SH, thiol)连接的烷基化RNA代谢测序(thiol(SH)-linked alkylation for metabolic sequencing of RNA， SLAM-seq)能够降低来源于5’RNA的信号。TT-seq将标记时间限制在5分钟，因此只标记新转录本的3’末端，它在进行生物素亲和纯化前，有一个RNA片段化操作，用于富集标记的RNA。SLAM-seq整合了3’mRNA-seq文库制备方法（虽然它也用于其它的文库制备，例如miRNA）， 它仅针对标记的新转录的RNA进行测序，而非整个转录本进行测序。此外，在SLAM-seq中，提取RNA后，还要加入碘乙酰胺(iodoacetamide)，用于烷基化已经插入到新生成的nascent RNA链中的4 sU残基。这种修饰会诱导反转录式依赖的胞腺嘧啶到胞嘧啶的转换(T &gt; C)，这在测序分析中会被检测为“突变”，从而直接识别为4 su整合位点。然而，低掺入率意味着只有少量的4 sU位点可以被转换为胞嘧啶，这就限制了灵敏性。有两种方法，即TUC-seq与TimeLapse-seq也使用T&gt;C这种突变分析方法，但是它们并不富集3’末端。这两种方法用于研究细胞干扰后的转录应答和RNA的半衰期。</p>
<p>Nascent RNA分析方法还未进行过直接比较。Nascent RNA方法都受到非特异性背景和/或降解的RNA的负面影响，这会影响读取深度。通过仅测序3’末端，那么non-nascent RNA的效应就会在PRO-seq，TT-seq和SLAM-seq中降低，但是几乎没有证据表明是否有其他方法更优。亲和纯化方法费时费力，与代谢标记法相比，前者需要更多的起始材料，但是，确定脉冲标记的时间比较复杂，并且短脉冲产生用于分析的RNA很少，这限制了灵敏度。最近开发的，组织特异性RNA标记方法以及亲折突变分析计算方法或许能够促进研究者转向使用生化（基于生物素）富集的手段来研究富含生物学意义的nascent RNA和其它RNA。Nascent RNA方法以及它们与其它方法的隧和，例如空间转录组学或RNA-RNA与RNA-蛋白质相互作用的方法，将会提高我们对转录过程的理解。</p>
<h3 id="使用核糖体分析方法检测活跃的翻译">使用核糖体分析方法检测活跃的翻译</h3>
<p>RNA-seq的主要用途在于研究样本中的mRNA的种类与数量，但是mRNAs的存在与否并不直接关系到蛋白质的合成。现在有两种方法可以研究转录以外的翻译情况，可以让研究者们更好的理解翻译组(translatome)：一种是多核糖体表达谱(polysomal profiling)，一个是核糖体足迹RNA-seq(Ribo-seq)。核糖体对mRNAs的翻译具有高度的调节作用，蛋白质水平主要由翻译活性决定。多核糖体表达谱与Ribo-seq可以让研究者探索一个转录本占用多少个核糖体以及核糖体在转录本上的分布(FIG. 5)。这种方法可以让研究者推断在特定时间或细胞状态下哪些转录本正在被活跃地翻译。这两种方法都假设mRNA 核糖体的密度与蛋白质合成的水平相关。在不同样本之间进行比较，就能提示治疗条件下，时间推移以及疾病发展过程中，核糖体的动力学特征，上述的这些情况都与翻译的异常调控有关，例如纤维化，朊病毒或癌症。</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805185740.png">

</div>
<p><strong>Figure 5-翻译组的关键概念。翻译组方法是从那些与核糖体结合的RNA中生成RNA-seq数据，这种方法假设mRNA上的核糖体的密度与蛋白质的合成水平相关。(a)多核糖体表达谱的方法是通过离心将RNA分子分成多核糖组分，然后通过RNA-seq的方法进行比较。在多核糖体组分中表达较高的RNA被认为是更活跃的转录。(b)核糖体足迹(Ribo-seq)法使用RNase来降解暴露的RNA，同时保留那些被核糖体保护的未被降解的RNA。通过对这些保护的RNA进行测序，就可以揭示出核糖体的密度与位置。通过修改变标准Ribo-seq方法，定量翻译起始测序(QTI-seq)或翻译复杂表达谱测序(TCP-seq)可以专门富集起始核糖体或其亚基，同时剔除延长的核糖体，因此可以对翻译的动态过程进行更详细的分析。对翻译组RNA-seq数据的过计算 分析可能确定每个mRAN的相对翻译程度，可以研究翻译的起始，延长与终止的动力学过程。</strong></p>
<p>在多核糖体表达谱实验中，使用蔗糖梯度超离心将与多个核糖体(多核糖体组分)结合的mRNA和与单个核糖体结合的mRNA（单核糖体组分）分离开来，前者用于RNA seq文库制备(FIG. 5a)。与单核糖体组分中检测到的mRNA相比，在多核糖体组织中检测到的高丰度mRNAs可以被认为翻译得更频繁。这种方法也可以用于推测单个mRNAs的翻译状态，也可以用于生成高分辨率的核糖体占有信息与密度（尽管它无法确定核糖体的位置）。这类方法的原始方法已经进行了几项改进。例如，使用非线性蔗糖梯度改善了多核糖体收集，使多核糖体在不同浓度蔗糖溶液界面的收集过程更为简单，使用Smart-seq文库构建技术可以让研究者们分析仅10ng级的多核糖体mRNA，使用更高分辨率的蔗糖梯度和深度测序可以检测了转录本异构体的特异性翻译。然而，多核糖体表达谱实验生成的翻译组信息分辨率相对低，这一过程还比较费力，需要特殊的仪器，这就限制了其应用范围。</p>
<p>Ribo-seq是基于RNA足迹的方法，它最初用于酵母研究。这种方法用环己胺(cyclohexamide)来抑制翻译延伸，并诱导核糖体在mRNAs上停滞。用RNase I消化mRNA会留下20-30个核苷酸，这20-30个核苷酸就是受核糖体保护的足迹，这些足迹被处理后用于制备RNA-seq文库(FIG. 5b)。Ribo-seq能生成高分辨率的翻译谱，描绘核糖体丰度和单个转录本的位置。而多核糖体分析中无法提供核糖体的位置信息时，这说明有可能检测到了翻译的暂停，这些检查可以调节蛋白质的表达。当方法修改了缓冲液和对酶进行了优化后，就能更清楚地揭示Ribo-seq数据中3-bp的周期性，以及条形码和UMIs（检测单个分子的事件）。标准的RNA-seq工具可以用于Ribo-seq的计算分析，但最近已经出现了特定的工具用于寻找开放阅读框，用于差异或异构体水平的翻译分析，以及用于研究密码子偏倚。Ribo-seq的主要限制就是超速离心，以及由于核酸酶不同批次间的变化，以需要经验来确定RNase I的消化条件。</p>
<p>这些方法检测的是来自翻译起始、延伸和终止的信号的平均强度，但是对Ribo-seq的修改可使得其能够研究翻译动力学。定量翻译起始测序(Quantitative translation initiation sequencing, QTI-seq)通过化学“冷冻”和富集起始核糖体，同时从结合的mRNA中去除延长的核糖体来定位转录起始位点。翻译复杂谱测序(Translation complex profile sequencing, TCP-seq)也通过在组装成熟核糖体之前富集与40S核糖体小亚基结合的RNA来检测起始位点。然而，由于这种方法中保留了核糖体的完整性，也可以分析和比较80S核糖体组分，从而更全面检测翻译动力学(FIG. 5b)。</p>
<p>所有的翻译组方法在概念上都是相似的；它们假设mRNA核糖体的密度与蛋白质的合成水平相关。虽然它们的样本制备方案不同，但都需要大量的起始细胞数。最终，翻译组与RNA-seq结合起来研究基因的表达水平，并与蛋白质组学一道来研究蛋白水平，这可能就需要对mRNA的翻译进行一个广泛地理解。如果想要了解翻译组的更详细信息，可以阅读最近的综述。</p>
<h2 id="rna结构与相互作用分析beyond-analysis-of-gene-expression">RNA结构与相互作用分析(Beyond analysis of gene expression)</h2>
<p>RNAs在调节其它生物分子和生物过程（例如剪接和翻译）中发挥着重要作用，它们涉及RNA与各种蛋白质和/或其它RNA分子的相互作用。RNA-seq可以用于研究分子内和分子间RNA-RNA的相互作用(RNA-RNA interactions, RRIs)，这可能让研究者更好地理解结构组(structurome)，或者是研究RNA与蛋白质之间的相互作用，这样就可以深入理解转录与翻译(FIG. 6)。针对相互作用组(interactome)分析而开发的各种方法都有一个共同的主题：在RNA中富集出那些与其它RNA有相互作用的RNA。一些方法利用的是天然生物学相互作用，而其它的方法则是在目标分子之间计算瞬时作用力或共价键；大多数方法使用的是抗体pull-dwon、亲和纯化或探针杂交的手段来富集RNA进行测序。在这里我们简要描述一下主要的基于RNA-seq的方法来研究结构组和相互作用体的内容。</p>
<h3 id="figure6rna结构和rna-蛋白质相互作用分析的关键概念">Figure6–RNA结构和RNA-蛋白质相互作用分析的关键概念</h3>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190805185828.png">

</div>
<p><strong>Figure 6-RNA结构和RNA-蛋白质相互作用分析的关键概念。(a)结构组分析使用核酸酶或化学标记试剂在全转录组范围内来研究结构化RNA（例如双链RNA，dsRNA）或非结构化RNA（单链RNA，ssRNA）。在大多数实验中，在单独的反应中对ssRNA和dsRNA进行检测，其结果联合反应性分析法来确定其结构特征。核酸酶消化方法使用针对dsRNA和/或ssRNA的一个或多个核酸酶来研究RNA的结构。例如，在对RNA结构要的并行分析(PARS)中，在体外使用RNase V1（一种dsRNA特异性核酸酶）或S1核酸酶（一种ssRNA特异性核酸酶）来酶切并行样本。酶解后剩余的RNA被转化为cDNA，然后进行测序，测序的读长深度与比对区域的反应性成正比。RNA-seq数据的覆盖和比较结果就能推断RNA的结构。化学分析法(Chemical-mapping methods)，例如使用引物延伸的选择性2ʹ-羟基酰化分析法(SHAPE-seq)或突变表达谱分析法(SHAPE-Map)，这些方法通过结构依赖形式在体外或体内对双链或单链区域的核糖核苷酸进行修饰。标记物可以阻断逆转录，导致cDNAs的截短，或者是导致修饰位置错误地掺入突变。RNA被转化为cDNA后进行测序，读长深度或突变率与比对区域的反应性成正比，从而推断RNA的结构。(b)RNA-RNA的相互作用分析方法，例如SPLASH，这种方法的第一步是将有相互作用的RNA分子通过生物素化的补骨脂进行交联，然后以通过链霉亲和素对其进行富集，第二步是在邻近位置加入相互作用RNA的自由端加入邻近连接与及片段化。第三步是进行RNA接头的连接以及环化，制备RNA-seq文库用于测序，从而揭示出分子内（也就是结构）的RNA相互作用以及分子间的相互作用位点。(c)RNA-蛋白质相互作用方法，例如RNA交联免疫沉淀后测序(CLIP-seq)，这种方法使用UV辐射在相互作用的RNA和蛋白质之间产生共价交联。目的蛋白被抗体富集后，与此蛋白结合的RNA也就被富集了下来，这些RNA加上3’接头后，提取出来用于cDNA的合成。从结合了接头的RNA生成的cDNA用于文库制备，测序。</strong></p>
<h3 id="通过研究rna分子内的相互作用来研究rna的结构">通过研究RNA分子内的相互作用来研究RNA的结构</h3>
<p>核糖体RNA和tRNA构成细胞的大部分RNA。它们与其他结构非编码RNA一起在细胞中发挥各种作用，例如从基因调节到翻译。现存主要有两种研究RNA结构的方法：基于核酸酶的方法和化学探针方法。核糖核酸酶消化于1965年首次用于研究RAN(tRNA(Ala))的结构。在接下来的40年中发展了化学方法，例如，通过引物延伸的选择性2ʹ-羟基酰化法(selective 2ʹ-hydroxyl acylation analysed by primer extension, SHAPE)，此种方法用于在单碱基分率水平上检测tRNA(Asp)的结构。但是，只有将各种核酸酶法和化学方法与RNA-seq相结合，才能使方法从单一RNA转移到全转录分析，这正在改变我们对结构复杂性和重要性的理解。在这里，我们集中讨论核酸酶和化学分析方法之间的主要区别(图·6a)，如果想对这方面有进一步的理解，可以看Strobel在这方面的综述。</p>
<p>核酸酶方法，例如RNA结构的平行分析法(Parallel Analysis of RNA Structure，PARS)和片段测序法(fragmentation sequencing, FRAG-seq)，这两种方法使用能消化单链RNA(ssRNA)或双链RNA(dsRNA)的酶。核酸酶消化后剩余的RNA用作RNA-seq的文库构建。随后通过对产生的RNA序列数据进行计算分析来识别结构化(双链)和非结构化(单链)区域。核酸酶易于使用，可以用于研究ssRNA和dsRNA，但是由于核酸酶消化法的随机特性，它们与化学分析法相比，分辨率比较低。此外，由于核酸酶尺寸比较大，这就限制了这些核酸酶进入细胞，这就使得它们不适合体内研究。</p>
<p>​ 化学分析法使用与RNA分子反应的化学探针，来标记结构化或非结构化核苷酸。这些标记要么阻断逆转录，要么导致cDNA的错配，从而可以定位并分析RNA-seq读长，用于揭示结构组。SHAPE之后进行测序，这种技术方法能够RNA骨架上的核糖2’-羟基反应来标记未配对的ssRNA，虽然发夹环中的碱基折叠会降低其效率。Structure-seq与硫酸二甲酯测序(dimethyl sulfate sequencing, DMS-seq)能使用DMS来标记腺嘌呤和胞嘧啶残基，阻断逆转录，最终从生成的截短cDNAs分析中推断出RNA结构。SHAPE和突变表达谱(SHAPE and utational profiling, SHAPE-Map)和DMS突变表达谱测序(DMS-MaPseq)都修改了实验条件，从而提高了逆转录酶的加工能力，并防止cDNA截短。相反，化学标记会导致错配事件，在RNA-seq数据的分析中，能够检测出这些“突变”，从而揭示RNA结构。化学探针是小分子化合物，尽管由于细胞内的环境处于动态变化中，数据有可能更加多变，但是化学探针还是能够用于研究活体内的有生物学意义的结构。化学探针还可以用于nascent RNAs的结构分析，并揭示共转录RAN折叠的顺序。</p>
<p>核酸酶和反转录阻断方法通常产生短RNA片段，并且只报告单个酶切位点或化学标记，而错误结合和突变检测方法可以报告每个读长的多个化学标记。没有方法不存在偏倚；逆转录阻断永远不会100%有效，本应诱导突变的化学标记可以阻断cDNA合成，这两个因素都可以影响数据的解读。Spike-in控制有可能改善结构组分析的质量，但尚未得到广泛使用。SHAPE方法的比较揭示了仅在体内实验中才会出现效率差异，因此这就突显出比较类似复杂方法时所需要谨慎。</p>
<p>这些方法正在产生关于RNA结构如何在基因和蛋白质调控中发挥作用的新理解。例如，DMS分析说明了，RNA结构有可能调控APA，或许会减慢催化活性区域的翻译，使得更多的时间用于蛋白质的折叠，从而减少错误折叠事件。结构RNA-seq方法的结合有可能产生所有的完整结构组信息。随着该领域的扩展，我们可能会发现，RNA的结构与疾病的进展和或疾病的状态有关；最近的结果表明，异常RNA结构在重复扩张性疾病方面可能发挥作用。最终，结构组分析也许会促进那些靶向作用于研究透彻的RNA结构的小分子的开发，从而开辟治疗开发的新领域。</p>
<h3 id="研究分子间rna-rna相互作用">研究分子间RNA-RNA相互作用</h3>
<p>分子间的RRIs在转录后调控中发挥着重要作用，例如miRNA与靶基因的3’UTR结合。现在已经开发了用于研究分子间RRI的工具，它们用于靶向分析和转录组分析。这些分析方法含有一个共同的工作流程，即RNA在打断与邻位连接之前，通过交联来保护其相互作用(FIG. 6b)。大多数并非全部，由不同方法嵌合生成的嵌合cDNA来源于稳定碱基配对（即相互作用）RRNA分子的连接。靶向方法，例如交联，连接和杂交物测序(Crosslinking, ligation and sequencing of hybrids, CLASH)， RNA相互作用组分析和测序(RNA interactome analysis and sequencing, RIA-seq)和RNA反义纯化方法测序(RNA antisense purification followed by RNA sequencing, RAP-RNA)能产生一个RNA或RNA家族的高深度相互作用图谱。CLASH丰富了使用IP来进行特定蛋白复合物介导的RRI分析方法，而RIA-seq使用反应寡核苷酸来回收那些与靶基因有相互作用的RNAs；这两种方法都无法区分直接和间接的RRIs，这就导致其生物学解释变得复杂。为了提高RRI分析的分辨率，RAP-RNA使用补骨脂素(psoralen)和其他交联剂，然后用反义寡核苷酸捕获RNA，以及使用高通量RNA-seq来检测直接和间接RRI。虽然该方法可以进行更具体的分析，它需要制备多个文库（每个交联剂一个文库）。</p>
<p>转录组方法从根本上类似于靶向方法：相互作用的RNA在体外被交联后并被富集。通过减少进入连接反应的非相互作用RNA的量来提高富集的特异性，并且可以通过2D凝胶纯化(如在RNA相互作用和结构的补骨脂素分析(psoralen analysis of RNA interactions and structures, PARIS)或交联RNA的生物素亲和纯化(如在补骨脂素交联，连接和选择的杂交测序， sequencing of psoralen crosslinked, ligated and selected hybrids,SPLASH)来实现，或者通过RNase R酶的消化来清除非交联RNA(如在相互作用的RNA连接之后的RNA-seq, ligation of interacting RNA followed by RNA- seq， LIGR-seq)。连接后，在进行RNA-seq文库制备前，去除交联，然后进行测序。PARIS能够生成所有方法中最高数目的相互作用次数，但是每个样本需要75M的读长，这些任何其他的RRI方法都多，并且所需要的DGE实验平均读长深度是其他实验的2倍。</p>
<p>对整理好的RNA相互作用数据的分析可以对多个相互作用进行可视化，并些这种分析方法已经提示了RNA各类的RRI分布的变化。总之，90%的RRIs涉及mRNAs。近一半涉及miRNA或长链非编码RNA，对于这些RNA，大多数相互作用都与mRNA靶基因相关。对这些整理数据的比较揭示了不同方法对特定RNA物种的偏倚，这导致这些方法之间几乎没有重叠。因此，绘制RRI的完整图谱可能需要使用不止一种方法。然而，RRI方法有几个局限性。也许最具挑战性的就是RRI是动态的，并受结构构象和其他分子间相互作用的影响，这使得在没有重复的情况下，很难对其进行解释。分子内的相互作用为分子间的RRI分析增加了干扰，这就需要过滤并除去那些高度结构化的RNAs，例如rRNAs。其它的问题还包括RNA提取过程中相互相互作用的打断，这就需要稳定的交联方法，但最常用的RRI交联剂是补骨脂素和4’-氨基-甲基三氧沙林(4ʹ-amino- methyltrioxsalen, AMT)，这些交联剂只交联嘧啶，其效率比较低，会降低灵敏度。此外，邻近连接步骤低效，并且这会连接相互作用和非相互作用RNA，进一步降低灵敏度。</p>
<h3 id="研究rna-蛋白质相互作用">研究RNA-蛋白质相互作用</h3>
<p>ChIP-seq已经成了绘制和研究DNA-蛋白质相互作用不可或缺的工具；类似的IP方法也用于研究RNA-蛋白质的相互作用。RNA-蛋白质相互作用方法依赖于IP，利用针对感兴趣的RNA结合蛋白的抗体来捕获其结合的RNA进行分析（第一次报道时是用芯片进行分析的）(FIG. 6c)。各种RNA-蛋白质相互作用方法之间最明显的区别在于相互作用的RNA和蛋白质是否交联以及如何交联：一些方法避免交联(天然IP， native IP)，其他方法使用甲醛进行交联，一些方法使用紫外线(UV)光进行交联。最简单的方法就是RNA免疫沉淀测序(RNA immunoprecipitation and sequencing, RIP-seq)，时常，但并非所有情况下都使用天然IP法，以及并非总进行RNA打断。这种简便性使用该方法易于被采用。这种方法能产生有用的生物学信息，但是它有两个重要的缺陷。第一，用于保存RNA-蛋白质相互作用的前提是需要进行温和地洗涤，这就意味着富集的片段中有相对高的非特异性结合片段。第二，没有进行RNA打断就降低了结合位点的分析。因此，RIP-seq具有高度灵活性，并依赖于RNA-蛋白质结合的自然稳定性。使用甲醛交联在RNA与其相互作用的蛋白质之间产生可逆的共价键提高了稳定性，并减少了非特异性RNA的回收，但甲醛也会导致蛋白质-蛋白质的交联。这种影响可以通过使用0.1%的甲醛（比ChIP-seq研究使用的甲醛低10倍）进行温和的交联来降低，这能在多个蛋白质靶点上产生高质量的结果。</p>
<p>在CLIP中使用254nm的UV来进行联系是一项关键的技术，它提高了RNA-蛋白质相互作用分析方法的特异性和位置分辨率。UV交联在蛋白质和RNA的相互作用位点产生共价键，但最重要的是，它不对蛋白质-蛋白质相互交联。这就稳定了RNA-蛋白质的结合，允许严格的富集，破坏了天然RNA-蛋白质的相互作用，减少了背景信号。CLIP的实验方法随后就构成了许多方法发展的基础。单个核苷酸分辨率的CLIP(iCLIP)将UMIs整合到文库中，用于移除PCR复制。它还利用了cDNA合成在交联核苷酸处常见的过早截短，通过对截短的cDNA进行扩增来获得交联位点的定量，核苷酸级分辨率图谱。光激活核糖核苷增强片段(Photoactivatable- ribonucleotide-enhanced CLIP,PAR-CLIP)通过使用4 sU和356nM的UV来进行交联。在细胞培养过程中，4 sU被整合到内源RNAs中，356nm的UV辐射会在4 sU整合位点处产生交联（产生高度的特异性）。在产生的测序数据中检测反转录诱导的T&gt;C替换就会能够实现碱基对级的分辨率，并且能够区分交联片段和非交联片段，进一步降低背景信号。最近对CLIP的改进提高了它的效应和灵敏度。红外CLIP(infrared CLIP, irCLIP)用红外凝胶成像技术来代替放射性同位素检验，它是基于珠子的纯化技术。与常规的iCLIP使用的1百万到2百万细胞相比，这些技术的改进可分析只有2万个细胞的RNA-蛋白质相互作用。增强型CLIP(enhanced CLIP, eCLIP)抛弃了RNA-蛋白质复合物的质控和可视化操作，而是在RNA接头中添加了条形码，这种改进可能让所有的样本混合到一起，并用珠子来代替了凝胶。这些改进旨在简化实验操作，eCLIP实验已经研究了近200个蛋白，它已经成了ENCODE项目的一部分。但是，irCLIP与eCLIP目前都没有被广泛采用，部分原因是eCLIP和irCLIP的灵敏性增加的原因是由于其特异性降低导致的，比如利用两个方法所鉴定的PTBP1结合位点上结合或有序和调节外显子的富集减少。随着公共数据库中可用的大量数据为计算分析提供了新的机会，因此谨慎考虑CLIP数据的质控，过滤，以及峰值调用(peak calling)和归一化方法就变得非常重要，这些会影响数据的生物学解释。为了更全面地讨论 RNA-蛋白质的相互作用的CLIP实验方法，我们建议读者可以阅读最近关于这个主题的综述。</p>
<p>一些RRI以及所有的RNA-蛋白质结合方法对IP的依赖限制了其对有良好特征抗体蛋白质的研究，而非特异抗体的结合仍然是一个问题（虽然这一问题并非局限于这个领域）。RNA结构也会影响RNA-蛋白质之间的相互作用；一些蛋白质能识别特异的RNA二级结构或与这些结构竞争结合RNA，这使得体外的发现转向体内就变得复杂了。此外，结构和RNA-蛋白质相互作用方法通常报告一个特定转录本或位置的平均值。在实验室方法中，在计算方法和单分子测序方面的未来发展或许有助于破译一些这些生物变异。</p>
<h2 id="结论">结论</h2>
<p>Wang，Gerstein和Snyder关于RNA-seq将“革命性地[如何]分析真核转录体”的预测肯定是正确的。但是，即使是他们，也有可能对这种转型的规模感到惊讶。现在我们可以分析RNA生物学的许多方面，这对于基因组功能、研究开发和确定导致癌症和其他疾病的分子调控异常方面来说是必不可少的。虽然生物学发现阶段还远未结束，但是已经在临床中使用了RNA-seq方法。单细胞测序正在成为许多实验的标准配置，空间转录组学的分析可能会遵循类似的路径，使其能够在与开发当前方法的实验室范围之外使用。长读长测序方法也有可能取代当前相当大比例的研究者们默认选择的Illumina的短读长RNA-seq。对于这种情况的出现，长读长测序技术还需要在增加通量和降低错误率方面做出极大的改进。 然而，长读长mRNA异构体测序的优点是，如果它变得像现在短读长测序一样便宜和可靠，那么对于那些除了易降解材料外，长读长测序就可能是首选。考虑到这些因素，那么任何关于RNA-seq在未来十年可能如何发展的预测都有可能过于保守。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/04/DAL/DALS004_Inference03_CLT_T_test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/04/DAL/DALS004_Inference03_CLT_T_test/" itemprop="url">DALS004-统计推断(Inference)02-CLT与T-test</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-04T12:00:00+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,967
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是《Data Analysis for the Life Sciences》的第2章：统计推断(Inference)的第3部分。这一部分的主要内容涉及中心极限理论，t检验和功效计算。</p>
<h2 id="中心极限定理central-limit-theorem与t分布">中心极限定理(Central Limit Theorem)与t分布</h2>
<h3 id="中心极限定理clt">中心极限定理(CLT)</h3>
<p>当样本的数目非常大的，一个随机样本的均值<span class="math inline">\(\bar{Y}\)</span>就会服从正态分布，这个正态分布的均值是总体均值(<span class="math inline">\(\mu_{Y}\)</span>)，标准差是总体的标准差<span class="math inline">\(\sigma_{Y}\)</span>除以样本的数目<span class="math inline">\(N\)</span>的平方根。</p>
<p>如果我们将一个随机变量减去一个常数，那么这个新生成的随机变量就会领衔这个常数，从数学角度来说，如果<span class="math inline">\(X\)</span>是一个服从均值为<span class="math inline">\(\mu\)</span>的分布，<span class="math inline">\(a\)</span>是一个常数，那么<span class="math inline">\(X-a\)</span>的均值的分布的均值就是<span class="math inline">\(\mu-a\)</span>。这个也适应用乘法与标准差(SD)。</p>
<p>如果<span class="math inline">\(X\)</span>是一个随机变量，它的分布的均值<span class="math inline">\(\mu\)</span>和标准差(SD)为<span class="math inline">\(\sigma\)</span>，而<span class="math inline">\(a\)</span>是一个常数，那么<span class="math inline">\(aX\)</span>这个新的随机变量分布的均值是<span class="math inline">\(a\mu\)</span>，标准差为<span class="math inline">\(|a|\sigma\)</span>。为了说明这个问题，我们就假设，每只小鼠的体重都减去10，那么平均体重也应该会减去10，类似的，如果我们将小鼠的体重单位由克(g, gram)换成毫克(mg, milligram)，也就相当于把原来的数字都乘以了1000，那么数字的扩散程度也会变大。</p>
<p>这就说明了，如果我们获得了<span class="math inline">\(N\)</span>个样本，那么这个公式<span class="math inline">\(\frac{\overline{Y}-\mu}{\sigma_{Y} / \sqrt{N}}\)</span>就接近于均值为0，标准差为1的正态分布。</p>
<p>现在我们感兴趣的是两个样本的均值的差值。这个数学公式就比较有用了。</p>
<p>如果我们有两个随机变量，即<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>，它们的总体均值与总体均值差为<span class="math inline">\(\mu_{X}\)</span>和<span class="math inline">\(\mu_{Y}\)</span>，<span class="math inline">\(\sigma_{X}\)</span>和<span class="math inline">\(\sigma_{Y}\)</span>，然后我们就会得到这些结果：</p>
<p><span class="math inline">\(X+Y\)</span>的均值：<span class="math inline">\(\mu_{X}+\mu_{Y}\)</span>。</p>
<p>也会得到<span class="math inline">\(Y-X\)</span>的均值，其实这也相当于<span class="math inline">\(Y-X=Y+aX\)</span>，其中<span class="math inline">\(a=-1\)</span>，这其实也就是说<span class="math inline">\(Y-X\)</span>的均值为<span class="math inline">\(\mu_{Y}-\mu_{X}\)</span>。</p>
<p>如果说<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>是相互独立的样本，那么<span class="math inline">\(Y+X\)</span>的方差，就是<span class="math inline">\(\sigma_{Y}^2+\sigma_{X}^2\)</span>，从这里我们可以推到，<span class="math inline">\(Y-X\)</span>，也即<span class="math inline">\(Y+aX\)</span>（其中a为-1）的方差是<span class="math inline">\(\sigma_{Y}^2+a^2\sigma_{X}^2=\sigma_{Y}^2+\sigma_{X}^2\)</span>。因此说，<span class="math inline">\(Y-X\)</span>这个差值的方差也是两个样本的方差和，这有点反直觉，我们需要知道的就是，X与Y这两个样本是相互独立的，它们确实不相互影响。</p>
<p>从数学角度来理解上面的内容对我们的研究目（两个样本的均值，以及均值的差值）。因此这两个样本都服从正态分布，它们的差值也服从正态分布，方差是两个样本总体的方差之和。在零假设（也就是说这两个样本所代表的两个总体的均值没有差异）成立的前提下，样本均值<span class="math inline">\(\bar{Y}-\bar{X}\)</span>的差值的分布接近于均值为0（也就是说没有差异），标准差为<span class="math inline">\(\sqrt{\sigma_{X}^{2}+\sigma_{Y}^{2}} / \sqrt{N}\)</span>的正态分布，也就是说下面的这个公式： <span class="math display">\[
\frac{\overline{Y}-\overline{X}}{\sqrt{\frac{\sigma_{X}^{2}}{M}+\frac{\sigma_{Y}^{2}}{N}}}
\]</span> 的值接近于标准正态分布（均值为0，标准差为1）。</p>
<p>通过这种近似计算，我们就能够将计算p值的过程简单化，因为我们知道任何值在标准正态分布下的比例。例如，这些值中只有5%的比例会大于2（绝对值），计算过程如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pnorm(-<span class="number">2</span>) + (<span class="number">1</span> - pnorm(<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; pnorm(-<span class="number">2</span>) + (<span class="number">1</span> - pnorm(<span class="number">2</span>))</div><div class="line">[<span class="number">1</span>] <span class="number">0.04550026</span></div></pre></td></tr></table></figure>
<p>从上面结果我们就可以知道，只有5%的可能性会大于2，我们前面计算的obstdiff的值是3.020833，因此12只小鼠足够了，不需要买更多的小鼠。</p>
<p>但是，这还没完。因为我们并不知道总体的标准差，也就是不知道<span class="math inline">\(\sigma_{X}\)</span>与<span class="math inline">\(\sigma_{Y}\)</span>。它们是未知的总体参数，但是，我们可以通过样本的标准差对它们进行估算，估算的总体标准差我们不能希腊字母<span class="math inline">\(\mu\)</span>来表示，只能用<span class="math inline">\(s\)</span>来表示，那么它们的估计值如下所示： <span class="math display">\[
s_{X}^{2}=\frac{1}{M-1} \sum_{i=1}^{M}\left(X_{i}-\overline{X}\right)^{2} \text { and } s_{Y}^{2}=\frac{1}{N-1} \sum_{i=1}^{N}\left(Y_{i}-\overline{Y}\right)^{2}
\]</span> 我们需要注意的是，上面的公式里面除以的是<span class="math inline">\(M-1\)</span>与<span class="math inline">\(N-1\)</span>，而不是前面的<span class="math inline">\(M\)</span>与<span class="math inline">\(N\)</span>，这有数学方面计算的原因，这里不表，记住就行。但是，为了更加直观地说明一些东西，我们还是要涉及一点。试想，如果你有2个数，把它们画在数轴上，它们之间的距离如果是L，那么中间的那一点就是它们的平均值，这个平均值离它们的距离分别都是0.5L。因此，从这个角度来说，你从这2个数中的一个就能够获取这个信息（这涉及自由度的问题），而不需要2个数，这点不怎么重要，重要的一点是，我们是用了<span class="math inline">\(s_{X}\)</span>和<span class="math inline">\(s_{Y}\)</span>来估计总体的均值，即<span class="math inline">\(\sigma_{X}\)</span>和<span class="math inline">\(\sigma_{Y}\)</span>，因为总体均值未知，只能靠样本均值来估计。</p>
<p>因此我们就把前面的那个公式： <span class="math display">\[
\frac{\overline{Y}-\overline{X}}{\sqrt{\frac{\sigma_{X}^{2}}{M}+\frac{\sigma_{Y}^{2}}{N}}}
\]</span> 定义为下面的这个样子： <span class="math display">\[
\frac{\overline{Y}-\overline{X}}{\sqrt{\frac{s_{X}^{2}}{M}+\frac{s_{Y}^{2}}{N}}}
\]</span> 如果<span class="math inline">\(M=N\)</span>，那么公式就可以化简为如下所示： <span class="math display">\[
\sqrt{N} \frac{\overline{Y}-\overline{X}}{\sqrt{s_{X}^{2}+s_{Y}^{2}}}
\]</span> CLT告诉我们，当M与N足够大的时候，上面的这个随机变量就会服从均值为0，标准差为1的正态分布。</p>
<h3 id="t分布">t分布</h3>
<p>CLT的计算依赖于大量的样本，也就是我们指的渐进性结果。当CLT不适用时，还需要另外一种不依赖于渐进性结果的选择。当原始总体来源于一个变量，也就是<span class="math inline">\(Y\)</span>时，如果这个<span class="math inline">\(Y\)</span>是服从均值为0的标准正态分布，那么我们就可以计算下面这个变量的分布： <span class="math display">\[
\sqrt{N} \frac{\overline{Y}}{s_{Y}}
\]</span> 这是两个随机变量的比值，因此这个比值不一定服从正态分布。事实上，这个公式的分母会偶然变小，因此就相应地会增加观察到更大值的概率。Gosset最初发现的这种分布，由于他开始在论文中以Student的名义投的稿，因此就称这种分布为Student‘s t-distribution，也就是t分布。</p>
<p>现在我们以小鼠的表型数据为例说明一下，我们创建2向量，一个当作对照总体，一个当作高脂总体，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">url &lt;- <span class="string">"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extd\</span></div><div class="line"><span class="string">ata/mice_pheno.csv"</span></div><div class="line">filename &lt;- <span class="string">"mice_pheno.csv"</span></div><div class="line">download(url,destfile=filename)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">head(dat)</div><div class="line"></div><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">controlPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"chow"</span>) %&gt;% select(Bodyweight) %&gt;% unlist</div><div class="line">hfPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"hf"</span>) %&gt;% select(Bodyweight) %&gt;% unlist</div></pre></td></tr></table></figure>
<p>这里需要注意提，我们假设的是的<span class="math inline">\(y_{1},y_{2},\dots,y_{n}\)</span>的分布，而不是随机变量<span class="math inline">\(\bar{Y}\)</span>的分布。现在我们来看一下这两个总体的分布：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">hist(hfPopulation)</div><div class="line">hist(controlPopulation)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190721200113.png">

</div>
<p>我们可以使用qq图来确认一下上面的分布是比较接近正态分布的，这里我们只作初步了解，更详细的了解在后面。如果在qq图上，点大致都藻在一条直线附近，它们就属于正态分布，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">qqnorm(hfPopulation)</div><div class="line">qqline(hfPopulation)</div><div class="line">qqnorm(controlPopulation)</div><div class="line">qqline(controlPopulation)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190721200657.png">

</div>
<h2 id="练习">练习</h2>
<p>P47</p>
<h2 id="中心极限定理的实际运用">中心极限定理的实际运用</h2>
<p>现在我们使用上面的数据来看一下，中心极限定理是如何逼近样本的均值的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">url &lt;- <span class="string">"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extd\</span></div><div class="line"><span class="string">ata/mice_pheno.csv"</span></div><div class="line">filename &lt;- <span class="string">"mice_pheno.csv"</span></div><div class="line">download(url,destfile=filename)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">head(dat)</div><div class="line"></div><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">controlPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"chow"</span>) %&gt;% select(Bodyweight) %&gt;% unlist</div><div class="line">hfPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"hf"</span>) %&gt;% select(Bodyweight) %&gt;% unlist</div><div class="line">mu_hf &lt;- mean(hfPopulation)</div><div class="line">mu_control &lt;- mean(controlPopulation)</div><div class="line">mu_hf - mu_control</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; head(dat)</div><div class="line">  Sex Diet Bodyweight</div><div class="line"><span class="number">1</span>   <span class="literal">F</span>   hf      <span class="number">31.94</span></div><div class="line"><span class="number">2</span>   <span class="literal">F</span>   hf      <span class="number">32.48</span></div><div class="line"><span class="number">3</span>   <span class="literal">F</span>   hf      <span class="number">22.82</span></div><div class="line"><span class="number">4</span>   <span class="literal">F</span>   hf      <span class="number">19.92</span></div><div class="line"><span class="number">5</span>   <span class="literal">F</span>   hf      <span class="number">32.22</span></div><div class="line"><span class="number">6</span>   <span class="literal">F</span>   hf      <span class="number">27.50</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="keyword">library</span>(dplyr)</div><div class="line">&gt; controlPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"chow"</span>) %&gt;% select(Bodyweight) %&gt;% unlist</div><div class="line">&gt; hfPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"hf"</span>) %&gt;% select(Bodyweight) %&gt;% unlist</div><div class="line">&gt; mu_hf &lt;- mean(hfPopulation)</div><div class="line">&gt; mu_control &lt;- mean(controlPopulation)</div><div class="line">&gt; mu_hf - mu_control</div><div class="line">[<span class="number">1</span>] <span class="number">2.375517</span></div></pre></td></tr></table></figure>
<p>现在计算一下种群的标准差，这里不要使用R的<code>sd()</code>函数，因此这个函数是计算样本的标准差的，它会除以<code>(n-1)</code>，当我们想要对总体进行估计时，按以下代码计算：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x &lt;- controlPopulation</div><div class="line">N &lt;- length(x)</div><div class="line">populationvar &lt;- mean((x-mean(x))^<span class="number">2</span>)</div><div class="line">populationvar</div><div class="line">var(x)</div><div class="line">var(x)*(N-<span class="number">1</span>)/N</div><div class="line">identical(var(x)*(N-<span class="number">1</span>)/N,populationvar)</div><div class="line">identical(var(x), populationvar)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; populationvar</div><div class="line">[<span class="number">1</span>] <span class="number">11.67205</span></div><div class="line">&gt; var(x)</div><div class="line">[<span class="number">1</span>] <span class="number">11.72416</span></div><div class="line">&gt; var(x)*(N-<span class="number">1</span>)/N</div><div class="line">[<span class="number">1</span>] <span class="number">11.67205</span></div><div class="line">&gt; identical(var(x)*(N-<span class="number">1</span>)/N,populationvar)</div><div class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></div><div class="line">&gt; identical(var(x), populationvar)</div><div class="line">[<span class="number">1</span>] <span class="literal">FALSE</span></div></pre></td></tr></table></figure>
<p>因此，为了在数学计算上是准确的，我们不使用<code>sd()</code>或<code>var()</code>函数，我们可以使用<code>rafalib</code>包中的<code>popvar()</code>与<code>popsd()</code>函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">sd_hf &lt;- popsd(hfPopulation)</div><div class="line">sd_control &lt;- popsd(controlPopulation)</div></pre></td></tr></table></figure>
<p>这里需要注意，在实际统计中，我们并不会计算总体参数，我们通常是由样本来估计总体参数，现在我们从总体中抽样，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">12</span></div><div class="line">hf &lt;- sample(hfPopulation, N)</div><div class="line">control &lt;- sample(controlPopulation,N)</div></pre></td></tr></table></figure>
<p>CLT告诉我们，对于更大的N来说，这些样本都近拉于正态分布。作为一种经验，这个N通常是大于30，这仅是一个经验法则，具体来说，它还需要取决于总体的分布。这里我们实际上可以查看一下近似值，并对各种N值进行计算，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Ns &lt;- c(<span class="number">3</span>, <span class="number">12</span>, <span class="number">25</span>, <span class="number">50</span>)</div><div class="line">B &lt;- <span class="number">10000</span></div><div class="line">res &lt;- sapply(Ns, <span class="keyword">function</span>(n)&#123;</div><div class="line">  replicate(B, mean(sample(hfPopulation, n)) - mean(sample(controlPopulation, n)))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>现在使用qq图看一下CLT理论对这些数据的近似值的适应情况。如果这些数据非常接近正态分布，那么这些数据点就会落在一个直线上（这个直接是正态分布的分位数(quantiles))。越偏离，说明数据越不符合正态分布，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> seq(along=Ns))&#123;</div><div class="line">  titleavg &lt;- signif(mean(res[,i]),<span class="number">3</span>)</div><div class="line">  titlesd &lt;- signif(popsd(res[,i]),<span class="number">3</span>)</div><div class="line">  title &lt;- paste0(<span class="string">"N="</span>, Ns[i], <span class="string">"Avg="</span>, titleavg, <span class="string">" SD="</span>, titlesd)</div><div class="line">  qqnorm(res[,i], main = title)</div><div class="line">  qqline(res[,i], col=<span class="number">2</span>)</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190721204249.png">

</div>
<p>从上面结果可以看出来，第3组数据的拟合结果最合适，这是因为它的总体相对最接近正态分布，平均值也最接近于正态分布。在实际中，我们可以计算这样一个比值：除以估计的标准误差来判断，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Ns &lt;- c(<span class="number">3</span>, <span class="number">12</span>, <span class="number">25</span>, <span class="number">50</span>)</div><div class="line">B &lt;- <span class="number">10000</span></div><div class="line">computetstat &lt;- <span class="keyword">function</span>(n)&#123;</div><div class="line">  y &lt;- sample(hfPopulation, n)</div><div class="line">  x &lt;- sample(controlPopulation, n)</div><div class="line">  (mean(y)- mean(x))/sqrt(var(y)/n+var(x)/n)</div><div class="line">&#125;</div><div class="line">res &lt;- sapply(Ns, <span class="keyword">function</span>(n)&#123;</div><div class="line">  replicate(B, computetstat(n))</div><div class="line">&#125;)</div><div class="line"></div><div class="line">mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> seq(along=Ns))&#123;</div><div class="line">  qqnorm(res[,i], main = Ns[i])</div><div class="line">  qqline(res[,i], col=<span class="number">2</span>)</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190721205303.png">

</div>
<p>从上面可以看出来，当<span class="math inline">\(N=3\)</span>时，CLT并不会提供一个有用的估计，当<span class="math inline">\(N=12\)</span>时，在较大值的点方面，稍微有点偏离。当<span class="math inline">\(N=25\)</span>或<span class="math inline">\(N=50\)</span>时，所有的点基本上都在直线上。</p>
<p>也就是说，在这个案例中，只要<span class="math inline">\(N=12\)</span>就能证明CLT，就像前言提到的那样，在多数情况下，这种模拟并不会很好。我们在这里只是通过这种模拟手段来说明CLT背后的思想与局限。</p>
<h2 id="练习-1">练习</h2>
<p>P52</p>
<h2 id="t检验的实际计算">t检验的实际计算</h2>
<p>现在我们来看一下如何通过计算得到p值，先来导入数据，在这一步中，我们要确定哪些是treatment组，哪些是control组，并且计算出它们的均值差异，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/femaleMiceWeights.csv"</span>)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">control &lt;- filter(dat,Diet==<span class="string">"chow"</span>) %&gt;% select(Bodyweight) %&gt;% unlist</div><div class="line">treatment &lt;- filter(dat,Diet==<span class="string">"hf"</span>) %&gt;% select(Bodyweight) %&gt;% unlist</div><div class="line">diff &lt;- mean(treatment) - mean(control)</div><div class="line">print(diff)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(diff)</div><div class="line">[<span class="number">1</span>] <span class="number">3.020833</span></div></pre></td></tr></table></figure>
<p>现在我们开始计算p值，上面的代码中有一个<code>diff</code>变量，可以称为<code>observed effect size</code>，这是一个随机变量，我们还知道，在零假设的前提下，<code>diff</code>均值的分布是0，而这个随机变量分布的标准误则是总体的标准差(population standard deviation)除了样本数目的平方根，如下所示： <span class="math display">\[
S E(\overline{X})=\sigma / \sqrt{N}
\]</span> 我们使用样本样本标准差(sample standard deviation)来对总体的标准差(population standard deviation)进行估计，在R中，也可以使用的<code>sd()</code>函数来计算标准误(SE)，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sd(control)/sqrt(length(control))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sd(control)/sqrt(length(control))</div><div class="line">[<span class="number">1</span>] <span class="number">0.8725323</span></div></pre></td></tr></table></figure>
<p>这个值就是样本均值(sample average)的SE，不过实际上，我们相想要的是<code>diff</code>的SE。我们前面已经知道了，统计学理论告诉我们，两个随机变量差的方差是原两个随机变量方差的和，因此我们计算一下方差以及平方根：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">se &lt;- sqrt(</div><div class="line">var(treatment)/length(treatment) +</div><div class="line">var(control)/length(control)</div><div class="line">)</div><div class="line">se</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; se</div><div class="line">[<span class="number">1</span>] <span class="number">1.469867</span></div></pre></td></tr></table></figure>
<p>统计学理论还告诉我们，如果我们将一个随机变量除以其SE，我们就会得到一个SE为1的新的随机变量，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tstat &lt;- diff/se</div><div class="line">tstat</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; tstat &lt;- diff/se</div><div class="line">&gt; tstat</div><div class="line">[<span class="number">1</span>] <span class="number">2.055174</span></div></pre></td></tr></table></figure>
<p>上面计算出来的<code>tstat</code>就是我们称的t统计量(t-statistic)。这是两个随机变量的比值，因此它也是一个随机变量。一旦我们知道了这个随机的分布，我们就很容易计算出其p值。</p>
<p>前面我们提到，CLT可以告诉我们，如果有大样本(large sample size)，那么样本的均值<code>mean(treatment)</code>和<code>mean(control)</code>都服从正态分布。统计学理论告诉我们，两个正态分布的随机变量的差值还服从正态分布，因此CLT也告诉我们，<code>tstat</code>接近于均值为0(零假设)，SD为1（我们除以它的SE）的正态分布。</p>
<p>现在我们要计算一下p值，此时我们需要问的一个问题就是：一个服从正态分布的随机变量有多大的概率会大于<code>diff</code>？R语言中的有一个<code>pnorm()</code>函数有解决这个问题。<code>pnorm(a)</code>会以返回一个值，这个值就是概率，它表示在一个标准正态分布中，一个随机变量低于<code>a</code> 的概率，具体这个函数的原理与用法，可以参考这篇笔记《R语言中dnorm, pnorm, qnorm与rnorm以及随机数》。</p>
<p>如果要计算大于<code>a</code>的概率，那么可以使用<code>1-pnorm(a)</code>，如果我们想知道看到一些像diff这种极端事件的概率：例如要么小于（更多的时候指的是负值）<code>-abs(diff)</code>，要么是大于<code>abs(diff)</code>，那么我们也可以过计算这两个尾部区域的概率：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">righttail &lt;- <span class="number">1</span>-pnorm(abs(tstat))</div><div class="line">lefttail &lt;- pnorm(-abs(tstat))</div><div class="line">pval &lt;- lefttail + righttail</div><div class="line">print(pval)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(pval)</div><div class="line">[<span class="number">1</span>] <span class="number">0.0398622</span></div></pre></td></tr></table></figure>
<p>在这个案例中，p值小于0.05，根据传统的p值阈值0.05，我们就可以下给结论，这种差值有统计学意义。</p>
<p>现在我们就面临一个问题，CLT只有在大样本的前提下才有效，12个样本这个数目够么？根据经验法则，通常大于30个样本（这仅仅是经验法则），就能满足CLT。我们计算的这个p值，只有在假设成立的前提下才是有效的近似值，而实际情况并非如此，还好，除了CLT之外，我们还有另外一种选择。</p>
<h2 id="t分布的实际计算">t分布的实际计算</h2>
<p>如果一个总体的分布是正态分布，那么我们在不需要CLT思想的前提下，就可以计算出t-statistic的精确分布。但是，如果我们只有小样本，我们就很难知道总体是否是正态的。但是，对于一些常见的统计量，例如体重，我们就可以猜测它的总体分布非常接近于正态分布，因此我们可以使用这种近似。此外，我们可以使用对样本画qq图，它会显示出样本的分布，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">qqnorm(treatment)</div><div class="line">qqline(treatment,col=<span class="number">2</span>)</div><div class="line">qqnorm(control)</div><div class="line">qqline(control,col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190727104205.png">

</div>
<p>如果我们使用这种近似计算，那么从统计学理论角度来讲我们随机变量<code>tstat</code>的分布就服从一个t分布(<code>-t-distribution</code>)，这种分布比正态分布更复杂。t分布没有像正态分布那样的位置参数( location parameter )，正态分布的参数是自由度(<code>degrees of freedom</code>)，R中的<code>t.test()</code>函数可以用于计算相应的p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.test(treatment, control)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; t.test(treatment, control)</div><div class="line"></div><div class="line">	Welch Two Sample t-test</div><div class="line"></div><div class="line">data:  treatment and control</div><div class="line">t = <span class="number">2.0552</span>, df = <span class="number">20.236</span>, p-value = <span class="number">0.053</span></div><div class="line">alternative hypothesis: true difference <span class="keyword">in</span> means is not equal to <span class="number">0</span></div><div class="line"><span class="number">95</span> percent confidence interval:</div><div class="line"> -<span class="number">0.04296563</span>  <span class="number">6.08463229</span></div><div class="line">sample estimates:</div><div class="line">mean of x mean of y </div><div class="line"> <span class="number">26.83417</span>  <span class="number">23.81333</span></div></pre></td></tr></table></figure>
<p>如果只想看p值，那么使用以下代码即可，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result &lt;- t.test(treatment,control)</div><div class="line">result$p.value</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; result &lt;- t.test(treatment,control)</div><div class="line">&gt; result$p.value</div><div class="line">[<span class="number">1</span>] <span class="number">0.05299888</span></div></pre></td></tr></table></figure>
<p>从计算结果来看，这个p值有点大，这是因为在CLT近似的计算中，<code>tstat</code>的分布实际上是固定的（对于大样本来说，分母实际上就是固定的），而t分布的近似计算则是考虑到了分母（差值的标准误）是一个随机变量，是不固定的，样本数目越小，那分母的变化就越大。</p>
<p>这样来看的，我们使用了两种方法，得到了2个不同的p值，这在数据分析过程中很常见，因为我们是使用了不同的前提，不同的近似，因此会得到不同的结果。在后面讲到的功效计算(power calculation)中，我们会讲到I类错误，II类错误。在这里我们只说一下，使用CLT近似会错误地拒绝( incorrectly reject )零假设(假阳性)，而t分布则会错误地接受(inccorrectly acept)零假设(假阴性)。</p>
<p>在R中计算t检验如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/mice_pheno.csv"</span>)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">control &lt;- filter(dat,Diet==<span class="string">"chow"</span>) %&gt;% select(Bodyweight)</div><div class="line">treatment &lt;- filter(dat,Diet==<span class="string">"hf"</span>) %&gt;% select(Bodyweight)</div><div class="line">t.test(treatment,control)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; t.test(treatment,control)</div><div class="line"></div><div class="line">	Welch Two Sample t-test</div><div class="line"></div><div class="line">data:  treatment and control</div><div class="line">t = <span class="number">7.1932</span>, df = <span class="number">735.02</span>, p-value = <span class="number">1.563e-12</span></div><div class="line">alternative hypothesis: true difference <span class="keyword">in</span> means is not equal to <span class="number">0</span></div><div class="line"><span class="number">95</span> percent confidence interval:</div><div class="line"> <span class="number">2.231533</span> <span class="number">3.906857</span></div><div class="line">sample estimates:</div><div class="line">mean of x mean of y </div><div class="line"> <span class="number">30.48201</span>  <span class="number">27.41281</span></div></pre></td></tr></table></figure>
<h2 id="置信区间confidence-intervals">置信区间(Confidence Intervals)</h2>
<p>在生命科学研究中，仅在研究结论中报道p值是不够的，因为统计学上的显著性无法保证科学研究上的意义。例如在对体重的差异进行统计时，使用大样本的情况下，即使是1毫克的差异，也有可能有统计学意义，不过这种1毫克的差异是一个重要的发现么？我们能否说明，某个因素导致了不到1%的体重变化？仅报道p值是无法提供一些有价值的信息的，也不会提供有关效应量(the effect size)的信息，效应量(effect size)就是我们前面提到的观察到的差异(observed difference)。有的时候，效应量会用除以对照组的均值，因此会表示为百分比。</p>
<p>为了纠正仅报道p值偏差，另外一个统计量就提了出来，即置信区间(confidence intervals)。置信区间包括了估计的效应量(estimated effect size)，以及与这个估计有关的不确定性(uncertainty)，现在我们使用这批小鼠数据来计算一下置信区间。</p>
<h3 id="总体均值的置信区间">总体均值的置信区间</h3>
<p>在我们展示如何过计算两组差值的置信区间之前，我们先来看一下如何计算对照组雌性小鼠的总体均值的置信区间。随后，我们会计算样本的置留区间，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/mice_pheno.csv"</span>)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">chowPopulation &lt;- dat[dat$Sex==<span class="string">"F"</span> &amp; dat$Diet==<span class="string">"chow"</span>,<span class="number">3</span>]</div><div class="line">mu_chow &lt;- mean(chowPopulation)</div><div class="line">print(mu_chow)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(mu_chow)</div><div class="line">[<span class="number">1</span>] <span class="number">23.89338</span></div></pre></td></tr></table></figure>
<p>现在计算的结果就是 总体均值<span class="math inline">\(\mu_{X}\)</span>。</p>
<p>现在我们对这个结果进行估计，在实际分析过程中，我们并不会获取所有的总体，因此我们也像前面计算p值那样，我们来演示一下，通过抽样的方法来计算置信区间，现在我们先抽30个样本，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">30</span></div><div class="line">chow &lt;- sample(chowPopulation, N)</div><div class="line">print(mean(chow))</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(mean(chow))</div><div class="line">[<span class="number">1</span>] <span class="number">23.95033</span></div></pre></td></tr></table></figure>
<p>我们知道这个均值是一个随机变量，因此样本均值并不是一个非常好的估计。实际上，我们使用这个案例只是为了计算这个样本的均值，每次计算并非完全一样，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; N &lt;- <span class="number">30</span></div><div class="line">&gt; chow &lt;- sample(chowPopulation, N)</div><div class="line">&gt; print(mean(chow))</div><div class="line">[<span class="number">1</span>] <span class="number">23.48467</span></div><div class="line">&gt; </div><div class="line">&gt; N &lt;- <span class="number">30</span></div><div class="line">&gt; chow &lt;- sample(chowPopulation, N)</div><div class="line">&gt; print(mean(chow))</div><div class="line">[<span class="number">1</span>] <span class="number">25.22967</span></div><div class="line">&gt; </div><div class="line">&gt; N &lt;- <span class="number">30</span></div><div class="line">&gt; chow &lt;- sample(chowPopulation, N)</div><div class="line">&gt; print(mean(chow))</div><div class="line">[<span class="number">1</span>] <span class="number">23.732</span></div></pre></td></tr></table></figure>
<p>如上所示，每次抽样计算的均值都不一样。现在我们来了解一下置信区间，置信区间一种报道你数据中样本均值的一种统计学表示方法，它能明确地显示出随机变量的变异程度。</p>
<p>现在我们的的样本是30，CLT告诉我们，<span class="math inline">\(\bar{X}\)</span>或chow组的均值(mean)服从一个均值为<span class="math inline">\(\mu_{X}\)</span>（这个是chowPopulaiton这个总体的均值，即<code>mean(chowPopulation)</code>，这个均值服从均值为<span class="math inline">\(\mu_{X}\)</span>，标准误<span class="math inline">\(s_{X} / \sqrt{N}\)</span>的标准分布，计算过程如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">se &lt;- sd(chow)/sqrt(N)</div><div class="line">print(se)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; se &lt;- sd(chow)/sqrt(N)</div><div class="line">&gt; print(se)</div><div class="line">[<span class="number">1</span>] <span class="number">0.597656</span></div></pre></td></tr></table></figure>
<h3 id="定义区间">定义区间</h3>
<p>95%置信区间是一个随机区间，这个区间有95%概率落在我们估计值的参数中。这里需要注意的是，说95%的随机区间将会包括真值，并不等于说真值有95%的概率落在我们的区间中。为了构建置信区间，我们需要注意，CLT告诉我们，<span class="math inline">\(\sqrt{N}\left(\overline{X}-\mu_{X}\right) / s_{X}\)</span>服从均值为0，SD为1的正态分布，这个概率也就是以下事件的概率： <span class="math display">\[
-2 \leq \sqrt{N}\left(\overline{X}-\mu_{X}\right) / s_{X} \leq 2
\]</span> 在R中的计算为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pnorm(<span class="number">2</span>) - pnorm(-<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; pnorm(<span class="number">2</span>) - pnorm(-<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9544997</span></div></pre></td></tr></table></figure>
<p>这个值与95%很接近，也就是<code>qnorm(1-0.05/2)</code>的这个值，现在我们把上面的公式变换一下，把<span class="math inline">\(\mu_{X}\)</span>放中间，就成了如下的样子： <span class="math display">\[
\overline{X}-2 s_{X} / \sqrt{N} \leq \mu_{X} \leq \overline{X}+2 s_{X} / \sqrt{N}
\]</span></p>
<p>也就是上面这个值的概率是95%。需要注意的是，区间<span class="math inline">\(\overline{X} \pm 2 s_{X} / \sqrt{N}\)</span>是两个边界，它们是随机的。此外，我们需要明确一下，置信区间的定义是，95%的随机区间（random intervals)包含真正的固定值<span class="math inline">\(\mu_{X}\)</span>。对于一个计算结果来说，计算出来的这个特定的区间，它要么包括固定的总体均值<span class="math inline">\(\mu\)</span>，要么不包括。</p>
<p>现在我们来模拟一下其中的思路，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">30</span></div><div class="line">chow &lt;- sample(chowPopulation, N)</div><div class="line">se &lt;- sd(chow)/sqrt(N)</div><div class="line">Q &lt;- qnorm(<span class="number">1</span> - <span class="number">0.05</span>/<span class="number">2</span>)</div><div class="line">interval &lt;- c(mean(chow)-Q*se, mean(chow) + Q*se)</div><div class="line">interval</div><div class="line">interval[<span class="number">1</span>] &lt; mu_chow &amp; interval[<span class="number">2</span>] &gt; mu_chow</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; interval</div><div class="line">[<span class="number">1</span>] <span class="number">22.17089</span> <span class="number">24.58044</span></div><div class="line">&gt; interval[<span class="number">1</span>] &lt; mu_chow &amp; interval[<span class="number">2</span>] &gt; mu_chow</div><div class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></div></pre></td></tr></table></figure>
<p>从上面我们可以看到，这个区间覆盖了总体均值<span class="math inline">\(\mu_{X}\)</span>或<code>mean(chowPopulation)</code>。但是，如果我们再取另外一批样本的话，有可能不会覆盖总体均值<span class="math inline">\(\mu_{X}\)</span>，但是，统计学理论告诉我们，经过均数次抽样后，这个样本覆盖均值的概率是95%。由于我们能够获取总体数据，现在我们来看一些样本：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">B &lt;- <span class="number">250</span></div><div class="line">mypar()</div><div class="line">plot(mean(chowPopulation)+c(-<span class="number">7</span>, <span class="number">7</span>), c(<span class="number">1</span>,<span class="number">1</span>), type=<span class="string">"n"</span>,</div><div class="line">     xlab=<span class="string">"weight"</span>, ylab = <span class="string">"interval"</span>, ylim=c(<span class="number">1</span>,B))</div><div class="line">abline(v=mean(chowPopulation))</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</div><div class="line">  chow &lt;- sample(chowPopulation, N)</div><div class="line">  sd &lt;- sd(chow)/sqrt(N)</div><div class="line">  interval &lt;- c(mean(chow)-Q*se, mean(chow)+Q*se)</div><div class="line">  covered &lt;- </div><div class="line">    mean(chowPopulation) &lt;= interval[<span class="number">2</span>] &amp; mean(chowPopulation) &gt;= interval[<span class="number">1</span>]</div><div class="line">  color &lt;- ifelse(covered, <span class="number">1</span>,<span class="number">2</span>)</div><div class="line">  lines(interval, c(i, i), col= color)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190727142655.png">

</div>
<p>在这个案例中，我们模拟了250次随机抽样，计算了250次置信区间，其中颜色表示这个区间是否包含总体均值，其中绿色是包括的，棕色是不包括的。</p>
<p>上面这个案例的置信区间比较大（这个案例除以的是是<span class="math inline">\(\sqrt{5}\)</span>，而非<span class="math inline">\(\sqrt{30}\)</span>），我们可以看到很多区间并未覆盖<span class="math inline">\(\mu_{X}\)</span>，这是因为CLT错误地告诉了我们(chow)的均值是近似地接近于正态分布，实际上这个数据是不太符合正态分布的（在接近<span class="math inline">\(\pm \infty\)</span>的地方，它有一个比较扁平的尾巴）。这种错误会影响我们计算<code>Q</code>值，而这个<code>Q</code>值在计算的时，是以正态分布为前提,，使用<code>qnorm()</code>来计算的。在这种情况下，数据会更符合t分布，现在我们使用<code>qt()</code>函数来计算<code>Q</code>值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">plot(mean(chowPopulation)+ c(-<span class="number">7</span>,<span class="number">7</span>), c(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">"n"</span>,</div><div class="line">     xlab=<span class="string">"weight"</span>,ylab=<span class="string">"interval"</span>,ylim=c(<span class="number">1</span>,B))</div><div class="line">abline(v=mean(chowPopulation))</div><div class="line">Q &lt;- qt(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>, df=<span class="number">4</span>)</div><div class="line">N &lt;- <span class="number">5</span></div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</div><div class="line">  chow &lt;- sample(chowPopulation, N)</div><div class="line">  se &lt;- sd(chow)/sqrt(N)</div><div class="line">  interval &lt;- c(mean(chow)-Q*se, mean(chow)+Q*se)</div><div class="line">  covered &lt;- mean(chowPopulation) &lt;= interval[<span class="number">2</span>] &amp; mean(chowPopulation) &gt;= interval[<span class="number">1</span>]</div><div class="line">  color &lt;- ifelse(covered, <span class="number">1</span>,<span class="number">2</span>)</div><div class="line">  lines(interval, c(i,i), col=color)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728085017.png">

</div>
<p>上面这个图中，我们使用了小样本来模拟了250次计算，得到了它的95%置信区间，这个置信区间是基于t分布进行计算的。与前面的那个案例相比，这个案例中置信区间更大，这是因为t分布的尾部更为扁平，得到的置信区间就更大，现在我们来计算一下t分布的累积分分布，并拿它与正态分布比较一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qt(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>, df=<span class="number">4</span>)</div><div class="line">qnorm(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; qt(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>, df=<span class="number">4</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">2.776445</span></div><div class="line">&gt; qnorm(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1.959964</span></div></pre></td></tr></table></figure>
<p>从上面结果就可以看出来，t分布的置信区间更大，因此它才能以更大的概率(例如95%)来覆盖<span class="math inline">\(\mu_{X}\)</span>。</p>
<h3 id="置信区间与p值的关系">置信区间与p值的关系</h3>
<p>作者推荐报道实验结果时使用置信区间，而非仅用p值，对于某些原因，我们可能只需要提供p值即可，或者是提供0.05或0.01水平上的统计结果，其实置信区间也能提供这些信息。</p>
<p>当我们谈论t检验(t-test)的p值时，我们实际上是在谈论我们观察到的这两个样本的差值(<span class="math inline">\(\overline{Y}-\overline{X}\)</span>)以及更极端情况下差值的概率，就像是谈论两个总体之间的总体均值之差等于0这种极端情况下的概率。因此我们可以构建一个含有这个观察到的差值的置信区间，不过我们不再写为<span class="math inline">\(\overline{Y}-\overline{X}\)</span>这种形成，而是写为一种新的形式，即<span class="math inline">\(d \equiv \overline{Y}-\overline{X}\)</span>。</p>
<p>当我们来写一个差值的95%置信区间时，使用CLT则会写为<span class="math inline">\(d \pm 2 s_{d} / \sqrt{N}\)</span>这种形式，这个结果并不包含0（假阳性）。因为置信区间不含0，这就暗示了，<span class="math inline">\(d-2 s_{d} / \sqrt{N}&gt;0\)</span>或<span class="math inline">\(d+2 s_{d} / \sqrt{N}&lt;0\)</span>，这种表达形式还说明，<span class="math inline">\(\sqrt{N} d / s_{d}&gt;2\)</span>或<span class="math inline">\(\sqrt{N} d / s_{d}&lt;2\)</span>。这说明，t统计量比2更极端，反过来又说明，p值必然小于0.05（为了更加精确地计算，可以使用<code>qnorm(0.05/2)</code>来替换2）。如果使用t分布来取代CLT，则使用使用<code>qt(0.05/2, df=N-2</code>。总之，一个95%或99%置信区间并不包含0，p它们的p值必然小于0.05或小于0.01。</p>
<p>现在我们使用t检验来计算一下<code>d</code>的置信区间，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.test(treatment,control,conf.level=<span class="number">0.95</span>)$conf.int</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; t.test(treatment,control,conf.level=<span class="number">0.95</span>)$conf.int</div><div class="line">[<span class="number">1</span>] <span class="number">2.231533</span> <span class="number">3.906857</span></div><div class="line">attr(,<span class="string">"conf.level"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.95</span></div></pre></td></tr></table></figure>
<p>如果我们把置信水平改为0.9，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; t.test(treatment,control,conf.level=<span class="number">0.90</span>)$conf.int</div><div class="line">[<span class="number">1</span>] <span class="number">2.366479</span> <span class="number">3.771911</span></div><div class="line">attr(,<span class="string">"conf.level"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9</span></div></pre></td></tr></table></figure>
<p>可以发现，置信区间变小了。</p>
<h2 id="功效计算">功效计算</h2>
<p>在前面的案例中，我们研究了不同包含对小鼠体重的影响，由于我们在使用这个案例的时候，我们研究的是总体，发现了这两种包含对小鼠的体重有着明显的影响，计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">dir &lt;- system.file(package = <span class="string">"dagdata"</span>)</div><div class="line">filename &lt;- file.path(dir,<span class="string">"extdata/mice_pheno.csv"</span>)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">controlPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"chow"</span>) %&gt;% dplyr::select(Bodyweight) %&gt;% unlist</div><div class="line">hfPopulation &lt;- filter(dat, Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"hf"</span>) %&gt;% dplyr::select(Bodyweight) %&gt;% unlist</div><div class="line"></div><div class="line">mu_hf &lt;- mean(hfPopulation)</div><div class="line">mu_control &lt;- mean(controlPopulation)</div><div class="line">print(mu_hf - mu_control)</div><div class="line">print((mu_hf - mu_control)/mu_control*<span class="number">100</span>)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; print(mu_hf - mu_control)</div><div class="line">[<span class="number">1</span>] <span class="number">2.375517</span></div><div class="line">&gt; print((mu_hf - mu_control)/mu_control*<span class="number">100</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">9.942157</span></div></pre></td></tr></table></figure>
<p>某些情况下，我们会采用抽样的形式，抽取一定数目的小鼠体重作为样本，此时就不能使用总体的计算方法，而是采用t检验，此时计算得到的p值不一定小于0.05，例如。我们随机抽取5只小鼠来计算一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">N &lt;- <span class="number">5</span></div><div class="line">hf &lt;- sample(hfPopulation, N)</div><div class="line">control &lt;- sample(controlPopulation, N)</div><div class="line">t.test(hf,control)$p.value</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; t.test(hf,control)$p.value</div><div class="line">[<span class="number">1</span>] <span class="number">0.1410204</span></div></pre></td></tr></table></figure>
<p>前后两种的计算方法出现了差异，第一次计算（使用小鼠的总体来进行计算）与第二次计算（随机抽两组的5只小鼠来计算）的p值不一样，是否出现了错误？</p>
<p>在第二次计算中，p值大于0.05，因此我们不拒绝零假设，从而说饮食对小鼠的体重没有影响么？能否这么讲？答案不是能。我们只能说，无法拒绝零假设（注意，没有后面那半句：包含对小鼠的体重没有影响）。我们无法拒绝零假设，并不意味着零假设一定为真。在这个特殊的案例中，这里我们面临的一个问题就是，我们没有足够的功效(power)。如果你从事科学研究，很有可能在某些时候不得不做一个功效计算。在很多情况下，这是一种首选义务，因此它可以帮助你在人的研究中，避免使用过多的小鼠，或者是避免使用过多的受试患者。现在我们就来解释一下统计功效(statistical power)的含义。</p>
<h3 id="错误类型">错误类型</h3>
<p>我们要有这么一个意识，即，一旦我们做统计，就有可能犯错误，这也就是为什么p值不等于0。在进行统计时，当p值很小时，这说明我们可以拒绝零假设，但是这种拒绝也有可能犯错误（虽然犯错误的概率很低），例如零假设确实是真时。例如当p值等于0.05时，那么我们重复20实验，就有可能1次会发生零假设成功的事件，统计学家把这种错误称为I类错误(<code>type I error</code>)。</p>
<p>I类错误的定义就是，零假设成立时，我们拒绝了（其实不应该拒绝的），也就是所谓假阳性。这里为什么使用0.05，而不使用0.00001呢？这是因为如果阈值设得过低，成本会非常高。此时我们还要引入II类错误(<code>type I error</code>)，II类错误是指，零假设不成立，但是我们接受了零假设，也就是所谓的假阴性。前面我们抽样了5只小鼠，计算得到的值大于0.05，因此我们无法拒绝零假设（在0.05这个水平上），此时所犯的错误就是II类错误，也就是假阴性（从总体上看，实际上是有差异的，但是我们没有发现）。如果我们把阈值提高到0.25，我们就不会犯这个错误了（计算出的p值为0.1410204），不过通常情况下，不会这么干。</p>
<h3 id="与0.01阈值cut-off">0.05与0.01阈值(cut-off)</h3>
<p>多数的期刊或监管机构都坚持0.01或0.05的显著性水平，当然这么做无可厚非。我们本书的目标就之一就是让读者对p值以及置信区间有一个更深入的理解，以便读者能够在一些情况下做出合理的选择。不幸的是，这些阈值在某些程度上已经滥用，不过这是又是一个容易引起争论的话量，此处不表。</p>
<h3 id="功效计算-1">功效计算</h3>
<p>功效(power)是指：当零假设为假时，拒绝它的概率，原书的描述如下所示：</p>
<blockquote>
<p>Power is the probability of rejecting the null when the null is false.</p>
</blockquote>
<p>不过“零假设为假”这种情况比较复杂，因为在许多情况下，零假设都有可能为假。<span class="math inline">\(\Delta \equiv \overline{Y}-\overline{X}\)</span>可以是任意的，功效实际上要依赖于这个参数，功效同时还依赖于你估计值的标准误，反过来，标准误又依赖于样本数目，以及总体标准差。实际情况中，我们并不知道一些<span class="math inline">\(\Delta\)</span>，<span class="math inline">\(\sigma_{X}\)</span>，<span class="math inline">\(\sigma_{Y}\)</span>值以及样本数目这些值。但是通过统计学理论，我们可以计算功效，R中的<code>pwr</code>包可以进行这样的计算，现在我们来模拟一下这个过程：</p>
<p>第一步：确定样本数目，我们确定为12，即<code>N &lt;- 12</code>；</p>
<p>第二步：设定拒绝零假设的阈值，这里为0.05，也就是常见的p值水平，即<code>alpha &lt;- 0.05</code>；</p>
<p>第三步：设计重复抽样次数，我们会重复地进行抽样，来计算一下拒绝零假设的比例，这里设为2000，即<code>B &lt;- 2000</code>；</p>
<p>这个模拟过程就是：我们会从对照组和处理组中抽取<code>N</code>个样本，使用t检验来计算p值，观察p值是否小于0.05，现在我们把这个过程写为一个函数，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">12</span></div><div class="line">alpha &lt;- <span class="number">0.05</span></div><div class="line">B &lt;- <span class="number">2000</span></div><div class="line"></div><div class="line">reject &lt;- <span class="keyword">function</span>(N, alpha=<span class="number">0.05</span>)&#123;</div><div class="line">  hf &lt;- sample(hfPopulation, N)</div><div class="line">  control &lt;- sample(controlPopulation, N)</div><div class="line">  pval &lt;- t.test(hf, control)$p.value</div><div class="line">  pval &lt; alpha</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果样本数目为12，那么我们是否能拒绝零假设呢，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; reject(<span class="number">12</span>)</div><div class="line">[<span class="number">1</span>] <span class="literal">FALSE</span></div></pre></td></tr></table></figure>
<p>答案是不能。现在我们使用<code>replicate()</code>函数来重复2000次，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">12</span></div><div class="line">rejections &lt;- replicate(B, reject(N))</div><div class="line">mean(rejections)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(rejections)</div><div class="line">[<span class="number">1</span>] <span class="number">0.218</span></div></pre></td></tr></table></figure>
<p>其中<code>rejecctions</code>的结果是一个逻辑值，即里面只有<code>TRUE</code>或<code>FALSE</code>，其中<code>TRUE</code>为1，<code>FALSE</code>是0，那么我们计算的均值，即<code>mean(rejections)</code>就是<code>TRUE</code>所占的比例，因此我们计算出来的功效为0.218。这就是为什么，当我们知道零假设为假时，t检验也无法拒绝的原因。当样本数目为12时，功效是21.8%，对为能够在0.05水平上降低假阳性，那么我们可以设置更高的阈值，但这会导致II类错误的增多。</p>
<p>现在我们来看一下，功效是如何随着N的变化而变化的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ns &lt;- seq(<span class="number">5</span>,<span class="number">50</span>, <span class="number">5</span>)</div><div class="line">power &lt;- sapply(Ns, <span class="keyword">function</span>(N)&#123;</div><div class="line">  rejections &lt;- replicate(B, reject(N))</div><div class="line">  mean(rejections)</div><div class="line">&#125;)</div><div class="line">power</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; power</div><div class="line"> [<span class="number">1</span>] <span class="number">0.0960</span> <span class="number">0.1640</span> <span class="number">0.2775</span> <span class="number">0.3775</span> <span class="number">0.4795</span> <span class="number">0.5540</span> <span class="number">0.6415</span> <span class="number">0.7075</span> <span class="number">0.7725</span> <span class="number">0.8160</span></div></pre></td></tr></table></figure>
<p>从上面的结果我们可以发现，随着N的增加，功效也在增加，曲线如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(Ns, power, type = <span class="string">"b"</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728122626.jpeg">

</div>
<p>再来看一个案例。我们把<code>alpha</code>这个拒绝阈值改变一下，再来看一下功效的变化。如果想要降低I类错误，那么功效就会越小，也就说，我们需要在两类错误之间进行权衡，现在我们看下面的代码，在保证N值相同的前提下，改变<code>alpha</code>后功效的大小：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">30</span></div><div class="line">alphas &lt;- c(<span class="number">0.1</span>, <span class="number">0.05</span>, <span class="number">0.01</span>, <span class="number">0.001</span>, <span class="number">0.001</span>)</div><div class="line">power &lt;- sapply(alphas, <span class="keyword">function</span>(alpha)&#123;</div><div class="line">  rejections &lt;- replicate(B, reject(N, alpha=alpha))</div><div class="line">  mean(rejections)</div><div class="line">&#125;)</div><div class="line">plot(alphas, power, xlab=<span class="string">"alpha"</span>, type=<span class="string">"b"</span>, log=<span class="string">"x"</span>)</div></pre></td></tr></table></figure>
<p>变化曲线如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728123209.jpeg">

</div>
<p>在实际统计中，没有绝对的功效，也没有绝对的alpha值，但是我们要理解这背后的统计学硬。</p>
<h3 id="替代假设下的p值">替代假设下的p值</h3>
<p>当零假设为假，替代假设为真时，那么p值有的时候就比较任意了。当替代假设为真时，我们通过增加样本数目，可以得到一个尽可能小的p值，通过从总体中不断抽取更大的样本数，我们就会知道p值的这种特性，现在看一下这个过程。</p>
<p>第一步：构建一个函数，这个函数能够返回一个样本数目为N时的p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">calculatePvalue &lt;- <span class="keyword">function</span>(N)&#123;</div><div class="line">  hf &lt;- sample(hfPopulation,N)</div><div class="line">  control &lt;- sample(controlPopulation, N)</div><div class="line">  t.test(hf, control)$p.value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步：设定样本数目，对于每个样本数目的计算，我们会得到一系列p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Ns &lt;- seq(<span class="number">10</span>, <span class="number">200</span>, by=<span class="number">10</span>)</div><div class="line">Ns_rep &lt;- rep(Ns, each=<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>第三步：计算p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pvalues &lt;- sapply(Ns_rep, calculatePvalue)</div></pre></td></tr></table></figure>
<p>第四步：绘制样本数目与其对应的p值，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plot(Ns_rep, pvalues, log=<span class="string">"y"</span>, xlab=<span class="string">"Sample size"</span>,</div><div class="line">     ylab=<span class="string">"p-value"</span>)</div><div class="line">abline(h=c(<span class="number">0.01</span>, <span class="number">0.05</span>), col=<span class="string">"red"</span>, lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190728125345.jpeg">

</div>
<p>上图是随着样本数目的变化，p值的变化。从上面结果可以看出，当替代假设成立时，随着样本数目的增多，p值会越来越小，从上面的两条红线分别是0.01与0.05的区间。</p>
<p>一旦我们在某个阈值上拒绝了零假设，我们如果想要获得一个更小的p值，那么就需要更多的样本，例如实验小鼠。样本增大会增加我们对差值<span class="math inline">\(\Delta\)</span>估计的精确性，但是，这个p值的降低仅仅是数学计算的自然结果。因为在计算p值时，它公式中的分母是样本数目的平方根，即<span class="math inline">\(\sqrt{N}\)</span>，即如果<span class="math inline">\(\Delta\)</span>不等于0，随着N的增加，p值必然降低。</p>
<p>因此，一个好的统计学结果需要列出效应量(effect size)与置信区间。效应量的计算是：将差值(difference)和置信区间(confidence interval)除以对照总体的均值，获得一个百分数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">N &lt;- <span class="number">12</span></div><div class="line">hf &lt;- sample(hfPopulation, N)</div><div class="line">control &lt;- sample(controlPopulation, N)</div><div class="line">diff &lt;- mean(hf) - mean(control)</div><div class="line">diff/mean(control)*<span class="number">100</span></div><div class="line">t.test(hf, control)$conf.int / mean(control) * <span class="number">100</span></div></pre></td></tr></table></figure>
<p>计算结果为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; diff/mean(control)*<span class="number">100</span></div><div class="line">[<span class="number">1</span>] <span class="number">5.783149</span></div><div class="line">&gt; t.test(hf, control)$conf.int / mean(control) * <span class="number">100</span></div><div class="line">[<span class="number">1</span>] -<span class="number">8.169363</span> <span class="number">19.735661</span></div><div class="line">attr(,<span class="string">"conf.level"</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.95</span></div></pre></td></tr></table></figure>
<p>此外，我们还可以写出一个名为<code>Cohen's d</code>的统计量，它是两组之间的差值除以这两组总和的标准差，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sd_pool &lt;- sqrt(((N-<span class="number">1</span>)*var(hf) + (N-<span class="number">1</span>)*var(control))/(<span class="number">2</span>*N - <span class="number">2</span>))</div><div class="line">diff / sd_pool</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; sd_pool &lt;- sqrt(((N-<span class="number">1</span>)*var(hf) + (N-<span class="number">1</span>)*var(control))/(<span class="number">2</span>*N - <span class="number">2</span>))</div><div class="line">&gt; diff / sd_pool</div><div class="line">[<span class="number">1</span>] <span class="number">0.3510624</span></div></pre></td></tr></table></figure>
<p>这个结果告诉我们，hf组的小鼠体重的均值与对照组(control)小鼠体重平均值偏离多少个标准差。在替代假设下，t统计量会随着样本数目的增加而增加，但是效应量(effect size)与<code>Cohen's d</code>却会变得更加精确。</p>
<h3 id="练习-2">练习</h3>
<p>P76</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/03/DAL/DALS003_Inference02_Population_Estimates/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/03/DAL/DALS003_Inference02_Population_Estimates/" itemprop="url">DALS003-统计推断(Inference)02-总体与样本估计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-03T12:00:00+08:00">
                2019-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物统计/" itemprop="url" rel="index">
                    <span itemprop="name">生物统计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  996
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是《Data Analysis for the Life Sciences》的第2章：统计推断(Inference)的第2部分。这一部分的主要内容涉及一些统计学的术语，即总体，样本和估计。</p>
<h2 id="总体population样本sample和估计estimates">总体(population)、样本(Sample)和估计(Estimates)</h2>
<h3 id="总体参数population-parameters">总体参数(population parameters)</h3>
<p>在小鼠体重的案例中，我们有两种总体，对照组雌性小鼠，高脂组雌性小鼠，其中体重是我们感兴趣的指标。现在我们假设种群的数目是固定的，而其中的随机误差就来源于抽样。我们使用下面的这个数据集来作为案例，这是因为我们正好有这种类型小鼠的数据，现在导入数据，跟前面的流程一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(downloader)</div><div class="line">url &lt;- <span class="string">"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extd\</span></div><div class="line"><span class="string">ata/mice_pheno.csv"</span></div><div class="line">filename &lt;- <span class="string">"mice_pheno.csv"</span></div><div class="line">download(url,destfile=filename)</div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">head(dat)</div></pre></td></tr></table></figure>
<p>计算结果如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(dat)</div><div class="line">  Sex Diet Bodyweight</div><div class="line"><span class="number">1</span>   <span class="literal">F</span>   hf      <span class="number">31.94</span></div><div class="line"><span class="number">2</span>   <span class="literal">F</span>   hf      <span class="number">32.48</span></div><div class="line"><span class="number">3</span>   <span class="literal">F</span>   hf      <span class="number">22.82</span></div><div class="line"><span class="number">4</span>   <span class="literal">F</span>   hf      <span class="number">19.92</span></div><div class="line"><span class="number">5</span>   <span class="literal">F</span>   hf      <span class="number">32.22</span></div><div class="line"><span class="number">6</span>   <span class="literal">F</span>   hf      <span class="number">27.50</span></div></pre></td></tr></table></figure>
<p>现在挑一个对照组的种群，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line">controlPopulation &lt;- filter(dat,Sex == <span class="string">"F"</span> &amp; Diet == <span class="string">"chow"</span>) %&gt;% dplyr::select(Bodyweight) %&gt;% unlist</div><div class="line">head(controlPopulation)</div><div class="line">length(controlPopulation)</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; head(controlPopulation)</div><div class="line">Bodyweight1 Bodyweight2 Bodyweight3 Bodyweight4 Bodyweight5 Bodyweight6 </div><div class="line">      <span class="number">27.03</span>       <span class="number">24.80</span>       <span class="number">27.02</span>       <span class="number">28.07</span>       <span class="number">23.55</span>       <span class="number">22.72</span> </div><div class="line">&gt; length(controlPopulation)</div><div class="line">[<span class="number">1</span>] <span class="number">225</span></div></pre></td></tr></table></figure>
<p>我们通常使用<span class="math inline">\(x_{1},x_{2},\dots,x_{m}\)</span>来表示对照组的这些数据，其中<span class="math inline">\(m\)</span>表示上述总体中的数字的数目。</p>
<p>现在我们来挑hf组的总体，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hfPopulation &lt;- filter(dat, Sex ==<span class="string">"F"</span> &amp; Diet == <span class="string">"hf"</span>) %&gt;% dplyr::select(Bodyweight) %&gt;% unlist</div><div class="line">head(hfPopulation)</div><div class="line">length(hfPopulation)</div></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; head(hfPopulation)</div><div class="line">Bodyweight1 Bodyweight2 Bodyweight3 Bodyweight4 Bodyweight5 Bodyweight6 </div><div class="line">      <span class="number">31.94</span>       <span class="number">32.48</span>       <span class="number">22.82</span>       <span class="number">19.92</span>       <span class="number">32.22</span>       <span class="number">27.50</span> </div><div class="line">&gt; length(hfPopulation)</div><div class="line">[<span class="number">1</span>] <span class="number">200</span></div></pre></td></tr></table></figure>
<p>现在我们使用y来表示hf组总体中的数目，即<span class="math inline">\(y_{1}, y_{2}, \dots,y_{y}\)</span>，现在我们定义这些总体的一些参数：</p>
<p>均值： <span class="math display">\[
\mu_{X}=\frac{1}{m} \sum_{i=1}^{m} x_{i} \text { and } \mu_{Y}=\frac{1}{n} \sum_{i=1}^{n} y_{i}
\]</span> 方差(variance)： <span class="math display">\[
\sigma_{X}^{2}=\frac{1}{m} \sum_{i=1}^{m}\left(x_{i}-\mu_{X}\right)^{2} \text { and } \sigma_{Y}^{2}=\frac{1}{n} \sum_{i=1}^{n}\left(y_{i}-\mu_{Y}\right)^{2}
\]</span> 我们从总体中获得的这两个参数，即均值和方差，称为总体参数(population parameters)。</p>
<p>我们一开始的问题就可以这么写：<span class="math inline">\(\mu_{Y}-\mu_{X}=0\)</span>?</p>
<p>虽然在我们的案例中我们获取了所有的值，并且验证这个问题是否为真，但是在实际中，我们并不能这么干。例如，在实际实验中，购买一个总体中的所有小鼠非常昂贵。此时，我们可以抽取一个样本(sample)来回答这个问题（也就是hf组和chow组中的小鼠体重的差异是否为0这个问题）。这就是统计推断(statistical inference)的本质。</p>
<h3 id="样本估计sample-estimates">样本估计(sample estimates)</h3>
<p>在前面部分中，我们从每个总体（hf总体和chow总体）中获取了样本，每个样本中有12只小鼠。在统计学中，我们经常使用大写字母来表示这些随机抽取的样本。因此这些样本就是<span class="math inline">\(X_{1}, \ldots, X_{M}\)</span>和<span class="math inline">\(Y_{1}, \ldots, Y_{N}\)</span>，在这个案例中，假设我们有12个样本，也就是说<span class="math inline">\(N=M=12\)</span>，当我们列出总体的值时（这个总体此时是设定的，不随机的），我们就使用小写字母来下标它们。</p>
<p>由于我们想知道总体的两个均值<span class="math inline">\(\mu_{Y}-\mu_{X}\)</span>是否为0，我们可以通过计算它们的样本之差是否为0，也即<span class="math inline">\(\bar{Y}-\bar{X}\)</span>是否为0来进行推断（在统计学中，常用希腊字母<span class="math inline">\(\mu\)</span>来表示总体均值，而用大写字母上加横的形式表示样本均值）： <span class="math display">\[
\overline{X}=\frac{1}{M} \sum_{i=1}^{M} X_{i} \text { and } \overline{Y}=\frac{1}{N} \sum_{i=1}^{N} Y_{i}
\]</span> 需要注意的是，2个均值的差值也是一个随机变量，这些内容我们在前面已经提及。</p>
<h2 id="练习">练习</h2>
<p>P39</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">214</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">105</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共844.9k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
