<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/2/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/2/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/10/Linux-shell10-sed进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/Linux-shell10-sed进阶/" itemprop="url">Shell学习笔记（10）——sed进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-10T12:12:54+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,053
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  41
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多行命令">多行命令</h2>
<p>sed编辑器包含了三个可用来处理多行文本的特殊命令，其中：</p>
<ol style="list-style-type: decimal">
<li><code>N</code>：将数据流中的下一行加进来创建一个多行组（multiline group）来处理；</li>
<li><code>D</code>：删除多行组中的一行</li>
<li><code>P</code>：打印多行组中的一行。</li>
</ol>
<h3 id="next-命令">next 命令</h3>
<p>小写的n命令（n表示next）会告诉sed编辑器移动到数据流中的下一文本行，而不用重新回到命令的最开始再执行一遍。通常sed编辑器在移动到数据流中的下一文本行之前，会在当前行上执行完所有定义好的命令。单行next命令改变了这个流程。在下面的这个例子中，你有个数据文件，共有5行内容，其中的两行是空的。目标是删除首行之后的空白行，而留下最后一行之前的空白行。如果写一个删掉空白行的sed脚本，你会删掉两个空白行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data1.txt</div><div class="line">THis is the header line.</div><div class="line"></div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/^$/d' data1.txt</div><div class="line"><span class="meta">#</span> 删除空行，^$表示空行</div><div class="line">THis is the header line.</div><div class="line">This is a data line.</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>如果只是删除第1行之后的空行，就要用到n命令，在下面的脚本中，首先要查找含有单词header的那一行。找到之后，n命令会让sed编辑器移动到文本的下一行，也就是那个空行，删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed '/header/&#123;n;d&#125;' data1.txt</div><div class="line">THis is the header line.</div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>这时，sed编辑器会继续执行命令列表，该命令列表使用d命令来删除空白行。sed编辑器执行完命令脚本后，会从数据流中读取下一行文本，并从头开始执行命令脚本。因为sed编辑器再也找不到包含单词header的行了。所以也不会有其他行会被删掉，如果再给文添加上一行，里面含有header字符串，之后再留1个空格，也会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data1a.txt </div><div class="line">THis is the header line.</div><div class="line"></div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is another line containing string 'header'. #这行文中也含有header，随后跟了一个空行</div><div class="line"></div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/header/&#123;n;d&#125;' data1a.txt # 这个命令会删除含有header之后的空行</div><div class="line"></div><div class="line">THis is the header line.</div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is another line containing string 'header'. # 后面的空行删除了</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<h4 id="合并文本行">合并文本行</h4>
<p>单行next命令会将数据流中的下一文本行移动到sed编辑器的工作空间（称为模式空间）。多行版本的next命令（用大写N）会将下一文本行添加到模式空间中已有的文本后。这样的作用是将数据流中的两个文本行合并到同一个模式空间中。文本行仍然用换行符分隔，但sed编辑器现在会将两行文本当成一行来处理。下面的例子演示了<code>N</code>命令的工作方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txtThis is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/first/&#123;N;s/\n/ / &#125;' data2.txt</div><div class="line">This is the first data line. This is the second data line.</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>在这段代码中，<code>sed '/first/{N;s/line/replace/ }' data2.txt</code>查找含有单词first的那行文本，找到该行后，使用N命令，将下一行合并到那行，然后用替换命令将换行符替换为空格。</p>
<p>如果要在数据文件中查找一个可能会分散在两行中的文本短语的话，这是个很实用的应用程序，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data3.txt </div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line">Thank you for your attendance.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N; s/System Administrator/Desktop User/' data3.txt</div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div><div class="line">Thank you for your attendance.</div></pre></td></tr></table></figure>
<p>替换命令会在文本文件中查找特定的双词短语System Administrator。如果短语在一行中的话，事情很好处理，替换命令可以直接替换文本。但如果短语分散在两行中的话，替换命令就没法识别匹配的模式了，在这个案例中，是第1行中有一个System，第2行有一个Administrator，使用System administrator时，这种情况下就无法匹配，此时就需要使用N命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data3.txt </div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line">Thank you for your attendance.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N;s/System.Administrator/Desktop User/' data3.txt</div><div class="line">On Tuesday, the Linux Desktop User's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div><div class="line">Thank you for your attendance.</div></pre></td></tr></table></figure>
<p>在这段代码中，使用N命令将发现第一个单词的那行和下一行合并后，即使短语内出现了换行，你仍然可以找到它。注意，替换命令在System和Administrator之间用了通配符模式（.）来匹配空格和换行符这两种情况。但当它匹配了换行符时，它就从字符串中删掉了换行符，导致两行合并成一行。这可能不是你想要的。要解决这个问题，可以在sed编辑器脚本中用两个替换命令：一个用来匹配短语出现在多行中的情况，一个用来匹配短语出现在单行中的情况，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N</div><div class="line">s/System\nAdministrator/Desktop\nUser/</div><div class="line"><span class="meta">&gt;</span> s/System Administrator/Desktop User/</div><div class="line"><span class="meta">&gt;</span> ' data3.txt</div><div class="line"></div><div class="line">On Tuesday, the Linux Desktop</div><div class="line">User's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div><div class="line">Thank you for your attendance.</div></pre></td></tr></table></figure>
<p>第一个替换命令专门查找两个单词间的换行符，并将它放在了替换字符串中。这样你就能在第一个替换命令专门在两个检索词之间寻找换行符，并将其纳入替换字符串。这样就允许你在新文本的同样位置添加换行符了。但这个脚本中仍有个小问题。这个脚本总是在执行sed编辑器命令前将下一行文本读入到模式空间。当它到了最后一行文本时，就没有下一行可读了，所以N命令会叫sed编辑器停止。如果要匹配的文本正好在数据流的最后一行上，命令就不会发现要匹配的数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data4.txt</div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N</div><div class="line">s/System\nAdministrator/Desktop\nUser/</div><div class="line">s/System Administrator/Desktop User/</div><div class="line">' data4.txt</div><div class="line"></div><div class="line">On Tuesday, the Linux Desktop</div><div class="line">User's group meeting will be held.</div><div class="line">All System Administrators should attend.</div></pre></td></tr></table></figure>
<p>在这个案例中，匹配的文正好在数据流的最后一行，并没有发生文本的替换，<code>N</code>命令会错过它，因为没有其他行可读入到模式空间跟这行合并。如果要解决这个问题，就要将单行命令放到N命令前面，并将多行命令放到N命令后面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed '</div><div class="line"><span class="meta">&gt;</span> s/System Administrator/Desktop User/</div><div class="line"><span class="meta">&gt;</span> N</div><div class="line"><span class="meta">&gt;</span> s/System\nAdministrator/Desktop\nUser/</div><div class="line"><span class="meta">&gt;</span> ' data4.txt</div><div class="line"></div><div class="line">On Tuesday, the Linux Desktop</div><div class="line">User's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div></pre></td></tr></table></figure>
<p>现在，查找单行中短语的替换命令在数据流的最后一行也能正常工作，多行替换命令则会负责短语出现在数据流中间的情况。</p>
<h3 id="多行删除命令">多行删除命令</h3>
<p>单行删除命令（d）和N命令一起使用时，需要注意，看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data4.txt</div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N; /System\nAdministrator/d' data4.txt</div><div class="line">All System Administrators should attend.</div></pre></td></tr></table></figure>
<p>删除命令会在不同的行中查找单词System和Administrator，然后在模式空间中将两行都删掉。sed编辑器提供了多行删除命令D，它只删除模式空间中的第一行。该命令会删除到换行符（含换行符）为止的所有字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N;/System\nAdministrator/D' data4.txt</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div></pre></td></tr></table></figure>
<p>文本的第二行被N命令加到了模式空间，最终结果只是删除了第1行，第2行但仍然完好。如果遇到一种情况，即需要删掉目标数据字符串所在行的前一文本行，此时就能派得上用场，看下面的一个案例，在这个案例中，它会删除数据流中出现在第一行前的空白行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data5.txt </div><div class="line">                         # 这里是一个空行</div><div class="line">This is the header line.</div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/^$/&#123;N;/header/D&#125;' data5.txt</div><div class="line">This is the header line.</div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>sed编辑器脚本会查找空白行，然后用N命令来将下一文本行添加到模式空间。如果新的模式空间内容含有单词header，则D命令会删除模式空间中的第一行。如果不结合使用N命令和D命令，就不可能在不删除其他空白行的情况下只删除第一个空白行。</p>
<h3 id="多行打印命令">多行打印命令</h3>
<p>多行打印命令（P）只打印多行模式空间中的第一行，这包括模式空间中直到换行符为止的所有字符。当你用-n选项来阻止脚本输出时，它和显示文本的单行p命令的用法大同小异，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data3.txt </div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line">Thank you for your attendance.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n 'N;/System\nAdministrator/P' data3.txt</div><div class="line">On Tuesday, the Linux System</div></pre></td></tr></table></figure>
<p>当多行匹配出现时，P命令只会打印模式空间中的第一行。</p>
<p>多行P命令的强大之处在和N命令及D命令组合使用时才能显现出来。D命令的独特之处在于强制sed编辑器返回到脚本的起始处，对同一模式空间中的内容重新执行这些命令（它不会从数据流中读取新的文本行）。在命令脚本中加入N命令，你就能单步扫过整个模式空间，将多行一起匹配。接下来，使用P命令打印出第一行，然后用D命令删除第一行并绕回到脚本的起始处。一旦返回，N命令会读取下一行文本并重新开始这个过程。这个循环会一直继续下去，直到数据流结束。</p>
<h2 id="保持空间">保持空间</h2>
<p>模式空间（pattern space）是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本。但它并不是sed编辑器保存文本的唯一空间。sed编辑器有另一块称作保持空间（hold space）的缓冲区域。在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。有5条命令可用来操作保持空间，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>命 令</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>h</td>
<td>将模式空间复制到保持空间</td>
</tr>
<tr class="even">
<td>H</td>
<td>将模式空间附加到保持空间</td>
</tr>
<tr class="odd">
<td>g</td>
<td>将保持空间复制到模式空间</td>
</tr>
<tr class="even">
<td>G</td>
<td>将保持空间附加到模式空间</td>
</tr>
<tr class="odd">
<td>x</td>
<td>交换模式空间和保持空间的内容</td>
</tr>
</tbody>
</table>
<p>这些命令用来将文本从模式空间复制到保持空间。这可以清空模式空间来加载其他要处理的字符串。通常，在使用h或H命令将字符串移动到保持空间后，最终还要用g、G或x命令将保存的字符串移回模式空间。由于有两个缓冲区域，弄明白哪行文本在哪个缓冲区域有时会比较麻烦。这里有个简短的例子演示了如何用h和g命令来将数据在sed编辑器缓冲空间之间移动，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '/first/&#123;h;p;n;p;g;p&#125;' data2.txt</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the first data line.</div></pre></td></tr></table></figure>
<p>代码与结果解释：</p>
<ol style="list-style-type: decimal">
<li>sed脚本在地址中使用正则表达式来过滤出含有单词first的行；</li>
<li>当含有单词first的行出现时，h命令将该行放到保持空间；</li>
<li>p命令打印模式空间的内容，也就是第一个数据行的内容；</li>
<li>n命令提取数据流中的下行（<code>This is the second data line</code>），并将它放到模式空间</li>
<li>p命令打印模式空间的内容，现在是第二个数据行；</li>
<li>g命令将保持空间的内容（<code>This is the first data line</code>）放回模式空间，替换当前文本；</li>
<li>p命令打印模式空间的当前内容，现在变回第一个数据行。</li>
</ol>
<p>通过使用保持空间来回移动文本行，可以强制输出中第一个数据行出现在第二个数据行后面。如果丢掉了第一个p命令，可以以相反的顺序输出这两行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '/first/&#123;h;n;p;g;p&#125;' data2.txt</div><div class="line">This is the second data line.</div><div class="line">This is the first data line.</div></pre></td></tr></table></figure>
<p>代码及结果解释；</p>
<ol style="list-style-type: decimal">
<li>sed过滤出含有单词first的行，打到<code>This is the first data line</code>后，将它保存到保持空间；</li>
<li>接着使用n命令，提取这一行的下一行，即<code>This is the second data line</code>，打印这一行的内容；</li>
<li>使用g命令，将保持空间的内容提取出来，进入模式空间，接着用p命令打印这一行，即<code>This is the first data line.</code>。</li>
</ol>
<p>从上面的例子可以看出，保持空间就相当于一个临时的储存空间，可以把匹配到的文本暂时放在这里面，随后再取出来。</p>
<h2 id="排除命令">排除命令</h2>
<p>感叹号命令（!）用来排除（negate）命令，也就是让原本会起作用的命令不起作用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txtThis is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '/header/p' data2.txt</div><div class="line">This is the header line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '/header/!p' data2.txt</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>普通p命令只打印data2文件中包含单词header的那行。加了感叹号之后，情况就相反了：除了包含单词header那一行外，文件中其他所有的行都被打印出来了。感叹号在有些应用中用起来很方便。在前面内容中的案例里，sed编辑器无法处理数据流中最后一行文本，因为之后再没有其他行了。可以用感叹号来解决这个问题，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data4.txt </div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N</div><div class="line"><span class="meta">&gt;</span> s/System\nAdministrator/Desktop\nUser/</div><div class="line"><span class="meta">&gt;</span> s/System Administrator/Desktop User/</div><div class="line"><span class="meta">&gt;</span> ' data4.txt</div><div class="line">On Tuesday, the Linux Desktop # 这一行进行了修改</div><div class="line">User's group meeting will be held.</div><div class="line">All System Administrators should attend. # 这一行无法修改</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '$!N;</div><div class="line">s/System\nAdministrator/Desktop\nUser/</div><div class="line">s/System Administrator/Desktop User/</div><div class="line">' data4.txt</div><div class="line">On Tuesday, the Linux Desktop</div><div class="line">User's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div></pre></td></tr></table></figure>
<p>这个例子演示了如何配合使用感叹号与N命令以及与美元符特殊地址。美元符表示数据流中的最后一行文本，所以当sed编辑器到了最后一行时，它没有执行N命令，但它对所有其他行都执行了这个命令。</p>
<p>利用这种方法，可以反转数据流中文本行的顺序。要实现这个效果（先显示最后一行，最后显示第一行），需要像如下顺序那样利用模式空间：</p>
<ol style="list-style-type: decimal">
<li>在模式空间中放置一行；</li>
<li>将模式空间中的行放到保持空间中；</li>
<li>在模式空间中放入下一行；</li>
<li>将保持空间附加到模式空间后；</li>
<li>将模式空间中的所有内容都放到保持空间中；</li>
<li>重复执行第3~5步，直到所有行都反序放到了保持空间中；</li>
<li>提取并打印行。</li>
</ol>
<p>这个顺序的示意图如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180513/Bj5caEliC8.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在使用这种方法时，如果不想在处理时打印行可以使用sed的-n命令行选项。下一步是决定如何将保持空间文本附加到模式空间文本后面。这可以用<code>G</code>命令完成。唯一的问题是你不想将保持空间附加到要处理的第一行文本后面。这可以用感叹号命令解决，即<code>1!G</code>。下一步是将新的模式空间（含有已反转的行）放到保持空间，使用<code>h</code>命令，将模式𡫊的整个数据流都反转了之后，打印结果，当到达数据流中的最后一行时，就已经得到了模式空间的整个数据流，打印结果需要用到<code>$p</code>命令，现在看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '&#123;1!G;h;$p&#125;' data2.txt</div><div class="line">This is the last line.</div><div class="line">This is the second data line.</div><div class="line">This is the first data line.</div><div class="line">This is the header line.</div></pre></td></tr></table></figure>
<p>Linux中也有反转文本的命令，就是<code>tac</code>，它就是<code>cat</code>反过来写。</p>
<h2 id="改变流">改变流</h2>
<p>通常，sed编辑器会从脚本的顶部开始，一直执行到脚本的结尾（D命令是个例外，它会强制sed编辑器返回到脚本的顶部，而不读取新的行）。sed编辑器提供了一个方法来改变命令脚本的执行流程，其结果与结构化编程类似。</p>
<h3 id="分支">分支</h3>
<p>sed编辑器可以基于地址、地址模式或地址区间排除一整块命令。这允许用户只对数据流中的特定 行执行一组命令。，分支（branch）命令<code>b</code>的格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address]b [label]</div></pre></td></tr></table></figure>
<p>address参数决定了哪些行的数据会触发分支命令。label参数定义了要中转到的位置，如下果没有label参数，跳转命令会跳转到脚本的结尾，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;2,3b;s/This is/Is this/;s/line./test?/&#125;' data2.txt</div><div class="line">Is this the header test?</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">Is this the last test?</div></pre></td></tr></table></figure>
<p>分支命令在数据流中的第2行和第3行处跳过了两个替换命令，也就是说，不在第2行与第3行进行替换，保持原样，此时没有加入label，因此就跳转到结尾。如果不不想直接跳到脚本的结尾，可以为分支命令定义一个要跳转到的标签。标签以冒号开始，最多可以是7个字符长度，格式为<code>:label2</code>，如果要指定标签，将它加到b命令后即可。使用标签允许你跳过地址匹配处的命令，但仍然执行脚本中的其他命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt </div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;/first/b jump1;s/This is the/No jump on/</div><div class="line">:jump1</div><div class="line">s/This is the/Jump here on/&#125;' data2.txt</div><div class="line"></div><div class="line">No jump on header line.</div><div class="line">Jump here on first data line.</div><div class="line">No jump on second data line.</div><div class="line">No jump on last line.</div></pre></td></tr></table></figure>
<p>跳转命令指定如果文本行中出现了first，程序应该跳到标签为jump1的脚本行，即<code>s/This is the/Jump here on/</code>进行执行，执行完后，再跳回原来的脚本行，即<code>s/This is the/No jump on</code>。如果这里的分支命令的模式没有匹配，sed编辑器就会继续执行脚本中的命令，包括分支标签后的命令（因此，所有的替换命令都会在不匹配分支模式的行上执行）。如果某行匹配了分支模式，sed编辑器就会跳转到带有分支标签的那行。因此，只有最后一个替换命令会执行。在这个例子中，就演示了跳转到sed脚本后面的标签上。也可以跳转到脚本中靠前面的标签上，这样就达到了循环的效果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "This, is, a, test, to, remove, commas."|sed -n '&#123;</div><div class="line"><span class="meta">&gt;</span> :start</div><div class="line"><span class="meta">&gt;</span> s/,//1p</div><div class="line"><span class="meta">&gt;</span> b start</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">This is, a, test, to, remove, commas.</div><div class="line">This is a, test, to, remove, commas.</div><div class="line">This is a test, to, remove, commas.</div><div class="line">This is a test to, remove, commas.</div><div class="line">This is a test to remove, commas.</div><div class="line">This is a test to remove commas.</div></pre></td></tr></table></figure>
<p>从结果来看，每一代运行，就删除了一个逗号，如果把命令写到一行，是这样的，即<code>sed -n '{:start s/,//1p b start }'</code>，其中<code>:start</code>是一个标签；<code>s/,//1p</code>表示，将第1行中的逗号删除，并显示第1行，s是替换，1p表示显示第1行。这个脚本有个问题：它永远不会结束。这就形成了一个无穷循环，不停地查找逗号，直到使用Ctrl+C组合键发送一个信号，手动停止这个脚本。要防止这个问题，可以为分支命令指定一个地址模式来查找。如果没有模式，跳转就应该结束，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "This, is, a, test, to, remove, commas."|sed -n '&#123;</div><div class="line">:start</div><div class="line">s/,//1p</div><div class="line">/,/b start</div><div class="line">&#125;'</div><div class="line">This is, a, test, to, remove, commas.</div><div class="line">This is a, test, to, remove, commas.</div><div class="line">This is a test, to, remove, commas.</div><div class="line">This is a test to, remove, commas.</div><div class="line">This is a test to remove, commas.</div><div class="line">This is a test to remove commas.</div></pre></td></tr></table></figure>
<p>现在分支命令只会在行中有逗号的情况下跳转。在最后一个逗号被删除后，分支命令不会再执行，脚本也就能正常停止了。</p>
<h3 id="测试">测试</h3>
<p>测试（test）命令（t）也可以用来改变sed编辑器脚本的执行流程。测试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转。如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令未能匹配指定的模式，测试命令就不会跳转。测试命令使用与分支命令相同的格式，即<code>[address]t [label]</code>。</p>
<p>跟分支命令一样，在没有指定标签的情况下，如果测试成功，sed会跳转到脚本的结尾。测试命令提供了对数据流中的文本执行基本的if-then语句的一个低成本办法。举个例子，如果已经做了一个替换，不需要再做另一个替换，那么测试命令能帮上忙，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt </div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;</div><div class="line">s/first/matched/</div><div class="line">t</div><div class="line">s/This is the/No mathch on/</div><div class="line">&#125;' data2.txt</div><div class="line">No mathch on header line.</div><div class="line">This is the matched data line.</div><div class="line">No mathch on second data line.</div><div class="line">No mathch on last line.</div></pre></td></tr></table></figure>
<p>第一个替换命令会查找模式文本first,如果匹配了行中的模式，它就会替换文本，也就是将first替换为matched，如果第一个替换命令未能匹配模式，第二个替换命令就会被执行。</p>
<p>有了测试命令，就能结束之前用分支命令形成的无限循环，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "This, is, a, test, to, remove, commas."|sed -n '&#123;</div><div class="line"><span class="meta">&gt;</span> :start</div><div class="line"><span class="meta">&gt;</span> s/,//1p</div><div class="line"><span class="meta">&gt;</span> t start</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">This is, a, test, to, remove, commas.</div><div class="line">This is a, test, to, remove, commas.</div><div class="line">This is a test, to, remove, commas.</div><div class="line">This is a test to, remove, commas.</div><div class="line">This is a test to remove, commas.</div><div class="line">This is a test to remove commas.</div></pre></td></tr></table></figure>
<p>当无需替换时，测试命令不会跳转而是继续执行剩下的脚本。</p>
<h2 id="模式替代">模式替代</h2>
<p>在使用通配符时，很难知道到底哪些文本会匹配模式。举个例子，如果想在行中匹配的单词两边上放上引号，只是要匹配模式中的一个单词的话，就比较简单，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "The cat sleeps in his hat."|sed 's/cat/"cat"/'</div><div class="line">The "cat" sleeps in his hat.</div></pre></td></tr></table></figure>
<p>如果要匹配多个单词，可能就会出问题了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"|sed 's/.at/".at"/g'</div><div class="line">The ".at" sleeps in his ".at".</div></pre></td></tr></table></figure>
<p>实际上，我想匹配的结果是<code>The &quot;cat&quot; sleeps in his &quot;hat&quot;.</code>这样的，但是使用了通配符后，把原来的字符串也给替换掉了，不符合预期。</p>
<h3 id="符号"><code>&amp;</code>符号</h3>
<p>为了解决上述问题，sed中有一个<code>&amp;</code>符号可以达到这个目的，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "The cat sleeps in his hat."|sed 's/.at/"&amp;"/g'</div><div class="line">The "cat" sleeps in his "hat".</div></pre></td></tr></table></figure>
<p>当模式匹配了单词<code>cat</code>，<code>&quot;cat&quot;</code>就会出现在了替换后的单词里。当它匹配了单词<code>hat</code>，<code>&quot;hat&quot;</code>就出现在了替换后的单词中。</p>
<h3 id="替代单独的单词">替代单独的单词</h3>
<p><code>&amp;</code>符号会提取匹配替换命令中指定模式的整个字符串。有时你只想提取这个字符串的一部分。当然可以这么做，只是要稍微花点心思而已。sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。sed编辑器会给第一个子模式分配字符<code>\1</code>，给第二个子模式分配字符<code>\2</code>，依此类推。当在替换命令中使用圆括号时，必须用转义字符将它们标示为分组字符而不是普通的圆括号。这跟转义其他特殊字符正好相反，看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "The System Administrator manual" | sed '</div><div class="line">s/\(System\) Administrator/\1 User/'</div><div class="line">The System User manual</div></pre></td></tr></table></figure>
<p>代码及结果解释：这个替换命令用一对圆括号将单词System括起来，将其标示为一个子模式。然后它在替代模式中使用来提取第一个匹配的子模式。这没什么特别的，但在处理通配符模式时却特别有用。如果需要用一个单词来替换一个短语，而这个单词刚好是该短语的子字符串，但那个子字符串碰巧使用了通配符，这时使用子模式会方便很多，再看两个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "That furry cat is pretty" |sed 's/furry \(.at\)/\1/'</div><div class="line">That cat is pretty</div><div class="line">biotest@ubuntu:~/advance_sed$ echo "That furry hat is pretty"|sed 's/furry \(.at\)/\1/'</div><div class="line">That hat is pretty</div></pre></td></tr></table></figure>
<p>代码及结果解释：<code>'s/furry \(.at\)/\1/'</code>表示，将原来文本中的<code>furry cat</code>替换为<code>cat</code>，<code>\1</code>是子模式1。</p>
<p>当需要在两个或多个子模式间插入文本时，这个特性尤其有用，在下面的这个案例中，使用子模式在大数字中插入逗号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "1233456" |sed '&#123;</div><div class="line"><span class="meta">&gt;</span> :start</div><div class="line"><span class="meta">&gt;</span> s/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/</div><div class="line"><span class="meta">&gt;</span> t start</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">1,233,456</div></pre></td></tr></table></figure>
<p>这段代码将匹配模式分成了2个部分，分别为<code>.*[0-9]</code>和<code>[0-9]{3}</code>。第一个子模式是以数字结尾的任意长度的字符。第二个子模式是若干组三位数字。如果这个模式在文本中找到了，替代文本会在两个子模式之间加一个逗号，每个子模式都会通过其位置来标示。这个脚本使用测试命令来遍历这个数字，直到放置好所有的逗号。</p>
<h2 id="在脚本中使用sed">在脚本中使用sed</h2>
<p>在shell脚本中也可以使用sed编辑器。</p>
<h3 id="使用包装脚本">使用包装脚本</h3>
<p>实现sed编辑器脚本的过程很烦琐，尤其是脚本很长的话。此时可以将sed编辑器命令放到shell包装脚本（wrapper）中，不用每次使用时都重新键入整个脚本。包装脚本充当着sed编辑器脚本和命令行之间的中间人角色。</p>
<p>在shell脚本中，可以将普通的shell变量及参数和sed编辑器脚本一起使用。下面有个将命令行参数变量作为sed脚本输入的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat reverse.sh #!/bin/bash</div><div class="line"><span class="meta">#</span> Shell wrapper for sed editor script.</div><div class="line"><span class="meta">#</span> to reverse text file lines.</div><div class="line"></div><div class="line">sed -n '&#123;1!G;h;$p&#125;' $1</div><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt </div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ bash ./reverse.sh data2.txt</div><div class="line">This is the last line.</div><div class="line">This is the second data line.</div><div class="line">This is the first data line.</div><div class="line">This is the header line.</div></pre></td></tr></table></figure>
<p>此时，就能在任何文件上轻松使用这个sed编辑器脚本，再不用每次都在命令行上重新输入了。</p>
<h3 id="重定向-sed-的输出">重定向 sed 的输出</h3>
<p>默认情况下，sed编辑器会将脚本的结果输出到STDOUT上。在shell脚本中，可以使用各种标准方法对sed编辑器的输出进行重定向。可以在脚本中用<code>$()</code>将sed编辑器命令的输出重定向到一个变量中，以备后用，在下面的例子中，就是使用sed脚本来向数值计算结果添加逗号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Add commas to number in factorial answer</div><div class="line"></div><div class="line">factorial=1</div><div class="line">counter=1</div><div class="line">number=$1</div><div class="line"></div><div class="line">while [ $counter -le $number ]</div><div class="line">do</div><div class="line">    factorial=$[ $factorial*$counter ]</div><div class="line">    counter=$[ $counter + 1 ]</div><div class="line">done</div><div class="line"></div><div class="line">result=$(echo $factorial | sed '&#123;</div><div class="line">:start</div><div class="line">s/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/</div><div class="line">t start</div><div class="line">&#125;')</div><div class="line"></div><div class="line">echo "The result is $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ bash ./fact.sh 20</div><div class="line">The result is 2,432,902,008,176,640,000</div></pre></td></tr></table></figure>
<p>在使用普通的阶乘计算脚本后，脚本的结果会被作为sed编辑器脚本的输入，它会给结果加上逗号。然后echo语句使用这个值产生最终结果。</p>
<h2 id="创建sed实用工具">创建sed实用工具</h2>
<h3 id="加倍行间距">加倍行间距</h3>
<p>下面是一个向文本文件的行间插入空白行的简单sed脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt </div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'G' data2.txt </div><div class="line">This is the header line.</div><div class="line"></div><div class="line">This is the first data line.</div><div class="line"></div><div class="line">This is the second data line.</div><div class="line"></div><div class="line">This is the last line.</div><div class="line">                        #这里有个空行</div></pre></td></tr></table></figure>
<p>G命令会简单地将保持空间内容附加到模式空间内容后。当启动sed编辑器时，保持空间只有一个空行。将它附加到已有行后面，你就在已有行后面创建了一个空白行。你可能已经注意到了，这个脚本在数据流的最后一行后面也加了一个空白行，使得文件的末尾也产生了一个空白行。如果你不想要这个空白行，可以用排除符号（!）和尾行符号（$）来确保脚本不会将空白行加到数据流的最后一行后面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed '$!G' data2.txt </div><div class="line">This is the header line.</div><div class="line"></div><div class="line">This is the first data line.</div><div class="line"></div><div class="line">This is the second data line.</div><div class="line"></div><div class="line">This is the last line.  # 这一行后面已经没有了空行</div></pre></td></tr></table></figure>
<p>代码解释：只要该行不是最后一行， G 命令就会附加保持空间内容。当sed编辑器到了最后一行时，它会跳过 G 命令。</p>
<h3 id="对可能含有空白行的文件加倍行间距">对可能含有空白行的文件加倍行间距</h3>
<p>再进一步探索上面的例子：如果文本文件已经有一些空白行，但你想给所有行加倍行间距要怎么办呢？如果用前面的脚本，有些区域会有两个餞行，因为每个已有的空白行也会被加倍，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data6.txt</div><div class="line">This is line one.</div><div class="line">This is line two.</div><div class="line"></div><div class="line">This is line three.</div><div class="line">This is line four.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '$!G' data6.txt</div><div class="line">This is line one.</div><div class="line"></div><div class="line">This is line two.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">This is line three.</div><div class="line"></div><div class="line">This is line four.</div></pre></td></tr></table></figure>
<p>原来空白行的位置有了三个空白行。这个问题的解决办法是，首先删除数据流中的所有空白行，然后用G命令在所有行后插入新的空白行。要删除已有的空白行，需要将d命令和一个匹配空白行的模式一起使用，即使用<code>/^$/d</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="给文件中的行编号">给文件中的行编号</h3>
<p>等号可以显示数据流中的数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '=' data2.txt</div><div class="line">1</div><div class="line">This is the header line.</div><div class="line">2</div><div class="line">This is the first data line.</div><div class="line">3</div><div class="line">This is the second data line.</div><div class="line">4</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>虽然添加了行号，但是不太美观，行号在文本的上方，比较好看的方式就是将等号与文本放在同一行。在获得了等号命令的输出之后，可以通过管道将输出传给另一个sed编辑器脚本，它会使用N命令来合并这两行。还需要用替换命令将换行符更换成空格或制表符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '=' data2.txt | sed 'N; s/\n/ /'</div><div class="line">1 This is the header line.</div><div class="line">2 This is the first data line.</div><div class="line">3 This is the second data line.</div><div class="line">4 This is the last line.</div></pre></td></tr></table></figure>
<p>在bash中，<code>nl</code>命令也可以添加行号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ nl data2.txt </div><div class="line">     1	This is the header line.</div><div class="line">     2	This is the first data line.</div><div class="line">     3	This is the second data line.</div><div class="line">     4	This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ cat -n data2.txt</div><div class="line">     1	This is the header line.</div><div class="line">     2	This is the first data line.</div><div class="line">     3	This is the second data line.</div><div class="line">     4	This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$</div></pre></td></tr></table></figure>
<p>通过<code>nl</code>添加行号时会在前面添加一个间隔。</p>
<h3 id="打印末尾行">打印末尾行</h3>
<p>美元符代表数据流中最后一行，所以只显示最后一行很容易，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '$p' data2.txt</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>如果要用美元符来显示数据流末尾的若干行，就需要创建滚动窗口。滚动窗口是检验模式空间中文本行块的常用方法，它使用N命令将这些块合并起来。N命令将下一行文本附加到模式空间中已有文本行后面。一旦你在模式空间有了一个10行的文本块，你可以用美元符来检查你是否已经处于数据流的尾部。如果不在，就继续向模式空间增加行，同时删除原来的行（记住，D命令会删除模式空间的第一行），如下所示：</p>
<p>通过循环N命令和D命令，在向模式空间的文本行块增加新行的同时也删除了旧行。分支命令非常适合这个循环。要结束循环，只要识别出最后一行并用q命令退出就可以了如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data7.txt</div><div class="line">This is line 1.</div><div class="line">This is line 2.</div><div class="line">This is line 3.</div><div class="line">This is line 4.</div><div class="line">This is line 5.</div><div class="line">This is line 6.</div><div class="line">This is line 7.</div><div class="line">This is line 8.</div><div class="line">This is line 9.</div><div class="line">This is line 10.</div><div class="line">This is line 11.</div><div class="line">This is line 12.</div><div class="line">This is line 13.</div><div class="line">This is line 14.</div><div class="line">This is line 15.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;</div><div class="line"><span class="meta">&gt;</span> :start</div><div class="line"><span class="meta">&gt;</span> $q;N;11,$D</div><div class="line"><span class="meta">&gt;</span> b start</div><div class="line"><span class="meta">&gt;</span> &#125;' data7.txt</div><div class="line">This is line 6.</div><div class="line">This is line 7.</div><div class="line">This is line 8.</div><div class="line">This is line 9.</div><div class="line">This is line 10.</div><div class="line">This is line 11.</div><div class="line">This is line 12.</div><div class="line">This is line 13.</div><div class="line">This is line 14.</div><div class="line">This is line 15.</div></pre></td></tr></table></figure>
<p>这个脚本会首先检查这行是不是数据流中最后一行。如果是，退出（quit）命令会停止循环。N命令会将下一行附加到模式空间中当前行之后。如果当前行在第10行后面，11,$D命令会删除模式空间中的第一行。这就会在模式空间中创建出滑动窗口效果。因此，这个sed程序脚本只会显示出data7.txt文件最后10行。</p>
<h3 id="删除行">删除行</h3>
<h4 id="删除连续的空白行">删除连续的空白行</h4>
<p>删除连续空白行的最简单办法是用地址区间来检查数据流。通过在地址中使用区间，sed编辑器会对所有匹配指定地址区间的行执行该命令。删除连续空白行的关键在于创建包含一个非空白行和一个空白行的地址区间。如果sed编辑器遇到了这个区间，它不会删除行。但对于不匹配这个区间的行（两个或更多的空白行），它会删除这些行，使用的主要代码是<code>/./,/^$/!d</code>，这段代码的的模式是<code>/./</code>到<code>/^$/</code>，这个区间的开始地址会匹配任何含有至少一个字符的行，区间的结束地址会匹配一个窄，在这个区间内的行不会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>结果显示，无论文件的数据行之间出现了多少空白行，在输出中只会在行间保留一个空白行。</p>
<h4 id="删除开头的空白行">删除开头的空白行</h4>
<p>主要的脚本是<code>/./,$!d</code>，这个脚本用地址区间来决定哪些行需要删掉，这个区间从含有字符的行开始，一直到数据流结束，在这个区间内的任何行都不会从输出中删除，这表明，含有字符的第一行之前的任何行都会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data9.txt </div><div class="line"></div><div class="line"></div><div class="line">This is line one.</div><div class="line"></div><div class="line">This is line two.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/./,$!d' data9.txt </div><div class="line">This is line one.</div><div class="line"></div><div class="line">This is line two.</div></pre></td></tr></table></figure>
<p>测试文件在数据行之前有两个空白行。这个脚本成功地删除了开头的两个空白行，保留了数据中的空白行。</p>
<h4 id="删除结尾的空白行">删除结尾的空白行</h4>
<p>删除结尾的空白行主要是通过循环来实验，脚本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed '&#123;</div><div class="line">:start</div><div class="line">/^\n*$/&#123;$d;N; b start &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure>
<p>在正常脚本的花括号里还有花括号。这允许你在整个命令脚本中将一些命令分组。该命令组会被应用在指定的地址模式上。地址模式能够匹配只含有一个换行符的行。如果找到了这样的行，而且还是最后一行，删除命令会删掉它。如果不是最后一行，N命令会将下一行附加到它后面，分支命令会跳到循环起始位置重新开始，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data10.txt </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;</div><div class="line">:start</div><div class="line">/^\n*$/&#123;$d; N; b start &#125;</div><div class="line">&#125;' data10.txt</div><div class="line">This is the first line.</div><div class="line">This is the second line.</div></pre></td></tr></table></figure>
<h3 id="删除-html-标签">删除 HTML 标签</h3>
<p>标准的HTML Web页面包含一些不同类型的HTML标签，标明了正确显示页面信息所需要的格式化功能，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data11.txt</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;This is the page title&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;</div><div class="line">This is the &lt;b&gt;first&lt;/b&gt; line in the Web page.</div><div class="line">This should provide some &lt;i&gt;useful&lt;/i&gt;</div><div class="line">information to use in our sed script.</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>HTML标签由小于号和大于号来识别。大多数HTML标签都是成对出现的：一个起始标签（比如<code>&lt;b&gt;</code>用来加粗），以及另一个结束标签（比如<code>&lt;/b&gt;</code>用来结束加粗）。但如果不够小心的话，删除HTML标签可能会带来问题，因为按照常规思路，用户可能认为删除HTML标签的办法就是查找以小于号（<code>&lt;</code>）开头、大于号（<code>&gt;</code>）结尾且其中有数据的文本字符串，即<code>s/&lt;.*.//g</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 's/&lt;.*&gt;//g' data11.txt</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">This is the  line in the Web page.</div><div class="line">This should provide some </div><div class="line">information to use in our sed script.</div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$</div></pre></td></tr></table></figure>
<p>从结果来看，标题文本以及加粗和倾斜的文本都不见了。sed编辑器将这个脚本理解为小于号和大于号之间的任何文本，且包括其他的小于号和大于号。每次文本出现在HTML标签中（比如<code>&lt;b&gt;first&lt;/b&gt;</code>），这个sed脚本都会删掉整个文本。这个问题的解决办法是让sed编辑器忽略掉任何嵌入到原始标签中的大于号。要这么做的话，你可以创建一个字符组来排除大于号。脚本改为如下所示代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 's/&lt;[^&gt;]*&gt;//g' data11.txt</div><div class="line"></div><div class="line"></div><div class="line">This is the page title</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">This is the first line in the Web page.</div><div class="line">This should provide some useful</div><div class="line">information to use in our sed script.</div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$</div></pre></td></tr></table></figure>
<p>现在就能正常删除了，此外，还可以添加一条删除多余空白行的命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 's/&lt;[^&gt;]*&gt;//g; /^$/d'  data11.txt</div><div class="line">This is the page title</div><div class="line">This is the first line in the Web page.</div><div class="line">This should provide some useful</div><div class="line">information to use in our sed script.</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/09/Linux-shell09-正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/Linux-shell09-正则表达式/" itemprop="url">Shell学习笔记（9）——正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T12:12:54+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,861
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  37
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="正则表达式定义">正则表达式定义</h2>
<h3 id="定义">定义</h3>
<p>正则表达式是你所定义的模式模板（pattern template），Linux工具可以用它来过滤文本。Linux工具（比如sed编辑器或gawk程序）能够在处理数据时使用正则表达式对数据进行模式匹配。如果数据匹配模式，它就会被接受并进一步处理；如果数据不匹配模式，它就会被滤掉。下图描述了这个过程。</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180509/gJmc5KFHBB.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>正则表达式模式利用通配符来描述数据流中的一个或多个字符。Linux中有很多场景都可以使用通配符来描述不确定的数据。星号通配符允许你只列出满足特定条件的文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ ls data*</div><div class="line">data10.cpp  data1b.txt  data3.txt</div><div class="line">data11.txt  data1.txt   data4.txt</div><div class="line">data12.txt  data2.txt   data9.txt</div></pre></td></tr></table></figure>
<p><code>data*</code> 参数会让 ls 命令只列出名字以da开头的文件。文件名中da之后可以有任意多个字符（包括什么也没有）。</p>
<p>正则表达式通配符模式的工作原理与之类似。正则表达式模式含有文本或特殊字符，为sed编辑器和gawk程序定义了一个匹配数据时采用的模板。可以在正则表达式中使用不同的特殊字符来定义特定的数据过滤模式。</p>
<h3 id="类型">类型</h3>
<p>使用正则表达式最大的问题在于有不止一种类型的正则表达式。Linux中的不同应用程序可能会用不同类型的正则表达式。这其中包括编程语言（Java、Perl和Python）、Linux实用工具（比如sed编辑器、gawk程序和grep工具）以及主流应用（比如MySQL和PostgreSQL数据库服务器）。正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。在Linux中，有两种流行的正则表达式引擎：</p>
<p>第一，POSIX基础正则表达式（basic regular expression，BRE）引擎；</p>
<p>第二，POSIX扩展正则表达式（extended regular expression，ERE）引擎</p>
<p>大多数Linux工具都至少符合POSIXBRE引擎规范，能够识别该规范定义的所有模式符号。遗憾的是，有些工具（比如sed编辑器）只符合了BRE引擎规范的子集。这是出于速度方面的考虑导致的，因为sed编辑器希望能尽可能快地处理数据流中的文本。POSIXBRE引擎通常出现在依赖正则表达式进行文本过滤的编程语言中。它为常见模式提供了高级模式符号和特殊符号，比如匹配数字、单词以及按字母排序的字符。gawk程序用ERE引擎来处理它的正则表达式模式。</p>
<h2 id="定义bre模式">定义BRE模式</h2>
<p>最基本的BRE模式是匹配数据流中的文本字符。</p>
<h3 id="纯文本">纯文本</h3>
<p>下面演示一下如何在sed编辑器和gawk程序中用标准文本字符串来过滤数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/test/p'</div><div class="line">This is a test</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/trial/p'</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|gawk '/test/&#123;print $0&#125;'</div><div class="line">This is a test</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|gawk '/trial/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>第一个模式定义了一个单词test。sed编辑器和gawk程序脚本用它们各自的print命令打印出匹配该正则表达式模式的所有行。由于echo语句在文本字符串中包含了单词test，数据流文本能够匹配所定义的正则表达式模式，因此sed编辑器显示了该行。</p>
<p>第二个模式也定义了一个单词，这次是trial。因为echo语句文本字符串没包含该单词，所以正则表达式模式没有匹配，因此sed编辑器和gawk程序都没打印该行。你可能注意到了，正则表达式并不关心模式在数据流中的位置。它也不关心模式出现了多少次。一旦正则表达式匹配了文本字符串中任意位置上的模式，它就会将该字符串传回Linux工具。关键在于将正则表达式模式匹配到数据流文本上。重要的是记住正则表达式对匹配的模式非常挑剔。第一条原则就是：正则表达式模式都区分大小写。这意味着它们只会匹配大小写也相符的模式。</p>
<h4 id="正则表达式区分大小写">正则表达式区分大小写</h4>
<p>看个例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/this/p'</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/This/p'</div><div class="line">This is a test</div></pre></td></tr></table></figure>
<p>第一次尝试没能匹配成功，因为 this 在字符串中并不都是小写，而第二次尝试在模式中使用大写字母，所以能正常工作。 在正则表达式中，你不用写出整个单词。只要定义的文本出现在数据流中，正则表达式就能够匹配，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "The books are expensive"|sed -n '/book/p'</div><div class="line">The books are expensive</div></pre></td></tr></table></figure>
<p>尽管数据流中的文本是books，但数据中含有正则表达式book，因此正则表达式模式跟数据匹配。当然，反之正则表达式就不成立了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "The book is expensive"|sed -n '/books/p'</div><div class="line"><span class="meta">#</span> 完整的正则表达式文本并未在数据流中出现，因此匹配失败，sed编辑器不会显示任何文本。</div></pre></td></tr></table></figure>
<p>可以在正则表达式中使用空格和数字，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is line number 1"|sed -n '/ber 1/p'</div><div class="line">This is line number 1</div><div class="line"><span class="meta">#</span> 空格也能匹配</div></pre></td></tr></table></figure>
<p>在正则表达式中，空格和其他的字符并没有什么区别，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is line number1"|sed -n '/ber 1/p'</div><div class="line">biotest@ubuntu:~/regx$ </div><div class="line"><span class="meta">#</span> number1之间没有空格，/ber 1/p就无法匹配，因此也不显示</div></pre></td></tr></table></figure>
<p>如果你在正则表达式中定义了空格，那么它必须出现在数据流中。甚至可以创建匹配多个连续空格的正则表达式模式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data1.txt </div><div class="line">This is a normal line of text.</div><div class="line">This is  a line with too many spaces.</div><div class="line">biotest@ubuntu:~/regx$ sed -n '/  /p' data1.txt </div><div class="line">This is  a line with too many spaces.</div><div class="line"><span class="meta">#</span> This  is这之间有两个空格</div></pre></td></tr></table></figure>
<h3 id="特殊字符">特殊字符</h3>
<p>正则表达式识别的特殊字符包括： <code>.*[]^${}\+?|()</code>，在文本模式中不要单独使用这些字符，如果要用某个特殊字符作为文本字符，就必须转义，在转义特殊字符时，你需要在它前面加一个反斜线（），如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data2.txt </div><div class="line">The cost is $4.00</div><div class="line">biotest@ubuntu:~/regx$ sed -n '/\$/p' data2.txt </div><div class="line">The cost is $4.00</div><div class="line"><span class="meta">#</span> 这里添加了反斜线对美元符号进行转义</div></pre></td></tr></table></figure>
<p>如果要匹配反斜线，需要用反斜线本身对基进行转义，也就是两个反斜线，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "\ is a special character" |sed -n '/\\/p'</div><div class="line">\ is a special character</div><div class="line"><span class="meta">#</span> 在这个案例中，匹配的是\，因此需要需要一个/来进行匹配，就成了//</div></pre></td></tr></table></figure>
<p>需要注意的是，虽然<code>/</code>不是正则表达式的特殊字符，但是也也需要<code>\</code>进行匹配，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "3/2"|sed -n '/\//p'</div><div class="line">3/2</div><div class="line"><span class="meta">#</span> 匹配模式就是/文本/命令；这里的文本就是/，添加上转义字符就是\/，整体来看就是/\//p。</div></pre></td></tr></table></figure>
<h3 id="锚字符">锚字符</h3>
<p>当指定一个正则表达式模式时，只要模式出现在数据流中的任何地方，它就能匹配。有两个特殊字符可以用来将模式锁定在数据流中的行首或行尾。</p>
<h4 id="锁定在行首">锁定在行首</h4>
<p>脱字符（<code>^</code>）定义从数据流中文本行的行首开始的模式。如果模式出现在行首之外的位置，正则表达式模式则无法匹配，如果要使用脱字符，就必须将它放到正则表达式中指定的模式前面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "The book store"|sed -n '/^book/p'</div><div class="line"><span class="meta">#</span> book不是首个单词，加了帽子的book无法匹配</div><div class="line">biotest@ubuntu:~/regx$ echo "Books are great"|sed -n '/^Book/p'</div><div class="line">Books are great</div><div class="line"><span class="meta">#</span> Books是首个单词，加了帽子的Books能够匹配</div></pre></td></tr></table></figure>
<p>脱字符会在每个由换行符决定的新数据行的行首检查模式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data3.txt </div><div class="line">This is a test line.</div><div class="line">this is another test line.</div><div class="line">A line that tests this feature.</div><div class="line">Yet more testing of this</div><div class="line">biotest@ubuntu:~/regx$ sed -n '/^this/p' data3.txt</div><div class="line">this is another test line.</div><div class="line"><span class="meta">#</span> 只要模式出现在新行的行首，脱字符就能够发现它。</div></pre></td></tr></table></figure>
<p>如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This ^ is a test"|sed -n '/This ^/p'</div><div class="line">This ^ is a test</div><div class="line"><span class="meta">#</span> 这里匹配的是This ^，这里不用转义</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ echo "This ^is a test"|sed -n '/\^is/p'</div><div class="line">This ^is a test</div><div class="line"><span class="meta">#</span> 这里匹配的是^is，由于^后面有字符，因此需要转义，如果不转义，匹配时会认为是只匹配首个单词</div></pre></td></tr></table></figure>
<p>需要注意的是，如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。但如果你在模式中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符。</p>
<h4 id="锁定在行尾">锁定在行尾</h4>
<p>特殊字符美元符（<code>$</code>）定义了行尾锚点。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is a good book"|sed -n '/book$/p'</div><div class="line">This is a good book</div><div class="line">biotest@ubuntu:~/regx$ echo "This book is good"|sed -n '/book$/p'</div><div class="line">biotest@ubuntu:~/regx$ echo "There are a lot of good books"|sed -n '/book$/p'</div><div class="line"><span class="meta">#</span> 无法完成匹配，因为原文本是books，而美元符号前面是book,可以理解为，原文本最后两个是ks，而美元符号是ok，肯定不能匹配了</div></pre></td></tr></table></figure>
<h4 id="组合锚点">组合锚点</h4>
<p>在一些常见情况下，可以在同一行中将行首锚点和行尾锚点组合在一起使用。在第一种情况中，假定你要查找只含有特定文本模式的数据行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data4.txt </div><div class="line">this is a test of using both anchors</div><div class="line">I said this is a test</div><div class="line">this is a test</div><div class="line">I'm sure this is a test.</div><div class="line">biotest@ubuntu:~/regx$ sed -n '/^this is a test$/p' data4.txt</div><div class="line">this is a test</div><div class="line"><span class="meta">#</span> sed编辑器忽略了那些不单单包含指定的文本的行，例如I said this is a test</div></pre></td></tr></table></figure>
<p>将两个锚点直接组合在一起，之间不加任何文本，这样过滤出数据流中的空白行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data5.txt </div><div class="line">No.1 This is one test line.</div><div class="line"></div><div class="line"></div><div class="line">No.2 This is another test line.</div><div class="line"></div><div class="line">No.3 This third test line.</div><div class="line">biotest@ubuntu:~/regx$ sed '/^$/d' data5.txt</div><div class="line">No.1 This is one test line.</div><div class="line">No.2 This is another test line.</div><div class="line">No.3 This third test line.</div><div class="line"><span class="meta">#</span> 定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行</div></pre></td></tr></table></figure>
<p>定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行。由于空白行在两个换行符之间没有文本，刚好匹配了正则表达式模式。sed编辑器用删除命令d来删除匹配该正则表达式模式的行，因此删除了文本中的所有空白行。这是从文档中删除空白行的有效方法。</p>
<h3 id="点号字符">点号字符</h3>
<p>特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。来看一些在正则表达式模式中使用点号字符的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data6.txt </div><div class="line">This is a test of a line.</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line">at ten o'clock we'll go home.:wq</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/.at/p' data6.txt </div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line"><span class="meta">#</span> 在第四行中，at前面有一个空格，这也是一个字符，因此能够匹配。</div></pre></td></tr></table></figure>
<h3 id="字符组">字符组</h3>
<p>如果要限定待匹配的具体字符的话，在正则表达式中，这称为字符组（characterclass）。可以定义用来匹配文本模式中某个位置的一组字符。如果字符组中的某个字符出现在了数据流中，那它就匹配了该模式。使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符。然后你可以在模式中使用整个组，就跟使用其他通配符一样，看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sed -n '/[ch]at/p' data6.txt</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div></pre></td></tr></table></figure>
<p>匹配这个模式的单词只有 cat 和 hat 。还要注意以 at 开头的行也没有匹配。字符组中必须有个字符来匹配相应的位置。</p>
<h4 id="不区分大小写">不区分大小写</h4>
<p>有时候这种方法在不清楚大小写的时候很有用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "Yes" | sed -n '/[Yy]es/p'</div><div class="line">Yes</div><div class="line">biotest@ubuntu:~/regx$ echo "yes"|sed -n '/[Yy]es/p'</div><div class="line">yes</div><div class="line">biotest@ubuntu:~/regx$ echo "Yes"|sed -n '/[Yy][Ee][Ss]/p'</div><div class="line">Yes</div><div class="line">biotest@ubuntu:~/regx$ echo "yEs"|sed -n '/[Yy][Ee][Ss]/p'</div><div class="line">yEs</div><div class="line">biotest@ubuntu:~/regx$ echo "yeS"|sed -n '/[Yy][Ee][Ss]/p'</div><div class="line">yeS</div></pre></td></tr></table></figure>
<h4 id="使用数字">使用数字</h4>
<p>字符组不必只含有字母，也可以在其中使用数字，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data6.txt</div><div class="line">This is a test of a line.</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line">at ten o'clock we'll go home.:wq</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/[0123]/p' data7.txt </div><div class="line">THis line has 1 number on it.</div><div class="line">THis line a number 2 on it.</div><div class="line"><span class="meta">#</span> 这个正则表达式模式匹配了任意含有数字0、1、2或3的行。含有其他数字以及不含有数字的行都会被忽略掉。</div></pre></td></tr></table></figure>
<h4 id="匹配某一位数的数字">匹配某一位数的数字</h4>
<p>有时候需要将字级组组合在一起，以检查数字是否具备正确的格式，比如电话号码和邮编。但当你尝试匹配某种特定格式时，必须小心。这里有个匹配邮编出错的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data8.txt </div><div class="line">46201</div><div class="line">60633</div><div class="line">223001</div><div class="line">4353</div><div class="line">22203</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '</div><div class="line"><span class="meta">&gt;</span> /[0123456789][0123456789][0123456789][0123456789][0123456789]/p</div><div class="line"><span class="meta">&gt;</span> ' data8.txt</div><div class="line">46201</div><div class="line">60633</div><div class="line">223001</div><div class="line">22203</div></pre></td></tr></table></figure>
<p>从结果可以看出，它滤过了4353，因为正则表达式中定义了5个字符组，4位的4353只有4个数字，最后一个数字无法匹配，就滤过了。但是223001这个6位数也通过了。因此正则表达式模式可见于数据流中文本的任何位置，因此我们设定过滤5个数字时，4个数字肯定能滤过去，但是大于5个数字的也能通过，因此如果要确保只匹配五位数，就必须将匹配的字符和其他字符分开，要么用空格，要么像这个例子中这样，指明它们就在行首和行尾，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sed -n '</div><div class="line">/^[0123456789][0123456789][0123456789][0123456789][0123456789]$/p</div><div class="line">' data8.txt</div><div class="line">46201</div><div class="line">60633</div><div class="line">22203</div></pre></td></tr></table></figure>
<h4 id="检查拼写">检查拼写</h4>
<p>字符组的一个极其常见的用法是解析拼错的单词，比如用户表单输入的数据。你可以创建正则表达式来接受数据中常见的拼写错误，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data9.txt </div><div class="line">I need to have some maintenence done on my car.</div><div class="line">I'll pay that in a seperate invoice.</div><div class="line">After I pay for the maintenance my car will be as good as new.</div><div class="line">biotest@ubuntu:~/regx$ sed -n '</div><div class="line">/maint[ea]n[ae]nce/p</div><div class="line">/sep[ea]r[ea]te/p</div><div class="line">' data9.txt</div><div class="line">I need to have some maintenence done on my car.</div><div class="line">I'll pay that in a seperate invoice.</div><div class="line">After I pay for the maintenance my car will be as good as new.</div></pre></td></tr></table></figure>
<p>本例中的两个sed打印命令利用正则表达式字符组来帮助找到文本中拼错的单词maintenance和separate。同样的正则表达式模式也能匹配正确拼写的maintenance。</p>
<h3 id="排除型字符组">排除型字符组</h3>
<p>在正则表达式模式中，也可以反转字符组的作用。可以寻找组中没有的字符，而不是去寻找组中含有的字符。要这么做的话，只要在字符组的开头加个脱字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data6.txt </div><div class="line">This is a test of a line.</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line">at ten o'clock we'll go home.:wq</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/[^ch]at/p' data6.txt</div><div class="line">This test is at line four.</div></pre></td></tr></table></figure>
<p>通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at开头的行仍然未能匹配模式。</p>
<h3 id="区间">区间</h3>
<p>如果必须要在每个字符组中列出所有可能的数字，有点麻烦，单破折线符号在字符组中表示字符区间。只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了，正则表达式会包括此区间内的任意字符，可以通过指定数字区间来简化邮编的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data8.txt</div><div class="line">46201</div><div class="line">60633</div><div class="line">223001</div><div class="line">4353</div><div class="line">22203</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8.txt</div><div class="line">46201</div><div class="line">60633</div><div class="line">22203</div></pre></td></tr></table></figure>
<p>这样可是节省了不少的键盘输入，每个字符组都会匹配0~9的任意数字。</p>
<p>这种方法也适用于字母，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data6.txt</div><div class="line">This is a test of a line.</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line">at ten o'clock we'll go home.:wq</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/[c-h]at/p' data6.txt</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div></pre></td></tr></table></figure>
<p>新的模式[c-h]at匹配了首字母在字母c和字母h之间的单词。这种情况下，只含有单词at的行将无法匹配该模式。还可以在单个字符组指定多个不连续的区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sed -n '/[a-ch-m]at/p' data6.txtThe cat is sleeping.</div><div class="line">That is a very nice hat.</div></pre></td></tr></table></figure>
<p>该字符组允许区间a<sub>c、h</sub>m中的字母出现在at文本前，但不允许出现d~g的字母。</p>
<h3 id="特殊的字符组">特殊的字符组</h3>
<p>除了定义自己的字符组外，BRE还包含了一些特殊的字符组，可用来匹配特定类型的字符。下表是可用的BRE特殊的字符组。</p>
<table>
<thead>
<tr class="header">
<th>组</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[:alpha:]]</td>
<td>匹配任意字母字符，不管是大写还是小写</td>
</tr>
<tr class="even">
<td>[[:alnum:]]</td>
<td>匹配任意字母数字字符0~9、A</td>
</tr>
<tr class="odd">
<td>[[:blank:]]</td>
<td>匹配空格或制表符</td>
</tr>
<tr class="even">
<td>[[:digit:]]</td>
<td>匹配0~9之间的数字</td>
</tr>
<tr class="odd">
<td>[[:lower:]]</td>
<td>匹配小写字母字符a~z</td>
</tr>
<tr class="even">
<td>[[:print:]]</td>
<td>匹配任意可打印字符</td>
</tr>
<tr class="odd">
<td>[[:punct:]]</td>
<td>匹配标点符号</td>
</tr>
<tr class="even">
<td>[[:space:]]</td>
<td>匹配任意空白字符：空格、制表符、NL、FF、VT和CR</td>
</tr>
<tr class="odd">
<td>[[:upper:]]</td>
<td>匹配任意大写字母字符A~Z</td>
</tr>
</tbody>
</table>
<p>可以在正则表达式模式中将特殊字符组像普通字符组一样使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "abc"|sed -n '/[[:digit:]]/p'</div><div class="line">biotest@ubuntu:~/regx$ echo "abc"|sed -n '/[[:alpha:]]/p'</div><div class="line">abc</div><div class="line">biotest@ubuntu:~/regx$ echo "abc123"| sed -n '/[[:digit:]]/p'</div><div class="line">abc123</div><div class="line">biotest@ubuntu:~/regx$ echo "This is , a test"|sed -n '/[[:punct:]]/p'</div><div class="line">This is , a test</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/[[:punct:]]/p'</div></pre></td></tr></table></figure>
<p>使用特殊字符组可以很方便地定义区间。可以用<code>[[:digit:]]</code>来代替区间<code>[0-9]</code>。</p>
<h3 id="星号">星号</h3>
<p>在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "ik"|sed -n '/ie*k/p'</div><div class="line">ik</div><div class="line">biotest@ubuntu:~/regx$ echo "iek"|sed -n '/ie*k/p'</div><div class="line">iek</div><div class="line">biotest@ubuntu:~/regx$ echo "ieek"|sed -n '/ie*k/p'</div><div class="line">ieek</div><div class="line">biotest@ubuntu:~/regx$ echo "ieeek"|sed -n '/ie*k/p'</div><div class="line">ieeek</div></pre></td></tr></table></figure>
<p>这个模式符号广泛用于处理有常见拼写错误或在不同语言中有拼写变化的单词。举个例子，如果需要写个可能用在美式或英式英语中的脚本，可以这么写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "I'm getting a color TV"|sed -n '/colou*r/p'</div><div class="line">I'm getting a color TV</div><div class="line">biotest@ubuntu:~/regx$ echo "I'm getting a colour TV"|sed -n '/colou*r/p'</div><div class="line">I'm getting a colour TV</div></pre></td></tr></table></figure>
<p>模式中的 <code>u*</code> 表明字母u可能出现或不出现在匹配模式的文本中。类似地，如果你知道一个单 词经常被拼错，你可以用星号来允许这种错误，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "I ate a potatoe with my lunch."|sed -n '/potatoe*/p'</div><div class="line">I ate a potatoe with my lunch.</div><div class="line">biotest@ubuntu:~/regx$ echo "I ate a potato with my lunch."|sed -n '/potatoe*/p'</div><div class="line">I ate a potato with my lunch.</div></pre></td></tr></table></figure>
<p>在可能出现的额外字母后面放个星号将允许接受拼错的单词。另一个方便的特性是将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "this is a regular pattern expression"|sed -n '</div><div class="line"><span class="meta">&gt;</span> /regular.*expression/p'</div><div class="line">this is a regular pattern expression</div></pre></td></tr></table></figure>
<p>可以使用这个模式轻松查找可能出现在数据流中文本行内任意位置的多个单词。星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|sed -n '/b[ae]*t/p'</div><div class="line">bt</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|sed -n '/b[ae]*t/p'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|sed -n '/b[ae]*t/p'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "btt"|sed -n '/b[ae]*t/p'</div><div class="line">btt</div><div class="line">biotest@ubuntu:~/regx$ echo "baat"|sed -n '/b[ae]*t/p'</div><div class="line">baat</div><div class="line">biotest@ubuntu:~/regx$ echo "baaeeet"|sed -n '/b[ae]*t/p'</div><div class="line">baaeeet</div></pre></td></tr></table></figure>
<p>只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。</p>
<h2 id="正则表达式扩展">正则表达式扩展</h2>
<p>POSIX ERE模式包括了一些可供Linux应用和工具使用的额外符号。gawk程序能够识别ERE模式，但sed编辑器不能。 记住，sed编辑器和gawk程序的正则表达式引擎之间是有区别的。gawk程序可以使用大多数扩展正则表达式模式符号，并且能提供一些额外过滤功能，而这些功能都是sed编辑器所不具备的。但正因为如此，gawk程序在处理数据流时通常才比较慢。</p>
<h3 id="问号">问号</h3>
<p>问号类似于星号，不过有点细微的不同。问号表明前面的字符可以出现0次或1次，但只限于此。它不会匹配多次出现的字符。问号类似于星号，不过有点细微的不同。问号表明前面的字符可以出现0次或1次，但只限于此。它不会匹配多次出现的字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk '/be?t/&#123;print $p&#125;'</div><div class="line">bt</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk '/be?t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk '/be?t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "beeet"|gawk '/be?t/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 如果字符 e 并未在文本中出现，或者它只在文本中出现了1次，那么模式会匹配。</div></pre></td></tr></table></figure>
<p>问号与星号一样，也能与字符组一起使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">bt</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bot"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "baet"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "beat"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk '/b[ae]?t/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>如果字符组中的字符出现了0次或1次，模式匹配就成立。但如果两个字符都出现了，或者其中一个字符出现了2次，模式匹配就不成立。</p>
<h3 id="加号">加号</h3>
<p>加号表明前面的字符可以出现1次或多次，但必须至少出现1次。如果该字符没有出现，那么模式就不会匹配，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk '/be+t/&#123;print $0&#125;'</div><div class="line">beet</div><div class="line">biotest@ubuntu:~/regx$ echo "beeet"|gawk '/be+t/&#123;print $0&#125;'</div><div class="line">beeet</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk '/be+t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk '/be+t/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>如果字符e没有出现，模式匹配就不成立。加号同样适用于字符组，与星号和问号的使用方式相同，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beat"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">beat</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">beet</div><div class="line">biotest@ubuntu:~/regx$ echo "beeat"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">beeat</div></pre></td></tr></table></figure>
<p>这次如果字符组中定义的任一字符出现了，文本就会匹配指定的模式。</p>
<h3 id="花括号">花括号</h3>
<p>ERE中的花括号允许你为可重复的正则表达式指定一个上限。这通常称为间隔（interval）。可以用两种格式来指定区间，其中<code>m</code>是正则表达式出现m次；<code>m,n</code>表现表达式至少出现m次，最多出现n次。这个特性可以精确调整字符或字符集在模式中具体出现的次数。 ，gawk程序不会识别正则表达式间隔。必须指定gawk程序的<code>--re- interval</code>命令行选项才能识别正则表达式间隔，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk --re-interval '/be&#123;1&#125;t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk --re-interval '/be&#123;1&#125;t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk --re-interval '/be&#123;1&#125;t/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>通过指定间隔为1，限定了该字符在匹配模式的字符串中出现的次数。如果该字符出现多次，模式匹配就不成立。</p>
<p>可以同时指定下限和上限，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk --re-interval '/be&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk --re-interval '/be&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk --re-interval '/be&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">beet</div><div class="line">biotest@ubuntu:~/regx$ echo "beeet"|gawk --re-interval '/be&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 在这个例子中，字符 e 可以出现1次或2次，这样模式就能匹配；否则，模式无法匹配。</div></pre></td></tr></table></figure>
<p>间隔模式匹配同样适用于字符组，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beat"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">beat</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">beet</div><div class="line">biotest@ubuntu:~/regx$ echo "baeet"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "baeaet"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 如果字母a或e在文本模式中只出现了1~2次，则正则表达式模式匹配；否则，模式匹配失败。</div></pre></td></tr></table></figure>
<h3 id="管道符号">管道符号</h3>
<p>管道符号允许你在检查数据流时，用逻辑OR方式指定正则表达式引擎要用的两个或多个模式。如果任何一个模式匹配了数据流文本，文本就通过测试。如果没有模式匹配，则数据流文本匹配失败。使用管道符号的格式为<code>expr1|expr2</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "The cat is asleep"|gawk '/cat|dog/&#123;print $0&#125;'</div><div class="line">The cat is asleep</div><div class="line">biotest@ubuntu:~/regx$ echo "The dog is asleep"|gawk '/cat|dog/&#123;print $0&#125;'</div><div class="line">The dog is asleep</div><div class="line">biotest@ubuntu:~/regx$ echo "The sheep is asleep"|gawk '/cat|dog/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 这个例子会在数据流中查找正则表达式cat或dog。正则表达式和管道符号之间不能有空格，否则它们也会被认为是正则表达式模式的一部分。</div></pre></td></tr></table></figure>
<p>管道符号两侧的正则表达式可以采用任何正则表达式模式（包括字符组）来定义文本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "He has a hat."|gawk '/[ch]at|dog/&#123;print $0&#125;'</div><div class="line">He has a hat.</div><div class="line"><span class="meta">#</span> 这个例子会匹配数据流文本中的 cat 、 hat 或 dog 。</div></pre></td></tr></table></figure>
<h3 id="表达式分组">表达式分组</h3>
<p>正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一个标准字符。可以像对普通字符一样给该组使用特殊字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "Sat"|gawk '/Sat(urday)?/&#123;print $0&#125;'</div><div class="line">Sat</div><div class="line">biotest@ubuntu:~/regx$ echo "Saturday"|gawk '/Sat(urday)?/&#123;print $0&#125;'</div><div class="line">Saturday</div><div class="line"><span class="meta">#</span> 结尾的urday分组以及问号，使得模式能够匹配完整的 Saturday 或缩写 Sat 。</div></pre></td></tr></table></figure>
<p>将分组和管道符号一起使用来创建可能的模式匹配组是很常见的做法，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "cat"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">cat</div><div class="line">biotest@ubuntu:~/regx$ echo "cab"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">cab</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bab"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">bab</div><div class="line">biotest@ubuntu:~/regx$ echo "tab"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "tac"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 模式 (c|b)a(b|t) 会匹配第一组中字母的任意组合以及第二组中字母的任意组合。</div></pre></td></tr></table></figure>
<h2 id="正则表达式实战">正则表达式实战</h2>
<h3 id="第一案例目录文件计数">第一案例：目录文件计数</h3>
<p>目标：对<code>PATH</code>环境变量中定义的目录的可执行文件进行计数。</p>
<p>第一步：查看<code>PATH</code>中的目录名，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo $PATH</div><div class="line">/home/biotest/miniconda2/bin:/home/miniconda2/bin:/home/bio/miniconda2/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/biotest/home/test:/home/biotest/home/biotest:/home/biotest:/home/biotest/</div></pre></td></tr></table></figure>
<p>从结果可以看出，<code>PATH</code>中的每个路径都是由冒号分隔的，如果要获取目录列表，就需要用空格来替换冒号。</p>
<p>第二步：用空格替换冒号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 用空格替换冒号</div><div class="line">biotest@ubuntu:~/regx$ echo $PATH | sed 's/:/ /g'</div><div class="line">/home/biotest/miniconda2/bin /home/miniconda2/bin /home/bio/miniconda2/bin /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/games /usr/local/games /snap/bin /home/biotest/home/test /home/biotest/home/biotest /home/biotest /home/biotest/</div></pre></td></tr></table></figure>
<p>第三步：用<code>for</code>语句遍历每个目录，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mypath=$(echo $PATH |sed 's/:/ /g')</div><div class="line">for directory in $mypath </div><div class="line">do </div><div class="line">.# 代码先略过</div><div class="line">done</div></pre></td></tr></table></figure>
<p>第四步：一旦获得了单个目录，就可以用 ls 命令来列出每个目录中的文件，并用另一个 for 语句来遍历每个文件，为文件计数器增值。 这个脚本的最终版本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> count number of files in your PATH</div><div class="line">mypath=$(echo $PATH | sed 's/:/ /g')</div><div class="line">count=0</div><div class="line">for directory in $mypath</div><div class="line">do</div><div class="line">    check=$(ls $directory)</div><div class="line">    for item in $check</div><div class="line">    do</div><div class="line">        count=$[ $count+1 ]</div><div class="line">    done</div><div class="line">    echo "$directory - $count"</div><div class="line">    count=0</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sudo bash countfiles.sh </div><div class="line">/usr/local/sbin - 0</div><div class="line">/usr/local/bin - 2</div><div class="line">/usr/sbin - 200</div><div class="line">/usr/bin - 1744</div><div class="line">/sbin - 188</div><div class="line">/bin - 167</div><div class="line">ls: cannot access '/snap/bin': No such file or directory</div><div class="line">/snap/bin - 0</div></pre></td></tr></table></figure>
<h3 id="第二案例验证电话号码">第二案例：验证电话号码</h3>
<p>在这个案例中，使用的验证的美国的电话号码，美国的电话号码有这几种形式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(123)456-7890 </div><div class="line">(123) 456-7890 </div><div class="line">123-456-7890 </div><div class="line">123.456.7890</div></pre></td></tr></table></figure>
<p>这样用户在表单中输入的电话号码就有4种可能。</p>
<p>第一步：左括号。在构建正则表达式时，最好从左手边开始，然后构建用来匹配可能遇到的字符的模式。在这个例子中，电话号码中可能有也可能没有左圆括号。这可以用<code>^/(?</code>这个模式来匹配，脱字符用来表明数据的开始。由于左圆括号是个特殊字符，因此必须将它转义成普通字符。问号表明左圆括号可能出现，也可能不出现。</p>
<p>第二步：三个连续数字。紧接着就是3位区号。在美国，区号以数字2开始（没有以数字0或1开始的区号），最大可到9。要匹配区号，可以用<code>[2-9][0-9]{2}</code>进行匹配，这要求第一个字符是2~9的数字，后跟任意两位数字。</p>
<p>第三步：右括号。在区号后面，收尾的右圆括号可能存在，也可能不存在。，使用<code>\)?</code>进行匹配。</p>
<p>第四步：在区号后，存在如下可能：有一个空格，没有空格，有一条单破折线或一个点。你可以对它们使用管道符号，并用圆括号进行分组，匹配模式为<code>(| |-|\.)</code>，这表示第一个管道符号紧跟在左圆括号后，用来匹配没有空格的情形。你必须将点字符转义，否则它会被解释成可匹配任意字符。</p>
<p>第五步：匹配3位电话交换机号码，模式为<code>[0-9]{3}</code>。</p>
<p>第六步：在电话交换机号码之后，你必须匹配一个空格、一条单破折线或一个点（这次不用考虑匹配没有空格的情况，因为在电话交换机号码和其余号码间必须有至少一个空格）。，模式为<code>( |-|\.)</code>。</p>
<p>第七步：最后，必须在字符串尾部匹配4位本地电话分机号，匹配模式为`[0-9]{4}$。</p>
<p>完整的模式为<code>^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}$</code>。</p>
<p>在gawk程序中用这个正则表达式模式来过滤掉不符合格式的电话号码。现在只需要在gawk程序中创建一个使用该正则表达式的简单脚本，然后用这个脚本来过滤电话薄。记住，在gawk程序中使用正则表达式间隔时，必须使用–re-interval命令行选项，否则就没法得到正确的结果，代码如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> script to filter out bad phone numbers</div><div class="line">gawk --re-interval '/^\(?[2-9][0-9]&#123;2&#125;\)?(| |-|\.)[0-9]&#123;3&#125;( |-|\.)[0-9]&#123;4&#125;/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ chmod u+x isphone.sh </div><div class="line">biotest@ubuntu:~/regx$ sudo echo "317-555-1234" |./isphone.sh</div><div class="line">317-555-1234</div></pre></td></tr></table></figure>
<h3 id="第三案例-解析邮件地址">第三案例： 解析邮件地址</h3>
<p>电子邮件的基本格式为<code>username$hostname</code>，除此之外，还有可能含有点号，单破折线，加号，下划线等。而邮件的地址<code>hostname</code>部分是由一个或多个域名和一个服务器名组成。服务器名和域名也必须遵照严格的命名规则，只允许字母 数字字符以及点号或下划线组成。</p>
<p>第一步：顶级域名的数量在过去十分有限，正则表达式模式编写者会尝试将它们都加到验证模式中。然而遗憾的是，随着互联网的发展，可用的顶级域名也增多了。这种方法已经不再可行。从左侧开始构建这个正则表达式模式。我们知道，用户名中可以有多个有效字符。这个相当容易，匹配模式为<code>^([a-zA-Z0-9_\-\.\+]+)@</code>，这个匹配模式指定了用户名中允许的字符，加号表明必须有至少一个字符，最后一个字符是<code>@</code>。</p>
<p>第二步：hostname 模式使用同样的方法来匹配服务器名和子域名，即<code>([a-zA-Z0-9_\-\.]+)</code>，这个模式可以匹配文本。</p>
<p>第三步：顶级域名。对于顶级域名，有一些特殊的规则。顶级域名只能是字母字符，必须不少于二个字符（国家或地区代码中使用），并且长度上不得超过五个字符。级级域名用的正则表达式模式为<code>\.([a-zA-Z]{2,5})$</code>。</p>
<p>整个匹配模式就是<code>^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\-\.]+)\.(a-zA-Z]{2,5})$</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> script to filter out bad mail</div><div class="line">gawk '/^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]&#123;2,5&#125;)$/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sudo echo "rich@here.now" | ./ismail.sh</div><div class="line">rich@here.now</div><div class="line">biotest@ubuntu:~/regx$ sudo echo "rich#here.now" | ./ismail.sh</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/08/生信-测序原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/生信-测序原理/" itemprop="url">二代测序原理笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T00:00:01+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物信息学/" itemprop="url" rel="index">
                    <span itemprop="name">生物信息学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,971
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽然我对二代测序的原理知道一些，但也仅限于知道一些而已，并没有一个十分清楚的理解，当时实验室买Illumina的测序仪时，参加过培训，但是时间过去太久了，当时也没有记笔记，现在网上找了一些资料，总结一下。</p>
<p>Illumina的测序芯片叫flowcell，长得如下所示：</p>
<p>flowcell的样子如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/6lbe0aG5a1.jpg?imageslim" alt="mark"> <img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/GdFGk20bmK.jpg?imageslim" alt="mark"></p>
<p>flowcell的构成为例： 1. 每个flowcell（中文意思是流动池）有8个泳道，一个泳道称为一个Lane（中文意思是通道），每条Lane上有两列，每列有多个有小格子，叫一个tile（中文意思是瓦片），平时我们如果自己建库，送公司测序的话，样品发如果比较多，通常就会直接买测序公司的一条lane，例如我们测了12个样本，在建库时，每个样本加上自己独有的index，送到测序公司，例如泛生子，直接告诉公司，我买一条测序仪上的一条lane就行了。</p>
<ol start="2" style="list-style-type: decimal">
<li>每一个flowcell上都有8条泳道，用于测序反应，可以添加试剂，洗脱等等。</li>
<li>tile是每一次测序荧光扫描的最小单位</li>
</ol>
<h2 id="建库">建库</h2>
<p>建库的流程如下图所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/dj9l6l81D3.png?imageslim" alt="mark"> 第一步：Sear Genomic DNA or begin with cDNA。这一步是将基因组打断为300~500bp的片段，采用的手段通常是超声波。</p>
<p>第二步：End Repair（Blunt ends）。由于打断后，DNA的片段的末端会呈现不平整的情况，因此需要用酶来补平，在这一步中，片段的末端都是平末端。</p>
<p>第三步：Add 3’ A Tail。完成补平以后，在3’端使用酶加上一个特异的碱基A。</p>
<p>第四步：Ligate Adapters。第三步中加A就是为了这一步加上adapter（接头），这个adapter分为两个部分，一部分是测序的时候所需的引物序列，另一部分是建库扩增的时候需要的引物序列，加接头的过程，以及加完接头的结构如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/E1Lmc67hKg.png?imageslim" alt="mark"> 从上图可以看到，接头的一边含有T，正好与第三步中加了A的片段连接。</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/3EEaA7jhe9.png?imageslim" alt="mark"> <img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/DhL9FliI48.png?imageslim" alt="mark"></p>
<p>第五步：Enrich/Linearize with PCR。这一步通过PCR扩增，使第四步中完成的接头扩增到足够的浓度。index也是在这一步加进去的，完成后的文库结构如下所示（网上找了好几个，不过都大同小异）： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/hI2fcJJ813.png?imageslim" alt="mark"></p>
<p>现在说明一下这个结构（有的文库是双index结构）：</p>
<ol style="list-style-type: decimal">
<li>两端是P5与P7片段，这两个片段与lane上的片段进行互补，与P5互补的的接头称为P5’，与P7互补的称为P7’；</li>
<li>Rd1 SP和Rd2 SP是测序的引物；</li>
<li>DNA Insert就是我们要测序的片段；</li>
<li>Index是用于区分不同样品的，通常是6个碱基，因为一条lane通常可以测多个样品，因此用Index将不同的样品区分开来。</li>
</ol>
<p>如果是双index结构的话，如下所示：<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/kLE8FH6IlJ.png?imageslim" alt="mark"></p>
<p>这里使用index1和index2是为了区别paired-end测序得到的双端reads。</p>
<h2 id="桥式pcr">桥式PCR</h2>
<p>建库以后，将这些文库加到flowcell中，再加入相应的测序试剂，就可以进行测序了，Illumina的测序原理主要是SBS。SBS指的是Sequencing by Synthesis，中文称为边测序连合成。</p>
<p>flowcell上随机分布了两种不同的序列，分别是P5’和P7，其中P5’与P5互补，P7序列与文库上的P7序列是一样的，当文库加入到flowcell时，先通过P5与flowcell上的P5’序列互补杂交，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/baj6lBcfe1.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时，开始PCR，从P5’端开始延伸，完成延伸，为了方便理解，我们将这条新生成的链称为A链，A链与flowcell结合的一端是P5’，另外一端是P7’，此时再用NaOH变性，解开双链，冲走文库片段，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/67bBm6HAjC.png?imageslim" alt="mark"> 因为A链的一端（P5’）在flowcell上，它不会被冲走，再加上flowcell上带有P7序列，A链的一端是能与P7序列互补的P7’序列，因此它能形成一个单链的拱形结构，如下图左图所示。此时再进行PCR，为了方便理解，我们称以A链为模板生成的链为B链，生成的这个B链一端是P7（就是flowcell上的那个序列），另外一端是P5，这就形成了一个双链的拱形结构，这个过程通常叫做桥式PCR，如下图右图所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/hH0FAcCHG0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>桥式PCR不会只进行一次，而是进行许多次，大量生成A链与B链。现在总结一下A链与B链的结构：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/giG54AcL2c.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在生成足够多的双链数目时（这个反应次数大概是35次），用NaOH水解掉双链，只剩下单链的A链与B链，如下图右图所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/l7JLlHjFEe.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>此时利用甲酰胺基嘧啶糖苷酶（Fpg）对8-氧鸟嘌呤糖苷（8-oxo-G）的选择性切断作用，选择性地将P5’与链的连接切断，留下与Flowcell上P7连接的链，也就是Forward strand。因为flowcell上的P5’的第4和第5位的C分别加入了一个-OH，形成的是一个8-oxo-G。在切除8-oxo-G的同时，游离的3’端被阻断，防止不必要的DNA延伸，如下图所示：<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/BDml30ic12.png?imageslim" alt="mark"></p>
<h2 id="测序">测序</h2>
<h3 id="边合成边测序">边合成边测序</h3>
<p>此时就可以进行测序了。首先测序引物（sequencing primer）结合到靠近P5的测序引物结合位点1（sequencing primer binding site 1）上，在系统中加入四种dNTP和DNA聚合酶。这里的dNTP有两个特点，第一，它是有荧光基团标记的， 每种碱基标记的荧光基团不一样。第二，它的3’末端连了一个叠氮基。这个叠氮基能够阻断后面的碱基与它相连，如下图所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/75f89CC0Jh.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>在聚合酶的作用下，与Forward strand相应位置碱基配对的dNTP就会结合到新合成的链上，而由于叠氮基的存在，后面的dNTP无法继续连接。这时用水将剩余的dNTP和酶给冲掉，对Flowcell进行扫描，扫描出来的荧光对应的碱基的配对碱基即是该链该位置的碱基。同时在这个Flowcell上有成千上万个cluster也在进行同样的反应，因此一个循环就能同时检测多个样本。这个循环完成后，加入化学试剂把叠氮基和标记的荧光基团切掉，进行下一个循环（碱基的连接、检测与切除）。如此重复直至所有链的碱基序列被检测出，也就是Forward read 序列。</p>
<h3 id="index1测序">index1测序</h3>
<p>当所有的循环结束后，read products 被洗掉，index1 primer与链上index primer1 结合位点杂交配对，进行index1的合成及检测，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/ai797E1Alf.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>index1测序完成后，洗脱测序产物，此时测序仪已经通过荧光得到了index1的序列。</p>
<h3 id="index2测序">index2测序</h3>
<p>Forward strand（B链）顶端的P5序列与Flowcell上的P5’杂交配对，进行index2测序。测序完成后洗脱产物，切掉P7，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/Ilgh9h9bi0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<h3 id="pe测序即对reverse-strand测序">PE测序（即对Reverse strand测序）</h3>
<p>洗脱index2后，以Flowcell上的P5’为引物，Forward strand为模板进行桥式扩增，得到双链，经变性，洗脱后，如下所示：<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/BBF9df06ae.png?imageslim" alt="mark"></p>
<p>接着的测序就与测B链的过程类似，readprimer2结合到靠近P7’的read primer binding site 2开始对Reverse strand的测 序。测序完成后即可得到Reverse read序列，如下所示：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/b0CKdaidjl.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p>未完待续。。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://blog.csdn.net/seallama/article/details/23446865" target="_blank" rel="external">1. 测序发展小结</a> <a href="https://www.illumina.com.cn/technology/next-generation-sequencing/paired-end-sequencing_assay.html" target="_blank" rel="external">2. 双端测序</a> <a href="https://blog.csdn.net/sixu_9days/article/details/78948914" target="_blank" rel="external">3. Illumina SBS测序详解</a> <a href="http://v.youku.com/v_show/id_XMTI1MjA5Mzg5Mg==.html?spm=a2h0k.8191407.0.0&amp;from=s1.8-1-1.2" target="_blank" rel="external">4. Illumina的SBS技术</a> <a href="https://zhuanlan.zhihu.com/p/20702684" target="_blank" rel="external">5. 孟浩巍.20160405 illumina 测序原理介绍</a> <a href="http://tucf-genomics.tufts.edu/home/faq" target="_blank" rel="external">6.建库流程</a> <a href="https://zhuanlan.zhihu.com/p/35278810" target="_blank" rel="external">7.测序之前篇： NGS测序中，接头是如何添加上的，以及如何去接头</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/06/Linux-shell08-sed与gawk(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/Linux-shell08-sed与gawk(1)/" itemprop="url">Shell学习笔记（8）——sed与gawk基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T12:12:54+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,874
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  41
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="sed与gawk的基本用法">sed与gawk的基本用法</h2>
<p>Linux系统中有两个常用的命令行编辑器，分别为<code>sed</code>和<code>gawk</code>。</p>
<h3 id="sed编辑器">sed编辑器</h3>
<p>sed编辑器被称作流编辑器（streameditor），和普通的交互式文本编辑器有所不同。在交互式文本编辑器中（比如vim），用户可以用键盘命令来交互式地插入、删除或替换数据中的文本。而流编辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。sed编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。可以简单地理解为，流编辑器像一种滤器，数据进入后，会以一定标准的格式出来，sed编辑器会执行下列操作：</p>
<ol style="list-style-type: decimal">
<li>一次从输入中读取一行数据。</li>
<li>根据所提供的编辑器命令匹配数据。</li>
<li>按照命令修改流中的数据。</li>
<li>将新的数据输出到STDOUT。</li>
</ol>
<p>在流编辑器将所有命令与一行数据匹配完毕后，它会读取下一行数据并重复这个过程。在流编辑器处理完流中的所有数据行后，它就会终止。由于命令是按顺序逐行给出的，sed编辑器只需对数据流进行一遍处理就可以完成编辑操作。</p>
<p>sed命令的格式如下为<code>sed options script file</code>，其中sed的选项如下所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-e script</td>
<td>在处理输入时，将script中指定的命令添加到已有的命令中</td>
</tr>
<tr class="even">
<td>-f file</td>
<td>在处理输入时，将file中指定的命令添加到已有的命令中</td>
</tr>
<tr class="odd">
<td>-n</td>
<td>不产生命令输出，使用print命令来完成输出</td>
</tr>
</tbody>
</table>
<p>script参数指定了应用于流数据上的单个命令。如果需要用多个命令，要么使用-e选项在命令行中指定，要么使用-f选项在单独的文件中指定。</p>
<h4 id="在命令行定义编辑器命令">在命令行定义编辑器命令</h4>
<p>默认情况下，sed编辑器会将指定的命令应用到STDIN输入流上。这样你可以直接将数据通过管道输入sed编辑器处理，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This is a test"|sed 's/test/big test/'</div><div class="line">This is a big test</div></pre></td></tr></table></figure>
<p>在这个例子中，sed编辑器使用了s命令。s命令会用斜线间指定的第二个文本字符串（这里是big test）来替换第一个文本字符串（test）模式。在本例中是big test替换了test。在运行这个例子时，结果应该立即就会显示出来，再看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dogs.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed 's/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>sed命令几乎瞬间就执行完并返回数据。在处理每行数据的同时，结果也显示出来了。可以在sed编辑器处理完整个文件之前就开始观察结果。需要注意的是，sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT，也可以发送到某个文件。如果你查看原来的文本文件，它仍然保留着原始数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/dog/cat/' data1.txt &gt; data1b.txt</div><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">biotest@ubuntu:~/sed$ cat data1b.txt</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h4 id="在命令行使用多个编辑器命令">在命令行使用多个编辑器命令</h4>
<p>要在sed命令行上执行多个命令时，只要用-e选项就可以了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -e 's/brown/green/;s/dog/cat/' data1.txt</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>两个命令都作用到文件中的每行数据上。命令之间必须用分号隔开，并且在命令末尾和分号之间不能有空格。如果不想用分号，也可以用bash shell中的次提示符来分隔命令。只要输入第一个单引号标示出sed程序脚本的起始（sed编辑器命令列表），bash会继续提示你输入更多命令，直到输入了标示结束的单引号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -e '</div><div class="line"><span class="meta">&gt;</span> s/brown/green/</div><div class="line"><span class="meta">&gt;</span> s/fox/elephant/</div><div class="line"><span class="meta">&gt;</span> s/dog/cat/' data1.txt</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h4 id="从文件中读取编辑器命令">从文件中读取编辑器命令</h4>
<p>如果有大量要处理的sed命令，那么将它们放进一个单独的文件中，可以在sed命令中用-f选项来指定文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script1.sed</div><div class="line">s/brown/green/</div><div class="line">s/fox/elephant/</div><div class="line">s/dog/cat/</div><div class="line">biotest@ubuntu:~/sed$ sed -f script1.sed data1.txt</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>在这种情况下，不用在每条命令后面放一个分号。sed编辑器知道每行都是一条单独的命令。跟在命令行输入命令一样，sed编辑器会从指定文件中读取命令，并将它们应用到数据文件中的每一行上。</p>
<h3 id="gawk-程序">gawk 程序</h3>
<p>gawk程序是另外的一个处理文本文件的工具，它是Unix原始awk程序的GUN版本，它能提供一个类编程环境来修改和重新组织文件中的数据。 gawk的强大之处在于程序脚本，用户可以写脚本来读取文本行的数据，然后处理并显示数据，创 建任何类型的输出报告。 Ubuntu本身并没有带gawk工具，需要自己安装，即<code>get apt install gawk</code>。在gawk编程语言中，用户可以做下面的事情：</p>
<ol style="list-style-type: decimal">
<li>定义变量来保存数据；</li>
<li>使用算术和字符串操作符来处理数据；</li>
<li>使用结构化编程概念（比如 if-then 语句和循环）来为数据处理增加处理逻辑；</li>
<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。</li>
</ol>
<p>gawk程序通常用来从大文本文件中提取数据元素，并将它们格式化成可读的报告。其中最常用的就是格式化日志文件。在日志文件中找出错误行会很难，gawk程序可以让用户从日志文件中过滤出需要的数据元素，然后将其格式化，使得重要的数据更易于阅读。</p>
<h4 id="gawk的用法">gawk的用法</h4>
<p>gawk的使用格式为<code>gawk options program file</code>，可用选项如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-F fs</td>
<td>指定行中划分数据字段的字段分隔符</td>
</tr>
<tr class="even">
<td>-f file</td>
<td>从指定的文件中读取程序</td>
</tr>
<tr class="odd">
<td>-v var=value</td>
<td>定义gawk程序中的一个变量及其默认值</td>
</tr>
<tr class="even">
<td>-mf N</td>
<td>指定要处理的数据文件中的最大字段数</td>
</tr>
<tr class="odd">
<td>-mr N</td>
<td>指定数据文件中的最大数据行数</td>
</tr>
<tr class="even">
<td>-W keyword</td>
<td>指定gawk的兼容模式或警告等级</td>
</tr>
</tbody>
</table>
<h4 id="从命令行读取程序脚本">从命令行读取程序脚本</h4>
<p>gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号（{}）中。如果你错误地使用了圆括号来包含gawk脚本，就会得到一条类似于下面的错误提示，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '(print "Hello World!"&#125;'</div><div class="line">gawk: cmd. line:1: (print "Hello World!"&#125;</div><div class="line">gawk: cmd. line:1:                     ^ syntax error</div></pre></td></tr></table></figure>
<p>由于gawk命令行假定脚本是单个文本字符串，必须将脚本放到单引号中。下面的例子在命令行上指定了一个简单的gawk程序脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;print "Hello World!"&#125;'</div><div class="line">Hello World!</div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>这个程序脚本定义了一个命令：print命令。这个命令会将文本打印到STDOUT。如果尝试运行这个命令，什么都不会发生。原因在于没有在命令行上指定文件名，所以gawk程序会从STDIN接收数据。在运行这个程序时，它会一直等待从STDIN输入的文本。如果输入一行文本并按下回车键，gawk会对这行文本运行一遍程序脚本。跟sed编辑器一样，gawk程序会针对数据流中的每行文本执行程序脚本。由于程序脚本被设为显示一行固定的文本字符串，因此不管在数据流中输入什么文本，都会得到同样的文本输出。</p>
<p>要终止这个gawk程序，你必须表明数据流已经结束了。bash shell提供了一个组合键来生成EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk程序并返回到命令行界面提示符下。</p>
<h4 id="使用数据字段变量">使用数据字段变量</h4>
<p>gawk的主要特性之一是其处理文本文件中数据的能力。它会自动给一行中的每个数据元素分配一个变量。默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段：</p>
<ol style="list-style-type: decimal">
<li><code>$0</code> 代表整个文本行；</li>
<li><code>$1</code> 代表文本行中的第1个数据字段；</li>
<li><code>$2</code> 代表文本行中的第2个数据字段；</li>
<li><code>$n</code> 代表文本行中的第n个数据字段。</li>
</ol>
<p>在文本行中，每个数据字段都是通过字段分隔符划分的。gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符）。在下面的例子中，gawk程序读取文本文件，只显示第1个数据字段的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data2.txt</div><div class="line">One line of test text.</div><div class="line">Two lines of test text.</div><div class="line">Three lines of test text.</div><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;print $1&#125;' data2.txt</div><div class="line">One</div><div class="line">Two</div><div class="line">Three</div></pre></td></tr></table></figure>
<p>该程序用$1字段变量来仅显示每行文本的第1个数据字段。如果你要读取采用了其他字段分隔符的文件，可以用-F选项指定，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk -F: '&#123;print $1&#125;' /etc/passwd</div><div class="line">root</div><div class="line">daemon</div><div class="line">bin</div><div class="line">sys</div><div class="line">sync</div><div class="line">games</div><div class="line">man</div><div class="line">lp</div><div class="line">mail</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个简短的程序显示了系统中密码文件的第1个数据字段。由于/<code>etc/passwd</code>文件用冒号来分隔数字字段，因而如果要划分开每个数据元素，则必须在gawk选项中将冒号指定为字段分隔符，其中<code>-F:</code>就是指定冒号为分隔符。</p>
<h4 id="在程序脚本中使用多个命令">在程序脚本中使用多个命令</h4>
<p>gawk编程语言允许多条命令组合成一个正常的程序。要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "My name is Zhang" |gawk '&#123;$4="Li";print $0&#125;'</div><div class="line">My name is Li</div></pre></td></tr></table></figure>
<p>第一条命令会给字段变量<code>$4</code>赋值。第二条命令会打印整个数据字段。注意，gawk程序在输出中已经将原文本中的第四个数据字段替换成了新值。也可以用次提示符一次一行地输入程序脚本命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> $4="Li"</div><div class="line"><span class="meta">&gt;</span> print $0&#125;'</div><div class="line">My name is Zhang</div><div class="line">My name is Li</div></pre></td></tr></table></figure>
<p>在用了表示起始的单引号后，bashs hell会使用次提示符来提示你输入更多数据。可以每次在每行加一条命令，直到输入了结尾的单引号。因为没有在命令行中指定文件名，gawk程序会从STDIN中获得数据。当运行这个程序的时候，它会等着读取来自STDIN的文本。要退出程序，只需按下Ctrl+D组合键来表明数据结束。</p>
<h4 id="从文件中读取程序">从文件中读取程序</h4>
<p>gawk编辑器允许将程序存储到文件中，然后再在命令行中引用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script2.gawk</div><div class="line">&#123;print $1 "'s home directory is " $6&#125;</div><div class="line">biotest@ubuntu:~/sed$ gawk -F: -f script2.gawk /etc/passwd</div><div class="line">root's home directory is /root</div><div class="line">daemon's home directory is /usr/sbin</div><div class="line">bin's home directory is /bin</div><div class="line">sys's home directory is /dev</div><div class="line">sync's home directory is /bin</div><div class="line">......</div></pre></td></tr></table></figure>
<p>在这个案例中，script2.gawk程序脚本会再次使用print命令打印/etc/passwd文件的主目录数据字段（字段变量<code>$6），以及userid数据字段（字段变量</code>$1`）。可以在程序文件中指定多条命令。要这么做的话，只要一条命令放一行即可，不需要用分号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script3.gawk </div><div class="line">&#123;</div><div class="line">text = "'s home directory is " # 变量未使用美元符号，需要注意</div><div class="line">print $1 text $6</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ gawk -F: -f script3.gawk /etc/passwd</div><div class="line">root's home directory is /root</div><div class="line">daemon's home directory is /usr/sbin</div><div class="line">bin's home directory is /bin</div><div class="line">sys's home directory is /dev</div><div class="line">sync's home directory is /bin</div></pre></td></tr></table></figure>
<p>script3.gawk程序脚本定义了一个变量来保存print命令中用到的文本字符串。注意，gawk程序在引用变量值时并未像shell脚本一样使用美元符。</p>
<h4 id="在处理数据前运行脚本">在处理数据前运行脚本</h4>
<p>gawk可以指定程序脚本何时运行。默认情况下，gawk会从输入中读取一行文本，然后针对该行的数据执行程序脚本。有时可能需要在处理数据前运行脚本，比如为报告创建标题。BEGIN关键字就是用来做这个的。它会强制gawk在读取数据前执行BEGIN关键字后指定的程序脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;print "Hello World!"&#125;'</div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>这次print命令会在读取数据前显示文本。但在它显示了文本后，它会快速退出，不等待任何数据。如果想使用正常的程序脚本中处理数据，必须用另一个脚本区域来定义程序，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;pirnt "The data3 File Contents:"&#125;</div><div class="line"><span class="meta">&gt;</span> &#123;print $0&#125;' data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div></pre></td></tr></table></figure>
<p>在gawk执行了BEGIN脚本后，它会用第二段脚本来处理文件数据。这么做时要小心，两段脚本仍然被认为是gawk命令行中的一个文本字符串。你需要相应地加上单引号。</p>
<h4 id="在处理数据后运行脚本">在处理数据后运行脚本</h4>
<p>与BEGIN关键字类似，END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;pirnt "The data3 File Contents:"&#125;</div><div class="line"><span class="meta">&gt;</span> &#123;print $0&#125;</div><div class="line"><span class="meta">&gt;</span> END &#123;print "End of FIle"&#125;' data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div><div class="line">End of FIle</div></pre></td></tr></table></figure>
<p>当gawk程序打印完文件内容后，它会执行END脚本中的命令。这是在处理完所有正常数据后给报告添加页脚的最佳方法。可以将所有这些内容放到一起组成一个脚本文件，用它从一个简单的数据文件中创建一份完整的报告，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script4.gawk </div><div class="line">BEGIN &#123;</div><div class="line">print "The latest list of users and shells"</div><div class="line">print " UserID \t Shell"</div><div class="line">print "-------- \t --------"</div><div class="line">FS=":"</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">print $1 "        \t " $7</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">print "This concludes the listing"</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~/sed$ gawk -f script4.gawk /etc/passwd</div><div class="line">The latest list of users and shells</div><div class="line"> UserID 	 Shell</div><div class="line">-------- 	 --------</div><div class="line">root        	 /bin/bash</div><div class="line">daemon        	 /usr/sbin/nologin</div><div class="line">bin        	 /usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>这个脚本用BEGIN脚本来为报告创建标题。它还定义了一个叫作FS的特殊变量。这是定义字段分隔符的另一种方法。这样就不用依靠脚本用户在命令行选项中定义字段分隔符了。BEGIN脚本创建了标题，程序脚本处理特定数据文件（<code>/etc/passwd）</code>中的信息，END脚本生成页脚。</p>
<h2 id="sed-编辑器基础">sed 编辑器基础</h2>
<h3 id="更多的替换选项">更多的替换选项</h3>
<p>s命令（substitute）用来在行中替换文本。这个命令还有另外一些选项。</p>
<h4 id="替换标记">替换标记</h4>
<p>先看一个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data4.txt </div><div class="line">This is a test of the test script.</div><div class="line">This is the second test of the test script.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/' data4.txt </div><div class="line">This is a trial of the test script.</div><div class="line">This is the second trial of the test script.</div></pre></td></tr></table></figure>
<p>替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记（substitution flag）。替换标记会在替换命令字符串之后设置，格式为<code>s/pattern/replacement/flags</code>，有4种可用的替换标记：</p>
<ol style="list-style-type: decimal">
<li>数字，表明新文本将替换第几处模式匹配的地方；</li>
<li>g ，表明新文本将会替换所有匹配的文本；</li>
<li>p ，表明原先行的内容要打印出来；</li>
<li>w file ，将替换的结果写到文件中。</li>
</ol>
<h5 id="数字替换标记">数字替换标记</h5>
<p>在第一类替换中，可以指定sed编辑器用新文本替换第几处模式匹配的地方，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/2' data4.txt </div><div class="line">This is a test of the trial script.</div><div class="line">This is the second test of the trial script.</div></pre></td></tr></table></figure>
<p>这个脚本运行的结果是：sed编辑器只替换每行中第2次出现的匹配模式。</p>
<h5 id="g替换标记">g替换标记</h5>
<p>g替换标记使你能替换文本中匹配模式所匹配的每处地方，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/g' data4.txt</div><div class="line">This is a trial of the trial script.</div><div class="line">This is the second trial of the trial script.</div></pre></td></tr></table></figure>
<p>如结果所示，使用了g替换标记后，文本中所有的地方都被替换了。</p>
<h5 id="p替换标记">p替换标记</h5>
<p>p替换标记会打印与替换命令中指定的模式匹配的行。这通常会和sed的-n选项一起使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test5.txt</div><div class="line">This is a test line.</div><div class="line">This is a different line.</div><div class="line">biotest@ubuntu:~/sed$ sed -n 's/test/trial/p' test5.txt</div><div class="line">This is a trial line.</div></pre></td></tr></table></figure>
<p>-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是只输出被替换命令修改过的行，第二行并没有被替换，也就不输出了。</p>
<h5 id="w替换标记">w替换标记</h5>
<p>w 替换标记会产生同样的输出，不过会将输出保存到指定文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/w test.txt' test5.txt </div><div class="line">This is a trial line.</div><div class="line">This is a different line.</div><div class="line">biotest@ubuntu:~/sed$ cat test.txt</div><div class="line">This is a trial line.</div></pre></td></tr></table></figure>
<p>sed编辑器的正常输出是在STDOUT中，而只有那些包含匹配模式的行才会保存在指定的输出文件中。</p>
<h4 id="替换字符">替换字符</h4>
<p>有时会在文本字符串中遇到一些不太方便在替换模式中使用的字符。Linux中一个常见的例子就是正斜线（/）。替换文件中的路径名会比较麻烦。比如想用C shell替换/etc/passwd文件中的bash shell，必须这么做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/csh</div><div class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</div><div class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</div><div class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>由于正斜线通常用作字符串分隔符，因而如果它出现在了模式文本中的话，必须用反斜线来转义。这通常会带来一些困惑和错误。 要解决这个问题，sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's!/bin/bash!/bin/csh!' /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/csh</div><div class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</div><div class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>在这个例子中，感叹号被用作字符串分隔符，这样路径名就更容易阅读和理解了。</p>
<h4 id="使用地址">使用地址</h4>
<p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（lineaddressing）。在sed编辑器中有两种形式的行寻址：第一，以数字形式表示区间；第二，用文本模式来过滤出行。两种形式都使用相同的格式来指定地址：</p>
<p><code>[address] command</code>或者是将特定地址的多个命令分组，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">address &#123;</div><div class="line">    command1</div><div class="line">    command2</div><div class="line">    command3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sed编辑器会将指定的每条命令作用到匹配指定地址的行上。本节将会演示如何在sed编辑器脚本中使用两种寻址方法。</p>
<h5 id="第一数字方式的行寻址">第一，数字方式的行寻址。</h5>
<p>当使用数字方式的行寻址时，可以用行在文本流中的行位置来引用。sed编辑器会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号。在命令中指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围内的行。这里有个sed命令作用到指定行号的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>sed编辑器只修改地址指定的第二行的文本。这里有另一个例子，这次使用了行地址区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,3s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>如果需要将命令作用到文本从某行开始的所有行，可以使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,$s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h5 id="第二使用文本模式过滤器">第二，使用文本模式过滤器</h5>
<p>另一种限制命令作用到哪些行上的方法会稍稍复杂一些。sed编辑器允许指定文本模式来过滤出命令要作用的行。格式为<code>/pattern/command，</code>必须用正斜线将要指定的pattern封起来。sed编辑器会将该命令作用到包含指定文本模式的行上。举个例子，如果你想只修改用户test001的默认shell，可以使用sed命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ grep biotest /etc/passwd</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/csh</div></pre></td></tr></table></figure>
<p>该命令只作用到匹配文本模式的行上。虽然使用固定文本模式能帮你过滤出特定的值，就跟上面这个用户名的例子一样，但其作用难免有限。sed编辑器在文本模式中支持正则表达式（regular expression）。</p>
<h5 id="第三命令组合">第三，命令组合</h5>
<p>如果需要在单行上执行多条命令，可以用花括号将多条命令组合在一起，sed编辑器会处理地址行处列出的每条命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed '2&#123;</div><div class="line"><span class="meta">&gt;</span> s/fox/elephant/</div><div class="line"><span class="meta">&gt;</span> s/dog/cat/</div><div class="line"><span class="meta">&gt;</span> &#125;' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown elephant jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>两条命令都会作用到该地址上，也可以在一组命令前指定一个地址区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '3,$&#123;</div><div class="line"><span class="meta">&gt;</span> s/brown/green/</div><div class="line"><span class="meta">&gt;</span> s/lazy/active/</div><div class="line"><span class="meta">&gt;</span> &#125;' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick green fox jumps over the active dog.</div><div class="line">The quick green fox jumps over the active dog.</div></pre></td></tr></table></figure>
<h3 id="删除行">删除行</h3>
<p>在sed中，删除使用的是<code>d</code>参数，使用此命令需要谨慎，如果用户忘记加入寻址模式的话，流中所有的文都会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt # 原始文本</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '3d' test6.txt # 删除第3行</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '2,3d' test6.txt # 删除第2，3行</div><div class="line">This is line number 1.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '3,$d' test6.txt # 删除第3行及3行以下</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">biotest@ubuntu:~/sed$ sed '/number 1/d' test6.txt # 删除第1行</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/3/d' test6.txt # 删除1到3行</div><div class="line">This is line number 4.</div><div class="line"><span class="meta">#</span> 指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed编辑器会删除两个指定行之间的所有行</div></pre></td></tr></table></figure>
<p>只要sed编辑器在数据流中匹配到了开始模式，删除功能就会打开。这可能会导致意外的结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test7.txt </div><div class="line">This is line number 1.</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is line number 1 again.</div><div class="line">THis is text you want to keep.</div><div class="line">This is the last line in the file.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/3/d' test7.txt</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>在这段代码中，第二个出现数字“1”的行再次触发了删除命令，因为没有找到停止模式，所以就将数据流中的剩余行全部删除了。如果你指定了一个从未在文本中出现的停止模式，显然会出现另外一个问题，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/5/d' test7.txt</div><div class="line">biotest@ubuntu:~/sed$</div></pre></td></tr></table></figure>
<p>在这段代码中，因为删除功能在匹配到第一个模式的时候打开了，但一直没匹配到结束模式，所以整个数据流都被删掉了。</p>
<h3 id="插入和附加文本">插入和附加文本</h3>
<p>sed编辑器可以向数据流插入和附加文本行。它有两种操作：第一，插入（insert）：命令（i）会在指定行前增加一个新行；第二，追加（append）命令（a）会在指定行后增加一个新行。这两条命令在使用格式上有些特殊，它们不能在单个命令行上使用。用户必须指定是要将行插入还是附加到另一行。格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed '[address] command\</div><div class="line">new line'</div></pre></td></tr></table></figure>
<p>其中，<code>new line</code>中的文本将会出现在sed编辑器输出中指定的位置。记住，当使用插入命令时，文本会出现在数据流文本的前面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "Test Line2"|sed 'i\Test Line 1' # 在第2行之前插入文本</div><div class="line">Test Line 1</div><div class="line">Test Line2</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ echo "Test Line2"|sed 'a\Test Line 1' # 在第2行之后插入文本 </div><div class="line">Test Line2</div><div class="line">Test Line 1</div></pre></td></tr></table></figure>
<p>在命令行界面提示符上使用sed编辑器时，用户会看到次提示符来提醒输入新的行数据。用户必须在该行完成sed编辑器命令。一旦你输入了结尾的单引号，bash shell就会执行该命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "Test Line 2"|sed 'i\</div><div class="line"><span class="meta">&gt;</span> Test Line 1'</div><div class="line">Test Line 1</div><div class="line">Test Line 2</div></pre></td></tr></table></figure>
<p>前面所述的方法只能给数据流中的文本前面或后面添加文本，但有时候还需要向一行的前后添加文本，要向数据流行内部插入或附加数据，必须用寻址来告诉sed编辑器想让数据出现在什么位置。可以在用这些命令时只指定一个行地址。可以匹配一个数字行号或文本模式，但不能用地址区间（因为用户只能将文本插入或附加到单个行的前面或后面，而不是行区间的前面或后面），在下面的例子中，用户将一个新行插入到数据流第三行前。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt </div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line"></div><div class="line"><span class="meta">#</span> 将一个新行插入到数据流第三行前</div><div class="line">biotest@ubuntu:~/sed$ sed '3i\ </div><div class="line"><span class="meta">&gt;</span> This is an inserted line.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is an inserted line.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line"></div><div class="line"><span class="meta">#</span>将一个新行附加到数据流中第三行后</div><div class="line">biotest@ubuntu:~/sed$ sed '3a\ </div><div class="line"><span class="meta">&gt;</span> This is an appended line.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is an appended line.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>如果有一个多行数据流，需要将新行追加到数据流的末决，只要用代表数据最后一行的美元符号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '$a\</div><div class="line"><span class="meta">&gt;</span> This is a new line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is a new line of text.</div></pre></td></tr></table></figure>
<p>同样的方法也适用于要在数据流起始位置增加一个新行。只要在第一行之前插入新行即可。要插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后一行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '1i\</div><div class="line"><span class="meta">&gt;</span> This ia one line of new text.\</div><div class="line"><span class="meta">&gt;</span> This is another line of new text.' test6.txt</div><div class="line">This ia one line of new text.</div><div class="line">This is another line of new text.</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<h3 id="修改行">修改行</h3>
<p>sed可以对文本进行修改，使用的参数是<code>c</code>，意思为修改（change）。这个参数允许修改数据流中整行文本的内容。它跟插入和附加命令的工作机制一样，必须在sed命令中单独指定新行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '3c\</div><div class="line"><span class="meta">&gt;</span> This is a change line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is a change line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>在这个例子中，sed编辑器会修改第三行中的文本。也可以用文本模式来寻址，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/number 3/c\</div><div class="line"><span class="meta">&gt;</span> This is a changed line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is a changed line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>文本模式修改命令会修改它匹配的数据流中的任意文本行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test8.txt</div><div class="line">This is line number 1. </div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is line number 1 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file. </div><div class="line">biotest@ubuntu:~/sed$ sed '/number 1/c\</div><div class="line"><span class="meta">&gt;</span> This is a changed line of text.' test8.txt</div><div class="line">This is a changed line of text.</div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is a changed line of text.</div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file.</div></pre></td></tr></table></figure>
<p>在修改命令中使用地址区间，结果就会出问题，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,3c\</div><div class="line"><span class="meta">&gt;</span> This is a new line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is a new line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>sed编辑器会用这一行文本来替换数据流中的两行文本，而不是逐一修改这两行文本。</p>
<h3 id="转换命令">转换命令</h3>
<p>sed中还有一个转换命令，参数是<code>y</code>，转换（ transform ）可以处理单个字符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address]y/inchars/outchars/</div></pre></td></tr></table></figure>
<p>转换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转换为outchars中的第一个字符，第二个字符会被转换成outchars中的第二个字符。这个映射过程会一直持续到处理完指定字符。如果inchars和outchars的长度不同，则sed编辑器会产生一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test8.txt</div><div class="line">This is line number 1. </div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is line number 1 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file. </div><div class="line">biotest@ubuntu:~/sed$ sed 'y/123/789/' test8.txt</div><div class="line">This is line number 7. </div><div class="line">This is line number 8. </div><div class="line">This is line number 9. </div><div class="line">This is line number 4. </div><div class="line">This is line number 7 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file.</div></pre></td></tr></table></figure>
<p>在这个案例中，<code>inchars</code>械中指定的字符的每个实例都会被替换成<code>outchars</code>模式中相同位置的那个字符，转换命令是一个全局命令，它会在文本行中找到所有指定字符自动进行转换，而不会考虑它们出现的位置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This 1 is a test of 1 try."|sed 'y/123/456/'</div><div class="line">This 4 is a test of 4 try.</div></pre></td></tr></table></figure>
<p>sed编辑器转换了在文本行中匹配到的字符1的两个实例。你无法限定只转换在特定地方出现的字符。</p>
<h3 id="回顾打印">回顾打印</h3>
<p>有3个命令可以打印文本行，分别为：</p>
<ol style="list-style-type: decimal">
<li>p命令用来打印文本行；</li>
<li>等号（=）用于打印行号；</li>
<li>l（小写的L）用于列出行。</li>
</ol>
<h4 id="打印行">打印行</h4>
<p>这里的<code>p</code>参业与替换中的<code>p</code>参数类似，它可以打印sed编译器输出中的一行，如果只使用这个命令，就是显示这一行命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This is a test"|sed 'p'</div><div class="line">This is a test</div><div class="line">This is a test</div></pre></td></tr></table></figure>
<p><code>p</code>参数就是打印已有的数据文本，打印命令常用的用法就是打印包含匹配文本模式的行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed -n '/number 3/p' test6.txt</div><div class="line">This is line number 3.</div></pre></td></tr></table></figure>
<p>在命令行上用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。也可以用它来快速打印数据流中的某些行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '2,3p' test6.txt</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div></pre></td></tr></table></figure>
<p>如果需要在修改之前查看行，也可以使用打印命令，比如与替换或修改命令一起使用。可以创建一个脚本在修改行之前显示该行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '/3/&#123;</div><div class="line"><span class="meta">&gt;</span> p</div><div class="line"><span class="meta">&gt;</span> s/line/test/p</div><div class="line"><span class="meta">&gt;</span> &#125;' test6.txt</div><div class="line">This is line number 3.</div><div class="line">This is test number 3.</div></pre></td></tr></table></figure>
<p>sed编辑器命令会查找包含数字3的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。</p>
<h4 id="打印行号">打印行号</h4>
<p>等号命令会打印行在数据流中的当前行号。行号由数据流中的换行符决定。每次数据流中出现一个换行符，sed编辑器会认为一行文本结束了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">biotest@ubuntu:~/sed$ sed '=' data1.txt</div><div class="line">1</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">2</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">3</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">4</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>sed编辑器在实际的文本行出现前打印了行号。如果你要在数据流中查找特定文本模式的话，等号命令用起来非常方便，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '/number 4/&#123;</div><div class="line"><span class="meta">&gt;</span> =</div><div class="line"><span class="meta">&gt;</span> p</div><div class="line"><span class="meta">&gt;</span> &#125;' test6.txt</div><div class="line">4</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>利用 -n 选项，你就能让sed编辑器只显示包含匹配文本模式的行的行号和文本。</p>
<h4 id="列出行">列出行</h4>
<p>列出（list）命令（l）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如，来代表制表符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data9.txt </div><div class="line">This	line	contains	tabs.</div><div class="line">biotest@ubuntu:~/sed$ sed -n 'l' data9.txt</div><div class="line">This\tline\tcontains\ttabs.$</div></pre></td></tr></table></figure>
<p>制表符的位置使用。行尾的美元符表示换行符。</p>
<h3 id="使用sed处理文件">使用sed处理文件</h3>
<h4 id="写入文件">写入文件</h4>
<p><code>w</code>选项用于向文件写入行，该选项的命令格式为<code>[address] w filename</code>，其中<code>filename</code>可以使用相对路径或绝对路径，并且用户要有文件的写权限，地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</p>
<p>下面的例子是将数据流中的前两行打印到一个文本文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '1,2w test.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ cat test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ cat test.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div></pre></td></tr></table></figure>
<p>如果不想让行显示到STDOUT上，可以用sed命令的-n选项。如果要根据一些公用的文本值从主文件中创建一份数据文件，比如下面的邮件列表中的，那么w命令会非常好用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data11.txt</div><div class="line">Zhang San</div><div class="line">Li Si</div><div class="line">Wang Er</div><div class="line">Liu Qi</div><div class="line">biotest@ubuntu:~/sed$ sed -n '/Zhang/w Zhang.txt' data11.txt</div><div class="line">biotest@ubuntu:~/sed$ cat Zhang.txt </div><div class="line">Zhang San</div></pre></td></tr></table></figure>
<p>sed编辑器会只将包含文本模式的数据写入目标文件。</p>
<h4 id="从文件读取数据">从文件读取数据</h4>
<p>取（read）命令（r）允许用户将一个独立文件中的数据插入到数据流中。读取命令的格式为<code>[address]r filename</code>，其中filename参数指定了数据文件的绝对路径或相对路径，在读取命令中使用地址区间，只能指定单独一个行号或文本模式地址。sed编辑器会将文件中的文本插入到指定地址后，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data12.txt</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">biotest@ubuntu:~/sed$ sed '3r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>使用文本模式进行读取，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/number 2/r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>如果需要在数据流的末尾添加文件，需要使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '$r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div></pre></td></tr></table></figure>
<p>读取命令的另一个很有用的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。举例来说，假定你有一份套用信件保存在文本文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat notice.std </div><div class="line">Would the following people:</div><div class="line">LIST</div><div class="line">please report to the ship's captain.</div></pre></td></tr></table></figure>
<p>套用信件将通用占位文本 LIST 放在人物名单的位置。要在占位文本后插入名单，只需读取 命令就行了。但这样的话，占位文本仍然会留在输出中。要删除占位文本的话，你可以用删除命 令。结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/LIST/&#123;</div><div class="line"><span class="meta">&gt;</span> r data11.txt</div><div class="line"><span class="meta">&gt;</span> d</div><div class="line"><span class="meta">&gt;</span> &#125;' notice.std</div><div class="line">Would the following people:</div><div class="line">Zhang San</div><div class="line">Li Si</div><div class="line">Wang Er</div><div class="line">Liu Qi</div><div class="line">please report to the ship's captain.</div></pre></td></tr></table></figure>
<p>现在占位文本已经被替换成了数据文件中的名单。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/06/病毒包装笔记(7)-第三代慢病毒包装笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/病毒包装笔记(7)-第三代慢病毒包装笔记/" itemprop="url">病毒包装笔记(7)-第三代慢病毒</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T12:02:00+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物实验笔记/" itemprop="url" rel="index">
                    <span itemprop="name">生物实验笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,283
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>最近在国内某公司买了一个慢病毒质粒，公司的人说可以用来包慢病毒，也可以用来瞬转。但是我发现这个质粒上没有<code>3'UTR</code>和<code>5' UTR</code>，我怀疑不能用来包慢病毒，公司说可以，但要用他们的试剂盒。我问了一下师兄，师兄说，这种质粒可能是第三代慢病毒包装质粒，试剂盒里的主要试剂就是包含三种包装质粒的混合液。我们实验室用的是第二代病毒包装系统，两个包装质粒，一个目的质粒，因此我对这种质粒包装系统并不清楚。现在查了一些三代包装系统的资料，现在总结如下。</p>
<h2 id="慢病毒的成分">慢病毒的成分</h2>
<p>现在的慢病毒包装系统通常包括几个质粒，这几个质粒上分别含有慢病毒复制的成分，这样做的目的就是为了增加安全性，毕竟如果只用一个成分的话，危险系数很高，人一旦接触这种病毒就有可能遇到危险。而把这几个成分分散在几个质粒中，很难在体外形成危险的病毒颗粒。第二代慢病毒包装系统含有3个质粒，第3代慢病毒包装系统含有4个质粒。这两代病毒包装系统都含有以下相同的成分：</p>
<p>第一，编码目的蛋白或转录目的基因的转移质粒。其实就是你自己的目的质粒，也就是通常需要自己做载体的质粒。目的基因的两侧都含有长末端重复序列（LTR，long terminal repeat），LTR的作用就是辅助目的基因插入到宿主细胞的基因组。许多慢病毒质粒都是基于HIV-1病毒改造的。为了安全目的，这些目的质粒的复能能力并不完全，它们的<code>3'LTR</code>有所删减，这样病毒插入到基因组后会自我失活（self-inactivating）（SIN）。</p>
<p>第二，包装质粒，毒包装的结构蛋白编码质粒。</p>
<p>第三，包膜质粒，编码蛋白质外壳。</p>
<p>第二代慢病毒利用病毒的LTR启动子用于基因的表达，第三代慢病毒利用一个杂合的LTR启动子进行基因表达。</p>
<h2 id="第二代慢病毒">第二代慢病毒</h2>
<p>下图是第二代慢病毒系统：</p>
<div class="figure">
<img src="https://media.addgene.org/data/easy-thumbnails/filer_public/cms/filer_public/56/36/563610a3-a100-4f87-9d10-309cf106dfe7/geneticorganizationoflentiviruses_1.jpg__450x255_q85_subsampling-2_upscale.png">

</div>
<p>这个系统含有3个质粒，第1个质粒：包装质粒，它编码Gag，PoI，Rev与Tat基因。第2个质粒：包膜质粒，含有VSV-G，编码蛋白Env。第3个质粒：目的质粒，含有病毒的LTRs和psi包装信号（图片未画出），除非有内部启动子，否则这个目的质粒的目的基因是由<code>5'LTR</code>驱动的，它是一个弱启动子，需要Tat元件 的来激活它。所有的第2代慢病毒目的质粒必须要用第2代慢病毒包装系统，因此它的LTR是Tat依赖性的。</p>
<h2 id="第三代慢病毒">第三代慢病毒</h2>
<p>第3代慢病毒如下所示：</p>
<div class="figure">
<img src="https://media.addgene.org/data/easy-thumbnails/filer_public/cms/filer_public/7f/54/7f549fd8-1c37-4448-a2d3-227e5c24c550/3rdgenerationplasmids.png__350x194_q85_subsampling-2_upscale.png">

</div>
<p>设计第3代病毒的目的主要还是提高安全性。在第3代病毒中，将第2代病毒的包装质粒分成了2个质粒，一个编码Rev，另外一个编码Gag和PoI。虽然第3代病毒更加安全了，但是它的效率却降低了。除此之外，第3代病毒删除了Tat元件，并且在目的质粒中引入了一个嵌合了<code>5'LTR</code>的异源启动子。这种目的质粒基因的启动子并不依赖于Tat元件。第3代病毒的目的质粒可以使用第2代或第3代的包装质粒，也就是说第3代慢病毒的目的质粒兼容第2代的包装系统。</p>
<h2 id="第二代慢病毒与第第三代病毒的区别">第二代慢病毒与第第三代病毒的区别</h2>
<table>
<colgroup>
<col width="10%">
<col width="41%">
<col width="47%">
</colgroup>
<thead>
<tr class="header">
<th>特点</th>
<th>第2代慢病毒</th>
<th>第3代慢病毒</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目的质粒</td>
<td>只能被含有TAT的2代病毒包装</td>
<td>可以被第2代和第3代病毒包装系统包装</td>
</tr>
<tr class="even">
<td>包装质粒</td>
<td>一个质粒上含有Gag，PoI，Rev，Tat（也就是psPAX2）</td>
<td>2个质粒，一个编码Gag和PoI；另外一个质粒编码Rev（也就是pMDLg/pRRE和pRSV-Rev）</td>
</tr>
<tr class="odd">
<td>包膜质粒</td>
<td>可替换，通常用于编码VSV-G（pMD2G）</td>
<td>可替换，通常用于编码VSV-G（pMD2G）</td>
</tr>
<tr class="even">
<td>案例性</td>
<td>安全。复能能力不完全，使用编码各种HIV基因的3个质粒。</td>
<td>更安全，复制能力不完全，有自身失活性（SIN）。使用4个质粒来替换2代慢病毒的3个质粒，删除了Tat元件。</td>
</tr>
<tr class="odd">
<td>LTR病毒启动子</td>
<td>广泛型</td>
<td>杂合：删除了部分的5’LTR，与另外一个异源增强子/启动子融合，例如CMV或RSV。</td>
</tr>
</tbody>
</table>
<h2 id="第三代病毒包装系统的过程">第三代病毒包装系统的过程</h2>
<p>其实买的目的质粒虽然是三代病毒包装系统的，但是完全可以用二代慢病毒包装系统来替代，用PMD2G和psPAX2，外加目的质粒进行转染。</p>
<h2 id="参考资料">参考资料</h2>
<p>https://www.addgene.org/viral-vectors/lentivirus/lenti-guide/</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/05/Linux-shell07-构建函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/Linux-shell07-构建函数/" itemprop="url">Shell学习笔记（7）——构建函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-05T12:12:54+08:00">
                2018-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,347
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本的脚本函数">基本的脚本函数</h2>
<p>函数是一个脚本代码块，用户可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。</p>
<h3 id="创建函数">创建函数</h3>
<p>创建函数有2种方式：第一种，使用关键字<code>function</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function name&#123;</div><div class="line">    commands</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。</p>
<p>第二种构建函数的格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name() &#123; </div><div class="line">    commands </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数名后的空括号表明正在定义的是一个函数。这种格式的命名规则和之前定义shell脚本函数的格式一样。</p>
<h3 id="使用函数">使用函数</h3>
<p>要在脚本中使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a function in a script</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">     echo "This is an example of a function"</div><div class="line">&#125;</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    func1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">echo "This is the end of the loop"</div><div class="line">func1</div><div class="line">echo "Now this is the end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test1.sh</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is the end of the loop</div><div class="line">This is an example of a function</div><div class="line">Now this is the end of the script</div></pre></td></tr></table></figure>
<p>每次引用函数名func1时，bash shell会找到func1函数的定义并执行你在那里定义的命令。如果在函数被定义前使用函数，会收到一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a function located in the middle of a script</div><div class="line"></div><div class="line">count=1</div><div class="line">echo "This line comes before the function definition"</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is an example of a function"</div><div class="line">&#125;</div><div class="line"></div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    func1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "This is the end of the loop"</div><div class="line">func2</div><div class="line">echo "Now this is the end of the scripts"</div><div class="line"></div><div class="line">function func2 &#123;</div><div class="line">   echo "This is an example of a function"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test2.sh</div><div class="line">This line comes before the function definition</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is the end of the loop</div><div class="line">test2.sh: line 17: func2: command not found</div><div class="line">Now this is the end of the scripts</div></pre></td></tr></table></figure>
<p>第一个函数func1的定义出现在脚本中的几条语句之后，运行起来没问题。当func1函数 在脚本中被使用时，shell知道去哪里找它。 脚本试图在func2函数被定义之前使用它。由于func2函数还没有定义，脚本运行函数调用处时，产生了一条错误消息。 此外，还需要注意函数名，函数名必须是唯一的，否则也会有问题。如果你重定义了函数，新定义会覆盖原来函数的定义，这一切不会产生任何错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing using a duplicate function name</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is the first definition of the function name"</div><div class="line">&#125;</div><div class="line"></div><div class="line">func1</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is a repeat of the same function name"</div><div class="line">&#125;</div><div class="line">func1</div><div class="line">echo "This is end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test3.sh</div><div class="line">This is the first definition of the function name</div><div class="line">This is a repeat of the same function name</div><div class="line">This is end of the script</div></pre></td></tr></table></figure>
<p>func1函数最初的定义工作正常，但重新定义该函数后，后续的函数调用都会使用第二个定义。</p>
<h2 id="返回值">返回值</h2>
<p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成退出状态码。</p>
<h3 id="默认退出状态码">默认退出状态码</h3>
<p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the exit status of a function</div><div class="line"></div><div class="line">func1() &#123;</div><div class="line">   echo "Trying to display a non-existent file"</div><div class="line">   ls -l badfile</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo "testing the function:  "</div><div class="line">func1</div><div class="line">echo "The exit status is : $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test4.sh</div><div class="line">testing the function:  </div><div class="line">Trying to display a non-existent file</div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">The exit status is : 2</div></pre></td></tr></table></figure>
<p>函数的退出状态码是2，这是因为函数中的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行。看下面的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the exit status of a fucntion </div><div class="line"></div><div class="line">func1() &#123;</div><div class="line">    ls -l badfile</div><div class="line">    echo "This was a test of a bad command"</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo "Testing the function: "</div><div class="line">func1</div><div class="line">echo "The exit status is:  $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test4b.sh</div><div class="line">Testing the function: </div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">This was a test of a bad command</div><div class="line">The exit status is:  0</div></pre></td></tr></table></figure>
<p>在这个案例中，由于函数最后一条语句echo运行成功，该函数的退出状态码就是0，尽管其中有一条 命令并没有正常运行。使用函数的默认退出状态码是很危险的。在bash shell中，有几种办法可以解决这个问题。</p>
<h3 id="使用return命令">使用return命令</h3>
<p>bash shell使用return命令来退出函数并返回特定的退出状态码。return命令允许指定一个 整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the return command in a function</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    read -p "Enter a value:" value</div><div class="line">    echo "doubling the value"</div><div class="line">    return $[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">dbl</div><div class="line">echo "The new value is $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5.sh</div><div class="line">Enter a value:5</div><div class="line">doubling the value</div><div class="line">The new value is 10</div></pre></td></tr></table></figure>
<p>dbl函数会将<code>$value</code>变量中用户输入的值翻倍，然后用return命令返回结果。脚本用<code>$?</code>变量显示了该值。但当用这种方法从函数中返回值时，需要注意两点：第一，函数一结束就取返回值；第二，退出状态码必须是0~255。如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。<code>$?</code>变量会返回执行的最后一条命令的退出状态码。第二个问题界定了返回值的取值范围。由于退出状态码必须小于256，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5.sh</div><div class="line">Enter a value:200</div><div class="line">doubling the value</div><div class="line">The new value is 144</div></pre></td></tr></table></figure>
<h3 id="使用函数的输出">使用函数的输出</h3>
<p>将函数的份输出保存到shell变量中，就能获取任何类型的函数输出，例如<code>result='dbl</code>就是将dbl函数的输出赋值给<code>$result</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the return command in a function</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    read -p "Enter a value:" value</div><div class="line">    echo $[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">result=$(dbl)</div><div class="line"></div><div class="line">echo "The new value is $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5b.sh</div><div class="line">Enter a value:200</div><div class="line">The new value is 400</div></pre></td></tr></table></figure>
<p>新函数会用echo语句来显示计算的结果。该脚本会获取dbl函数的输出，而不是查看退出状态码。在这个例子中，dbl函数实际上输出了两条消息。read命令输出了一条简短的消息来向用户询问输入值。bash shell脚本并不将其作为STDOUT输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中。通过这种技术，还可以返回浮点值和字符串值。</p>
<h2 id="在函数中使用变量">在函数中使用变量</h2>
<p>在test5例子的脚本里，在函数里用了一个叫作$value的变量来保存处理后的值。在函数中使用变量时，用户需要注意它们的定义方式以及处理方式。这是shell脚本中常见错误的根源。</p>
<h3 id="向函数传递参数">向函数传递参数</h3>
<p>函数使用两种类型的变量，分别为全局变量和局部变量。</p>
<h4 id="全局变量">全局变量</h4>
<p>全局变量是在shell脚本中任何地方都有效的变量。如果在脚本的主体部分定义了一个全局 变量，那么可以在函数内读取它的值。同样的，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。 默认情况下，在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a global variable to pass a value</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    value=$[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">read -p "Enter a vluae: " value</div><div class="line">dbl</div><div class="line">echo "The new value is :  $value"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test8.sh</div><div class="line">Enter a vluae: 300</div><div class="line">The new value is :  600</div></pre></td></tr></table></figure>
<p><code>$value</code>变量在函数外定义并被赋值。当dbl函数被调用时，该变量及其值在函数中都依然有效。如果变量在函数内被赋予了新值，那么在脚本中引用该变量时，新值也依然有效。但这操作其实很危险，因为如果是不同的脚本都使用该函数，有可能造成冲突，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating a bad use of variable</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    temp=$[ $value+5 ]</div><div class="line">    result=$[ $temp*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">temp=4</div><div class="line">value=6</div><div class="line"></div><div class="line">func1</div><div class="line">echo "The result is $result"</div><div class="line">if [ $temp -gt $value ]</div><div class="line">then</div><div class="line">    echo "temp is larger"</div><div class="line">else</div><div class="line">    echo "temp is smaller"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest2.sh </div><div class="line">The result is 22</div><div class="line">temp is larger</div></pre></td></tr></table></figure>
<p>由于函数中用到了<code>$temp</code>变量，它的值在脚本中使用时受到了影响，产生了意想不到的后果。</p>
<h4 id="局部变量">局部变量</h4>
<p>在函数内部，通常无需使用全局变量，使用局部变量即可，要实现这一点，只要在变量声明的前面加上 local 关键字就可以了，例如<code>local temp</code>，local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量， 那么shell将会保持这两个变量的值是分离的。现在你就能很轻松地将函数变量和脚本变量隔离开了，只共享需要共享的变量。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test9.sh</div><div class="line">The result is 22</div><div class="line">temp is smaller</div></pre></td></tr></table></figure>
<p>在 func1 函数中使用<code>$temp</code>变量时，并不会影响在脚本主体中赋给 <code>$temp</code>变量的值。</p>
<h2 id="数组变量和函数">数组变量和函数</h2>
<h3 id="向函数传数组参数">向函数传数组参数</h3>
<p>如果你试图将该数组变量作为函数参数，函数只会取数组变量的第一个值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Trying to pass an arraya variable</div><div class="line"></div><div class="line">function testit &#123;</div><div class="line">    echo "The parameters are: $@"</div><div class="line">    thisarray=$1</div><div class="line">    echo "The received array is $&#123;thisarray[*]&#125;"</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5)</div><div class="line">echo "The original array is: $&#123;myarray[*]&#125;"</div><div class="line">testit $myarray</div></pre></td></tr></table></figure>
<p>结果运行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest3b.sh</div><div class="line">The original array is: 1 2 3 4 5</div><div class="line">The parameters are: 1</div><div class="line">The received array is 1</div></pre></td></tr></table></figure>
<p>要解决上述问题，用户必须将该数组变量的值分解成单个的值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ cat test10.sh</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> array variable to function test</div><div class="line">function testit &#123; </div><div class="line">   local newarray </div><div class="line">   newarray=($(echo "$@")) </div><div class="line">   echo "The new array value is: $&#123;newarray[*]&#125;" </div><div class="line">&#125; </div><div class="line"> </div><div class="line">myarray=(1 2 3 4 5) </div><div class="line">echo "The original array is $&#123;myarray[*]&#125;" </div><div class="line">testit $&#123;myarray[*]&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test10.sh</div><div class="line">The original array is 1 2 3 4 5</div><div class="line">The new array value is: 1 2 3 4 5</div></pre></td></tr></table></figure>
<p>该脚本用<code>$myarray</code>变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> adding values in an array</div><div class="line"></div><div class="line">function addarray &#123;</div><div class="line">    local sum=0</div><div class="line">    local newarray</div><div class="line">    newarray=($(echo "$@"))</div><div class="line">    for value in $&#123;newarray[*]&#125;</div><div class="line">    do</div><div class="line">        sum=$[ $sum+$value ]</div><div class="line">    done</div><div class="line">    echo $sum</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5)</div><div class="line">echo "The original array is : $&#123;myarray[*]&#125;"</div><div class="line">arg1=$(echo $&#123;myarray[*]&#125;)</div><div class="line">result=$(addarray $arg1)</div><div class="line">echo "The result is $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test11.sh</div><div class="line">The original array is : 1 2 3 4 5</div><div class="line">The result is 15</div></pre></td></tr></table></figure>
<p>addarray函数会遍历所有的数组元素，将它们累加在一起。你可以在myarray数组变量中放置任意多的值，addarry函数会将它们都加起来。</p>
<h3 id="从函数返回数组">从函数返回数组</h3>
<p>从函数里向shell脚本传回数组变量也用类似的方法。函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span>returning an array value</div><div class="line"></div><div class="line">function arraydblr &#123;</div><div class="line">    local origarray</div><div class="line">    local newarray</div><div class="line">    local elements</div><div class="line">    local i</div><div class="line">    origarray=($(echo "$@"))</div><div class="line">    newarray=($(echo "$@"))</div><div class="line">    elements=$[ $# -1 ]</div><div class="line">    for (( i=0;i&lt;=$elements;i++))</div><div class="line">    &#123;</div><div class="line">        newarray[$i]=$[ $&#123;origarray[$i]&#125;*2 ]</div><div class="line">    &#125;</div><div class="line">    echo $&#123;newarray[*]&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5 )</div><div class="line">echo "The original array is: $&#123;myarray[*]&#125;"</div><div class="line">arg1=$(echo $&#123;myarray[*]&#125;)</div><div class="line">result=($(arraydblr $arg1))</div><div class="line">echo "The new array is: $&#123;result[*]&#125;"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test12.sh</div><div class="line">The original array is: 1 2 3 4 5</div><div class="line">The new array is: 2 4 6 8 10</div></pre></td></tr></table></figure>
<p>该脚本用<code>$arg1</code>变量将数组值传给arraydblr函数。arraydblr函数将该数组重组到新的数 组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并 将结果存入函数中该数组变量的副本。 arraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来 重新生成一个新的数组变量。</p>
<h2 id="函数递归">函数递归</h2>
<p>函数可以调用函数自身，这个过程就称为函数的递归。下面看一个函数，这个函数就是通过递归来计算阶乘，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using recursion</div><div class="line"></div><div class="line">function factorial &#123;</div><div class="line">    if [ $1 -eq 1 ]</div><div class="line">    then</div><div class="line">        echo 1</div><div class="line">    else</div><div class="line">        local temp=$[ $1 -1 ]</div><div class="line">        local result=$(factorial $temp)</div><div class="line">        echo $[ $result*$1 ]</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">read -p "Enter value: " value</div><div class="line">result=$(factorial $value)</div><div class="line">echo "The factorial of $value is: $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test13.sh</div><div class="line">Enter value: 5</div><div class="line">The factorial of 5 is: 120</div></pre></td></tr></table></figure>
<p>在创建了函数后，可以在其他的脚本中调用。</p>
<h2 id="创建库">创建库</h2>
<p>如果用户要在多个脚本中使用同一段代码的话，这就需要创建函数库文件，然后在多个脚本中引用该库文件。这个过程的第一步是创建一个包含脚本中所需函数的公用库文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> my script functions </div><div class="line"></div><div class="line">function addem &#123;</div><div class="line">    echo $[ $1+$2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">function multem &#123;</div><div class="line">    echo $[ $1*$2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">function divem &#123;</div><div class="line">    if [ $2 -ne 0 ]</div><div class="line">    then</div><div class="line">        echo $[ $1/$2 ]</div><div class="line">    else</div><div class="line">        echo -1</div><div class="line">    fi</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下一步是在用到这些函数的脚本文件中包含myfuncs库文件。从这里开始，事情就变复杂了。问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。这同样适用于脚本。如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a library file the wrong way</div><div class="line">bash myfuncs.sh</div><div class="line"></div><div class="line">result=$(addem 10 15)</div><div class="line">echo "The result is $result"</div></pre></td></tr></table></figure>
<p>运行后如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest4.sh </div><div class="line">badtest4.sh: line 5: addem: command not found</div><div class="line">The result is</div></pre></td></tr></table></figure>
<p>使用函数库的需要用到<code>source</code>命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。source命令有个快捷的别名，称作<code>点操作符（dotoperator）</code>。要在shell脚本中运行myfuncs库文件，只需添加这一行，即<code>. ./myfuncs</code>(两个点之间有空格），这个例子是假定myfuncs库文件与shell脚本位于同一目录，如果不是，则需要输入全路径。使用source命令的脚本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a library file the wrong way</div><div class="line">. ./myfuncs.sh</div><div class="line"></div><div class="line">value1=10</div><div class="line">value2=5</div><div class="line">result1=$(addem $value1 $value2)</div><div class="line">result2=$(multem $value1 $value2)</div><div class="line">result3=$(divem $value1 $value2)</div><div class="line">echo "The result of adding them is: $result1"</div><div class="line">echo "The result of multiplying them is: $result2"</div><div class="line">echo "The result of dividing them is: $result3"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test14.sh</div><div class="line">The result of adding them is: 15</div><div class="line">The result of multiplying them is: 50</div><div class="line">The result of dividing them is: 2</div></pre></td></tr></table></figure>
<h2 id="在命令行上使用函数">在命令行上使用函数</h2>
<p>在命令行界面中也可以使用函数，一旦在shell中定义了函数，用户就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。</p>
<p>### 在命令行上创建函数</p>
<h4 id="第1种方法直接定义函数">第1种方法：直接定义函数</h4>
<p>这一种方法使用的是单行试，需要函数主体部分的每个命令后面加上分号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function divem &#123; echo $[ $1/$2 ]; &#125;</div><div class="line">biotest@ubuntu:~/funciton$ divem 100 5</div><div class="line">20</div></pre></td></tr></table></figure>
<p>再看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function doubleit &#123; read -p "Enter value: " value; echo $[ $value*2 ]; &#125;</div><div class="line">biotest@ubuntu:~/funciton$ doubleit</div><div class="line">Enter value: 12</div><div class="line">24</div></pre></td></tr></table></figure>
<h4 id="第2种方法多行形式">第2种方法：多行形式</h4>
<p>还可以采用多行方式定义函数，此种情况下，bash shell会用提示符提示输入更多的命令，此种方法不需要在命令后面加分号，直接回车就行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function multem &#123;</div><div class="line"><span class="meta">&gt;</span> echo $[ $1*$2 ]</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line">biotest@ubuntu:~/funciton$ multem 2 5</div><div class="line">10</div></pre></td></tr></table></figure>
<h3 id="在.bashrc文件中定义函数">在<code>.bashrc</code>文件中定义函数</h3>
<p>在命令行上直接定义shell函数的明显缺点是退出shell时，函数就消失了。对于复杂的函数来说，这种形式并不常用。解决这个问题的方式就是将函数定义在一个特定的位置，这个位置在每次启动一个新shell的时候，都会由shell重新载入。最佳地点就是.bashrc文件。bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。</p>
<h4 id="直接定义函数">直接定义函数</h4>
<p>打开<code>.bashrc</code>文件，下拉在文件的末尾处写入函数即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if [ -r /etc/bashrc ];then</div><div class="line">        . /etc/bashrc</div><div class="line">fi</div><div class="line"></div><div class="line">function addem &#123;</div><div class="line">    echo $[ $1 + $2 ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ addem 10 2</div><div class="line">12</div></pre></td></tr></table></figure>
<p>也可以将库文件写入到<code>.bashrc</code>文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if [ -r /etc/bashrc ];then</div><div class="line">        . /etc/bashrc</div><div class="line">fi</div><div class="line"></div><div class="line">. /home/biotest/funciton/myfuncs.sh</div></pre></td></tr></table></figure>
<p>然后<code>source ~/.bashrc，</code>这样在shell中就可以使用myfuncs.sh中的函数了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ addem 10 5</div><div class="line">15</div><div class="line">biotest@ubuntu:~/funciton$ multem 10 5</div><div class="line">50</div><div class="line">biotest@ubuntu:~/funciton$ divem 10 5</div><div class="line">2</div></pre></td></tr></table></figure>
<h2 id="案例">案例</h2>
<p>shtool库提供了一些简单的shell脚本函数，可以用来完成日常的shell功能，例如处理临时文件和目录或者格式化输出显示。</p>
<h3 id="下载及安装">下载及安装</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget ftp://ftp.gnu.org/gnu/shtool/shtool-2.0.8.tar.gz</div><div class="line">tar -zxvf shtool-2.0.8.tar.gz</div></pre></td></tr></table></figure>
<h3 id="构建库">构建库</h3>
<p>shtool文件必须针对特定的Linux环境进行配置。配置工作必须使用标准的configure和make命令，这两个命令常用于C编程环境。要构建库文件，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ ./configure</div><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ make</div></pre></td></tr></table></figure>
<p>configure命令会检查构建shtool库文件所必需的软件。一旦发现了所需的工具，它会使用工具路径修改配置文件。make命令负责构建shtool库文件。最终的结果（shtool）是一个完整的库软件包。也可以使用make命令测试这个库文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make test</div></pre></td></tr></table></figure>
<p>测试模式会测试shtool库中所有的函数。如果全部通过测试，就可以将库安装到Linux系统中的公用位置，这样所有的脚本就都能够使用这个库了。要完成安装，需要使用make命令的install选项。不过需要以root用户的身份运行该命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ sudo make install</div></pre></td></tr></table></figure>
<p>现在就能在自己的shell脚本中使用这些函数了。</p>
<h3 id="shtool-库函数">shtool 库函数</h3>
<p>shtool库提供了大量方便的、可用于shell脚本的函数。如下所示：</p>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arx</td>
<td>创建归档文件（包含一些扩展功能）</td>
</tr>
<tr class="even">
<td>Echo</td>
<td>显示字符串，并提供了一些扩展构件</td>
</tr>
<tr class="odd">
<td>fixperm</td>
<td>改变目录树中的文件权限</td>
</tr>
<tr class="even">
<td>install</td>
<td>安装脚本或文件</td>
</tr>
<tr class="odd">
<td>mdate</td>
<td>显示文件或目录的修改时间</td>
</tr>
<tr class="even">
<td>mkdir</td>
<td>创建一个或更多目录</td>
</tr>
<tr class="odd">
<td>Mkln</td>
<td>使用相对路径创建链接</td>
</tr>
<tr class="even">
<td>mkshadow</td>
<td>创建一棵阴影树</td>
</tr>
<tr class="odd">
<td>move</td>
<td>带有替换功能的文件移动</td>
</tr>
<tr class="even">
<td>Path</td>
<td>处理程序路径</td>
</tr>
<tr class="odd">
<td>platform</td>
<td>显示平台标识</td>
</tr>
<tr class="even">
<td>Prop</td>
<td>显示一个带有动画效果的进度条</td>
</tr>
<tr class="odd">
<td>rotate</td>
<td>转置日志文件</td>
</tr>
<tr class="even">
<td>Scpp</td>
<td>共享的C预处理器</td>
</tr>
<tr class="odd">
<td>Slo</td>
<td>根据库的类别，分离链接器选项</td>
</tr>
<tr class="even">
<td>Subst</td>
<td>使用sed的替换操作</td>
</tr>
<tr class="odd">
<td>Table</td>
<td>以表格的形式显示由字段分隔（field</td>
</tr>
<tr class="even">
<td>tarball</td>
<td>从文件和目录中创建tar文件</td>
</tr>
<tr class="odd">
<td>version</td>
<td>创建版本信息文件</td>
</tr>
</tbody>
</table>
<p>shtool函数的使用格式为<code>shtool [options] [function [options] [args]]</code>。</p>
<h3 id="使用库">使用库</h3>
<p>下面是一个在shell脚本中使用platform函数的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">shtool platform</div></pre></td></tr></table></figure>
<p>运行后如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test16.sh</div><div class="line">Ubuntu 16.04 (AMD64)</div></pre></td></tr></table></figure>
<p>platform函数会返回Linux发行版以及系统所使用的CPU硬件的相关信息。还有一个函数是prop函数。它可以使用、|、/和-字符创建一个旋转的进度条。可以告诉shell脚本用户目前正在进行一些后台处理工作。要使用prop函数，只需要将希望监看的输出管接到shtool脚本就行了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ ls -al /usr/bin | shtool prop -p "waiting..."</div><div class="line">waiting...</div></pre></td></tr></table></figure>
<p>prop函数会在处理过程中不停地变换进度条字符。在本例中，输出信息来自于ls命令。你能看到多少进度条取决于CPU能以多快的速度列出/usr/bin中的文件，-p选项允许你定制输出文本，这段文本会出现在进度条字符之前。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/04/Linux-shell06-控制脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/Linux-shell06-控制脚本/" itemprop="url">Shell学习笔记（6）——控制脚本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T12:12:54+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,083
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="控制信号">控制信号</h2>
<p>Linux利用信号与运行在系统中的进程进行通信。通过对脚本进行编程，使其在收到特定信号时执行某些命令，从而控制shell脚本的操作。Linux系统和应用程序可以生成超过30个信息，下表是常见的Linux系统信号：</p>
<h3 id="常见的信号">常见的信号</h3>
<table>
<thead>
<tr class="header">
<th>信号</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>SIGHUP</td>
<td>挂起进程</td>
</tr>
<tr class="even">
<td>2</td>
<td>SIGINF</td>
<td>终止进程</td>
</tr>
<tr class="odd">
<td>3</td>
<td>SIGQUIT</td>
<td>停止进程</td>
</tr>
<tr class="even">
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程</td>
</tr>
<tr class="odd">
<td>15</td>
<td>SIGTERM</td>
<td>尽可能终止进程</td>
</tr>
<tr class="even">
<td>17</td>
<td>SIGSTOP</td>
<td>无条件停止进程，但不是终止进程</td>
</tr>
<tr class="odd">
<td>18</td>
<td>SIGTSTP</td>
<td>停止或暂停进程，但不终止进程</td>
</tr>
<tr class="even">
<td>19</td>
<td>SIGCONT</td>
<td>继续运行停止的进程</td>
</tr>
</tbody>
</table>
<p>默认情况下，bash shell会忽略收到的任何 SIGQUIT (3) 和 SIGTERM (5) 信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的 SIGHUP (1) 和 SIGINT (2) 信号。如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。通过SIGINT信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这种情况发生时，shell会将SIGINT信号传给所有由它所启动的进程，以此告知出现的状况。你可能也注意到了，shell会将这些信号传给shell脚本程序来处理。而shell脚本的默认行为是忽略这些信号。它们可能会不利于脚本的运行。要避免这种情况，你可以脚本中加入识别信号的代码，并执行命令来处理信号。</p>
<h3 id="生成信号">生成信号</h3>
<p>使用键盘上的组合键可以生成2种基本的Linux信号。</p>
<h4 id="中断进程">中断进程</h4>
<p>Ctrl<code>+</code>C<code>会生成</code>SIGINT`信号，将其发送给当前在shell运行中的所有进程，停止shell当前运行的进程，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 500</div><div class="line">^C</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$</div></pre></td></tr></table></figure>
<h4 id="暂停进程">暂停进程</h4>
<p><code>Ctrl</code>+<code>Z</code>可以生成一个SIGTSTP信号，停止shell运行的任何进程，停止进程（stopping）与终止（terminating）进程不同，停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 100</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 sleep 100</div></pre></td></tr></table></figure>
<p>结果中的方括号里的数字是shell分配的作业号（job number），shell将运行中的每个进程称为作为，并为每个作业分配有唯一的作业号，第一个作业分配的是作业号1，第二个是2。如果shell会话中有一个已经停止的作业，在退出shell时，bash会提醒用户，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 100</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 sleep 100</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ^C</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ exit</div><div class="line">exit</div><div class="line">There are stopped jobs.</div></pre></td></tr></table></figure>
<p>通过ps命令可以查看已经停止的作业，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ps -l</div><div class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">0 S  1000  10009  10002  0  80   0 -  5700 wait   pts/4    00:00:01 bash</div><div class="line">0 T  1000  28664  10009  0  80   0 -  1822 signal pts/4    00:00:00 sleep</div><div class="line">0 R  1000  28674  10009  0  80   0 -  7229 -      pts/4    00:00:00 ps</div></pre></td></tr></table></figure>
<p>在S列（进程状态），ps命令将已经停止作业的状态显示为T，这说明命令要么被跟踪，要么被停止了。如果在有已停止作业存在的情况下，你仍旧想退出shell，只要再输入一遍 exit 命令就行了。shell会退出，终止已停止作业。或者，既然你已经知道了已停止作业的PID，就可以用 kill 命令来发送一个 SIGKILL 信号来终止它(-9表示强迫终止）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ kill -9 28664</div><div class="line">[1]+  Killed                  sleep 100</div></pre></td></tr></table></figure>
<h3 id="捕获信号">捕获信号</h3>
<p>在信号出现时捕获它们并执行其他命令时用<code>trap</code>，此命令可以指定shell脚本要监视并从shell中拦截的Linux信号，如果脚本收到了trap命令中列出的信号，此信号不再由shell处理，则是交给本地处理，trap的用法为<code>trap commands signals</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing signla trapping</div><div class="line"></div><div class="line">trap "echo ' Sorry! I have trapped Ctrl-C'" SIGINT</div><div class="line"></div><div class="line">echo This is a test script</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">echo "This is the end of the test script"</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test1.sh </div><div class="line">This is a test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #6</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #7</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #8</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #9</div><div class="line">Loop #10</div><div class="line">This is the end of the test script</div></pre></td></tr></table></figure>
<p>在这个案例中，使用了trap命令，在检测到SIGINT信号时，就会显示一行简单的文本消息，捕获这些信号会阻止用户使用bash shell组合键<code>Ctrl</code>+<code>C</code>来停止程序。也就是说每次使用组合键<code>Ctrl</code>+<code>C</code>时，脚本就都会执行<code>trap</code>命令中指定的<code>echo</code>语句，而不是处理该信号并允许shell停止该脚本。</p>
<h3 id="捕获脚本退出">捕获脚本退出</h3>
<p>shell脚本在退出时也能进行捕获，这是在shell完成任务时执行命令的一种简便方法，用法是在trap命令后加上EXIT信号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Trapping the script exit</div><div class="line"><span class="meta">#</span></div><div class="line">trap "echo Goodbye..." EXIT</div><div class="line"><span class="meta">#</span></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test2.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Goodbye...</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ bash test2.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">^CGoodbye...</div></pre></td></tr></table></figure>
<p>当脚本运行到正常的退出位置时，捕获就被触发了，shell会执行在trap命令行指定的命令。如果提前退出脚本，同样能够捕获到EXIT。这是因为SIGINT信号并没有出现在trap命令的捕获列表中，当按下Ctrl+C组合键发送SIGINT信号时，脚本就退出了。但在脚本退出前捕获到了EXIT，于是shell执行了trap命令。</p>
<h3 id="修改或移除捕获">修改或移除捕获</h3>
<p>要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Modifying a set trap</div><div class="line"></div><div class="line">trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">trap "echo 'I modified the trap!'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Second Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test3.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">^C Sorry...Ctrl-C is trapped.</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Second Loop #1</div><div class="line">^CI modified the trap!</div><div class="line">Second Loop #2</div><div class="line">Second Loop #3</div><div class="line">Second Loop #4</div><div class="line">Second Loop #5</div></pre></td></tr></table></figure>
<p>修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的 trap 命令进行处理。 也可以删除已设置好的捕获。只需要在 trap 命令与希望恢复默认行为的信号列表之间加上两个破折号就行了。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> removing a set trap</div><div class="line"></div><div class="line">trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">   echo "Loop #$count"</div><div class="line">   sleep 1</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span> Remove the trap</div><div class="line">trap -- SIGINT</div><div class="line">echo "I just removed the trap"</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">   echo "Second Loop #$count"</div><div class="line">   sleep 1</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test3b.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">^C Sorry...Ctrl-C is trapped.</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">I just removed the trap</div><div class="line">Second Loop #1</div><div class="line">Second Loop #2</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>移除信号捕获后，脚本按照默认行为来处理 SIGINT 信号，也就是终止脚本运行。但如果信号是在捕获被移除前接收到的，那么脚本会按照原先 trap 命令中的设置进行处理。 在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，脚本会照旧执行 trap 中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。</p>
<h2 id="后台模式运行脚本">后台模式运行脚本</h2>
<p>有些脚本不会在终端的显示器上显示，而是在后台（background）运行，在后台模式中，进行运行不会与STDIN、STDOUT以及STDERR发生关联。</p>
<h3 id="后台运行脚本">后台运行脚本</h3>
<p>打开后台模式运行脚本霜肆在脚本后面添加上<code>&amp;</code>符号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> test running in the background</div><div class="line"><span class="meta">#</span></div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count + 1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test4.sh &amp;</div><div class="line">[1] 28920</div><div class="line">biotest@ubuntu:~/signal$ ps </div><div class="line">   PID TTY          TIME CMD</div><div class="line"> 10009 pts/4    00:00:01 bash</div><div class="line"> 28920 pts/4    00:00:00 bash</div><div class="line"> 28923 pts/4    00:00:00 sleep</div><div class="line"> 28924 pts/4    00:00:00 ps</div><div class="line"> </div><div class="line"> # 按回车键</div><div class="line"> biotest@ubuntu:~/signal$ </div><div class="line">[1]+  Done                    bash test4.sh</div></pre></td></tr></table></figure>
<p>从结果可以看出，当 &amp; 符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后 台进程运行。显示的第一行是[1] 28920，其中[1]是shell分配给后台进程的作业号。28920是进程号。在运行结束后，按回车键，脚本会在终端显示消息（<code>[1]+ Done...</code>），就是结果的最后一部分，这表明了作业的作业号以及作业状态（Done）。当脚本在后台运行时，它仍然会使用终端显示器来显示STDOUT和STDERR，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Test running in the background with output</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span></div><div class="line">echo "Start the test script"</div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 5</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"><span class="meta">#</span></div><div class="line">echo "Test script is complete"</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test5.sh &amp;</div><div class="line">[1] 28986</div><div class="line">biotest@ubuntu:~/signal$ Start the test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Test script is complete</div><div class="line"></div><div class="line">[1]+  Done                    bash test5.sh</div></pre></td></tr></table></figure>
<p>在这个案例中，脚本test5.sh的输出与shell提示符混杂在一歧异，这也是为什么Start the test script会出现在提示符普边的原因。在显示输出的同时，仍然可以运行命令，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ Start the test script</div><div class="line">Loop #1</div><div class="line">ls</div><div class="line">test1.sh  test2.sh  test3b.sh  test3.sh  test4.sh  test5.sh</div></pre></td></tr></table></figure>
<p>当脚本test5.sh运行在后台模式时，输入了命令ls。脚本输出、输入的命令以及命令输出全都混在了一起。针对这种情况，最好是将后台运行的脚本的STDOUT和STDERR进行重定向，避免这种杂乱的输出。</p>
<h3 id="运行多个后台作业">运行多个后台作业</h3>
<p>可以在命令行提示符下同时启动多个后台作业，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test6.sh &amp;</div><div class="line">[2] 29019</div><div class="line">[1]   Done                    bash test5.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test6.sh: No such file or directory</div><div class="line">bash test7.sh &amp;</div><div class="line">[3] 29020</div><div class="line">[2]   Exit 127                bash test6.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test7.sh: No such file or directory</div><div class="line">bash test8.sh &amp;</div><div class="line">[4] 29021</div><div class="line">[3]   Exit 127                bash test7.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test8.sh: No such file or directory</div><div class="line">ps</div><div class="line">   PID TTY          TIME CMD</div><div class="line"> 10009 pts/4    00:00:01 bash</div><div class="line"> 29022 pts/4    00:00:00 ps</div><div class="line">[4]+  Exit 127                bash test8.sh</div></pre></td></tr></table></figure>
<p>每次启动新作业时，Linux系统都会为其分配一个新的作业号和PID。通过 ps 命令，可以看到所有脚本处于运行状态。 在终端会话中使用后台进程时一定要小心。注意，在ps命令的输出中，每一个后台进程都和终端会话（pts/0）终端联系在一起。如果终端会话退出，那么后台进程也会随之退出。</p>
<h2 id="nohup命令">nohup命令</h2>
<p>在有些情况下，用户会终端会话中启动shell脚本，即使退出了终端会话，脚本也会一直在后台模式运行，直到结束。这可以用nohup命令来实现。nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会话时阻止进程退出。nohup命令的格式为<code>nohup commands &amp;</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nohup bash test1.sh &amp;</div><div class="line">[1] 29325</div><div class="line">biotest@ubuntu:~/signal$ nohup: ignoring input and appending output to 'nohup.out'</div></pre></td></tr></table></figure>
<p>shell会给命令分配一个作业号，Linux系统会为其分配一个PID号。与shell中的普通进程相比，区 别在于，当使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号。 由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。 为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为 nohup.out的文件中。如果使用nohup运行了另一个命令，该命令的输出会被追加到已有的nohup.out文件中。因此，当运行位于同一个目录中的多个命令时一定要小心，因为所有的输出都会被发送到同一个nohup.out文件中，结果会让人摸不清头脑。</p>
<p>nohup.out文件包含了通常会发送到终端显示器上的所有输出。在进程完成运行后，你可以查 看nohup.out文件中的输出结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ ls</div><div class="line">nohup.out  test1.sh  test2.sh  test3b.sh  test3.sh  test4.sh  test5.sh</div><div class="line">biotest@ubuntu:~/signal$ cat nohup.out </div><div class="line">This is a test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Loop #6</div><div class="line">Loop #7</div><div class="line">Loop #8</div><div class="line">Loop #9</div><div class="line">Loop #10</div><div class="line">This is the end of the test script</div></pre></td></tr></table></figure>
<h2 id="作业控制">作业控制</h2>
<p>在作业停止后，Linux系统会让用户选择是终止还是重启。用户可以用kill命令终止该进程。要重启停止的进程需要向其发送一个SIGCONT信号。启动、停止、终止以及恢复作业的这些功能统称为<strong>作业控制</strong>。通过作业控制，就能完全控制shell环境中所有进程的运行方式。</p>
<h3 id="查看作业">查看作业</h3>
<p>查看作业的命令是<code>jobs</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> test job control</div><div class="line"></div><div class="line">echo "Script process ID: $$"</div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 10</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "End of script ..."</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh</div><div class="line">Script process ID: 29360</div><div class="line">Loop #1</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10.out &amp;</div><div class="line">[2] 29364</div><div class="line">biotest@ubuntu:~/signal$ jobs</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line">[2]-  Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[1]+ 29360 Stopped                 bash test10.sh</div><div class="line">[2]- 29364 Running                 bash test10.sh &gt; test10.out &amp;</div></pre></td></tr></table></figure>
<p>代码及结果解释：脚本使用<code>$$</code>变量业显示Linux系统分配给此脚本的PID，然后进入循环，每次迭代都休眠10秒，可以从命令行中启动脚本，然后使用<code>Ctrl</code>+<code>Z</code>停止脚本。随后又使用了<code>&amp;</code>操作将另外一个作用设为后台进程启动，出于简化目的，在这个案例中，脚本的输出被重定向到文件中，避免出现在屏幕上。<code>jobs</code>命令可以查看分配给Shell的作用，jobs命令显示了2个已经停止/运行中的作用，以及它们的作业号和作业中使用的命令。如果使用<code>job -l</code>则会业显示作用的PID，有关jobs命令的一些参数，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-l</td>
<td>列出进程的PID以及作业号</td>
</tr>
<tr class="even">
<td>-n</td>
<td>只列出上次shell发出的通知后改变了状态的作业</td>
</tr>
<tr class="odd">
<td>-p</td>
<td>只列出作业的PID</td>
</tr>
<tr class="even">
<td>-r</td>
<td>只列出运行中的作业</td>
</tr>
<tr class="odd">
<td>-s</td>
<td>只列出已停止的作业</td>
</tr>
</tbody>
</table>
<p>jobs命令输出中有加号和减号。带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候，不管shell中有多少个正在运行的作业，shell中都只有一个带加号的作业和一个带减号的作业。</p>
<p>下面例子说明了队列中的下一个作业在默认作业移除时是如何成为默认作业的。有3个独立的进程在后台被启动。jobs命令显示出了这些进程、进程的PID及其状态。注意，默认进程（带有加号的那个）是最后启动的那个进程，也就是3号作业。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10a.out &amp;</div><div class="line">[2] 29402</div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10.out &amp;</div><div class="line">[3] 29404</div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10c.out &amp;</div><div class="line">[4] 29409</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[2]+ 29402 Running                 bash test10.sh &gt; test10a.out &amp;</div><div class="line">[3]  29404 Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">[4]- 29409 Running                 bash test10.sh &gt; test10c.out &amp;</div><div class="line">biotest@ubuntu:~/signal$ kill 29402</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[3]+ 29404 Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">[4]- 29409 Terminated              bash test10.sh &gt; test10c.out</div><div class="line">biotest@ubuntu:~/signal$ kill 29404</div><div class="line"><span class="meta">#</span> 调用了 kill 命令向默认进程发送了一个 SIGHUP 信号，终止了该作业。在接下来的 jobs</div><div class="line"><span class="meta">#</span> 命令输出中，先前带有减号的作业成了现在的默认作业，减号也变成了加号。</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[3]+ 29409 Terminated              bash test10.sh &gt; test10.out</div></pre></td></tr></table></figure>
<h3 id="重启停止的作业">重启停止的作业</h3>
<p>在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你当前工作的终端，所以在使用该功能时要小心，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh</div><div class="line">Script process ID: 29612</div><div class="line">Loop #1</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line">biotest@ubuntu:~/signal$ bg</div><div class="line">[1]+ bash test10.sh &amp;</div><div class="line">biotest@ubuntu:~/signal$ jobs</div><div class="line">[1]+  Running                 bash test10.sh &amp;</div></pre></td></tr></table></figure>
<p>因为该作业是默认作业（从加号可以看出），只需要使用bg命令就可以将其以后台模式重启。 注意，当作业被转入后台模式时，并不会列出其PID。如果有多个作业，需要在<code>bg</code>命令后加上作业号，如果要以前台模式恢复运行，则用<code>fg</code>加上作业号。</p>
<h2 id="调整优先级">　调整优先级</h2>
<p>在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。调度优先级是个整数值，从20（最高优先级）到+19（最低优先级）。默认情况下，bashshell以优先级0来启动所有进程。</p>
<p>有时用户要改变一个shell脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他 进程过多的处理能力），还是给予它更高的优先级（这样它就能获得更多的处理时间），都可以通过<code>nice</code>这个命令达到目的。</p>
<h3 id="nice命令">nice命令</h3>
<p>nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice的-n命令行来指定新的优先级级别。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -n 10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[2] 29646</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29646 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line">[2]-  Done                    nice -n 10 bash test4.sh &gt; test4.out</div></pre></td></tr></table></figure>
<p>注意，必须将nice命令和要启动的命令放在同一行中。ps命令的输出验证了谦让度值（NI列）已经被调整到了10。</p>
<p>nice命令会让脚本以更低的优先级运行。但如果想提高某个命令的优先级，普通用户则无法实现,如下所示:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -n -10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[2] 29677</div><div class="line">biotest@ubuntu:~/signal$ nice: cannot set niceness: Permission denied</div></pre></td></tr></table></figure>
<p>nice命令阻止普通系统用户来提高命令的优先级。注意，指定的作业的确运行了，但是试图使用nice命令提高其优先级的操作却失败了,这很好,理解计算机的资源是有限有，用户可以将自己的作业推后，但是你不能提前。nice命令的-n选项并不是必须的，只需要在破折号后面跟上优先级就行了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[3] 29691</div><div class="line">[2]   Done                    nice -n -10 bash test4.sh &gt; test4.out</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29691 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line">[3]-  Done                    nice -10 bash test4.sh &gt; test4.out</div></pre></td></tr></table></figure>
<h3 id="renice命令">renice命令</h3>
<p><code>renice</code>命令可以改变系统上已经运行命令的优先级，它允许用户指定运行进程的PID来改变它的优先级，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &amp;</div><div class="line">[2] 29718</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29718 -o pid,Loop #3</div><div class="line">ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line"> 29718  10009   0 bash test10.sh</div><div class="line">biotest@ubuntu:~/signal$ renice -n 10 -p 29718</div><div class="line">29718 (process ID) old priority 0, new priority 10</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29718 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line"> 29718  10009  10 bash test10.sh</div></pre></td></tr></table></figure>
<p>renice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一些限制：第一，只能对属于用户自身的进程执行renice；只能通过renice降低进程的优先级；root用户可以通过renice来任意调整进程的优先级。如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令。</p>
<h2 id="定时运行作业">定时运行作业</h2>
<p><code>at</code>命令和<code>cron</code>表可以指定用户在某个时间运行脚本。</p>
<h3 id="at命令"><code>at</code>命令</h3>
<p>at命令允许指定Linux系统何时运行脚本。at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程atd会以后台模式运行，检查作业队列来运行作业。atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下，atd守护进程会每60秒检查一下这个目录。有作业时，atd守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配，atd守护进程就会运行此作业。</p>
<h4 id="at命令的格式">at命令的格式</h4>
<p>at命令的格式at命令的基本格式为：<code>at [-f filename ] time</code></p>
<p>默认情况下，at命令会将STDIN的输入放到队列中。用户可以用-f参数来指定用于读取命令（脚本文件）的文件名。time参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过，at命令会在第二天的那个时间运行指定的作业。at命令能识别多种不同的时间格式。</p>
<ol style="list-style-type: decimal">
<li>标准的小时和分钟格式，比如10:15。</li>
<li>AM/PM指示符，比如10:15 PM。</li>
<li>特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。 除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。</li>
<li>标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。</li>
<li>文本日期，比如Jul 4或Dec 25，加不加年份均可。</li>
<li>可以指定时间增量（例如当前时间+25min；明天10:15 PM；10:15 + 7days）。</li>
</ol>
<p>在使用at命令时，该作业会被提交到作业队列（jobqueue）。作业队列会保存通过at命令提交的待处理的作业。针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a<sub>z和大写字母A</sub>Z来指代。作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的作业会被提交到a作业队列。如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。</p>
<h4 id="获取作业的输出">获取作业的输出</h4>
<p>当作业在Linux系统上运行时，显示器并不会关联到该作业。取而代之的是，Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给该用户。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>注：Ubuntu上可能没有安装<code>at</code>，需要自己手动安装。at命令会显示分配给作业的作业号以及为作业安排的运行时间。-f选项指明使用哪个脚本 文件，now指示at命令立刻执行该脚本。</p>
<p>使用e-mail作为at命令的输出极其不便。at命令利用sendmail应用程序来发送邮件。如果你的系统中没有安装sendmail，那就无法获得任何输出，因此在使用at命令时，最好在脚本中对STDOUT和STDERR进行重定向，如下例所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Test using at command</div><div class="line"></div><div class="line">echo "This script ran at $(date +%B%d,%T)" &gt; test13b.out</div><div class="line">echo &gt;&gt; test13b.out</div><div class="line">sleep 5</div><div class="line">echo "This is the script's end ..." &gt;&gt; test13b.out</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ chmod u+x test13b.sh</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh now</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 3 at Sun May  6 05:10:00 2018</div><div class="line">biotest@ubuntu:~/signal$ cat test13b.out</div><div class="line">This script ran at May06,05:10:51</div><div class="line"></div><div class="line">This is the script's end ...</div></pre></td></tr></table></figure>
<p>如果不想在at命令中使用邮件或重定向，最好加上-M选项来屏蔽作业产生的输出信息。</p>
<h4 id="列出等待的作业">列出等待的作业</h4>
<p>atq命令可以查看系统中有哪些作业在等待，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh teatime</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 4 at Sun May  6 16:00:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh tomorrow</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 5 at Mon May  7 05:16:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh 13:30</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 6 at Sun May  6 13:30:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh now</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 7 at Sun May  6 05:16:00 2018</div><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">2	Sun May  6 05:06:00 2018 = biotest</div><div class="line">7	Sun May  6 05:16:00 2018 = biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div></pre></td></tr></table></figure>
<p>作业列表中显示了作业号、系统运行该作业的日期和时间及其所在的作业队列。</p>
<h4 id="删除作业">删除作业</h4>
<p>一旦知道了哪些作业在作业队列中等待，就能用 atrm 命令来删除等待中的作业。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">2	Sun May  6 05:06:00 2018 = biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div><div class="line">biotest@ubuntu:~/signal$ atrm 2</div><div class="line">Warning: deleting running job</div><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div></pre></td></tr></table></figure>
<h3 id="cron时间表">cron时间表</h3>
<p>如果用户需要脚本在每天的同一时间运行或是每周一次、每月一次运行，就要使用cron程序来安排要定期执行的作业。cron程序会在后台运行并检查一个特殊的表（被称作cron时间表），以获知已安排执行的作业。</p>
<h4 id="cron时间表-1">cron时间表</h4>
<ol style="list-style-type: decimal">
<li>cron时间表采用一种特别的格式来指定作业何时运行。其格式为<code>min hour dayofmonth month dayofweek command</code>，cron时间表允许你用特定值、取值范围（比如1~5）或者是通配符（星号）来指定条目。</li>
<li>例如，如果想在每天的10:15运行一个命令，可以用cron时间表条目：<code>15 10 * * * command</code>，在<code>dayofmonth</code>、<code>month</code>以及<code>dayofweek</code>字段中使用了通配符，表明cron会在每个月每天的10:15执行该命令。要指定在每周一4:15PM运行的命令，可以用这样的命令，即<code>15 16 * * 1 command</code>。</li>
<li>可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）来指定dayofweek表项。 再看一个例子，如果要在每个月的第一天中午12点执行命令。可以用这样的命令，即<code>00 12 1 * * command</code>，dayofmonth表项指定月份中的日期值（1~31）。</li>
<li>如何设置一个在每个月的最后一天执行的命令，因为无法设置dayofmonth的值来涵盖所有的月份。常用的方法是加一条使用date 命令的 if-then 语句来检查明天的日期是不是01，如下所示：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 12 * * * if [ ` date +%d -d tomorrow `  = 01 ] ; then ; command</div></pre></td></tr></table></figure>
<p>上述这段代码会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。</p>
<ol start="5" style="list-style-type: decimal">
<li>命令列表必须指定要运行的命令或脚本的全路径名。你可以像在普通的命令行中那样，添加任何想要的命令行参数和重定向符号。 <code>15 10 * * * /home/biotest/test4.sh &gt; test4out</code>，cron程序会用提交作业的用户账户运行该脚本。因此，用户必须有访问该命令和命令中指定的输出文件的权限。</li>
</ol>
<h4 id="构建cron时间表">构建cron时间表</h4>
<p>每个系统用户（包括root用户）都可以用自己的cron时间表来运行安排好的任务。Linux提供了crontab命令来处理cron时间表。要列出已有的cron时间表，可以用-l选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ crontab -l</div><div class="line">no crontab for biotest</div></pre></td></tr></table></figure>
<p>默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。 在添加条目时，crontab命令会启用一个文本编辑器，使用已有的cron时间表作为文件内容，如果时间表不存在的话，它会新建一个空文件。</p>
<h4 id="浏览cron目录">浏览cron目录</h4>
<p>如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个基本目录：hourly、daily、monthly和weekly。 Ubuntu无此目录，略过。</p>
<h4 id="anacron程序">anacron程序</h4>
<p>cron程序的唯一问题是它假定Linux系统是7×24小时运行的。如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问题，许多Linux发行版还包含了anacron程序。如果anacron知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果Linux系统关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行。这个功能常用于进行常规日志维护的脚本。如果系统在脚本应该运行的时间刚好关机，日志文件就不会被整理，可能会变很大。通过anacron，至少可以保证系统每次启动时整理日志文件。anacron程序只会处理位于cron目录的程序，比如/etc/cron.monthly。它用时间戳来决定作业是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/anacron，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ sudo cat /var/spool/anacron/cron.monthly</div><div class="line">[sudo] password for biotest: </div><div class="line">20180427</div></pre></td></tr></table></figure>
<p>anacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ sudo cat /etc/anacrontab </div><div class="line"><span class="meta">#</span> /etc/anacrontab: configuration file for anacron</div><div class="line"></div><div class="line"><span class="meta">#</span> See anacron(8) and anacrontab(5) for details.</div><div class="line"></div><div class="line">SHELL=/bin/sh</div><div class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">HOME=/root</div><div class="line">LOGNAME=root</div><div class="line"></div><div class="line"><span class="meta">#</span> These replace cron's entries</div><div class="line">1	5	cron.daily	run-parts --report /etc/cron.daily</div><div class="line">7	10	cron.weekly	run-parts --report /etc/cron.weekly</div><div class="line">@monthly	15	cron.monthly	run-parts --report /etc/cron.monthly</div></pre></td></tr></table></figure>
<p>anacron时间表的基本格式和cron时间表略有不同，前者的格式为<code>period delay identifier command。</code></p>
<p>period条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。command条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的任何脚本。注意，anacron不会运行位于/etc/cron.hourly的脚本。这是因为anacron程序不会处理执行时间需求小于一天的脚本。identifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误邮件中的作业。</p>
<h2 id="使用新-shell-启动脚本">使用新 shell 启动脚本</h2>
<p>如果每次运行脚本的时候都能够启动一个新的bashshell（即便只是某个用户启动了一个bashshell），将会非常的方便。有时候，用户希望为shell会话设置某些shell功能，或者只是为了确保已经设置了某个文件。用户登入bashshell时需要运行的启动文件基本上依照下列顺序所找到的第一个文件会被运行，其余的文件会被忽略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$HOME/.bash_profile </div><div class="line">$HOME/.bash_login </div><div class="line">$HOME/.profile</div></pre></td></tr></table></figure>
<p>因此，应该将需要在登录时运行的脚本放在上面第一个文件中。每次启动一个新shell时，bash shell都会运行.bashrc文件。可以这样来验证：在主目录下的.bashrc文件中加入一条简单的echo语句，然后启动一个新shell。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> source global definitions</div><div class="line">if [ -f /etc/bashrc ]; then</div><div class="line">          . /etc/bashrc</div><div class="line">fi</div><div class="line"><span class="meta">#</span> User specific aliases and functions</div><div class="line">echo "I'm in a new shell!"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash</div><div class="line">I&apos;m in a new shell!</div><div class="line">biotest@ubuntu:~$ exit</div><div class="line">exit</div></pre></td></tr></table></figure>
<p>.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是当你登入bashshell时，另一次是当你启动一个bashshell时。如果你需要一个脚本在两个时刻都得以运行，可以把这个脚本放进该文件中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/03/Linux-shell05-理解shell的重定向/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/Linux-shell05-理解shell的重定向/" itemprop="url">Shell学习笔记（5）——理解Shell的重定向</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T00:00:01+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,079
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解输入与输出">理解输入与输出</h2>
<p>脚本的两种显示方法就是：第一，在显示器屏幕上显示输出；第二，将输出重定向到文件。这篇笔记主要是理解Linux如何处理输入与输出的。</p>
<h3 id="标准文件描述符">标准文件描述符</h3>
<p>Linux系统将每个对象当作文件处理，这就包括了输入和输出过程，Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，每个进程最多可以有9个文件描述符，而bash shell保留了前3个文件描述符，即0、1和2。</p>
<table>
<thead>
<tr class="header">
<th>文件描述符</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr class="even">
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr class="odd">
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
<p>这三个特殊文件描述符会处理脚本中的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</p>
<h3 id="stdin">STDIN</h3>
<p>STDIN文件描述符代表了shell的标准输入，对于终端来说，标准输入就是键盘，shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上的键输入的。许多bash命令能接受STDIN的输入，尤其是在命令行上指定文件的话。下面看一下<code>cat</code>这个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat</div><div class="line">test cat command</div><div class="line">test cat command</div><div class="line">cat command can input from keyboard</div><div class="line">cat command can input from keyboard</div></pre></td></tr></table></figure>
<p>当在命令行上只输入<code>cat</code>时，它会从<code>STDIN</code>接受僌，输入一行，<code>cat</code>命令就会显示出一行。但也可以通过<code>STDIN</code>重定向符号强制<code>cat</code>命令接受来自另一个非<code>STDIN</code>文件的输入，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat testfile </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div><div class="line">biotest@ubuntu:~/input$ cat &lt; testfile </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div></pre></td></tr></table></figure>
<p>这个结果显示，cat命令会用testfile文件中的行作为输入。</p>
<h3 id="stdout">STDOUT</h3>
<p><code>STDOUT</code>文件描述符代表shell的标准输出。在终端界面上，标准输出应时终显示器。Shell的所有输出（包括shell文中运行的程序和脚本）会被定向到标准输出中，也就是显示器。默认情况下，大多数bash命令会将输出导向STDOUT文件描述符，也可以使用输出重定向来改变，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -l &gt; test2</div><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div></pre></td></tr></table></figure>
<p>使用<code>&gt;&gt;</code>符号可以向一个文件中追加数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div><div class="line">biotest@ubuntu:~/input$ who</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">biotest@ubuntu:~/input$ who &gt;&gt; test2</div><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div></pre></td></tr></table></figure>
<p>当某个主文件不存在时，无产进行重定向，但会生成要重定向的文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al badfile &gt; test3</div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">biotest@ubuntu:~/input$ cat test3</div></pre></td></tr></table></figure>
<p>由于不存在badfile文件，因此bash无法获取里面的信息，也无法将其信息重定向到test3，但是test3这个文件会被创建，只是里面是空的。</p>
<h3 id="stderr">STDERR</h3>
<p><code>STDERR</code>文件描述符被设成2，可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al badfile 2&gt; test3</div><div class="line">biotest@ubuntu:~/input$ cat test3</div><div class="line">ls: cannot access 'badfile': No such file or directory</div></pre></td></tr></table></figure>
<p>此时，错误消息不会出现在屏幕上，该命令生怕任何错误消息都会保存在输出文件中，用这种方法，shell只重定向错误消息，而非普通数据。下面的一个案例是将<code>STDOUT</code>和<code>STDERR</code>消息混杂在同一个输出中的例子，如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test badtest test2 2&gt; test5</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">biotest@ubuntu:~/input$ cat test5</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div></pre></td></tr></table></figure>
<p>ls命令的正常<code>STDOUT</code>输出仍然公改善到默认的<code>STDOUT</code>文件描述符，也就是显示器，由于该命令将文件描述符2的输出（<code>STDERR</code>）重定向到了一个输出文件，shell将生成的所有错误消息直接改善到指定的重定向文件中。</p>
<h4 id="重定向错误和数据">重定向错误和数据</h4>
<p>如果想重定向错误和正常输出，需要用2个重定向符号，需要在符号前放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</div><div class="line">biotest@ubuntu:~/input$ cat test6</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div><div class="line">biotest@ubuntu:~/input$ cat test7</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest  55 May  5 19:48 test3</div></pre></td></tr></table></figure>
<p>在这个案例中，shell利用<code>1&gt;</code>符号将ls命令的正常输出重定向到了<code>test7</code>文件，而这些输出本该是进入<code>STDOUT</code>的。所有本该输出到<code>STDERR</code>的错误消息通过<code>2&gt;</code>符号被重定向到了<code>test6</code>文件。 这种方法哦可以将脚本的正常输出和脚本的错误消息分离开来。</p>
<p>除此之外，还可以将<code>STDERR</code>和<code>STDOUT</code>的输出重定向到同一个输出文件，可以使用特殊的重定向符号<code>$&gt;</code>，如下所示：：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test test2 test3 badtest &amp;&gt; test7</div><div class="line">biotest@ubuntu:~/input$ cat test7</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest  55 May  5 19:48 test3</div></pre></td></tr></table></figure>
<p>当使用<code>&amp;&gt;</code>符号哩主，命令生成的所有输出都会改善到同一位置，包括数据和错误。bash shell会自动赋予错误消息更高的优先级，在输出文件的最开头部分显示错误消息。</p>
<h2 id="在脚本中重定向输出">在脚本中重定向输出</h2>
<p>有2种方法在脚本中重定向输出，第一，临时重定向行输出；第二，永久重定向脚本中的所有命令。</p>
<h3 id="临时重定向">临时重定向</h3>
<p>如果脚本中意外生成错误消息，可以将单独的一行输出重定向到<code>STDERR</code>，在重定向到文件描述符时，需要在文件描述符前面添加一具<code>&amp;</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing STDERR messages</div><div class="line"></div><div class="line">echo "This is an error" &gt;&amp;2</div><div class="line">echo "This is normal output"</div></pre></td></tr></table></figure>
<p>运行过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test8.sh</div><div class="line">biotest@ubuntu:~/input$ ./test8.sh</div><div class="line">This is an error</div><div class="line">This is normal output</div><div class="line">biotest@ubuntu:~/input$ ./test8.sh 2&gt;test9</div><div class="line">This is normal output</div><div class="line">biotest@ubuntu:~/input$ cat test9</div><div class="line">This is an error</div></pre></td></tr></table></figure>
<p>从结果可以看出，STDOUT显示的文件会出现在屏幕上，而发送给STDERR的echo语句的文本则被重定向到了输出文件。这个方便适合在脚本中生成错误的消息。</p>
<h3 id="永久重定向">永久重定向</h3>
<p>如果脚本中有大量数据需要重定向，则可以使用<code>exec</code>命令告诉shell脚本执行期间重定向某个特定文件的描述符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting all output to a file</div><div class="line">exec 1&gt; testout</div><div class="line"></div><div class="line">echo "This is a test of redirecting all output"</div><div class="line">echo "from a script to another file."</div><div class="line">echo "without having to redirect every individual line"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test10.sh</div><div class="line">biotest@ubuntu:~/input$ ./test10.sh</div><div class="line">biotest@ubuntu:~/input$ cat testout</div><div class="line">This is a test of redirecting all output</div><div class="line">from a script to another file.</div></pre></td></tr></table></figure>
<p><code>exec</code>命令会启动一个新的shell，并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。可以在脚本执行过程中重定向STDOUT，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting output to different locatons</div><div class="line"></div><div class="line">exec 2&gt; testerror</div><div class="line"></div><div class="line">echo "This is the start of the script"</div><div class="line">echo "now redirecting all output to another location"</div><div class="line"></div><div class="line">exec 1&gt; testout</div><div class="line"></div><div class="line">echo "THis output should go to the testout file"</div><div class="line">echo "but this should go to the testerror file" &gt;&amp;2</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test11.sh</div><div class="line">biotest@ubuntu:~/input$ ./test11.sh</div><div class="line">This is the start of the script</div><div class="line">now redirecting all output to another location</div><div class="line">biotest@ubuntu:~/input$ cat testerror</div><div class="line">but this should go to the testerror file</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将发给STDERR的输出重定向到了文件testerror，接下来，脚本用echo语句向STDOUT显示了几行文本，随后再次使用exec命令来将STDOUT重定向到了testout文件，虽然STDOUT被重定向了，但仍然可以将echo语句的输出发给STDERR，在此案例中，重定向到了testerror文件。</p>
<h2 id="在脚本中重定向输入">在脚本中重定向输入</h2>
<p>在脚本中可以使用与重向STDOUT和STDERR同样的方法来将STDIN从键盘重定向到其他位置。exec命令可以将STDIN重定向到linux系统上的文件中，用法是<code>exec 0&lt; testfile</code>，这个命令会告诉shell应该从文件testfile中获得输入，而不是<code>STDIN</code>，这个重定向只要在脚本需要输入时就会作用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting fiel input</div><div class="line"></div><div class="line">exec 0&lt; testfile</div><div class="line">count=1</div><div class="line"></div><div class="line">while read line</div><div class="line">do</div><div class="line">    echo "Line #$count: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test12.sh</div><div class="line">biotest@ubuntu:~/input$ ./test12.sh</div><div class="line">Line #1: This is the first line.</div><div class="line">Line #2: This is the second line.</div><div class="line">Line #3: This is the third line.</div></pre></td></tr></table></figure>
<p>将<code>STDIN</code>重定向到文件后，当read命令试图从STDIN读入数据时，它会到文件中去读取数据，而不是键盘。</p>
<h2 id="创建自己的重定向">创建自己的重定向</h2>
<p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符（即0，1和2）。shell中最多可以有9个打开的文件描述符。其他6个从 3 ~ 8 的文件描述符均可用作输入或输出重定向。用户可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>
<h3 id="创建输出文件描述符">创建输出文件描述符</h3>
<p>exec 命令可以给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using an alternative file descriptor</div><div class="line"></div><div class="line">exec 3&gt;test13out</div><div class="line"></div><div class="line">echo "This should display on the monitor"</div><div class="line">echo "and this should be stored in the file" &gt;&amp;3</div><div class="line">echo "Then this shold be back on the monitor"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test13.sh</div><div class="line">biotest@ubuntu:~/input$ ./test13.sh</div><div class="line"></div><div class="line">This should display on the monitor</div><div class="line">Then this shold be back on the monitor</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat test13out</div><div class="line">and this should be stored in the file</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内容会像预想中那样显示在STDOUT 上。但你重定向到文件描述符3 的那行echo语句的输出却进入了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如日志文件）。 也可以不用创建文件，使用exec命令来将输出追加到现有文件早，例如<code>exec 3&gt;&gt; test13out</code>。</p>
<h3 id="重定向文件描述符">重定向文件描述符</h3>
<p>看一个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> storing STDOUT, then coming back to it</div><div class="line"></div><div class="line">exec 3&gt;&amp;1 # 将文件描述符3重定向到文件描述符1的位置，也就是STDOUT，这意味着任何发送给文件描述符3的输出都将会出现在显示器上</div><div class="line"></div><div class="line">exec 1&gt; test14out # 将STDOUT重定向到文件，shell现在会将改善给STDOUT的输出直接重定向到输出文件上，但文件描述符3仍然指向STDOUT原来的位置，也就是显示器，如果此时将输出数据改善给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了</div><div class="line"></div><div class="line">echo "This should store in the output file"</div><div class="line">echo "along with this line."</div><div class="line"></div><div class="line">exec 1&gt;&amp;3</div><div class="line"><span class="meta">#</span> 在向STDOUT发送一些输出后，脚本将STDOUT重定向到文件描述符3的当前位置（显示器），这意味着现在STDOUT又指向了原来的位置，即显示器</div><div class="line"></div><div class="line">echo "Now things should be back to normal"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test14.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test14.sh </div><div class="line">Now things should be back to normal</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat test14out </div><div class="line">This should store in the output file</div><div class="line">along with this line.</div></pre></td></tr></table></figure>
<h3 id="创建输入文件描述符">创建输入文件描述符</h3>
<p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将 STDIN 文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将 STDIN 恢复到它原来的位置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting input file descriptors</div><div class="line"></div><div class="line">exec 6&lt;&amp;0</div><div class="line"></div><div class="line">exec 0&lt; testfile</div><div class="line"></div><div class="line">count=1</div><div class="line">while read line </div><div class="line">do</div><div class="line">    echo "Line #$cont: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">exec 0&lt;&amp;6</div><div class="line">read -p "Are you done now " answer</div><div class="line">case $answer in </div><div class="line">Y|y) echo "Goodbye";;</div><div class="line">N|n) echo "Sorry, this is the end.";;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test15.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test15.sh</div><div class="line">Line #: This is the first line.</div><div class="line">Line #: This is the second line.</div><div class="line">Line #: This is the third line.</div><div class="line">Are you done now Y</div><div class="line">Goodbye</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test15.sh</div><div class="line">Line #: This is the first line.</div><div class="line">Line #: This is the second line.</div><div class="line">Line #: This is the third line.</div><div class="line">Are you done now n</div><div class="line">Sorry, this is the end.</div></pre></td></tr></table></figure>
<p>在这个案例中，文件描述符6用来保存STDIN的位置，然后脚本将STDIN重定向到一个文件，read命令的所有输入都来自重定向后的STDIN（也就是输入文件），在读取了所有行之后，脚本将STDIN重定向到文件描述符6，从而将STDIN恢复到原来的位置，该脚本用了另外一个read命令来测试STDIN是否恢复正常，这将它等待键盘的输入。</p>
<h3 id="创建读写文件描述符">创建读写文件描述符</h3>
<p>在bash shell中，可以打开单个文件描述符来作为输入和输出，可以用一个文件描述符对同一个文件进行读写，不过使用这种方法需要谨慎，由于用户是对一个文件进行数据读写，shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始，如果不够小心，会生成严重的后果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing input/output file descriptor</div><div class="line"></div><div class="line">exec 3&lt;&gt; testfile</div><div class="line">read line &lt;&amp;3</div><div class="line">echo "Read: $line"</div><div class="line">echo "This is a test line" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test16.sh </div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test16.sh</div><div class="line">Read: This is the first line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is a test line</div><div class="line">ine.</div><div class="line">This is the third line.</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将文件描述符分配文件testfile以进行文件读写，接下来，通过使用分配好的文件描述符，使read命令读取文件中的第一行，然后将这一行显示在STDOUT上，最后使用echo语句将一行数据写入由同一个文件描述符打开的文件中。在运行结果中，开始运行正常，输出内容表明脚本读取了testfile文件中的第一行，如果脚本运行完毕，查看testfile文件时发现，写入文件中的数据覆盖了已有的数据。原因是，当脚本向中文件中写入数据时，它会从文件指针所处的位置开始，read命令读取了第一行数据，所以它使得文件指针指向了第二行数据的第一个字符，在echo语句将数据输出到文件时，它会将数据放在文件指针的当前位置，覆盖了该位置的已有数据。</p>
<h3 id="关闭文件描述符">关闭文件描述符</h3>
<p>如果用户创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们，有些情况下需要在脚本关闭之前手动关闭文件描述符，要关闭文件描述符，将它重定向到特殊符号<code>&amp;-</code>，在脚本中是这样的<code>exec 3&gt;&amp;-</code>，这条语句会关闭文件描述符3，不再脚本中使用它，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing closing file descriptors</div><div class="line"></div><div class="line">exec 3&gt; tets17file</div><div class="line"></div><div class="line">echo "This is a test line of data " &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">echo "This won't work" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash badtest2.sh </div><div class="line">badtest2.sh: line 9: 3: Bad file descriptor</div></pre></td></tr></table></figure>
<p>一旦关闭了文件描述符，就无法在脚本中写入任何数据，否则shell会生成错误消息。在关闭文件描述符时还需要注意，如果在随后的脚本中打开了同一个输出文件，shell会用一个新文件来替换已有的文件，这就意味着，如果输出数据，它就会覆盖已有鹰爪，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing closing file descriptors</div><div class="line"></div><div class="line">exec 3&gt; test17file</div><div class="line">echo "This is a test line of test" &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">cat test17file</div><div class="line"></div><div class="line">exec 3&gt;test17file</div><div class="line">echo "This will be bad" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test17.sh</div><div class="line">This is a test line of test</div><div class="line">biotest@ubuntu:~/input$ cat test17file</div><div class="line">This will be bad</div></pre></td></tr></table></figure>
<p>在向test17file文件发送一个数据字符串并关闭该文件描述符之后，脚本用了 cat 命令来显示文件的内容。下一步，脚本重新打开了该输出文件并向它发送了另一个数据字符串。当显示该输出文件的内容时，你所能看到的只有第二个数据字符串。shell覆盖了原来的输出文件。</p>
<h2 id="列出打开的文件描述符">列出打开的文件描述符</h2>
<p>bash shell中有一个<code>lsof</code>命令，这个命令会列出整个Linux系统打开的所有文件描述符，<code>lsof</code>命令位于<code>/usr/sbin</code>目录中，这个命令会产生大量的输出，它会显示Linux系统中打开的每个文件的有产信息，这包括后台运行的所有进程，以及登录到系统的任何用户。<code>lsof</code>有各种命令选项和参数可以使用，最常用的是<code>-p</code>和<code>-d</code>，前者用于指定进程ID（即PID），后者用于指定显示的文件描述符编号，如果要知道进程的当前PID，可以使用特殊的环境变量<code>$$</code>（shell会将它设为当前PID），<code>-a</code>选项用来对其他两个选项的结果执行布尔<code>AND</code>运算，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ lsof -a -p $$ -d 0,1,2</div><div class="line">COMMAND   PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</div><div class="line">bash    10009 biotest    0u   CHR  136,4      0t0    7 /dev/pts/4</div><div class="line">bash    10009 biotest    1u   CHR  136,4      0t0    7 /dev/pts/4</div><div class="line">bash    10009 biotest    2u   CHR  136,4      0t0    7 /dev/pts/4</div></pre></td></tr></table></figure>
<p>结果显示了当前进程的国俯文件描述符（0、1和2），lsof的默认输出有7列信息，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COMMAND</td>
<td>正在运行的命令名的前9个字符</td>
</tr>
<tr class="even">
<td>PID</td>
<td>进程的PID</td>
</tr>
<tr class="odd">
<td>USER</td>
<td>进程属主的登录名</td>
</tr>
<tr class="even">
<td>FD</td>
<td>文件描述符号以及访问类型（r代表读，w代表写，u代表读写）</td>
</tr>
<tr class="odd">
<td>TYPE</td>
<td>文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）</td>
</tr>
<tr class="even">
<td>DEVICE</td>
<td>设备的设备号（主设备号和从设备号）</td>
</tr>
<tr class="odd">
<td>SIZE</td>
<td>如果有的话，表示文件的大小</td>
</tr>
<tr class="even">
<td>NODE</td>
<td>本地文件的节点号</td>
</tr>
<tr class="odd">
<td>NAME</td>
<td>文件名</td>
</tr>
</tbody>
</table>
<p>与 STDIN 、 STDOUT 和 STDERR 关联的文件类型是字符型。因为 STDIN 、 STDOUT 和 STDERR 文 件描述符都指向终端，所以输出文件的名称就是终端的设备名。现在看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing lsof with file descriptors</div><div class="line"></div><div class="line">exec 3&gt; test18file1</div><div class="line">exec 6&gt; test18file2</div><div class="line">exec 7&lt; testfile</div><div class="line"></div><div class="line">lsof -a -p $$ -d0,1,2,3,6,7</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test18.sh</div><div class="line">COMMAND   PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</div><div class="line">bash    28264 biotest    0u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    1u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    2u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    3w   REG    8,1        0 928519 /home/biotest/input/test18file1</div><div class="line">bash    28264 biotest    6w   REG    8,1        0 928521 /home/biotest/input/test18file2</div><div class="line">bash    28264 biotest    7r   REG    8,1       73 928491 /home/biotest/input/testfile</div></pre></td></tr></table></figure>
<p>这个脚本创建了3个替代性文件描述符，两个是输出（3和6），一个是输入（7），在脚本运行了<code>lsof</code>命令时，可以在输出中看到新的文件描述符，如果去掉输出中的第一部分，就会看到文件名的结果，文件名显示了文件描述符所使用的文件的完整路径名，它将每个文件都显示成了REG类型，这就说明它们是文件系统中的常规文件。</p>
<h2 id="阻止命令输出">阻止命令输出</h2>
<p>有些情况下，用户不想显示脚本的输出。这在将脚本作为后台进程运行时很常见，如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al &gt; /dev/null</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null</div><div class="line">biotest@ubuntu:~/input$ ls -al badfile2 test16.sh 2&gt; /dev/null</div><div class="line">-rwxrw-r-- 1 biotest biotest 135 May  5 23:28 test16.sh</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null</div><div class="line">biotest@ubuntu:~/input$</div></pre></td></tr></table></figure>
<p>也可以在输入重定向中将<code>dev/null</code>作为输入文件，由于<code>dev/null</code>文件不含有任何内容，用户通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is a test line</div><div class="line">ine.</div><div class="line">This is the third line.</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null &gt; testfile</div><div class="line">biotest@ubuntu:~/input$ cat testfile</div></pre></td></tr></table></figure>
<p>文件testfile仍然存在于系统上，但现在是空文件，这是清除日志文件的一个常用的方法。</p>
<h2 id="创建临时文件">创建临时文件</h2>
<p>Linux系统有特殊的目录，专供临时文件使用。Linux使用/tmp目录来存放不需要永久保留的文件。系统上的任何用户账户都有权限在读写/tmp目录中的文件。这个特性为用户提供了一种创建临时文件的简单方法，而且还不用操心清理工作。有个特殊命令可以用来创建临时文件。mktemp命令可以在/tmp目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的umask值（参见第7章）。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。一旦创建了文件，你就在脚本中有了完整的读写权限，但其他人没法访问它（当然，root用户除外）。</p>
<h3 id="创建本地临时文件">创建本地临时文件</h3>
<p>默认情况下，<code>mktemp</code>会在本地目录中创建一个文件，要用<code>mktemp</code>在本地目录中创建一个临时文件，只要指定一个文件名模板就行了，模板可以包含任意文本文件名，在文件名末尾加上6个x就行了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.ATlZBX</div><div class="line">biotest@ubuntu:~/input$ ls -al testing*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:32 testing.ATlZBX</div></pre></td></tr></table></figure>
<p><code>mktemp</code>命令会用6个字符码替换这6个x，从而保证文件名在目录中是唯一的。用户可以创建多个临床文件，这种用法可以使每个文件名都是唯一的。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.EWLscI</div><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.Y6pjo8</div><div class="line">biotest@ubuntu:~/input$ ls -al testing*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:32 testing.ATlZBX</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:37 testing.EWLscI</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:37 testing.Y6pjo8</div></pre></td></tr></table></figure>
<p>在脚本中使用<code>mktemp</code>命令可以将文件名保存到变量中，这样就可以在后面的脚本中引用了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> creating and using a temp file</div><div class="line"></div><div class="line">tempfile=$(mktemp test19.XXXXXX)</div><div class="line"></div><div class="line">exec 3&gt;$tempfile</div><div class="line">echo "This script writes to temp file $tempfile"</div><div class="line"></div><div class="line">echo "This is the first line" &gt;&amp;3</div><div class="line">echo "This is the second line" &gt;&amp;3</div><div class="line">echo "This is the last line" &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">echo "Done creating temp file. The contents are: "</div><div class="line">cat $tempfile</div><div class="line">rm -f $tempfile 2&gt; /dev/null</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test19.sh</div><div class="line">This script writes to temp file test19.RyVPfD</div><div class="line">Done creating temp file. The contents are: </div><div class="line">This is the first line</div><div class="line">This is the second line</div><div class="line">This is the last line</div><div class="line">biotest@ubuntu:~/input$ ls -al test19*</div><div class="line">-rw-rw-r-- 1 biotest biotest 354 May  6 00:40 test19.sh</div></pre></td></tr></table></figure>
<p>在这个脚本中，使用mktemp命令创建临时文件，并将文件名赋给<code>$tempfile</code>变量，接着将这个临时文件作为文件描述3的输出重定向文件，在将临时文件名显示在STDOUT之后，向中临时文件中写入了几行文本，然后关闭了文件描述符，最后显示出临时文件的内容，并用<code>rm</code>命令将其删除。</p>
<h3 id="在tmp目录创建临时文件">在<code>/tmp</code>目录创建临时文件</h3>
<p><code>-t</code>选项会强制mktemp命令在系统的临时目录来创建文件，在使用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不是仅有文件名，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp -t test.XXXXXX</div><div class="line">/tmp/test.oL5jbT</div><div class="line">biotest@ubuntu:~/input$ ls -al /tmp/test*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:45 /tmp/test.oL5jbT</div></pre></td></tr></table></figure>
<p>由于mktemp返回了全路径，因此用户可以在Linux系统的任意目录下引用该临时文件，不管目录在哪里，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> creating a temp file in /tmp</div><div class="line"></div><div class="line">tempfile=$(mktemp -t tmp.XXXXXX)</div><div class="line"></div><div class="line">echo "This is a test file." &gt; $tempfile</div><div class="line">echo "This is the second line of the test." &gt;&gt; $tempfile</div><div class="line"></div><div class="line">echo "The temp file is located at: $tempfile"</div><div class="line">cat $tempfile</div><div class="line">rm -f $tempfile</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test20.sh</div><div class="line">The temp file is located at: /tmp/tmp.4hLOyR</div><div class="line">This is a test file.</div><div class="line">This is the second line of the test.</div></pre></td></tr></table></figure>
<p>mktemp创建了临时文件时，它会返回全路径给变量，这样就可以在任何命令中使用该值来引用临时变量了。</p>
<h3 id="创建临时目录">创建临时目录</h3>
<p><code>-d</code>选项告诉mktemp命令来创建一个临时目录，而不是临时文件，这样就能用此目录进行任何需要的操作，体积如创建其他的临时文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a temporary directory</div><div class="line"></div><div class="line">tempdir=$(mktemp -d dir.XXXXXX)</div><div class="line">cd $tempdir</div><div class="line">tempfile1=$(mktemp temp.XXXXXX)</div><div class="line">tempfile2=$(mktemp temp.XXXXXX)</div><div class="line">exec 7&gt; $tempfile1</div><div class="line">exec 8&gt; $tempfile2</div><div class="line"></div><div class="line">echo "Sending data to directory $tempdir"</div><div class="line">echo "This is a test line of data for $tempfile1" &gt;&amp;7</div><div class="line">echo "This is a test line of data for $tempfile2" &gt;&amp;8</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test21.sh</div><div class="line">Sending data to directory dir.4ZeP0T</div><div class="line">biotest@ubuntu:~/input$ ls -al</div><div class="line">drwx------  2 biotest biotest 4096 May  6 01:02 dir.4ZeP0T</div><div class="line">... ...</div><div class="line">-rw-rw-r--  1 biotest biotest   29 May  5 23:41 tets17file</div><div class="line">biotest@ubuntu:~/input$ cd dir.4ZeP0T</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ls</div><div class="line">temp.7KoQoD  temp.jj2vb1</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat temp.7KoQoD </div><div class="line">This is a test line of data for temp.7KoQoD</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat temp.jj2vb1 </div><div class="line">This is a test line of data for temp.jj2vb1</div></pre></td></tr></table></figure>
<p>这段脚本在当前目录创建了一个目录，然后它用cd命令进入该目录，并创建了两个临时文件。之后这两个临时文件被分配给文件描述符，用来存储脚本的输出。</p>
<h2 id="记录消息">记录消息</h2>
<p>有时候需要将输出同时发送到显示器和日志文件，此时需要<code>tee</code>命令。tee在英文就是T的意思，在Linux中，这个命令相当于管道一个T接头，它将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是tee命令所指定的文件名<code>tee filename</code>，由于tee会重定向来自STDIN的数据，可以用它配合管道命令来重定向命令输出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ date | tee testfile2</div><div class="line">Sun May  6 01:12:57 PDT 2018</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">Sun May  6 01:12:57 PDT 2018</div></pre></td></tr></table></figure>
<p>输出出现在了STDOUT中，同时也写入了指定的文件中，默认情况下，tee命令会在每次使用时覆盖输出文件的内容，如下挂满：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ who | tee testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div></pre></td></tr></table></figure>
<p>如果需要追加数据，则要使用<code>-a</code>参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ date | tee -a testfile2</div><div class="line">Sun May  6 01:14:55 PDT 2018</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">Sun May  6 01:14:55 PDT 2018</div></pre></td></tr></table></figure>
<p>看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the tee command for logging </div><div class="line"></div><div class="line">tempfile=test22file</div><div class="line"></div><div class="line">echo "This is the start of the test" |tee $tempfile</div><div class="line">echo "This is the second line of the test" | tee -a $tempfile</div><div class="line">echo "This is the end of the test" | tee -a $tempfile</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ bash test22.sh</div><div class="line">This is the start of the test</div><div class="line">This is the second line of the test</div><div class="line">This is the end of the test</div><div class="line"></div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat test22file</div><div class="line">This is the start of the test</div><div class="line">This is the second line of the test</div><div class="line">This is the end of the test</div></pre></td></tr></table></figure>
<p>从结果可以看出，用户显示输出的同时，还能保存一份输出内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/02/Linux-shell03-break几层循环的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Linux-shell03-break几层循环的理解/" itemprop="url">break n层循环的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T12:13:54+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物信息学/" itemprop="url" rel="index">
                    <span itemprop="name">生物信息学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  590
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Shell脚本的break与continue语句时，有一些困惑，就是<code>break n</code>可以跳出几层循环的问题，continue也是如此。不过弄懂了<code>break n</code>的问题，<code>continue n</code>的问题应该也清楚了。</p>
<p>第一步：<code>break 1</code>。</p>
<p>新建一个<code>loop.sh</code>脚本，输入以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 1</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 1 the out cycle is 2,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 2,and inner cycle is 2</div><div class="line">The m cycle is 1 the out cycle is 3,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 3,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 2,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 2,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 3,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 3,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>第二步：<code>break 2</code>。</p>
<p>现在将<code>break 1</code>改为<code>break 2</code>，运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 2</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>第三步，<code>break 3</code>。</p>
<p>现在将<code>break 2</code>改为<code>break 3</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 3</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>从上面的结果可以看出来：①最内层的是第1层循环，再次是第2层循环，最外层就是第3层循环。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/02/Linux-shell04-处理用户输入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Linux-shell04-处理用户输入/" itemprop="url">Shell学习笔记（4）——处理用户输入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T12:12:54+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,003
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="命令行参数">命令行参数</h2>
<p>脚本还可以接受一些参数。向shell脚本传递数据的最基本方法是使用命令行参数，命令行参数就像是一些常规的Linux命令一样，例如<code>head -20 file001.sh</code>，在一条命令上，head命令就能接收一个<code>-20</code>的参数，用户自己定义的脚本，也可以接收一定的参数。</p>
<h3 id="读取参数">读取参数</h3>
<h4 id="第1个案例读取1个参数">第1个案例：读取1个参数</h4>
<p>bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数，这也包括shell所执行的脚本名称，位于参数变量是标准的数据，其中，<code>$0</code>是程序名，<code>$1</code>是第1个参数，<code>$2</code>是第2个参数，直到第9个参数，即<code>$9</code>。下面的案例是shell脚本中使用单个命令行参数的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using one command line parameter</div><div class="line"><span class="meta">#</span> </div><div class="line"></div><div class="line">factorial=1</div><div class="line"></div><div class="line">for (( number=1; number &lt;= $1;number++ )) </div><div class="line"><span class="meta">#</span> 这里的$1指的是脚本运行过程中输入的参数，在后面的运行过程中，输入5</div><div class="line"> do</div><div class="line">    factorial=$[ $factorial*$number ]</div><div class="line"> done</div><div class="line"> echo The factorial of $1 is $factorial</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test1.sh 5</div><div class="line">The factorial of 5 is 120</div></pre></td></tr></table></figure>
<p>运行过程：第1次：factorial=1，number=1；第2次：n=2，f=2；第3次：n=3，f=6；第4次：n=4,f=24；第5次：n=5；f=120。</p>
<h4 id="第2个案例读取2个及以上参数">第2个案例：读取2个及以上参数</h4>
<p>如果要读取更多的参数，需要将每个参数用空格分开，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing two command line parameters</div><div class="line"><span class="meta">#</span></div><div class="line">total=$[ $1*$2 ]</div><div class="line">echo The first parameter is $1.</div><div class="line">echo The second parameter is $2.</div><div class="line">echo The total value is $total.</div></pre></td></tr></table></figure>
<p>运行结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The first parameter is 2.</div><div class="line">The second parameter is 5.</div><div class="line">The total value is 10.</div></pre></td></tr></table></figure></p>
<h4 id="第3个案例使用字符串作为变量">第3个案例，使用字符串作为变量</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> testing string parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo Hello $1, glad to meet you.</div></pre></td></tr></table></figure>
<p>运行结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh Zhang</div><div class="line">Hello Zhang, glad to meet you.</div></pre></td></tr></table></figure></p>
<p>在这个案例中，使用了字符串作为脚本的参数，但是，如果参数中含有空格，则会出现问题，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh Zhang San</div><div class="line">Hello Zhang, glad to meet you.</div></pre></td></tr></table></figure></p>
<p>脚本只识别了Zhang，没有识别出完整的Zhang San，因为shell脚本会把空格分隔开的字符串当成两个参数，如果要使含有空格的字符串当成一个，需要添加引号，如下所示；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh &apos;Zhang San&apos;</div><div class="line">Hello Zhang San, glad to meet you.</div></pre></td></tr></table></figure>
<h4 id="第4个案例参数大于9个">第4个案例：参数大于9个</h4>
<p>如果脚本需要的命令行参数大于9个，此时需要在变量数字周围加上花括号，例如<code>${``10``}</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> handling lots of paramerters</div><div class="line"><span class="meta">#</span></div><div class="line">total=$[ $&#123;10&#125;*$&#123;11&#125; ]</div><div class="line">echo The tenth parameter is $&#123;10&#125;</div><div class="line">echo The eleventh parameter is $&#123;11&#125;</div><div class="line">echo The total is $total</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test4.sh 1 2 3 4 5 6 7 8 9 10 11 12</div><div class="line">The tenth parameter is 10</div><div class="line">The eleventh parameter is 11</div><div class="line">The total is 110</div></pre></td></tr></table></figure></p>
<h4 id="第5个案例读取脚本名">第5个案例：读取脚本名</h4>
<h5 id="参数的意义"><code>$0</code>参数的意义。</h5>
<p><code>$0</code>参数用于获取shell在命令行启动的脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing the $0 parameter</div><div class="line"><span class="meta">#</span></div><div class="line">echo The zero parameter is set to:$0</div></pre></td></tr></table></figure>
<p>需要注意的是，如果使用完整路径运行脚本，则<code>$0</code>就是完整脚本，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash /home/biotest/userdata/test5.sh</div><div class="line">The zero parameter is set to:/home/biotest/userdata/test5.sh</div></pre></td></tr></table></figure>
<h5 id="basename命令可以补充0参数的局限"><code>basename</code>命令可以补充<code>$0</code>参数的局限</h5>
<p>如果要写一个根据脚本名来执行不同功能的脚本，则就需要注意把脚本的运行路径给剥离掉，shell中有一个命令可以考虑，即<code>basename</code>命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Using basename with the $0 parameter</div><div class="line"><span class="meta">#</span></div><div class="line">name=$(basename $0)</div><div class="line">echo</div><div class="line">echo The script name is: $name</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test5b.sh</div><div class="line">The script name is: test5b.sh</div><div class="line">biotest@ubuntu:~/userdata$ bash /home/biotest/userdata/test5b.sh</div><div class="line">The script name is: test5b.sh</div></pre></td></tr></table></figure>
<p>从结果可以看出来，使用了<code>basename</code>命令后，即使运行脚本时输入全路径，<code>$0</code>也只是脚本的名称。</p>
<h5 id="相对路径与绝对路径的案例">相对路径与绝对路径的案例</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing a Multi-function script</div><div class="line"><span class="meta">#</span></div><div class="line">name=$(basename $0)</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $name = "addem" ]</div><div class="line">then</div><div class="line">    total=$[ $1 + $2 ]</div><div class="line"><span class="meta">#</span></div><div class="line">elif [ $name = "multem" ]</div><div class="line">then</div><div class="line">    total=$[ $1*$2 ]</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">echo The calculated value is $total</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cp test6.sh addem</div><div class="line">biotest@ubuntu:~/userdata$ chmod u+x addem</div><div class="line">biotest@ubuntu:~/userdata$ ln -s test6.sh multem</div><div class="line">biotest@ubuntu:~/userdata$ ls -l *em</div><div class="line">-rwxrw-r-- 1 biotest biotest 224 May  1 10:48 addem</div><div class="line">lrwxrwxrwx 1 biotest biotest   8 May  1 10:48 multem -&gt; test6.sh</div><div class="line">biotest@ubuntu:~/userdata$ bash addem 2 5</div><div class="line">The calculated value is 7</div><div class="line">biotest@ubuntu:~/userdata$ sudo bash ./multem 2 5</div><div class="line">The calculated value is 10</div></pre></td></tr></table></figure>
<p>结果解释：第一，<code>cp test6.sh addem</code>复制<code>test6.sh</code>脚本，新生成的文件命令为<code>addem</code>；第二，<code>chmod u+x addem</code>，将<code>addem</code>文件权限更改为可执行；第三，<code>ln -s test6.sh multem</code>，其中<code>ln</code>是为文件创建链接，<code>-s</code>表示软连接，可以理解为Linux的快捷方式；第四，当执行<code>addem 2 5</code>时，执行<code>total=$[ $1 + $2 ]</code>语句，如果是<code>bash ./multem 2 5</code>，则执行<code>total=$[ 41*$2 ]</code>语句。</p>
<h4 id="测试参数">测试参数</h4>
<p>当脚本认为参数变量中会有数据，而实际上没有时，脚本就有可能会产生错误消息。通常要避免这种脚本的写法，在使用参数前一定要检查其中是否存在为数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat test7.sh</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing parameters befoire user</div><div class="line"><span class="meta">#</span></div><div class="line"> if [ -n "$1" ]</div><div class="line">then</div><div class="line">    echo Hello $1, gload to meet you.</div><div class="line">else</div><div class="line">    echo "Sorry you did not identify yourself."</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test7.sh Zhang</div><div class="line">Hello Zhang, gload to meet you.</div><div class="line">biotest@ubuntu:~/userdata$ bash test7.sh</div><div class="line">Sorry you did not identify yourself.</div></pre></td></tr></table></figure>
<p>代码解释：在<code>if</code>语句中使用了<code>if [ -n &quot;$1&quot; ]</code>语句，这里的<code>-n</code>是用于判断<code>$1</code>中是否有数据。</p>
<h2 id="特殊参数变量">特殊参数变量</h2>
<p>在bash shell中有一些变量，它们会记录命令行参数。</p>
<h3 id="参数统计基本用法">参数统计基本用法</h3>
<p>bash shell有一个特殊的变量，可以记录命令行中输入了多少个参数，其中这个特殊变量就是<code>$#</code>，哦可以肝脚本中任何地方使用这个特殊的变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> getting the number of parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo There were $# parameters supplied.</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh</div><div class="line">There were 0 parameters supplied.</div><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh 1 2 3 4 5 6 7</div><div class="line">There were 7 parameters supplied.</div><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh &quot;Zhang San&quot;</div><div class="line">There were 1 parameters supplied.</div></pre></td></tr></table></figure>
<h3 id="参数统计案例">参数统计案例</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>/bin/bash</div><div class="line"><span class="meta">#</span> Testing parameters</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $# -ne 2 ] # -ne测试命令行参数的数量，-ne是检查$#是否不等于2，ne相当于non-equal</div><div class="line">then</div><div class="line">    echo</div><div class="line">    echo Usage: test9..sh a b</div><div class="line">    echo</div><div class="line">else</div><div class="line">    total=$[ $1 + $2 ]</div><div class="line">    echo</div><div class="line">    echo The total is $total</div><div class="line">    echo</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh </div><div class="line">Usage: test9..sh a b</div><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh 10</div><div class="line">Usage: test9..sh a b</div><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh 10 10 15</div><div class="line">Usage: test9..sh a b</div></pre></td></tr></table></figure>
<p>需要注意的是，如果认为<code>$#</code>变量含有参数的总数，而变量<code>$\{$#\}</code>代表了最后一个命令行参数变量，那就会出错，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing grabbing last parameter</div><div class="line"><span class="meta">#</span></div><div class="line">echo The last parameter was $&#123;$#&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash badtest1.sh 10</div><div class="line">The last parameter was 19343</div></pre></td></tr></table></figure>
<p>结果是19343，这说明，在花括号内不能使用美元符号，除非按照下面的方式进行修改，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Grabbing the last parameter</div><div class="line"><span class="meta">#</span></div><div class="line">params=$#</div><div class="line">echo</div><div class="line">echo The last parameter is $params</div><div class="line">echo The last parameter is $&#123;!#&#125;</div><div class="line">echo</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test10.sh 1 2 3 4 5 6</div><div class="line">The last parameter is 6</div><div class="line">The last parameter is 6</div><div class="line"></div><div class="line">biotest@ubuntu:~/userdata$ bash test10.sh</div><div class="line">The last parameter is 0</div><div class="line">The last parameter is test10.sh</div></pre></td></tr></table></figure>
<p>从结果来看，如果将<code>$#</code>变量的值赋给了变量<code>params</code>，然后也按特殊命令行参数变量的格式（即使用<code>$/{!#/}</code>）使用了该变量，结果就能正常显示。但是，当脚本没有参数时，<code>$#</code>的值为0，params变量的值也一样，但<code>$\{!#\}</code>变量的返回值则是脚本名本身。</p>
<h3 id="抓取所有的数据">抓取所有的数据</h3>
<p>有时候需要抓取命令行上提供的所有参数，这时候不需要先用<code>$#</code>变量来判断命令行上有多少参数，然后再进行遍历，可以使用其他的特殊变量来解决这个问题，其中<code>$*</code>和<code>$@</code>变量可以访问所有的参数，这两个变量都能够在单个变量中存储所有的命令行参数。</p>
<p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存，这个单词包含了命令行中出现的每一个参数，基本上<code>$*</code>变量会将这些参数视为一个整体，而不是单独的个体。而<code>$@</code>变量会将命令行上提供的所有参数当作同一字符串中多个独立的单词，这样可以遍历所有的参数值，得到每个参数，这通常使用for命令完成。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing $* and $@</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">echo "Using the \$* method: $*"</div><div class="line">echo</div><div class="line">echo "Using the \$@ mehtods: $@"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biostudy@ubuntu18:~/script$ bash test11.sh Zhang Li Wang</div><div class="line">Using the $* method: Zhang Li Wang</div><div class="line">Using the $@ mehtods: Zhang Li Wang</div></pre></td></tr></table></figure>
<p>从结果来看，<code>$*</code>和<code>$@</code>在形式上并没有区别。但是下面的例子则能看出区别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing $* and $@</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">count=1</div><div class="line"></div><div class="line">for param in "$*"</div><div class="line">do</div><div class="line">    echo "\$ Parameter # $count=$param"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line"></div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">    echo "\$@ Parameter # $count=$param"</div><div class="line">    ecount=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test12.sh Zhang Li Wang</div><div class="line"></div><div class="line">$ Parameter # 1=Zhang Li Wang</div><div class="line">$@ Parameter # 1=Zhang</div><div class="line">$@ Parameter # 1=Li</div><div class="line">$@ Parameter # 1=Wang</div></pre></td></tr></table></figure>
<p>从结果可以看出来，使用for遍历这两个特殊的变量时，<code>$*</code>会将所有参数当成单个参数，而<code>$@</code>变量会单独处理所有的参数。</p>
<h2 id="移动变量">移动变量</h2>
<p>bash shell中的<code>shift</code>命令可以操作命令行参数，<code>shift</code>可以根据它们的相对位置来移动命令行参数。当使用该命令时，它会将每个参数变量向左移动一个位置。因此，变量<code>$3</code>的值会移到<code>$2</code>，变量<code>$2</code>的值会移到<code>$1</code>，而变量<code>$1</code>的值则会被删除（因为<code>$0</code>的值是程序名，不会改变）。这是遍历命令行参数的一个方法，当用户不矢科有多少个参数时，可以只操作第1个参数，移动参数，然后继续操作下一个参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating the shift command</div><div class="line"></div><div class="line">echo</div><div class="line">count=1</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    echo "Parameter #$count=$1"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">    shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[000.DESKTOP-FS88S5S] &gt; bash test13.sh Zhang Li Wang Tian</div><div class="line"></div><div class="line">Parameter #1=Zhang</div><div class="line">Parameter #2=Li</div><div class="line">Parameter #3=Wang</div><div class="line">Parameter #4=Tian</div></pre></td></tr></table></figure>
<p>代码及结果解释： -n 测试来检查命令行参数<code>$1</code>中是否有数据。如果不是0，就执行，一直执行到<code>$1</code>参数为0为止。也可以为shift提供一个参数，指明要移动的位置数即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating a multi-positon shift</div><div class="line"><span class="meta">#</span></div><div class="line">echo "The original parameters: $*"</div><div class="line">shift 2</div><div class="line">echo "Here's the new first parameter: $1"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[000.DESKTOP-FS88S5S] &gt; bash test14.sh 1 2 3 4 5</div><div class="line">The original parameters: 1 2 3 4 5</div><div class="line">Here&apos;s the new first parameter: 3</div></pre></td></tr></table></figure>
<p>从上述案例可知，通过使用shfit的参数可以跳过不想要的参数。</p>
<h2 id="处理选项">处理选项</h2>
<p>选项指的是这样的一种情况，在命令后面的短横线的单个字母 ，例如 <code>ls -a</code>，其中<code>-a</code>就是选项。</p>
<h3 id="查找选项">查找选项</h3>
<p>在提取每个单独参数时用<code>case</code>语句来判断某个参数是否为选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting command line options as parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in </div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) echo "Found the -b option";;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">    esac</div><div class="line">    shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test15.sh -a -b -c -d</div><div class="line">Found the -a option</div><div class="line">Found the -b option</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>case语句会检查每个参数是不是有效选项。如果是的话，就运行对应case语句中的命令，无论选项按什么顺序出现在命令行上，这种方法都适用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test15.sh -d -c -a</div><div class="line">-d is not an option</div><div class="line">Found the -c option</div><div class="line">Found the -a option</div></pre></td></tr></table></figure>
<p>case语句在命令行参数中找到一个选项，就处理一个选项，如果命令行上的还提供了其他参数，就可以在case语句的通用情况处理部分中处理。</p>
<h3 id="分离参数和选项">分离参数和选项</h3>
<p>在shell脚本中同时使用选项有参数时，Linux处理这种问题的标准方式是用特殊字符，也就是双破折号（<code>--</code>）将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。在双破折线之后，脚本可以将剩下的命令行参数当作参数，而不是选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting options and parameters</div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in</div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) echo "Found the -b option";;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">        --) shift</div><div class="line">            break;;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">    esac</div><div class="line">    shift</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line">for param in $@</div><div class="line">do</div><div class="line">   echo "Parameter #$count: $param"</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test16.sh -c -a -b test1 test2 test3</div><div class="line">Found the -c option</div><div class="line">Found the -a option</div><div class="line">Found the -b option</div><div class="line">test1 is not an option</div><div class="line">test2 is not an option</div><div class="line">test3 is not an option</div></pre></td></tr></table></figure>
<p>当脚本遇到双破折号时，它会停止处理选项，并将剩下的参数都当作命令行参数。</p>
<h3 id="处理带值的选项">处理带值的选项</h3>
<p>有些选项会带上额外的参数值，例如像这样的<code>bash testing.sh -a test1 -b -c -d test2</code>，如果例行选项中带有额外的参数，脚本必须要能检测到，并且进行处理，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting command line options and values</div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in </div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) param="$2"</div><div class="line">            echo "Found the -b option, with parameter value $param"</div><div class="line">           shift;;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">        --) shift</div><div class="line">            break;;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">     esac</div><div class="line">     shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -a -b test1 -d</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with parameter value test1</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>代码及结果解释：在这案例中，<code>case</code>语句定义了3个安要处理的选项，其中<code>-b</code>选项还需要一个额外的参数值，由于要处理的参数是<code>$1</code>，额外的参数值就应该位于<code>$2</code>位置上（因为所有的参数在处理完后就会被移出），只要将参数值从<code>$2</code>变量中提取出来就行，因为这个选项占了2个参数位，因此还需要<code>shift</code>命令多移动一个位置。只用这些基本的特性，整个过程就能正常工作，不管按什么顺序放置选项（但要记住包含每个选项相应的选项参数）。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -b test1 -a -d</div><div class="line">Found the -b option, with parameter value test1</div><div class="line">Found the -a option</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>此时，shell脚本就有了处理例行选项的基本能力，但还一些限制，例如，想要多个选项放一个参数时，就像<code>ls -lh</code>这个命令这样，脚本就无法正常工作，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -ac</div><div class="line">-ac is not an option</div></pre></td></tr></table></figure>
<p>此时需要<code>getopt</code>命令。</p>
<h3 id="使用getopt命令">使用getopt命令</h3>
<h4 id="getopt命令基本用法">getopt命令基本用法</h4>
<p><code>getopt</code>命令是一个在处理命令行选项和参数时非常方便的工具，它能够识别命令行参数，从而在脚本中解析它们时更方便。<code>getopt</code>命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换为适当的格式，它的使用方法为<code>getopt optstring parameters</code>，其中，<code>optstring</code>定义了命令行有效的选项字符，不这它义了哪些选项字母需要参数值。首先在<code>optstring</code>中列出要在脚本中用到的每个命令行选项字母，然后在每个需要参数值的选项字母后面加一个冒号，<code>getopt</code>命令会基于定义的<code>optstring</code>解析提供的参数。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt ab:cd -a -b test1 -cd test2 test3</div><div class="line"> -a -b test1 -c -d -- test2 test3</div></pre></td></tr></table></figure>
<p>optstring定义了4个有效选项字母，a、b、c和d。冒号（<code>：</code>）被放到了字母b的后面，因为b选项需要一个参数值，当<code>getopt</code>命令运行时，它会检查提供的参数列表（-a -b test1 -cd test2 test3），并基于提供的<code>optstring</code>进行解析。此时，它会自动将<code>-cd</code>选项分成两个单独的选项，并插入双破折线来分隔行中的额外参数，如果指定了一个不在<code>optstring</code>中的选项，默认情况下，<code>getopt</code>会产生一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt ab:cd -a -b test1 -cde test2 test3</div><div class="line">getopt: invalid option -- 'e'</div><div class="line"> -a -b test1 -c -d -- test2 test3</div></pre></td></tr></table></figure>
<p>如果需要忽略这条错误消息，可以在命令后加<code>-q</code>选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt -q ab:cd -a -b test1 -cde test2 test3</div><div class="line"> -a -b 'test1' -c -d -- 'test2' 'test3'</div></pre></td></tr></table></figure>
<p>注意：getopt命令选项必须出现在optstring之间。</p>
<h4 id="在脚本中使用getopt">在脚本中使用getopt</h4>
<p>在脚本中使用<code>getopt</code>来格式化脚本所携带的任何选项或参数时，方法就是使用<code>getopt</code>命令生成的格式化后的版本替换已有的命令行选项的参数。这其中要用到<code>set</code>命令。<code>set</code>命令的选项之一就是双破折线（<code>--</code>），它会将命令行参数值的成set命令的命令行值。该方法会将原始脚本的命令行参数传给<code>getopt</code>命令，之后再将<code>getopt</code>命令的输出传给<code>set</code>命令，用<code>getopt</code>格式化后的命令行参数来替换原始的命令行参数，看起来就像这样的<code>set --$(getopt -q ab:cd &quot;$@&quot;)</code>,此时，原始命令行参数变量的值会被<code>getopt</code>命令的输出替换，而<code>getopt</code>已经格式化好了命令行参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Extract command line options and values with getop</div><div class="line"><span class="meta">#</span> </div><div class="line">set --$(getopt -q ab:cd "$@")</div><div class="line"><span class="meta">#</span></div><div class="line">echo </div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in</div><div class="line">    -a) echo "Found the -a option";;</div><div class="line">    -b) param="$2"</div><div class="line">        echo "Found the -b option, with paraeter value $param"</div><div class="line">        shift;;</div><div class="line">    -c) echo "Found the -c option";;</div><div class="line">    --) shift</div><div class="line">        break;;</div><div class="line">     *) echo "$1 is not an option";;</div><div class="line">     esac</div><div class="line">  shift</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">    echo "Parameter $count: $param"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -ac</div><div class="line">Found the -a option</div><div class="line">Found the -c option</div><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -a -b test1 -cd test2 test3 test4</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with paraeter value &apos;test1&apos;</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div><div class="line">Parameter 1: &apos;test2&apos;</div><div class="line">Parameter 2: &apos;test3&apos;</div><div class="line">Parameter 3: &apos;test4&apos;</div><div class="line"></div><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -a -b test1 -cd &quot;test2 test3&quot; test4</div><div class="line">Found the -a option</div><div class="line">Found the -b option, with paraeter value &apos;test1&apos;</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div><div class="line">Parameter 1: &apos;test2</div><div class="line">Parameter 2: test3&apos;</div><div class="line">Parameter 3: &apos;test4</div></pre></td></tr></table></figure>
<p>从运行结果来看，第一个与第二个没有问题，第三个出现了问题，在第三个运行过程中，参数选项其中人有<code>&quot;test2 test3&quot;</code>，用了双引号，由于<code>getopt</code>命令不擅长处理带空格和引号的参数值，它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。此时就需要另外一个命令，即<code>getopts</code>，这个命令是在<code>getopt</code>后面加了一个<code>s</code>。</p>
<h3 id="使用getopts命令注意后面加了s">使用getopts命令（注意后面加了s）</h3>
<p><code>getopts</code>命令能够与已有的shell参数变量进行配合。每调用它时，它一次只处理命令行上检测到的一个参数，处理完所有的参数后，它会退回一个大于0的退出状态码，因此这个命令很适合解析命令行所有参数的循环。它的用法为<code>getopts optstring variable</code>。<code>optstring</code>中储存的是有效的选项字母，如果选项字母要求有个参数值，就要加一个冒号，要去年错误消息的话，可以在<code>optstring</code>之前加一个冒号，<code>getopts</code>命令将当前参数保存在命令行中定义的<code>variable</code>中。<code>getopts</code>命令会用到两个环境变量，如果选项需要跟一个参数值，<code>OPTARG</code>环境变量会保存这个值，<code>OPTIND</code>环境变量保存了参数列表中<code>getopts</code>正在处理的参数位置。这样能够在处理完选项之后继续处理其他命令行参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> simple demonstration of the getopts command</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">while getopts :ab:c opt</div><div class="line">do</div><div class="line">    case "$opt" in </div><div class="line">        a) echo "Found the -a option";;</div><div class="line">        b) echo "Found the -b option, with value $OPTARG";;</div><div class="line">        c) echo "Found the -c option";;</div><div class="line">        *) echoi "Unknown options:$opt";;</div><div class="line">    esac</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -ab test1 -c</div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div><div class="line">Found the -c option</div></pre></td></tr></table></figure>
<p>while语句定义了<code>getopts</code>命令，指明了要查找哪些命令选项，以及每次迭代中储存它们的变量名（<code>opt</code>）。此时<code>case</code>语句的用法有些不同，getopts命令解析命令行选项时会移除开头的单破拆线，所以在case定义中不用单破折线。getopts命令的参数值中可以包含空格，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Found the -b option, with value test1 test2</div><div class="line">Found the -a option</div></pre></td></tr></table></figure>
<p>还可以将选项字母和参数值放在一起使用，而不用加空格，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -abtest1</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div></pre></td></tr></table></figure>
<p><code>getopts</code>命令能够从<code>-b</code>选项中正确解析出<code>test1</code>值。除此之外，<code>getopts</code>还能够将命令行上找到的所有未定义的选项统一输出成问号，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -d</div><div class="line"></div><div class="line">Unknown options:?</div><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -acde</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -c option</div><div class="line">Unknown options:?</div><div class="line">Unknown options:?</div></pre></td></tr></table></figure>
<p><code>optstring</code>中未定义的选项字母会以问号形式发给代码。<code>getopts</code>命令知道何时停止处理选项，并将参数留给用户处理，在使用<code>getopts</code>处理每个选项时，它会将<code>OPTIND</code>环境变量值增一。在<code>getopts</code>完成处理时，用户可以使用<code>shift</code>命令和<code>OPTIND</code>值来移动参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Processing options and parameters with getopts</div><div class="line"></div><div class="line">echo </div><div class="line">while getopts :ab:cd opt</div><div class="line">do</div><div class="line">    case "$opt" in </div><div class="line">    a) echo "Found the -a option";;</div><div class="line">    b) echo "Found the -b option, with value $OPTARG";;</div><div class="line">    c) echo "Found the -c option";;</div><div class="line">    c) echo "Found the 0d option";;</div><div class="line">    *) echo "Unknown option: $opt";;</div><div class="line">    esac</div><div class="line">done</div><div class="line"></div><div class="line">shift $[ $OPTIND - 1 ]</div><div class="line"></div><div class="line">echo</div><div class="line">count=1</div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">   echo "Parameter $count: $param"</div><div class="line">   coiunt=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test20.sh -a -b test1 -d test2 test3 test4</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div><div class="line">Unknown option: d</div><div class="line"></div><div class="line">Parameter 1: test2</div><div class="line">Parameter 1: test3</div><div class="line">Parameter 1: test4</div></pre></td></tr></table></figure>
<h2 id="选项标准化">选项标准化</h2>
<p>在Linux系统中，一些字母选项已经拥有了某种程度的标准含义，因此在写bash shell脚本时，用户自己脚本中如果要使用一些选项参数的话，最好与Linux系统中的保持一致，一些常用的linux命令选项如下所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-a</td>
<td>显示所有对象</td>
</tr>
<tr class="even">
<td>-c</td>
<td>生成一个计数</td>
</tr>
<tr class="odd">
<td>-d</td>
<td>指定一个目录</td>
</tr>
<tr class="even">
<td>-e</td>
<td>扩展一个对象</td>
</tr>
<tr class="odd">
<td>-f</td>
<td>指定读入数据的文件</td>
</tr>
<tr class="even">
<td>-h</td>
<td>显示命令的帮助信息</td>
</tr>
<tr class="odd">
<td>-i</td>
<td>忽略文本大小写</td>
</tr>
<tr class="even">
<td>-l</td>
<td>产生输出的长格式版本</td>
</tr>
<tr class="odd">
<td>-n</td>
<td>使用非交互模式（批处理）</td>
</tr>
<tr class="even">
<td>-o</td>
<td>将所有输出重定向到的</td>
</tr>
<tr class="odd">
<td>-q</td>
<td>以安静模式运行</td>
</tr>
<tr class="even">
<td>-r</td>
<td>递归地处理目录和文件</td>
</tr>
<tr class="odd">
<td>-s</td>
<td>以安静模式运行</td>
</tr>
<tr class="even">
<td>-v</td>
<td>生成详细输出</td>
</tr>
<tr class="odd">
<td>-x</td>
<td>排除某个对象</td>
</tr>
<tr class="even">
<td>-y</td>
<td>对所有问题回答yes</td>
</tr>
</tbody>
</table>
<h3 id="获得用户输入">获得用户输入</h3>
<p>虽然命令行选项和参数可以从脚本用户处获得输入，但还有一种情况下，需要读取用户的一些信息，例如在运行某个脚本时，需要用户输入自己的用户名。bash shell为此提供了<code>read</code>命令。</p>
<h3 id="read的基本用法"><code>read</code>的基本用法</h3>
<p><code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入，在收入输入后，<code>read</code>命令会将数据放进一个变量，下面是<code>read</code>命令的一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the read command</div><div class="line"><span class="meta">#</span></div><div class="line">echo -n "Enter your name: "</div><div class="line">read name</div><div class="line">echo "Hello, $name, welcome to my program."</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行后结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test21.sh</div><div class="line">Enter your name: Zhang San</div><div class="line">Hello, Zhang San, welcome to my program.</div></pre></td></tr></table></figure>
<p>代码及结果解释：生成提示的echo使用了<code>-n</code>选项，该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。<code>read</code>命令还包含了<code>-p</code>选项，可以直接在<code>read</code>命令行指定指示符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the read -p option</div><div class="line"><span class="meta">#</span></div><div class="line">read -p "Please enter your age: " age</div><div class="line">days=$[ $age*365 ]</div><div class="line">echo "That makes your over $days days old!"</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test22.sh</div><div class="line">Please enter your age: 20</div><div class="line">That makes your over 7300 days old!</div></pre></td></tr></table></figure>
<p>代码及结果解释，在第一个例子中当有名字输入时，<code>read</code>命令会将姓和名保存在同一个变量中，<code>read</code>命令会将提示符后输入的所有数据分配给单个变量，要么用户指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span> entering multiple varibales</div><div class="line">read -p "Enter your name:    " first last</div><div class="line">echo "Checking data for $last, $first..."</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test23.sh</div><div class="line">Enter your name:    Zhang San</div><div class="line">Checking data for San, Zhang...</div></pre></td></tr></table></figure>
<p>如果<code>read</code>命令行中不指定变量，<code>read</code>命令会将它收到的任何数据都放到特殊环境变量<code>REPLY</code>中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing the REPLY Environemnt variable</div><div class="line"><span class="meta">#</span></div><div class="line">read -p "Enter uyuour name: "</div><div class="line">echo</div><div class="line">echo Hello $REPLY, welcome to my program.</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test24.sh</div><div class="line">Enter uyuour name: Zhang</div><div class="line"></div><div class="line">Hello Zhang, welcome to my program.</div></pre></td></tr></table></figure>
<p><code>REPLY</code>环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。</p>
<h3 id="超时">超时</h3>
<p>在使用<code>read</code>命令时需要注意，脚本很有可能会一直等着用户的输入，如果不管是否有数据输入，脚本都必须继续执行，可以使用<code>-t</code>选项来指定个计时器，<code>-t</code>选项指定了<code>read</code>命令等待输入的秒数，当计时器过期后，<code>read</code>命令会返回一个非零退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> timing the data entry</div><div class="line"><span class="meta">#</span> </div><div class="line">if read -t 5 -p "Please enter your name:  " name</div><div class="line">then</div><div class="line">    echo "Hello $name, welcome to my script"</div><div class="line">else</div><div class="line">    echo</div><div class="line">    echo "Sorry, too slow!"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test25.sh</div><div class="line">Please enter your name:  Zhang</div><div class="line">Hello Zhang, welcome to my script</div><div class="line">biotest@ubuntu:~/userdata$ bash test25.sh</div><div class="line">Please enter your name:  </div><div class="line">Sorry, too slow!</div></pre></td></tr></table></figure>
<p>代码及结果解释：如果计时器过期，<code>read</code>命令会以非零退出状态码退出，可以使用如<code>if-then</code>语句或<code>while</code>循环这种标准的结构化语句所发生的具体情况，在这个例子中，<code>if</code>语句不成立，shell会执行else部分的命令。也可以不进行诸，让<code>read</code>命令来统计输入的字符数，当输入的字符数达到预设的字符数时，就自动退出，将输入的数据赋给变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> getting just one character of input</div><div class="line"><span class="meta">#</span></div><div class="line">read -n1 -p "Do you want to continue [Y/N]? " answer</div><div class="line">case $answer in </div><div class="line">Y|y) echo</div><div class="line">     echo "fine, continue on...";;</div><div class="line">N|n) echo</div><div class="line">     echo OK, goodbye</div><div class="line">     exit;;</div><div class="line">esac</div><div class="line">echo "This is the end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test26.sh</div><div class="line">Do you want to continue [Y/N]? Y</div><div class="line">fine, continue on...</div><div class="line">This is the end of the script</div><div class="line">biotest@ubuntu:~/userdata$ bash test26.sh</div><div class="line">Do you want to continue [Y/N]? n</div><div class="line">OK, goodbye</div></pre></td></tr></table></figure>
<p>在这个案例中，将<code>-n选项</code>和值<code>1</code>一起使用，告诉<code>read</code>命令在接受单个字符后退出，只要按下单个字符回答后，<code>read</code>命令就会接受输入并将它传给变量，无需按回车键。</p>
<h3 id="隐藏方式读取">隐藏方式读取</h3>
<p>有时候需要从脚本用户处得到输入，在屏幕上显示输入信息。但有种例外，就是输入密码，需要隐藏输入的信息。在<code>read</code>命令使用时，使用<code>-s</code>选项可以避免在<code>read</code>命令中输入的数据出现在显示器上（其实数据是会显示的，只是<code>read</code>命令将文本的颜色设成了跟背景色一样），下面是一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> hiding input data from the monitor</div><div class="line"><span class="meta">#</span></div><div class="line">read -s -p "Enter your passwd:  " pass</div><div class="line">echo</div><div class="line">echo "Is your password really $pass?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test27.sh</div><div class="line">Enter your passwd:  </div><div class="line">Is your password really dsfdf?</div></pre></td></tr></table></figure>
<p>输入提示符输入的数据不会出现在屏幕上，但会赋值给变量，以便在脚本中使用。</p>
<h3 id="从文件中读取数据">从文件中读取数据</h3>
<p><code>read</code>可以用于读取文件中的数据，每次调用<code>read</code>命令时，它就会从文件中读取一行文本。当文件中再没有内容时，<code>read</code>命令就会退出，并返回非零退出状态码。通常使用<code>cat</code>命令将数据中的文件传给含有<code>read</code>命令的<code>while</code>命令，看一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> reading data from a file</div><div class="line"></div><div class="line">count=1</div><div class="line">cat test|while read line</div><div class="line">do</div><div class="line">    echo "Line $count: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "Finished processing the file"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat test</div><div class="line">The quick brown dog jumps over the lazy fox.</div><div class="line">This is a test, this is only a test.</div><div class="line">O Romeo, Romeo! Wherefore art thou Romeo?</div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">77</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共256.5k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
