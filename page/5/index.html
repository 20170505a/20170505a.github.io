<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/5/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/5/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/14/Perl/Perl学习笔记（3）-条件与循环语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/Perl/Perl学习笔记（3）-条件与循环语句/" itemprop="url">Perl学习笔记（３）-条件与循环语句以及错误处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T12:00:00+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Perl/" itemprop="url" rel="index">
                    <span itemprop="name">Perl</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,632
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="(0)前言"></a>(0)前言</h2><p>很多程序语言其实是比较类似的。基本上都有数据类型，循环结构，条件语句等内容。Perl也不例外。</p>
<h2 id="1-if语句"><a href="#1-if语句" class="headerlink" title="(1)if语句"></a>(1)if语句</h2><p>if语句由一个布尔表达式后跟一个或多个语句组成。语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(boolean_expression)&#123;</div><div class="line">   表达式</div><div class="line">   <span class="comment"># 在布尔表达式 boolean_expression 为 true 执行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果布尔表达式 boolean_expression为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行，如下所示：</p>
<h3 id="if语句案例第一"><a href="#if语句案例第一" class="headerlink" title="if语句案例第一"></a>if语句案例第一</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat if01.pl</div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>($a&lt;<span class="number">20</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"a is less 20\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"The value of a is: $a\n"</span>;</div><div class="line"></div><div class="line">$a=<span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>($a)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"variable of a is true.\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"The value of a is $a\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl if01.pl</div><div class="line">a is less <span class="number">20</span></div><div class="line">The value of a is: <span class="number">10</span></div><div class="line">The value of a is</div></pre></td></tr></table></figure>
<h2 id="2-if…else语句"><a href="#2-if…else语句" class="headerlink" title="(2)if…else语句"></a>(2)if…else语句</h2><p>一个if语句后可跟一个可选的else语句，else语句在布尔表达式为false时执行。语法语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(boolean_expression)&#123;    </div><div class="line">    表达式A;</div><div class="line">    <span class="comment"># 在布尔表达式 boolean_expression 为 true 执行 </span></div><div class="line">&#125;<span class="keyword">else</span>&#123;    </div><div class="line">    表达式B;</div><div class="line">    <span class="comment"># 在布尔表达式 boolean_expression 为 false 执行 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果布尔表达式boolean_expression为true，则执行if块内的表达式A。如果布尔表达式为false，则执行else块内的表达式B，如下所示：</p>
<h3 id="if…else语句案例1："><a href="#if…else语句案例1：" class="headerlink" title="if…else语句案例1："></a>if…else语句案例1：</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat ifelse01.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>($a&lt;<span class="number">20</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"a is less 20\n"</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"a is more 20\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">print</span> <span class="string">"The value of a is $a\n"</span>;</div><div class="line"></div><div class="line">$a = <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>($a)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"condition of a is true.\n"</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"condition of a ls flase.\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">print</span> <span class="string">"The value of a is $a\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl ifelse01.pl </div><div class="line">a is more <span class="number">20</span></div><div class="line">The value of a is <span class="number">100</span></div><div class="line">condition of a ls flase.</div><div class="line">The value of a is</div></pre></td></tr></table></figure>
<h3 id="三元运算符-："><a href="#三元运算符-：" class="headerlink" title="三元运算符 ?："></a>三元运算符 <code>?：</code></h3><p>可以使用 条件运算 <code>? :</code>来简化<code>if...else</code>语句的操作。通常格式为：<code>Exp1 ? Exp2 : Exp3</code>；如果 Exp1 表达式为 true ，则返回 Exp2 表达式计算结果，否则返回 Exp3，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat ifelse02.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a = <span class="number">100</span>;</div><div class="line">$result=($a&lt;<span class="number">20</span>)?<span class="string">"a is less 20\n"</span>:<span class="string">"a is more 20\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$result\n"</span>;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl ifelse02.pl </div><div class="line">a is more <span class="number">20</span></div></pre></td></tr></table></figure>
<h2 id="3-if…elsif…else语句"><a href="#3-if…elsif…else语句" class="headerlink" title="(3)if…elsif…else语句"></a>(3)if…elsif…else语句</h2><p>一个if语句后可跟一个可选的elsif语句，然后再跟另一个else语句，这种条件判断语句在多个条件的情况下非常有用，在使用if,elsif,else语句时你需要注意以下几点：</p>
<ol>
<li>if语句后可以跟上0个或1个else语句，但是elsif后面必须有else语句。</li>
<li>if语句后可以跟上0个或1个elsif语句，但它们必须写在else语句前。</li>
<li>如果其中的一个elsif执行成功，其他的elsif和else将不再被执行。</li>
</ol>
<p>语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(boolean_expression1)&#123;</div><div class="line">   表达式A</div><div class="line">   <span class="comment">#在布尔表达式boolean_expression1为true执行A</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">elsif</span>(boolean_expression2)&#123;</div><div class="line">   表达式B</div><div class="line">   <span class="comment">#在布尔表达式boolean_expression2为true执行B</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">elsif</span>(boolean_expression3)&#123;</div><div class="line">   表达式C</div><div class="line">   <span class="comment">#在布尔表达式boolean_expression3为true执行C</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">   表达式D</div><div class="line">   <span class="comment">#布尔表达式的条件都为false时执行D</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="if…elsif案例1"><a href="#if…elsif案例1" class="headerlink" title="if…elsif案例1:"></a>if…elsif案例1:</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat ifelsif.pl</div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">$a=<span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>($a==<span class="number">20</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The value of a is 20\n"</span>;</div><div class="line">&#125;<span class="keyword">elsif</span>($a==<span class="number">30</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The value of a is 30\n"</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The value of a is $a\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl ifelsif.pl </div><div class="line">The value of a is <span class="number">100</span></div></pre></td></tr></table></figure>
<h2 id="4-unless语句"><a href="#4-unless语句" class="headerlink" title="(4)unless语句"></a>(4)unless语句</h2><p>一个unless语句由一个布尔表达式后跟一个或多个语句组成。语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unless</span>(boolean_expression)&#123;</div><div class="line">    表达式A</div><div class="line">    <span class="comment">#在布尔表达式boolean_expression为false执行A</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="unless使用案例1"><a href="#unless使用案例1" class="headerlink" title="unless使用案例1:"></a>unless使用案例1:</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat unless.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">120</span>;</div><div class="line"></div><div class="line"><span class="keyword">unless</span>($a&lt;<span class="number">20</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"a is more or equeal 20\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">print</span> <span class="string">"The value of a is $a\n"</span>;</div><div class="line"></div><div class="line">$a=<span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="keyword">unless</span>($a)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The condition of a is false\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">print</span> <span class="string">"The value of a is $a\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl unless.pl </div><div class="line">a is more <span class="keyword">or</span> equeal <span class="number">20</span></div><div class="line">The value of a is <span class="number">120</span></div><div class="line">The condition of a is false</div><div class="line">The value of a is</div></pre></td></tr></table></figure>
<h2 id="5-unless…else语句"><a href="#5-unless…else语句" class="headerlink" title="(5)unless…else语句"></a>(5)unless…else语句</h2><p>一个unless语句后可跟一个可选的else语句，else语句在布尔表达式为true时执行。语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unless</span>(boolean_expression)&#123;</div><div class="line">    表达式A</div><div class="line">    <span class="comment">#在布尔表达式boolean_expression为false执行A</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    表达式B</div><div class="line">    <span class="comment">#在布尔表达式boolean_expression为true执行B</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果布尔表达式boolean_expression为false，则执行unless块内的代码。如果布尔表达式为true，则执行else块内的代码。</p>
<h3 id="unless…else使用案例1"><a href="#unless…else使用案例1" class="headerlink" title="unless…else使用案例1:"></a>unless…else使用案例1:</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat unlessif.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">unless</span>($a==<span class="number">20</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The condition given is false\n"</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The conditoin given is true\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">print</span> <span class="string">"The value of a is $a\n"</span>;</div><div class="line"></div><div class="line">$a=<span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="keyword">unless</span>($a)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The condition of a given is false\n"</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The conditoin of a given is true\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">print</span> <span class="string">"THe value of a is $a\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl unlessif.pl </div><div class="line">The condition <span class="keyword">given</span> is false</div><div class="line">The value of a is <span class="number">100</span></div><div class="line">The condition of a <span class="keyword">given</span> is false</div><div class="line">THe value of a is</div></pre></td></tr></table></figure>
<h2 id="6-unless…elsif…else-statement"><a href="#6-unless…elsif…else-statement" class="headerlink" title="(6)unless…elsif…else statement"></a>(6)unless…elsif…else statement</h2><p>一个unless语句后可跟一个可选的elsif语句，然后再跟另一个else语句，这种条件判断语句在多个条件的情况下非常有用。<br>在使用unless,elsif,else语句时你需要注意以下几点。</p>
<ol>
<li>unless语句后可以跟上0个或1个else语句，但是elsif后面必须有else语句。</li>
<li>unless语句后可以跟上0个或1个elsif语句，但它们必须写在else语句前。</li>
<li>如果其中的一个elsif执行成功，其他的elsif和else将不再被执行。</li>
</ol>
<p>它的使用格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unless</span>(boolean_expression1)&#123;</div><div class="line">    表达式A</div><div class="line">    <span class="comment">#在布尔表达式boolean_expression1为false执行A</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">elsif</span>(boolean_expression2)&#123;</div><div class="line">    表达式B</div><div class="line"><span class="comment">#在布尔表达式boolean_expression2为true执行B</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">elsif</span>(boolean_expression3)&#123;</div><div class="line">    表达式C</div><div class="line">    <span class="comment">#在布尔表达式boolean_expression3为true执行C</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">    表达式A</div><div class="line">    <span class="comment">#没有条件匹配时执行D</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="unless…elsif…else-statement使用案例"><a href="#unless…elsif…else-statement使用案例" class="headerlink" title="unless…elsif…else statement使用案例"></a>unless…elsif…else statement使用案例</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat unless03.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="keyword">unless</span>($a==<span class="number">30</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The vlaue of a is not 30\n"</span>;</div><div class="line">&#125;<span class="keyword">elsif</span>($a==<span class="number">30</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The value of a is 30\n"</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The value of a is $a\n"</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl unless03.pl </div><div class="line">The vlaue of a is <span class="keyword">not</span> <span class="number">30</span></div></pre></td></tr></table></figure>
<h2 id="7-switch"><a href="#7-switch" class="headerlink" title="(7)switch"></a>(7)switch</h2><p>一个switch语句允许测试一个变量等于多个值时的情况。每个值称为一个case，且被测试的变量会对每个switch case进行检查。<br>switch case执行是基于<code>Switch</code>模块，<code>Switch</code>模块使用<code>Filter::Util::Call</code>和<code>Text::Balanced</code>来执行，这两个模块都需要安装。</p>
<p>switch的格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> Switch;</div><div class="line"> </div><div class="line">switch(argument)&#123;</div><div class="line">   case <span class="number">1</span>            &#123; <span class="keyword">print</span> <span class="string">"数字 1"</span> &#125;</div><div class="line">   case <span class="string">"a"</span>          &#123; <span class="keyword">print</span> <span class="string">"字符串 a"</span> &#125;</div><div class="line">   case [<span class="number">1</span>..<span class="number">10</span>,<span class="number">42</span>]   &#123; <span class="keyword">print</span> <span class="string">"数字在列表中"</span> &#125;</div><div class="line">   case (\@array)    &#123; <span class="keyword">print</span> <span class="string">"数字在数组中"</span> &#125;</div><div class="line">   case /\w+<span class="regexp">/        &#123; print "正则匹配模式" &#125;</span></div><div class="line"><span class="regexp">   case qr/</span>\w+<span class="regexp">/      &#123; print "正则匹配模式" &#125;</span></div><div class="line"><span class="regexp">   case (\%hash)     &#123; print "哈希" &#125;</span></div><div class="line"><span class="regexp">   case (\&amp;sub)      &#123; print "子进程" &#125;</span></div><div class="line"><span class="regexp">   else              &#123; print "不匹配之前的条件" &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p>以下是switch语句的规则:</p>
<ol>
<li>switch语句的括号中可以使用任意类型的标量参数。</li>
<li>在一个switch中可以有任意数量的case语句。每个case后跟一个要比较的值和一个冒号。</li>
<li>case语句后的标量会与switch语句的标量进行比较，判断是否相等。</li>
<li>当被测试的变量等于case中的常量时，case后跟的语句将被执行，直到遇到break语句为止。</li>
<li>switch语句可以有一个可选的else,该语句在最后面，该语句在所有case不匹配的情况下执行。</li>
<li>当匹配case后，会执行case语句块代码，执行后跳出switch语句。</li>
<li>当匹配case后，如果我们需要继续执行接下来的case语句，则需要添加next语句。</li>
</ol>
<h3 id="switch使用案例"><a href="#switch使用案例" class="headerlink" title="switch使用案例"></a>switch使用案例</h3><p>代码如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat switch01.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">use</span> Switch;</div><div class="line"></div><div class="line">$var=<span class="number">10</span>;</div><div class="line">@array=(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</div><div class="line">%hash=(<span class="string">'key1'</span>=&gt;<span class="number">10</span>,<span class="string">'key2'</span>=&gt;<span class="number">20</span>);</div><div class="line"></div><div class="line">switch($var)&#123;</div><div class="line">    case <span class="number">10</span>            &#123;<span class="keyword">print</span> <span class="string">"Number 10\n"</span>;<span class="keyword">next</span>;&#125;</div><div class="line">    case <span class="string">"a"</span>           &#123;<span class="keyword">print</span> <span class="string">"string a "</span>&#125;</div><div class="line">    case [<span class="number">1</span>..<span class="number">10</span>,<span class="number">42</span>]    &#123;<span class="keyword">print</span> <span class="string">"Number in list"</span>&#125;</div><div class="line">    case (\@array)     &#123;<span class="keyword">print</span> <span class="string">"Number in array"</span>&#125;</div><div class="line">    case (\%hash)      &#123;<span class="keyword">print</span> <span class="string">"In hash"</span>&#125;</div><div class="line">    <span class="keyword">else</span>               &#123;<span class="keyword">print</span> <span class="string">"There is no matching condition"</span>&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl switch01.pl </div><div class="line">Can<span class="string">'t locate Switch.pm in @INC (you may need to install the Switch module) (@INC contains: /home/biotest/miniconda2/lib/perl5/site_perl/5.22.0/x86_64-linux-thread-multi /home/biotest/miniconda2/lib/perl5/site_perl/5.22.0 /home/biotest/miniconda2/lib/perl5/5.22.0/x86_64-linux-thread-multi /home/biotest/miniconda2/lib/perl5/5.22.0 .) at switch01.pl line 3.</span></div><div class="line"><span class="string">BEGIN failed--compilation aborted at switch01.pl line 3.</span></div></pre></td></tr></table></figure>
<p>从结果来看，这是因为Perl没有安装Switch模块，<code>Filter::Util::Call</code>和<code>Text::Balanced</code>接着需要安装这个模块，代码如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">perl -MCPAN -e shell <span class="comment">#进入cpan</span></div><div class="line">install Switch</div><div class="line">install Filter::Util::Call</div><div class="line">install Text::Balanced</div></pre></td></tr></table></figure>
<p>安装后，继续运行，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl switch01.pl </div><div class="line">Number <span class="number">10</span></div><div class="line">Number in list</div></pre></td></tr></table></figure>
<h2 id="8-while循环"><a href="#8-while循环" class="headerlink" title="(8)while循环"></a>(8)while循环</h2><p>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。编程语言提供了更为复杂执行路径的多种控制结构。Perl中有while循环，until循环，for循环。<br>while语句在给定条件为true时，重复执行语句或语句组，循环主体执行之前会先测试条件。<br>while循环的语法格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(condition)</div><div class="line">&#123;</div><div class="line"> statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，statement(s)可以是一个单独的语句，也可以是几个语句组成的代码块。condition可以是任意的表达式，当为任意非零值时都为true。当条件为true时执行循环。当条件为false时，程序流将继续执行紧接着循环的下一条语句。</p>
<h3 id="while循环案例使用"><a href="#while循环案例使用" class="headerlink" title="while循环案例使用"></a>while循环案例使用</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat while.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">10</span>;</div><div class="line"><span class="comment">#execute while loop</span></div><div class="line"><span class="keyword">while</span>($a&lt;<span class="number">20</span>)&#123;</div><div class="line">     <span class="keyword">printf</span> <span class="string">"The value of a is:  $a\n"</span>;</div><div class="line">     $a=$a+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl while.pl </div><div class="line">The value of a is:  <span class="number">10</span></div><div class="line">The value of a is:  <span class="number">11</span></div><div class="line">The value of a is:  <span class="number">12</span></div><div class="line">The value of a is:  <span class="number">13</span></div><div class="line">The value of a is:  <span class="number">14</span></div><div class="line">The value of a is:  <span class="number">15</span></div><div class="line">The value of a is:  <span class="number">16</span></div><div class="line">The value of a is:  <span class="number">17</span></div><div class="line">The value of a is:  <span class="number">18</span></div><div class="line">The value of a is:  <span class="number">19</span></div></pre></td></tr></table></figure>
<p>程序中在变量a小于20时执行循环体，在变量a大于等于20时，退出循环。</p>
<h2 id="8-until循环"><a href="#8-until循环" class="headerlink" title="(8)until循环"></a>(8)until循环</h2><p>until语句在给定条件为false时，重复执行语句或语句组。语法格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">until</span>(condition)</div><div class="line">&#123;</div><div class="line"> statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，statement(s)可以是一个单独的语句，也可以是几个语句组成的代码块。condition可以是任意的表达式，当条件为false时执行循环。当条件为true时，程序流将继续执行紧接着循环的下一条语句。</p>
<h3 id="until循环案例"><a href="#until循环案例" class="headerlink" title="until循环案例"></a>until循环案例</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat until.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">$a=<span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="keyword">until</span>($a&gt;<span class="number">10</span>)&#123;</div><div class="line">    <span class="keyword">printf</span> <span class="string">"The value of a is: $a\n"</span>;</div><div class="line">    $a=$a+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl until.pl </div><div class="line">The value of a is: <span class="number">5</span></div><div class="line">The value of a is: <span class="number">6</span></div><div class="line">The value of a is: <span class="number">7</span></div><div class="line">The value of a is: <span class="number">8</span></div><div class="line">The value of a is: <span class="number">9</span></div><div class="line">The value of a is: <span class="number">10</span></div></pre></td></tr></table></figure>
<p>程序中在变量<code>$a</code>小于10时执行循环体，在变量<code>$a</code>大于等于10时，退出循环。</p>
<h2 id="9-for循环"><a href="#9-for循环" class="headerlink" title="(9)for循环"></a>(9)for循环</h2><p>for循环用于多次执行一个语句序列，简化管理循环变量的代码。语法格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(init;condition;increment)&#123;</div><div class="line"> statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是for循环的控制流程解析：</p>
<ol>
<li>init会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</li>
<li>接下来，会判断condition。如果为true，则执行循环主体。如果为false，则不执行循环主体，且控制流会跳转到紧接着for循环的下一条语句。<br>在执行完for循环主体后，控制流会跳回上面的increment语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</li>
<li>条件再次被判断。如果为true，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为false时，for循环终止。</li>
<li>在这里，statement(s)可以是一个单独的语句，也可以是几个语句组成的代码块。condition可以是任意的表达式，当条件为false时执行循环。<br>当条件为true时，程序流将继续执行紧接着循环的下一条语句。</li>
</ol>
<h3 id="for循环案例"><a href="#for循环案例" class="headerlink" title="for循环案例"></a>for循环案例</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat for.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>($a=<span class="number">1</span>;$a&lt;<span class="number">10</span>;$a=$a+<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The value of a is: $a\n"</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl for.pl </div><div class="line">The value of a is: <span class="number">1</span></div><div class="line">The value of a is: <span class="number">2</span></div><div class="line">The value of a is: <span class="number">3</span></div><div class="line">The value of a is: <span class="number">4</span></div><div class="line">The value of a is: <span class="number">5</span></div><div class="line">The value of a is: <span class="number">6</span></div><div class="line">The value of a is: <span class="number">7</span></div><div class="line">The value of a is: <span class="number">8</span></div><div class="line">The value of a is: <span class="number">9</span></div></pre></td></tr></table></figure>
<h2 id="10-foreach循环"><a href="#10-foreach循环" class="headerlink" title="(10)foreach循环"></a>(10)foreach循环</h2><p>foreach循环用于迭代一个列表或集合变量的值。语法格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">foreach</span> var (list) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="foreach循环案例"><a href="#foreach循环案例" class="headerlink" title="foreach循环案例"></a>foreach循环案例</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat foreach.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@list=(<span class="number">2</span>,<span class="number">12</span>,<span class="number">36</span>,<span class="number">42</span>,<span class="number">51</span>);</div><div class="line"></div><div class="line"><span class="keyword">foreach</span> $a(@list)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"The value of a : $a\n"</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl foreach.pl </div><div class="line">The value of a : <span class="number">2</span></div><div class="line">The value of a : <span class="number">12</span></div><div class="line">The value of a : <span class="number">36</span></div><div class="line">The value of a : <span class="number">42</span></div><div class="line">The value of a : <span class="number">51</span></div></pre></td></tr></table></figure>
<h2 id="11-do…while循环"><a href="#11-do…while循环" class="headerlink" title="(11)do…while循环"></a>(11)do…while循环</h2><p>do…while循环是在循环的尾部检查它的条件。do…while循环与while循环类似，但是do…while循环会确保至少执行一次循环。语法格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line"> statement(<span class="keyword">s</span>);</div><div class="line">&#125;<span class="keyword">while</span>(condition);</div></pre></td></tr></table></figure></p>
<p>请注意，条件表达式出现在循环的尾部，所以循环中的statement(s)会在条件被测试之前至少执行一次。<br>如果条件为true，控制流会跳转回上面的do，然后重新执行循环中的statement(s)。这个过程会不断重复，直到给定条件变为false为止。</p>
<h3 id="do…while案例使用"><a href="#do…while案例使用" class="headerlink" title="do…while案例使用"></a>do…while案例使用</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat dowhile.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    <span class="keyword">printf</span> <span class="string">"The value of a is:  $a\n"</span>;</div><div class="line">    $a=$a+<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">while</span>($a&lt;<span class="number">15</span>);</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl dowhile.pl </div><div class="line">The value of a is:  <span class="number">10</span></div><div class="line">The value of a is:  <span class="number">11</span></div><div class="line">The value of a is:  <span class="number">12</span></div><div class="line">The value of a is:  <span class="number">13</span></div><div class="line">The value of a is:  <span class="number">14</span></div></pre></td></tr></table></figure>
<h2 id="12-循环嵌套"><a href="#12-循环嵌套" class="headerlink" title="(12)循环嵌套"></a>(12)循环嵌套</h2><p>Perl语言允许在一个循环内使用另一个循环，下面演示几个实例来说明这个概念。</p>
<h3 id="12-1-嵌套for循环语句的语法"><a href="#12-1-嵌套for循环语句的语法" class="headerlink" title="(12.1)嵌套for循环语句的语法"></a>(12.1)嵌套for循环语句的语法</h3><p>格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( init; condition; increment )&#123;</div><div class="line">   <span class="keyword">for</span> ( init; condition; increment )&#123;</div><div class="line">      statement(<span class="keyword">s</span>);</div><div class="line">   &#125;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="12-2-while循环嵌套"><a href="#12-2-while循环嵌套" class="headerlink" title="(12.2)while循环嵌套"></a>(12.2)while循环嵌套</h3><p>使用格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(condition)&#123;</div><div class="line">   <span class="keyword">while</span>(condition)&#123;</div><div class="line">      statement(<span class="keyword">s</span>);</div><div class="line">   &#125;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用案例<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat while2.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">0</span>;</div><div class="line">$b=<span class="number">0</span>;;</div><div class="line"></div><div class="line"><span class="keyword">while</span>($a&lt;<span class="number">3</span>)&#123;</div><div class="line">    $b=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>($b&lt;<span class="number">3</span>)&#123;</div><div class="line">         <span class="keyword">print</span> <span class="string">"a=$a,b=$b\n"</span>;</div><div class="line">         $b=$b+<span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line">     $a=$a+<span class="number">1</span>;</div><div class="line">     <span class="keyword">print</span> <span class="string">"a=$a\n\n"</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl while2.pl </div><div class="line">a=<span class="number">0</span>,b=<span class="number">0</span></div><div class="line">a=<span class="number">0</span>,b=<span class="number">1</span></div><div class="line">a=<span class="number">0</span>,b=<span class="number">2</span></div><div class="line">a=<span class="number">1</span></div><div class="line"></div><div class="line">a=<span class="number">1</span>,b=<span class="number">0</span></div><div class="line">a=<span class="number">1</span>,b=<span class="number">1</span></div><div class="line">a=<span class="number">1</span>,b=<span class="number">2</span></div><div class="line">a=<span class="number">2</span></div><div class="line"></div><div class="line">a=<span class="number">2</span>,b=<span class="number">0</span></div><div class="line">a=<span class="number">2</span>,b=<span class="number">1</span></div><div class="line">a=<span class="number">2</span>,b=<span class="number">2</span></div><div class="line">a=<span class="number">3</span></div></pre></td></tr></table></figure></p>
<h3 id="13-3-do…while循环嵌套"><a href="#13-3-do…while循环嵌套" class="headerlink" title="(13.3)do…while循环嵌套"></a>(13.3)do…while循环嵌套</h3><p>格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">   <span class="keyword">do</span>&#123;</div><div class="line">      statement(<span class="keyword">s</span>);</div><div class="line">   &#125;<span class="keyword">while</span>( condition );</div><div class="line"></div><div class="line">&#125;<span class="keyword">while</span>( condition );</div></pre></td></tr></table></figure></p>
<h3 id="13-4-until循环嵌套"><a href="#13-4-until循环嵌套" class="headerlink" title="(13.4)until循环嵌套"></a>(13.4)until循环嵌套</h3><p>格式如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">until</span>(condition)&#123;</div><div class="line">   <span class="keyword">until</span>(condition)&#123;</div><div class="line">      statement(<span class="keyword">s</span>);</div><div class="line">   &#125;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="13-5-foreach循环嵌套"><a href="#13-5-foreach循环嵌套" class="headerlink" title="(13.5)foreach循环嵌套"></a>(13.5)foreach循环嵌套</h3><p>格式如下：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">foreach</span> $a (@listA)&#123;</div><div class="line">   <span class="keyword">foreach</span> $b (@listB)&#123;</div><div class="line">      statement(<span class="keyword">s</span>);</div><div class="line">   &#125;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="13-循环控制语句"><a href="#13-循环控制语句" class="headerlink" title="(13)循环控制语句"></a>(13)循环控制语句</h2><p>循环控制语句改变了代码的执行顺序，通过它你可以实现代码的跳转，Perl中的循环控制语句有这些：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>next 语句</td>
<td>停止执行从next语句的下一语句开始到循环体结束标识符之间的语句，转去执行continue语句块，然后再返回到循环体的起始处开始执行下一次循环。</td>
</tr>
<tr>
<td>last 语句</td>
<td>退出循环语句块，从而结束循环</td>
</tr>
<tr>
<td>continue 语句</td>
<td>continue 语句块通常在条件语句再次判断前执行。</td>
</tr>
<tr>
<td>redo 语句</td>
<td>redo  语句直接转到循环体的第一行开始重复执行本次循环，redo语句之后的语句不再执行，continue语句块也不再执行；</td>
</tr>
<tr>
<td>goto 语句</td>
<td>Perl 有三种 goto 形式：got LABLE，goto EXPR，和 goto  &amp;NAME。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="13-1-next语句"><a href="#13-1-next语句" class="headerlink" title="(13.1) next语句"></a>(13.1) next语句</h3><p>next语句用于停止执行从next语句的下一语句开始到循环体结束标识符之间的语句，转去执行continue语句块，然后再返回到循环体的起始处开始执行下一次循环。语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">next</span>[LABEL];</div></pre></td></tr></table></figure>
<p>其中LABEL是可选的，如果没有指定LABEL，next语句将返回到循环体的起始处开始执行下一次循环，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat next.pl</div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">10</span>;</div><div class="line"><span class="keyword">while</span>($a&lt;<span class="number">20</span>)&#123;</div><div class="line">    <span class="keyword">if</span>($a==<span class="number">15</span>)</div><div class="line">    &#123;</div><div class="line">       <span class="comment"># jump loop</span></div><div class="line">       $a=$a+<span class="number">1</span>;</div><div class="line">       <span class="keyword">next</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">print</span> <span class="string">"The value of a is: $a\n"</span>;</div><div class="line">     $a = $a+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl next.pl </div><div class="line">The value of a is: <span class="number">10</span></div><div class="line">The value of a is: <span class="number">11</span></div><div class="line">The value of a is: <span class="number">12</span></div><div class="line">The value of a is: <span class="number">13</span></div><div class="line">The value of a is: <span class="number">14</span></div><div class="line">The value of a is: <span class="number">16</span></div><div class="line">The value of a is: <span class="number">17</span></div><div class="line">The value of a is: <span class="number">18</span></div><div class="line">The value of a is: <span class="number">19</span></div></pre></td></tr></table></figure>
<p>从结果可以看出，如果a等于15了，就跳出这个循环。</p>
<h3 id="13-2-last语句"><a href="#13-2-last语句" class="headerlink" title="(13.2) last语句"></a>(13.2) last语句</h3><p>last 语句用于退出循环语句块，从而结束循环，last语句之后的语句不再执行，continue语句块也不再执行。语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">last</span> [LABEL];</div></pre></td></tr></table></figure>
<p>案例如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<h3 id="13-3-continue"><a href="#13-3-continue" class="headerlink" title="(13.3)continue"></a>(13.3)continue</h3><p>continue块通常在条件语句再次判断前执行。continue语句可用在while和foreach循环中。<br>while循环中continue语句语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(condition)&#123;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">&#125;<span class="keyword">continue</span>&#123;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>foreach循环中continue语句语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">foreach</span> $a (@listA)&#123;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">&#125;<span class="keyword">continue</span>&#123;</div><div class="line">   statement(<span class="keyword">s</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>while中的continue使用案例如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat continue.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>($a&lt;<span class="number">3</span>)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"a=$a\n"</span>;</div><div class="line">&#125;<span class="keyword">continue</span>&#123;</div><div class="line">    $a=$a+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl continue.pl </div><div class="line">a=<span class="number">0</span></div><div class="line">a=<span class="number">1</span></div><div class="line">a=<span class="number">2</span></div></pre></td></tr></table></figure>
<p>foreach中的continue使用如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat continue2.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@list=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</div><div class="line"><span class="keyword">foreach</span> $a(@list)&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"a=$a\n"</span>;</div><div class="line">&#125;<span class="keyword">continue</span>&#123;</div><div class="line">    <span class="keyword">last</span> <span class="keyword">if</span> $a==<span class="number">4</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl continue2.pl </div><div class="line">a=<span class="number">1</span></div><div class="line">a=<span class="number">2</span></div><div class="line">a=<span class="number">3</span></div><div class="line">a=<span class="number">4</span></div></pre></td></tr></table></figure>
<h3 id="13-4-0redo语句"><a href="#13-4-0redo语句" class="headerlink" title="(13.4)0redo语句"></a>(13.4)0redo语句</h3><p>redo语句直接转到循环体的第一行开始重复执行本次循环，redo语句之后的语句不再执行，continue语句块也不再执行。continue语句可用在while和foreach循环中。<br>语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">redo</span> [LABEL]</div></pre></td></tr></table></figure>
<p>其中LABEL是可选的。带标号修饰符LABEL的redo语句表示把循环控制流程直接转到与标号修饰符LABEL相关联的语句块的第一行处开始执行，而不再执行redo语句之后的语句和continue语句块；不带标号修饰符LABEL的redo语句表示把循环控制流程直接转到当前语句块的第一行处开始执行，而不再执行redo语句之后的语句和continue语句块；如果是在for循环中或者是带有continue语句块，则for循环中的递增列表和continue语句块都不再被执行，看下面的案例：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat redo.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>($a&lt;<span class="number">10</span>)&#123;</div><div class="line">    <span class="keyword">if</span>($a==<span class="number">5</span>)&#123;</div><div class="line">      $a=$a+<span class="number">1</span>;</div><div class="line">      <span class="keyword">redo</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">print</span> <span class="string">"a=$a\n"</span>;</div><div class="line">&#125;<span class="keyword">continue</span>&#123;</div><div class="line">    $a=$a+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl redo.pl </div><div class="line">a=<span class="number">0</span></div><div class="line">a=<span class="number">1</span></div><div class="line">a=<span class="number">2</span></div><div class="line">a=<span class="number">3</span></div><div class="line">a=<span class="number">4</span></div><div class="line">a=<span class="number">6</span></div><div class="line">a=<span class="number">7</span></div><div class="line">a=<span class="number">8</span></div><div class="line">a=<span class="number">9</span></div></pre></td></tr></table></figure>
<p>从结果来看，当a=5时，重新转到第一行运行。</p>
<h3 id="13-5-goto语句"><a href="#13-5-goto语句" class="headerlink" title="(13.5)goto语句"></a>(13.5)goto语句</h3><p>Perl 有三种 goto 形式：got LABLE，goto EXPR，和 goto &amp;NAME，如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>goto 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>goto LABEL-找出标记为  LABEL 的语句并且从那里重新执行。</td>
</tr>
<tr>
<td>2</td>
<td>goto EXPR-goto  EXPR 形式只是 goto LABEL 的一般形式。它期待表达式生成一个标记名称，并跳到该标记处执行。</td>
</tr>
<tr>
<td>3</td>
<td>goto  &amp;NAME-它把正 在运行着的子进程替换为一个已命名子进程的调用。</td>
</tr>
</tbody>
</table>
</div>
<p>语法格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">goto</span> LABEL</div><div class="line">或</div><div class="line"><span class="keyword">goto</span> EXPR</div><div class="line">或</div><div class="line"><span class="keyword">goto</span> &amp;NAME</div></pre></td></tr></table></figure>
<p>使用案例如下所示：</p>
<p>在下面的这个案例中，当a=15时，跳出循环，进入<code>LOOP</code>这个标签处，此时a=16，继续循环。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>下面的这个案例使用了goto EXPR的形式，它其实就是上一下案例的变形，只是中间的LABEL变成了一个表达式，本质还是一样的，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat gotoexpr.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">10</span>;</div><div class="line">$str1=<span class="string">"LO"</span>;</div><div class="line">$str2=<span class="string">"OP"</span>;</div><div class="line"></div><div class="line">LOOP:<span class="keyword">do</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>($a==<span class="number">15</span>)&#123;</div><div class="line">        $a=$a+<span class="number">1</span>;</div><div class="line">        <span class="keyword">goto</span> $str1.$str2; <span class="comment"># this is similar to goto LOOP</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">print</span> <span class="string">"a=$a\n"</span>;</div><div class="line">    $a=$a+<span class="number">1</span>;</div><div class="line">&#125;<span class="keyword">while</span>($a&lt;<span class="number">20</span>);</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl gotoexpr.pl </div><div class="line">a=<span class="number">10</span></div><div class="line">a=<span class="number">11</span></div><div class="line">a=<span class="number">12</span></div><div class="line">a=<span class="number">13</span></div><div class="line">a=<span class="number">14</span></div><div class="line">a=<span class="number">16</span></div><div class="line">a=<span class="number">17</span></div><div class="line">a=<span class="number">18</span></div><div class="line">a=<span class="number">19</span></div></pre></td></tr></table></figure>
<h2 id="14-错误处理"><a href="#14-错误处理" class="headerlink" title="(14)错误处理"></a>(14)错误处理</h2><p>程序运行过程中，总会碰到各式各样的错误，比如打开一个不存在的文件。程序运行过程中如果出现错误就会停止，我们就需要使用一些检测方法来避免错误，从而防止程序退出。</p>
<h3 id="14-1-if语句判断错误"><a href="#14-1-if语句判断错误" class="headerlink" title="(14.1) if语句判断错误"></a>(14.1) if语句判断错误</h3><p>if语句可以用于判断返回值，使用格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">open</span>(DATA, $file))&#123;</div><div class="line">   ...</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">   <span class="keyword">die</span> <span class="string">"Error:Can not open file - $!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果文件打不开，就会返回错误信息，错误信息包含在变量<code>$!</code>中，上述代码也可以简化为以下的代码：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span>(DATA,$file)||<span class="keyword">die</span> <span class="string">"Error:Can not open file - $!"</span>;</div></pre></td></tr></table></figure>
<h3 id="14-2-unless函数判断错误"><a href="#14-2-unless函数判断错误" class="headerlink" title="(14.2)unless函数判断错误"></a>(14.2)unless函数判断错误</h3><p>unless函数与if相反，只有在表达式返回false时才会执行，使用方法如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unless</span>(<span class="keyword">chdir</span>(<span class="string">"/etc"</span>)&#123;</div><div class="line">    <span class="keyword">die</span> <span class="string">"Error: Can not open directionary-$!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样也可以简写为：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">die</span> <span class="string">"Error:Can not open directionary-$!"</span>;</div></pre></td></tr></table></figure>
<p>以上错误信息只有在目录切换出现错误的情况下才会出现。</p>
<h3 id="14-3-三元运算符"><a href="#14-3-三元运算符" class="headerlink" title="(14.3)三元运算符"></a>(14.3)三元运算符</h3><p>以下是三元运算符的使用案例：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span>(<span class="keyword">exists</span>($hash<span class="string">&#123;value&#125;</span>)?<span class="string">'Exist'</span>:<span class="string">'No Exist'</span>,<span class="string">"\n"</span>);</div></pre></td></tr></table></figure>
<p><code>exists</code>函数用于判断hash里面有没有对应的key，如果存在，返回True，不存在返回False。三元运算符的基本格式就是格式为<code>表达式 ? 值一 : 值二。</code></p>
<h3 id="14-4-warn函数"><a href="#14-4-warn函数" class="headerlink" title="(14.4)warn函数"></a>(14.4)warn函数</h3><p>warn函数用于触发一个警告信息，不会有其他操作，输出到STDERR(标准输出文件)，通常用于给用户提示，使用方法如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">chdir</span>(<span class="string">'/etc'</span>) <span class="keyword">or</span> <span class="keyword">warn</span> <span class="string">"Can not change directionary"</span>;</div></pre></td></tr></table></figure></p>
<h3 id="14-5-die函数"><a href="#14-5-die函数" class="headerlink" title="(14.5)die函数"></a>(14.5)die函数</h3><p>die函数类似于warn, 但它会执行退出。一般用作错误信息的输出，使用方法如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">chdir</span>(<span class="string">'/etc'</span>) <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can not change directionary"</span>;</div></pre></td></tr></table></figure>
<h3 id="14-6-Carp模块"><a href="#14-6-Carp模块" class="headerlink" title="(14.6)Carp模块"></a>(14.6)Carp模块</h3><p>在Perl脚本中，报告错误的常用方法是使用<code>warn()</code>或<code>die()</code>函数来报告或产生错误。而对于<code>Carp</code>模块，它可以对产生的消息提供额外级别的控制，尤其是在模块内部。标准<code>Carp模块</code>提供了<code>warn()</code>和<code>die()</code>函数的替代方法，它们在提供错误定位方面提供更多信息，而且更加友好。当在模块中使用时，错误消息中包含模块名称和行号。</p>
<h4 id="14-6-1-carp函数"><a href="#14-6-1-carp函数" class="headerlink" title="(14.6.1) carp函数"></a>(14.6.1) carp函数</h4><p><code>carp</code>函数可以输出程序的跟踪信息，类似于<code>warn</code>函数，通常会将该信息发送到<code>STDERR</code>，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ cat carp.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> T;</div><div class="line"></div><div class="line"><span class="keyword">require</span> Exporter;</div><div class="line">@ISA=<span class="keyword">qw</span>/Exporter/;</div><div class="line">@EXPORT=<span class="keyword">qw</span>/function/;</div><div class="line"><span class="keyword">use</span> Carp;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">function</span></span>&#123;</div><div class="line">    carp <span class="string">"Error in module!"</span>;</div><div class="line">&#125;</div><div class="line"><span class="number">1</span>;</div><div class="line"><span class="keyword">use</span> T;</div><div class="line">function();</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perl carp.pl</div><div class="line">Can<span class="string">'t locate T.pm in @INC (you may need to install the T module) (@INC contains: /home/biotest/miniconda2/lib/perl5/site_perl/5.22.0/x86_64-linux-thread-multi /home/biotest/miniconda2/lib/perl5/site_perl/5.22.0 /home/biotest/miniconda2/lib/perl5/5.22.0/x86_64-linux-thread-multi /home/biotest/miniconda2/lib/perl5/5.22.0 .) at carp.pl line 14.</span></div><div class="line"><span class="string">BEGIN failed--compilation aborted at carp.pl line 14.</span></div></pre></td></tr></table></figure>
<p>Carp模块里面好多代码不懂，先空起来，有空再来补充笔记。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.runoob.com/perl/perl-tutorial.html" target="_blank" rel="external">Perl教程|菜鸟教程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/13/Perl/Perl学习笔记（2）-数据、变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/Perl/Perl学习笔记（2）-数据、变量/" itemprop="url">Perl学习笔记（2）-变量、数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T12:00:00+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Perl/" itemprop="url" rel="index">
                    <span itemprop="name">Perl</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,577
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  28
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Perl的数据类型总览"><a href="#Perl的数据类型总览" class="headerlink" title="Perl的数据类型总览"></a>Perl的数据类型总览</h2><p>Perl 是一种弱类型语言，所以变量不需要指定类型，Perl 解释器会根据上下文自动选择匹配类型。Perl 有三个基本的数据类型：标量、数组、哈希。</p>
<h2 id="标量（scalar）"><a href="#标量（scalar）" class="headerlink" title="标量（scalar）"></a>标量（scalar）</h2><p>标量是Perl语言中最基本的一种数据类型。这种数据类型的变量可以是数字，字符串，浮点数，八进制等，不作严格的区分。在使用时在变量的名字前面加上一个<code>$</code>表示是标量。如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$myfirst=<span class="number">123</span>;　    <span class="comment">#数字123　</span></div><div class="line">$mysecond=<span class="string">"123"</span>;   <span class="comment">#字符串123</span></div></pre></td></tr></table></figure>
<p>我不是太能理解标量的含义，我猜测可能是因为Perl擅长处理文本，而把一些最基本的符号，例如数字，字符串，浮点数都当作是一个东西，这样比较容易达到目的，毕竟Perl设计的初衷并不是为了处理一些数据。因此对于标量的理解，就把它当作是组成文本的最基本单位就行了。</p>
<h3 id="define函数判断变量的定义"><a href="#define函数判断变量的定义" class="headerlink" title="define函数判断变量的定义"></a>define函数判断变量的定义</h3><p>如果未定义变量，那么这个变量就会赋予<code>undef</code>的值，它不是数字，也不是字符串，有时候也会被当作数字0，使用<code>defined</code>函数会知道一个变量是否被定义了，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ cat define.pl </div><div class="line"><span class="comment">#!/usr/bin/perl -w</span></div><div class="line"></div><div class="line">$var = <span class="keyword">undef</span>;</div><div class="line"><span class="keyword">print</span> ($var);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">defined</span>($var))&#123;</div><div class="line">    <span class="keyword">print</span>(<span class="string">"definded!\n"</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">print</span>(<span class="string">"undefined!\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$var++;</div><div class="line"><span class="keyword">print</span>($var.<span class="string">"\n"</span>);</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ perl define.pl </div><div class="line">Use of uninitialized value $var in <span class="keyword">print</span> at define.pl line <span class="number">4</span>.</div><div class="line">undefined!</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="单引号内的字符串"><a href="#单引号内的字符串" class="headerlink" title="单引号内的字符串"></a>单引号内的字符串</h3><p>单引号内的字符串直接量指的是一对单引号内的一串字符，这两个单引号并不属于字符串的内容。如果要表示单引号，需要加反斜线进行转义，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'fred'</span> <span class="comment"># 共4个字符，即f、r、e、d</span></div><div class="line"><span class="string">''</span> <span class="comment"># 空字符</span></div><div class="line"><span class="string">'Dont\'t'</span> <span class="comment"># 加了反斜线进行转义</span></div></pre></td></tr></table></figure>
<h3 id="双引号内的字符串"><a href="#双引号内的字符串" class="headerlink" title="双引号内的字符串"></a>双引号内的字符串</h3><p>双引号可以转义许多字符，或者是用八进制或十六进制写法来表示任何字符，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"barney"</span> <span class="comment"># 这种写法与'barney'写法一样</span></div><div class="line"><span class="string">"hello world\n"</span> <span class="comment"># 输出为helloworld，后面接着换行符</span></div><div class="line"><span class="string">"coke\tspirte"</span> <span class="comment"># 输出结果为coke、制表符、spirte</span></div></pre></td></tr></table></figure>
<h3 id="Perl中的转义字符"><a href="#Perl中的转义字符" class="headerlink" title="Perl中的转义字符"></a>Perl中的转义字符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\\</td>
<td>反斜线</td>
</tr>
<tr>
<td>\’</td>
<td>单引号</td>
</tr>
<tr>
<td>\”</td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>系统响铃</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\0nn</td>
<td>创建八进制格式的数字</td>
</tr>
<tr>
<td>\xnn</td>
<td>创建十六进制格式的数字</td>
</tr>
<tr>
<td>\cX</td>
<td>控制字符，x可以是任何字符</td>
</tr>
<tr>
<td>\u</td>
<td>强制下一个字符为大写</td>
</tr>
<tr>
<td>\l</td>
<td>强制下一个字符为小写</td>
</tr>
<tr>
<td>\U</td>
<td>强制将所有字符转换为大写</td>
</tr>
<tr>
<td>\L</td>
<td>强制将所有的字符转换为小写</td>
</tr>
<tr>
<td>\Q</td>
<td>将到\E为止的非单词（non-word）字符加上反斜线</td>
</tr>
<tr>
<td>\E</td>
<td>结束\L、\U、\Q</td>
</tr>
</tbody>
</table>
</div>
<h4 id="转义字符的使用案例"><a href="#转义字符的使用案例" class="headerlink" title="转义字符的使用案例"></a>转义字符的使用案例</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat escapecharacter.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$result = <span class="string">"newbie tutorial \"runoob\""</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$result\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"\$result\n"</span>;</div><div class="line"></div><div class="line">$str=<span class="string">"BAIDU search \nwwww.baidu.com"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$str\n"</span>;</div><div class="line"></div><div class="line">$str=<span class="string">'BAIDU search \nwwww.baidu.com'</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$str\n"</span>;</div><div class="line"></div><div class="line">$str = <span class="string">'\Ulinux'</span>;<span class="comment"># 单引号不能进行转义</span></div><div class="line"><span class="keyword">print</span> <span class="string">"$str\n"</span>;</div><div class="line"></div><div class="line">$str = <span class="string">"Welcome to \Utaobao\E.com!"</span>; <span class="comment"># 大写E表示大写到此终止</span></div><div class="line"><span class="keyword">print</span> <span class="string">"$str\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># Notice following code don't contain E</span></div><div class="line">$str=<span class="string">"Welcome to \Utaobao.com"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$str\n"</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl escapecharacter.pl </div><div class="line">newbie tutorial <span class="string">"runoob"</span></div><div class="line">$result</div><div class="line">BAIDU search </div><div class="line">wwww.baidu.com</div><div class="line">BAIDU search \nwwww.baidu.com</div><div class="line">\Ulinux</div><div class="line">Welcome to TAOBAO.com!</div><div class="line">Welcome to TAOBAO.COM</div></pre></td></tr></table></figure>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>字符串的连接使用点号（<code>.</code>），如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ cat dot.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">$hello=<span class="string">"hello"</span>;</div><div class="line">$world=<span class="string">"world"</span>;</div><div class="line"><span class="keyword">print</span> $hello.$world.<span class="string">"\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ perl dot.pl </div><div class="line">helloworld</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$</div></pre></td></tr></table></figure>
<p>字符串也能做乘法，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">$word=<span class="string">"fred"</span>;</div><div class="line"><span class="keyword">print</span> $word <span class="keyword">x</span> <span class="number">3</span>; <span class="comment"># 这个格式是变量+空格+小写字母x+空格+数字</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl repeat.pl </div><div class="line">fredfredfredbiotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$</div></pre></td></tr></table></figure>
<h3 id="数字与字符串之间的自动转换"><a href="#数字与字符串之间的自动转换" class="headerlink" title="数字与字符串之间的自动转换"></a>数字与字符串之间的自动转换</h3><p>通常Perl会根据需要，自动在数字和字符串之间进行类型转换。这主要取决于操作符，如果操作符（比如+）需要的是数字，Perl就会将操作数视为数字，如果是操作符（比如点号）需要字符串时，Perl便会将操作数视为字符串。因此，你不必担心数字和字符串间的差异，只管合理使用操作符，Perl会自动完成剩下的工作。</p>
<p>对数字进行运算的操作符（例如乘法），如果遇到字符串类型的操作，Perl会自动将字符串转换成等效的十进制浮点数进行运算，例如<code>&quot;12&quot;*&quot;3&quot;</code>的结果会是36，字符串中非数字的部分（以前前置的空白符号）会被忽略，因此，”12fred34”*”3”也会得到36。完全不含数字的字符串会被转换为零。“前置零”只对直接量有效，不能用于字符串的自动转换，自动转换只能按照十进制数字来处理，例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0377</span> <span class="comment"># 十进制数字255的八进制写法</span></div><div class="line"><span class="string">'0377'</span> <span class="comment"># 会转换成十进制数字377，任何其他进制的数字都会被转换为十进制</span></div></pre></td></tr></table></figure>
<p>在进行字符串的操作时（例如使用字符串连接符号）意外得到数字时，为数字就会被转换为形式相的字符串。比如要把字符串Z与“5乘以7的结果”相连接，就如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Z"</span>. <span class="number">5</span>*<span class="number">7</span> <span class="comment">#等同于"Z".35，得到"Z35"</span></div></pre></td></tr></table></figure>
<h2 id="标量变量"><a href="#标量变量" class="headerlink" title="标量变量"></a>标量变量</h2><p>Perl中变量是通过前面的符号来区分的，这个符号称为魔符（sigil），变量分为标量变量（用<code>$</code>来区分），数组变量（用<code>@</code>来区分），哈希变量（用<code>%</code>来区分）。</p>
<h3 id="标量变量的赋值"><a href="#标量变量的赋值" class="headerlink" title="标量变量的赋值"></a>标量变量的赋值</h3><p>变量不需要声明类型，在变量赋值后，解释器会自动分配匹配的类型空间，变量使用等号(=)来赋值，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat variable.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">$age=<span class="number">25</span>; <span class="comment"># 整型</span></div><div class="line">$name=<span class="string">"Zhang San"</span>; <span class="comment"># 字符串</span></div><div class="line">$number=<span class="number">123.456</span>;<span class="comment"># 浮点数</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Age=$age\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"Name=$name\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"Salary=$number\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl variable.pl </div><div class="line">Age=<span class="number">25</span></div><div class="line">Name=Zhang San</div><div class="line">Salary=<span class="number">123.456</span></div></pre></td></tr></table></figure>
<h3 id="借助代码点创建字符"><a href="#借助代码点创建字符" class="headerlink" title="借助代码点创建字符"></a>借助代码点创建字符</h3><p>用于编码抽象字符的整数范围叫做代码空间，其中的特殊整数叫做代码点（code point），简单来说，就是处理一些不常见字符的代码。在Perl中，使用代码点，然后使用chr()函数转换为对应的字符，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat codepoint.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">$alef=<span class="keyword">chr</span>(<span class="number">0x05D</span>);</div><div class="line">$alpha=<span class="keyword">chr</span>(<span class="keyword">hex</span>(<span class="string">'03B1'</span>));</div><div class="line">$omega=<span class="keyword">chr</span>(<span class="number">0x03C9</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"This is $alef\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"This is alpha, $alpha\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"This is omega, $omega\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl codepoint.pl </div><div class="line">This is ]</div><div class="line">Wide character in <span class="keyword">print</span> at codepoint.pl line <span class="number">6</span>.</div><div class="line">This is alpha, α</div><div class="line">Wide character in <span class="keyword">print</span> at codepoint.pl line <span class="number">7</span>.</div><div class="line">This is omega, ω</div></pre></td></tr></table></figure>
<p>从结果可以看出，使用代码点可以输出一些特殊字符，结果中还有一些提示信息，提示这些字符是宽字符，先不用管它们。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>如果把Perl的标量（scalar）理解为单数（singular），那么Perl里的复数（plural）就是数组与列表。数组是用于存储一个有序的标量值的变量。数组用<code>@</code>表示，要访问数组的变量，可以使用美元符号(<code>$</code>)+变量名，并指定下标来访问，实例如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat array.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@ages=(<span class="number">25</span>,<span class="number">30</span>,<span class="number">40</span>);</div><div class="line">@names=(<span class="string">"google"</span>,<span class="string">"runoob"</span>,<span class="string">"taobao"</span>);</div><div class="line"></div><div class="line"><span class="keyword">print</span><span class="string">"\$ages[0]=$ages[0]\n"</span>;</div><div class="line"><span class="comment"># 在 $ 标记前使用了转义字符 (\) ，这样才能输出字符 $</span></div><div class="line"><span class="keyword">print</span><span class="string">"\ages[1]=$ages[1]\n"</span>;</div><div class="line"><span class="keyword">print</span><span class="string">"\$ages[2]=$ages[2]\n"</span>;</div><div class="line"><span class="keyword">print</span><span class="string">"\ages[0]=$ages[0]\n"</span>;</div><div class="line"><span class="keyword">print</span><span class="string">"\$ages[1]=$ages[1]\n"</span>;</div><div class="line"><span class="keyword">print</span><span class="string">"\$ages[2]=$ages[2]\n"</span>;</div><div class="line"><span class="keyword">print</span><span class="string">"\$ages[-1]=$ages[-1]\n"</span>;</div><div class="line"><span class="comment"># 在Perl中，可以使用-1表示最后一个索引</span></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl array.pl </div><div class="line">$ages[<span class="number">0</span>]=<span class="number">25</span></div><div class="line">ges[<span class="number">1</span>]=<span class="number">30</span></div><div class="line">$ages[<span class="number">2</span>]=<span class="number">40</span></div><div class="line">ges[<span class="number">0</span>]=<span class="number">25</span></div><div class="line">$ages[<span class="number">1</span>]=<span class="number">30</span></div><div class="line">$ages[<span class="number">2</span>]=<span class="number">40</span></div><div class="line">$ages[-<span class="number">1</span>]=<span class="number">40</span></div></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是包含在括号里的一序列的值，可以为任何数值，也可为空，如<code>(1, 5.3 , &quot;hello&quot; , 2)</code>，空列表：<code>()</code>，下面都是列表：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="number">17</span>, $var, <span class="string">"a string"</span>)</div><div class="line">(<span class="number">17</span>, <span class="number">26</span> &lt;&lt; <span class="number">2</span>)</div><div class="line">(<span class="number">17</span>, $var1 + $var2)</div><div class="line">($value, <span class="string">"The answer is $value"</span>)</div></pre></td></tr></table></figure>
<p>列表存贮于数组变量中，数组变量以字符”@”打头，以<code>@ages=(25,30,40);</code>为例说明一下：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180517/HD6JF30LbI.png?imageslim" alt="mark"></p>
<p>数组还可以产使用<code>qw</code>定义数组，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat qw.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@array1=(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'hello'</span>);</div><div class="line">@array2=<span class="keyword">qw</span>/this is an array/;</div><div class="line"><span class="keyword">print</span>(<span class="string">"@array1\n"</span>);</div><div class="line"><span class="keyword">print</span>(<span class="string">"@array2\n"</span>);</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl qw.pl </div><div class="line"><span class="number">1</span> <span class="number">2</span> hello</div><div class="line">this is an array</div></pre></td></tr></table></figure>
<p>Perl提供了可以按序列输出的数组形式，格式为<code>起始值 + .. + 结束值</code>，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat dot2.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@var_10=(<span class="number">1</span>..<span class="number">10</span>);</div><div class="line">@var_20=(<span class="number">10</span>..<span class="number">20</span>);</div><div class="line">@var_abc=(a..z);</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"@var_10\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"@var_20\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"@var_abc\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl dot2.pl </div><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></div><div class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></div><div class="line">a b c d e f g h i j k l <span class="keyword">m</span> n o p <span class="keyword">q</span> r <span class="keyword">s</span> t u v w <span class="keyword">x</span> <span class="keyword">y</span> z</div></pre></td></tr></table></figure>
<p>数组长度返回的是数组物理大小，而不是元素的个数，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat size.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">@array=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">$array[<span class="number">50</span>]=<span class="number">4</span>;</div><div class="line"></div><div class="line">$size=@array;</div><div class="line">$max_index=$#array;</div><div class="line"><span class="keyword">print</span> <span class="string">"the size of array: $size\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"the max of index: $max_index\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl size.pl </div><div class="line">the size of array: <span class="number">51</span></div><div class="line">the max of <span class="keyword">index</span>: <span class="number">50</span></div></pre></td></tr></table></figure>
<p>从输出的结果可以看出，数组元素只有四个，但是数组大小为 51。</p>
<h3 id="添加与删除数组元素"><a href="#添加与删除数组元素" class="headerlink" title="添加与删除数组元素"></a>添加与删除数组元素</h3><p>添加和删除数组元素，数组中常用的操作函数如下所示：</p>
<ol>
<li>push @ARRAY, LIST——将列表的值放到数组的末尾</li>
<li>pop @ARRAY——弹出数组最后一个值，并返回它</li>
<li>shift @ARRAY——弹出数组第一个值，并返回它。数组的索引值也依次减一。</li>
<li>unshift @ARRAY, LIST——将列表放在数组前面，并返回新数组的元素个数。</li>
</ol>
<p>看下面的案例：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat array_del.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="comment"># creat a simple array</span></div><div class="line">@sites=(<span class="string">"google"</span>,<span class="string">"microsoft"</span>,<span class="string">"ibm"</span>);</div><div class="line"><span class="keyword">print</span><span class="string">"1.\@sites=@sites\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># add an element in the end of the array:</span></div><div class="line"><span class="keyword">push</span>(@sites,<span class="string">"intel"</span>);</div><div class="line"><span class="keyword">print</span><span class="string">"2.\@sites=@sites\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># add an element in the beginning of the array:</span></div><div class="line"><span class="keyword">unshift</span>(@sites,<span class="string">"sun"</span>);</div><div class="line"><span class="keyword">print</span><span class="string">"3.\@sites=@sites\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># delete an element in the end of the array:</span></div><div class="line"><span class="keyword">pop</span>(@sites);</div><div class="line"><span class="keyword">print</span><span class="string">"4.\@sites=@sites\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># delete an element in the begining of the array:</span></div><div class="line"><span class="keyword">shift</span>(@sites);</div><div class="line"><span class="keyword">print</span><span class="string">"5.\@sites=@sites\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl array_del.pl </div><div class="line"><span class="number">1</span>.@sites=google microsoft ibm</div><div class="line"><span class="number">2</span>.@sites=google microsoft ibm intel</div><div class="line"><span class="number">3</span>.@sites=sun google microsoft ibm intel</div><div class="line"><span class="number">4</span>.@sites=sun google microsoft ibm</div><div class="line"><span class="number">5</span>.@sites=google microsoft ibm</div></pre></td></tr></table></figure>
<h3 id="切割数组"><a href="#切割数组" class="headerlink" title="切割数组"></a>切割数组</h3><p>切割一个数组，并返回切割后的新数组，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat cut.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@sites=<span class="keyword">qw</span>/google tencent jd facebook <span class="number">163</span> microsoft/;</div><div class="line">@sites2=@sites[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">print</span> <span class="string">"@sites2\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl cut.pl </div><div class="line">facebook <span class="number">163</span> microsoft</div></pre></td></tr></table></figure>
<h3 id="替换数组元素"><a href="#替换数组元素" class="headerlink" title="替换数组元素"></a>替换数组元素</h3><p>Perl 中数组元素替换使用 splice() 函数，语法格式如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">splice</span> @ARRAY, OFFSET [ , LENGTH [ , LIST ] ]</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ol>
<li>@ARRAY：要替换的数组。</li>
<li>OFFSET：起始位置。</li>
<li>LENGTH：替换的元素个数。</li>
<li>LIST：替换元素列表。</li>
</ol>
<p>以下案例从第6个元素开始替换数组中的5个元素：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat replace.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@nums=(<span class="number">1</span>..<span class="number">20</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"Before replacement--@nums\n"</span>;</div><div class="line"><span class="keyword">splice</span>(@nums,<span class="number">5</span>,<span class="number">6</span>,<span class="number">20</span>..<span class="number">25</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"After replacement--@nums\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl replace.pl </div><div class="line">Before replacement--<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></div><div class="line">After replacement--<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></div></pre></td></tr></table></figure>
<p>可以看出来，从第６个元素开始替换，替换的是从第５个元素开始往后的６个元素。</p>
<h3 id="将字符串转换为数组"><a href="#将字符串转换为数组" class="headerlink" title="将字符串转换为数组"></a>将字符串转换为数组</h3><p>Perl 中将字符串转换为数组使用 split() 函数，语法格式如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">split</span> [ PATTERN [ , EXPR [ , LIMIT ] ] ]</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ol>
<li>PATTERN：分隔符，默认为空格。</li>
<li>EXPR：指定字符串数。</li>
<li>LIMIT：如果指定该参数，则返回该数组的元素个数。</li>
</ol>
<p>看下面的案例</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat trans_character_array.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="comment"># define string:</span></div><div class="line">$var_test=<span class="string">"baidu"</span>;</div><div class="line">$var_string=<span class="string">"www-baidu-com"</span>;</div><div class="line">$var_names=<span class="string">"google, interl, baidu,ati"</span>;</div><div class="line"></div><div class="line"><span class="comment"># transform strings into array:</span></div><div class="line">@test=<span class="keyword">split</span>(<span class="string">''</span>,$var_test);</div><div class="line">@string=<span class="keyword">split</span>(<span class="string">'-'</span>,$var_string);</div><div class="line">@names=<span class="keyword">split</span>(<span class="string">','</span>,$var_names);</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"$test[3]\n"</span>; <span class="comment"># output character "d"</span></div><div class="line"><span class="keyword">print</span> <span class="string">"$string[2]\n"</span>; <span class="comment"># output character "com"</span></div><div class="line"><span class="keyword">print</span> <span class="string">"$names[3]\n"</span>; <span class="comment"># output character "ati"</span></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl trans_character_array.pl </div><div class="line">d</div><div class="line">com</div><div class="line">ati</div></pre></td></tr></table></figure>
<h3 id="将数组转换为字符串"><a href="#将数组转换为字符串" class="headerlink" title="将数组转换为字符串"></a>将数组转换为字符串</h3><p>Perl 中将数组转换为字符串使用 join() 函数，语法格式如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">join</span> EXPR, LIST</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ol>
<li>EXPR：连接符。</li>
<li>LIST：列表或数组。</li>
</ol>
<p>如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat array_into_string.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="comment"># defing string:</span></div><div class="line">$var_string=<span class="string">"wwww-baidu-com"</span>;</div><div class="line">$var_names=<span class="string">"google,intel,ibm,tencent"</span>;</div><div class="line"></div><div class="line"><span class="comment"># Transform string into array:</span></div><div class="line">@string=<span class="keyword">split</span>(<span class="string">'-'</span>,$var_string);</div><div class="line">@names=<span class="keyword">split</span>(<span class="string">','</span>,$var_names);</div><div class="line"></div><div class="line"><span class="comment"># Transform array into string:</span></div><div class="line">$string1=<span class="keyword">join</span>(<span class="string">'-'</span>,@string);</div><div class="line">$string2=<span class="keyword">join</span>(<span class="string">','</span>,@names);</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"$string1\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$string2\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl array_into_string.pl </div><div class="line">wwww-baidu-com</div><div class="line">google,intel,ibm,tencent</div></pre></td></tr></table></figure>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>Perl 中数组排序使用 sort() 函数，语法格式如下：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sort</span> [ SUBROUTINE ] LIST</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<ol>
<li>SUBROUTINE：指定规则。</li>
<li>LIMIT：列表或数组。</li>
</ol>
<p>案例如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat sort.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@sites=<span class="string">qw(ibm tencent amzon sun microsoft interl)</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"beofore sorting: @sites\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># sort array</span></div><div class="line">@sites=<span class="keyword">sort</span>(@sites);</div><div class="line"><span class="keyword">print</span> <span class="string">"After sorting: @sites\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl sort.pl </div><div class="line">beofore sorting: ibm tencent amzon sun microsoft interl</div><div class="line">After sorting: amzon ibm interl microsoft sun tencent</div></pre></td></tr></table></figure>
<h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><p>数组的元素是以逗号来分割，我们也可以使用逗号来合并数组，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat merge.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@n1=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">@n2=(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</div><div class="line">@n =(@n1,@n2);</div><div class="line"><span class="keyword">print</span> <span class="string">"numbers1:@n1\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"numbers2:@n2\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"Merge numbers1 and numbers2:@n\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl merge.pl </div><div class="line">numbers1:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">numbers2:<span class="number">3</span> <span class="number">4</span> <span class="number">5</span></div><div class="line">Merge numbers1 <span class="keyword">and</span> numbers2:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></div></pre></td></tr></table></figure>
<h3 id="从列表中选择元素"><a href="#从列表中选择元素" class="headerlink" title="从列表中选择元素"></a>从列表中选择元素</h3><p>一个列表可以当作一个数组使用，在列表后指定索引值可以读取指定的元素，如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat select.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">$var = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">444</span>, <span class="number">5555</span>)[<span class="number">4</span>];</div><div class="line"><span class="keyword">print</span> <span class="string">"the value of var is:  $var\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl select.pl </div><div class="line">the value of var is:  <span class="number">5555</span></div></pre></td></tr></table></figure></p>
<p>同样可以在数组中使用 .. 来读取指定范围的元素：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat range_array.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@list = (<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)[<span class="number">1</span>..<span class="number">3</span>];</div><div class="line"><span class="keyword">print</span> <span class="string">"list的值 = @list\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl range_array.pl </div><div class="line">list的值 = <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></div></pre></td></tr></table></figure>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希是一个<code>key/value</code>对的集合，可以把它理解为Python中的字典。哈希<code>%</code>开始。如果要访问哈希值，可以使用<code>$+{key}</code>格式来访问，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat hash.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">%data=(<span class="string">'google'</span>,<span class="number">45</span>,<span class="string">'runoob'</span>,<span class="number">30</span>,<span class="string">'taobao'</span>,<span class="number">40</span>);</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"\$data&#123;'google'&#125; = $data&#123;'google'&#125;\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"\$data&#123;'runoob'&#125; = $data&#123;'runoob'&#125;\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"\$data&#123;'taobao'&#125; = $data&#123;'taobao'&#125;\n"</span>;</div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl hash.pl </div><div class="line">$data&#123;<span class="string">'google'</span>&#125; = <span class="number">45</span></div><div class="line">$data&#123;<span class="string">'runoob'</span>&#125; = <span class="number">30</span></div><div class="line">$data&#123;<span class="string">'taobao'</span>&#125; = <span class="number">40</span></div></pre></td></tr></table></figure>
<h3 id="创建哈希"><a href="#创建哈希" class="headerlink" title="创建哈希"></a>创建哈希</h3><p>创建哈希有两种方式：第一，为每个key设置value；第二，通过列表创建。<br>先看第一种方式，如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$site&#123;<span class="string">'google'</span>&#125;=<span class="string">'google.com'</span>;</div><div class="line">$site&#123;<span class="string">'bing'</span>&#125;=<span class="string">'bing.com'</span>;</div><div class="line">$site&#123;<span class="string">'baidu'</span>&#125;=<span class="string">'baidu.com'</span>;</div></pre></td></tr></table></figure></p>
<p>第二种，通过列表设置，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%data=(<span class="string">'google'</span>,<span class="string">'google.com'</span>,<span class="string">'bing'</span>,<span class="string">'bing.com'</span>,<span class="string">'taobao'</span>,<span class="string">'taobao.com'</span>)</div></pre></td></tr></table></figure>
<p>也可以使用<code>=&gt;</code>符号来设置<code>key/value</code>，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%data=(<span class="string">'google'</span>=&gt;<span class="string">'google.com'</span>,<span class="string">'bing'</span>=&gt;<span class="string">'bing.com'</span>,<span class="string">'taobao'</span>=&gt;<span class="string">'taobao.com'</span>)</div></pre></td></tr></table></figure>
<p>也可以使用<code>-</code>来代替引号，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%data=(<span class="string">-google=&gt;</span><span class="string">'google.com'</span>,<span class="string">-bing=&gt;</span><span class="string">'bing.com'</span>,<span class="string">-taobao=&gt;</span><span class="string">'taobao.com'</span>)</div></pre></td></tr></table></figure>
<p>不过这种方式创建的哈希，需要<code>key</code>不能出现空格，读取元素方式为：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$val = $data&#123;-google&#125;</div><div class="line">$val = $data&#123;-runoob&#125;</div></pre></td></tr></table></figure>
<h3 id="访问哈希"><a href="#访问哈希" class="headerlink" title="访问哈希"></a>访问哈希</h3><p>访问哈希元素格式：<code>${key}</code>，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat access_hash.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">%data=(<span class="string">'google'</span>=&gt;<span class="string">'google.com'</span>,<span class="string">'baidu'</span>=&gt;<span class="string">'baidu.com'</span>,<span class="string">'mit'</span>=&gt;<span class="string">'mit.edu'</span>);</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"\$data&#123;'google'&#125;=$data&#123;'google'&#125;\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"\$data&#123;'baidu'&#125;=$data&#123;'baidu'&#125;\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"\$data&#123;'mit'&#125;=$data&#123;'mit'&#125;\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl access_hash.pl </div><div class="line">$data&#123;<span class="string">'google'</span>&#125;=google.com</div><div class="line">$data&#123;<span class="string">'baidu'</span>&#125;=baidu.com</div><div class="line">$data&#123;<span class="string">'mit'</span>&#125;=mit.edu</div></pre></td></tr></table></figure>
<h3 id="读取哈希的key和value"><a href="#读取哈希的key和value" class="headerlink" title="读取哈希的key和value"></a>读取哈希的<code>key</code>和<code>value</code></h3><h4 id="读取hash的key"><a href="#读取hash的key" class="headerlink" title="读取hash的key"></a>读取hash的key</h4><p>我们可以使用<code>keys</code>函数读取哈希所有的键，语法格式如下：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">keys</span> %HASH</div></pre></td></tr></table></figure></p>
<p>该函数返回所有哈希的所有 key 的数组，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat values_hash.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">%data=(<span class="string">'google'</span>=&gt;<span class="string">'google.com'</span>,<span class="string">'abc'</span>=&gt;<span class="string">'abc.com'</span>,<span class="string">'UFO'</span>=&gt;<span class="string">'ufo.com'</span>);</div><div class="line"></div><div class="line">@names=<span class="keyword">keys</span> %data;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"$names[0]\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$names[1]\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$names[2]\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl values_hash.pl </div><div class="line">UFO</div><div class="line">google</div><div class="line">abc</div></pre></td></tr></table></figure>
<h4 id="读取hash的value"><a href="#读取hash的value" class="headerlink" title="读取hash的value"></a>读取hash的value</h4><p>使用<code>values</code>函数读取hash的值，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat value_hash.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">%data=(<span class="string">'google'</span>=&gt;<span class="string">'google.com'</span>,<span class="string">'abc'</span>=&gt;<span class="string">'abc.com'</span>,<span class="string">'UFO'</span>=&gt;<span class="string">'ufo.com'</span>);</div><div class="line"></div><div class="line">@url=<span class="keyword">values</span>%data;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"$url[0]\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$url[1]\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$url[2]\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl value_hash.pl </div><div class="line">google.com</div><div class="line">abc.com</div><div class="line">ufo.com</div></pre></td></tr></table></figure>
<h3 id="检测元素是否存在"><a href="#检测元素是否存在" class="headerlink" title="检测元素是否存在"></a>检测元素是否存在</h3><p>如果你在哈希中读取不存在的<code>key/value</code>对 ，会返回<code>undefined</code>值，且在执行时会有警告提醒。为了避免这种情况，我们可以使用<code>exists</code>函数来判断<code>key</code>是否存在，存在的时候读取，如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat exists.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">%data=(<span class="string">'google'</span>=&gt;<span class="string">'google.com'</span>,<span class="string">'sina'</span>=&gt;<span class="string">'sina.com'</span>,<span class="string">'taobao'</span>=&gt;<span class="string">'taobao.com'</span>);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">exists</span>($data&#123;<span class="string">'facebook'</span>&#125;))&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"the website of factbook is $data&#123;'facebook'&#125;\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"facebook doesn't exist\n"</span>;</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl exists.pl </div><div class="line">facebook doesn<span class="string">'t exist</span></div></pre></td></tr></table></figure></p>
<h3 id="获取哈希大小"><a href="#获取哈希大小" class="headerlink" title="获取哈希大小"></a>获取哈希大小</h3><p>哈希大小为元素的个数，我们可以通过先获取<code>key</code>或<code>value</code>的所有元素数组，再计算数组元素多少来获取哈希的大小，如下所示：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat size_of_hash.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">%data=(<span class="string">'google'</span>=&gt;<span class="string">'google.com'</span>,<span class="string">'sina'</span>=&gt;<span class="string">'sina.com'</span>,<span class="string">'taobao'</span>=&gt;<span class="string">'taobao.com'</span>);</div><div class="line"></div><div class="line">@keys=<span class="keyword">keys</span>%data;</div><div class="line">$size=@keys;</div><div class="line"><span class="keyword">print</span> <span class="string">"1- size of hash: $size\n"</span>;</div><div class="line"></div><div class="line">@values=<span class="keyword">values</span>%data;</div><div class="line">$size=@values;</div><div class="line"><span class="keyword">print</span> <span class="string">"2- size of hash: $size\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl size_of_hash.pl </div><div class="line"><span class="number">1</span>- size of hash: <span class="number">3</span></div><div class="line"><span class="number">2</span>- size of hash: <span class="number">3</span></div></pre></td></tr></table></figure></p>
<h3 id="哈希中添加或删除元素"><a href="#哈希中添加或删除元素" class="headerlink" title="哈希中添加或删除元素"></a>哈希中添加或删除元素</h3><p><code>delete</code>函数用于删除哈希中的元素；使用赋值来添加哈希中的元素，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ cat delete.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">%data=(<span class="string">'google'</span>=&gt;<span class="string">'google.com'</span>,<span class="string">'baidu'</span>=&gt;<span class="string">'baidu.com'</span>,<span class="string">'bing'</span>=&gt;<span class="string">'bing.com'</span>);</div><div class="line">@keys=<span class="keyword">keys</span>%data;</div><div class="line">$size=@keys;</div><div class="line"><span class="keyword">print</span> <span class="string">"1-The size of hash: $size\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># add element:</span></div><div class="line">$data&#123;<span class="string">'facebook'</span>&#125;=<span class="string">'facebook.com'</span>;</div><div class="line">@keys=<span class="keyword">keys</span>%data;</div><div class="line">$size=@keys;</div><div class="line"><span class="keyword">print</span> <span class="string">"2-The size of hash:$size\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># delete element:</span></div><div class="line"><span class="keyword">delete</span> $data&#123;<span class="string">'baidu'</span>&#125;;</div><div class="line">@keys=<span class="keyword">keys</span>%data;</div><div class="line">$size=@keys;</div><div class="line"><span class="keyword">print</span> <span class="string">"3-The size of hash: $size\n"</span>;</div><div class="line">biotest@ubuntu:~$ perl delete.pl </div><div class="line"><span class="number">1</span>-The size of hash: <span class="number">3</span></div><div class="line"><span class="number">2</span>-The size of hash:<span class="number">4</span></div><div class="line"><span class="number">3</span>-The size of hash: <span class="number">3</span></div></pre></td></tr></table></figure>
<h2 id="变量上下文"><a href="#变量上下文" class="headerlink" title="变量上下文"></a>变量上下文</h2><p>所谓上下文：指的是表达式所在的位置。上下文是由等号左边的变量类型决定的，等号左边是标量，则是标量上下文，等号左边是列表，则是列表上下文。Perl解释器会根据上下文来决定变量的类型，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat context.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">@names = (<span class="string">'google'</span>,<span class="string">'baidu'</span>,<span class="string">'sogou'</span>);</div><div class="line">@copy = @names;</div><div class="line">$size=@names;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Names is: @copy\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"Name is :$size\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl context.pl </div><div class="line">Names is: google baidu sogou</div><div class="line">Name is :<span class="number">3</span></div></pre></td></tr></table></figure>
<p>代码及结果解释：代码中<code>@names</code>是一个数组，它应用在了两个不同的上下文中。第一个将其复制给另外一个数组<code>@copy</code>，所以它输出了数组的所有元素。第二个我们将数组赋值给一个标量，它返回了数组的元素个数。以下列出了多种不同的上下文：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>上下文及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>标量 −赋值给一个标量变量，在标量上下文的右侧计算</td>
</tr>
<tr>
<td>2</td>
<td>列表 −赋值给一个数组或哈希，在列表上下文的右侧计算。</td>
</tr>
<tr>
<td>3</td>
<td>布尔 −布尔上下文是一个简单的表达式计算，查看是否为 true 或 false。</td>
</tr>
<tr>
<td>4</td>
<td>Void −这种上下文不需要关系返回什么值，一般不需要返回值。</td>
</tr>
<tr>
<td>5</td>
<td>插值 −这种上下文只发生在引号内。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Perl的内置警告信息"><a href="#Perl的内置警告信息" class="headerlink" title="Perl的内置警告信息"></a>Perl的内置警告信息</h2><p>从Perl 5.6开始，就能心通过编译指令开启警告功能，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">usr warnings;</div></pre></td></tr></table></figure>
<p>也可以在命令行上使用<code>-w</code>选项开启警告，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl -w my_program</div></pre></td></tr></table></figure>
<p>例如，如果用户把<code>12fred34</code>当成数字用，Perl就会发出警告，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ARgument <span class="string">"12fred34"</span> isn<span class="string">'t numeric</span></div></pre></td></tr></table></figure>
<h2 id="全局特殊常量"><a href="#全局特殊常量" class="headerlink" title="全局特殊常量"></a>全局特殊常量</h2><p>在Perl中有一些特殊的字符的应用例如<code>.__FILE__.</code>, .<code>__LINE__.</code>和<code>.__PACKAGE__.</code>（注意，这是一个点加两条下划线），它们分别表示当前执行脚本的文件名，行号，包名，这些特殊字符是单独的标记，不能写在字符串中，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ cat special_string.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"The name of script file  "</span> .__FILE_<span class="number">_</span>.<span class="string">"\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"The line number of scripte file  "</span>.__LINE_<span class="number">_</span>.<span class="string">"\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"The name of package  "</span>.__PACKAGE_<span class="number">_</span>.<span class="string">"\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># Following code will not run:</span></div><div class="line"><span class="keyword">print</span> <span class="string">".__FILE__. .__LINE__. .__PACKAGE__. \n"</span>;</div><div class="line">biotest@ubuntu:~$ perl special_string.pl </div><div class="line">The name of script file  special_string.pl</div><div class="line">The line number of scripte file  <span class="number">4</span></div><div class="line">The name of <span class="keyword">package</span>  main</div><div class="line">.__FILE_<span class="number">_</span>. .__LINE_<span class="number">_</span>. .__PACKAGE_<span class="number">_</span>.</div></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__END__</code></td>
<td>脚本的逻辑结束，忽略后面的文本。</td>
</tr>
<tr>
<td><code>__FILE__</code></td>
<td>当前文件名</td>
</tr>
<tr>
<td><code>__LINE__</code></td>
<td>当前行号</td>
</tr>
<tr>
<td><code>__PACKAGE__</code></td>
<td>当前包名，默认的包名是main。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Perl特殊变量"><a href="#Perl特殊变量" class="headerlink" title="Perl特殊变量"></a>Perl特殊变量</h2><p>Perl语言中定义了一些特殊的变量，通常以<code>$</code>，<code>@</code>，或<code>%</code>作为前缀，例如<code>$_</code>。很多特殊的变量有一个很长的英文名，操作系统变量<code>$!</code>可以写为<code>$OS_ERROR</code>。如果你想使用英文名的特殊变量需要在程序头部添加<code>use English</code>;。这样就可以使用具有描述性的英文特殊变量。最常用的特殊变量为<code>$_</code>，该变量包含了默认输入和模式匹配内容。如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat special_variable.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">foreach</span>(<span class="string">'Google'</span>,<span class="string">'Baidu'</span>,<span class="string">'Tencent'</span>)&#123;</div><div class="line">    <span class="keyword">print</span> $_;</div><div class="line">    <span class="keyword">print</span> <span class="string">"\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl special_variable.pl </div><div class="line">Google</div><div class="line">Baidu</div><div class="line">Tencent</div></pre></td></tr></table></figure>
<p>如果不使用<code>$_</code>作为输出，则是这个样子：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ cat output.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">foreach</span>(<span class="string">'Google'</span>,<span class="string">'Baidu'</span>,<span class="string">'Tencent'</span>)&#123;</div><div class="line">    <span class="keyword">print</span>;</div><div class="line">    <span class="keyword">print</span><span class="string">"\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl output.pl </div><div class="line">Google</div><div class="line">Baidu</div><div class="line">Tencent</div></pre></td></tr></table></figure>
<p>实例中，首先输出”Google”，接着输出”Baidu”，最后输出”Tencent”。在迭代循环中，当前循环的字符串会放在<code>$_</code>中,然后通过print输出。另外print在不指定输出变量，默认情况下使用的也是<code>$_</code>。</p>
<p>以下是几处即使没有写明Perl也会假定使用<code>$_</code>的地方：</p>
<ol>
<li>各种单目函数，包括像<code>ord()</code>和<code>int()</code>这样的函数以及除<code>&quot;-t&quot;</code>以外所有的文件测试操作<code>(&quot;-f&quot;，&quot;-d&quot;)</code>，<code>&quot;-t&quot;</code>默认操作<code>STDIN</code>。</li>
<li>各种列表函数，例如<code>print()</code>和<code>unlink()</code>。</li>
<li>没有使用<code>&quot;=~&quot;</code>运算符时的模式匹配操作<code>&quot;m//&quot;</code>、<code>&quot;s///&quot;</code>和<code>&quot;tr///&quot;</code>。<br>4 在没有给出其他变量时是<code>&quot;foreach&quot;</code>循环的默认迭代变量。</li>
<li><code>grep()</code>和<code>map()</code>函数的隐含迭代变量。</li>
<li>当<code>&quot;while&quot;</code>仅有唯一条件，且该条件是对””操作的结果进行测试时，<code>$_</code>就是存放输入记录的默认位置。除了<code>&quot;while&quot;</code>测试条件之外不会发生这种情况。(助记：下划线在特定操作中是可以省略的。)</li>
</ol>
<h2 id="特殊变量类型"><a href="#特殊变量类型" class="headerlink" title="特殊变量类型"></a>特殊变量类型</h2><p>根据特殊的变量的使用性质，可以分为以下几类：</p>
<ol>
<li>全局标量特殊变量。</li>
<li>全局数组特殊变量。</li>
<li>全局哈希特殊变量。</li>
<li>全局特殊文件句柄。</li>
<li>全局特殊常量。</li>
<li>正则表达式特殊变量。</li>
<li>文件句柄特殊变量。</li>
</ol>
<h3 id="全局标量特殊变量"><a href="#全局标量特殊变量" class="headerlink" title="全局标量特殊变量"></a>全局标量特殊变量</h3><p>以下列出了所有的标量特殊变量，包含了特殊字符与英文形式的变量：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>对应的英文形式变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$_</code></td>
<td><code>$ARG</code></td>
<td>默认输入和模式匹配内容。</td>
</tr>
<tr>
<td><code>$.</code></td>
<td><code>$NR</code></td>
<td>前一次读的文件句柄的当前行号</td>
</tr>
<tr>
<td><code>$/</code></td>
<td><code>$RS</code></td>
<td>输入记录分隔符,默认是新行字符。如用<code>undef</code>这个变量,将读到文件结尾。</td>
</tr>
<tr>
<td><code>$,</code></td>
<td><code>$OFS</code></td>
<td>输出域分隔符</td>
</tr>
<tr>
<td><code>$\</code></td>
<td><code>$ORS</code></td>
<td>输出记录分隔符</td>
</tr>
<tr>
<td><code>$&quot;</code></td>
<td><code>$LIST_SEPARATOR</code></td>
<td>该变量同   $,类似，但应用于向双引号引起的字符串(或类似的内插字符串)中内插数组和切片值的场合。默认为一个空格。</td>
</tr>
<tr>
<td><code>$;</code></td>
<td><code>$SUBSCRIPT_SEPARATOR</code></td>
<td>在仿真多维数组时使用的分隔符。默认为   <code>&quot;\034&quot;</code>。</td>
</tr>
<tr>
<td><code>$^L</code></td>
<td><code>$FORMAT_FORMFEED</code></td>
<td>发送到输出通道的走纸换页符。默认为   <code>&quot;\f&quot;</code>.</td>
</tr>
<tr>
<td><code>$:</code></td>
<td><code>$FORMAT_LINE_BREAK_CHARACTERS</code></td>
<td>The current set   of characters after which a string may be broken to fill continuation fields   (starting with ^) in a format. Default is <code>&quot;\n&quot;&quot;</code>.</td>
</tr>
<tr>
<td><code>$^A</code></td>
<td><code>$ACCUMULATOR</code></td>
<td>打印前用于保存格式化数据的变量</td>
</tr>
<tr>
<td><code>$#</code></td>
<td><code>$OFMT</code></td>
<td>打印数字时默认的数字输出格式（已废弃）。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td><code>$CHILD_ERROR</code></td>
<td>返回上一个外部命令的状态</td>
</tr>
<tr>
<td><code>$!</code></td>
<td><code>$OS_ERROR or $ERRNO</code></td>
<td>这个变量的数字值是<code>errno</code>的值,字符串值是对应的系统错误字符串</td>
</tr>
<tr>
<td><code>$@</code></td>
<td><code>$EVAL_ERROR</code></td>
<td>命令<code>eval</code>的错误消息.如果为空,则表示上一次<code>eval</code>命令执行成功</td>
</tr>
<tr>
<td>$$$$</td>
<td><code>$PROCESS_ID or $PID</code></td>
<td>运行当前Perl脚本程序的进程号</td>
</tr>
<tr>
<td><code>$&lt;</code></td>
<td><code>$REAL_USER_ID or $UID</code></td>
<td>当前进程的实际用户号</td>
</tr>
<tr>
<td><code>$&gt;</code></td>
<td><code>$EFFECTIVE_USER_ID or $EUID</code></td>
<td>当前进程的有效用户号</td>
</tr>
<tr>
<td><code>$(</code></td>
<td><code>$REAL_GROUP_ID or $GID</code></td>
<td>当前进程的实际组用户号</td>
</tr>
<tr>
<td><code>$)</code></td>
<td><code>$EFFECTIVE_GROUP_ID or $EGID</code></td>
<td>当前进程的有效组用户号</td>
</tr>
<tr>
<td><code>0</code></td>
<td><code>$PROGRAM_NAME</code></td>
<td>包含正在执行的脚本的文件名</td>
</tr>
<tr>
<td><code>$[</code></td>
<td></td>
<td>数组的数组第一个元素的下标,默认是   0。</td>
</tr>
<tr>
<td><code>$]</code></td>
<td><code>$PERL_VERSION</code></td>
<td>Perl的版本号</td>
</tr>
<tr>
<td><code>$^D</code></td>
<td><code>$DEBUGGING</code></td>
<td>调试标志的值</td>
</tr>
<tr>
<td><code>$^E</code></td>
<td><code>$EXTENDED_OS_ERROR</code></td>
<td>在非UNIX环境中的操作系统扩展错误信息</td>
</tr>
<tr>
<td><code>$^F</code></td>
<td><code>$SYSTEM_FD_MAX</code></td>
<td>最大的文件捆述符数值</td>
</tr>
<tr>
<td><code>$^H</code></td>
<td></td>
<td>由编译器激活的语法检查状态</td>
</tr>
<tr>
<td><code>$^I</code></td>
<td><code>$INPLACE_EDIT</code></td>
<td>内置控制编辑器的值</td>
</tr>
<tr>
<td><code>$^M</code></td>
<td></td>
<td>备用内存池的大小</td>
</tr>
<tr>
<td><code>$^O</code></td>
<td><code>$OSNAME</code></td>
<td>操作系统名</td>
</tr>
<tr>
<td><code>$^P</code></td>
<td><code>$PERLDB</code></td>
<td>指定当前调试值的内部变量</td>
</tr>
<tr>
<td><code>$^T</code></td>
<td><code>$BASETIME</code></td>
<td>从新世纪开始算起,脚步本以秒计算的开始运行的时间</td>
</tr>
<tr>
<td><code>$^W</code></td>
<td><code>$WARNING</code></td>
<td>警告开关的当前值</td>
</tr>
<tr>
<td><code>$^X</code></td>
<td><code>$EXECUTABLE_NAME</code></td>
<td>Perl二进制可执行代码的名字</td>
</tr>
<tr>
<td><code>$ARGV</code></td>
<td></td>
<td>从默认的文件句柄中读取时的当前文件名</td>
</tr>
</tbody>
</table>
</div>
<h3 id="全局数组特殊变量"><a href="#全局数组特殊变量" class="headerlink" title="全局数组特殊变量"></a>全局数组特殊变量</h3><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@ARGV</code></td>
<td>传给脚本的命令行参数列表</td>
</tr>
<tr>
<td><code>@INC</code></td>
<td>在导入模块时需要搜索的目录列表</td>
</tr>
<tr>
<td><code>@F</code></td>
<td>命令行的数组输入</td>
</tr>
</tbody>
</table>
</div>
<h3 id="全局哈希特殊变量"><a href="#全局哈希特殊变量" class="headerlink" title="全局哈希特殊变量"></a>全局哈希特殊变量</h3><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%INC</code></td>
<td>散列表<code>%INC</code>包含所有用do或require语句包含的文件.关键字是文件名,值是这个文件的路径</td>
</tr>
<tr>
<td><code>%ENV</code></td>
<td>包含当前环境变量</td>
</tr>
<tr>
<td><code>%SIG</code></td>
<td>信号列表及其处理方式</td>
</tr>
</tbody>
</table>
</div>
<h3 id="全局特殊文件句柄"><a href="#全局特殊文件句柄" class="headerlink" title="全局特殊文件句柄"></a>全局特殊文件句柄</h3><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ARGV</code></td>
<td>遍历数组变量@ARGV中的所有文件名的特殊文件句柄</td>
</tr>
<tr>
<td><code>STDERR</code></td>
<td>标准错误输出句柄</td>
</tr>
<tr>
<td><code>STDIN</code></td>
<td>标准输入句柄</td>
</tr>
<tr>
<td><code>STDOUT</code></td>
<td>标准输出句柄</td>
</tr>
<tr>
<td><code>DATA</code></td>
<td>特殊文件句柄引用了在文件中 <code>__END__</code> 标志后的任何内容包含脚本内容。或者引用一个包含文件中<code>__DATA__</code>标志后的所有内容，只要你在同一个包有读取数据，<code>__DATA__</code>就存在。</td>
</tr>
<tr>
<td><code>_ (下划线)</code></td>
<td>特殊的文件句柄用于缓存文件信息(fstat、stat和lstat)。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="正则表达式特殊变量"><a href="#正则表达式特殊变量" class="headerlink" title="正则表达式特殊变量"></a>正则表达式特殊变量</h3><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>英文形式变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$n</code></td>
<td></td>
<td>包含上次模式匹配的第n个子串</td>
</tr>
<tr>
<td><code>$&amp;</code></td>
<td><code>$MATCH</code></td>
<td>前一次成功模式匹配的字符串</td>
</tr>
<tr>
<td><code>$` </code></td>
<td><code>$PREMATCH</code></td>
<td>前次匹配成功的子串之前的内容</td>
</tr>
<tr>
<td><code>$&#39;</code></td>
<td><code>$POSTMATCH</code></td>
<td>前次匹配成功的子串之后的内容</td>
</tr>
<tr>
<td><code>$+</code></td>
<td><code>$LAST_PAREN_MATCH</code></td>
<td>与上个正则表达式搜索格式匹配的最后一个括号。例如：`/Version:   (.*)</td>
<td>Revision: (.*)/ &amp;&amp; ($rev = $+);`</td>
</tr>
</tbody>
</table>
</div>
<h3 id="文件句柄特殊变量"><a href="#文件句柄特殊变量" class="headerlink" title="文件句柄特殊变量"></a>文件句柄特殊变量</h3><div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>英文形式变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>`$</td>
<td>`</td>
<td><code>$OUTPUT_AUTOFLUSH</code></td>
<td>如果设置为零,在每次调用函数write或print后，自动调用函数fflush,将所写内容写回文件</td>
</tr>
<tr>
<td><code>$%</code></td>
<td><code>$FORMAT_PAGE_NUMBER</code></td>
<td>当前输出页号</td>
</tr>
<tr>
<td><code>$=</code></td>
<td><code>$FORMAT_LINES_PER_PAGE</code></td>
<td>当前每页长度。默认为 60。</td>
</tr>
<tr>
<td><code>$-</code></td>
<td><code>$FORMAT_LINES_LEFT</code></td>
<td>当前页剩余的行数</td>
</tr>
<tr>
<td><code>$~</code></td>
<td><code>$FORMAT_NAME</code></td>
<td>当前报表输出格式的名称。默认值是文件句柄名。</td>
</tr>
<tr>
<td><code>$^</code></td>
<td><code>$FORMAT_TOP_NAME</code></td>
<td>当前报表输出表头格式的名称。默认值是带后缀”_TOP”的文件句柄名。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.runoob.com/perl/perl-tutorial.html" target="_blank" rel="external">Perl教程|菜鸟教程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/12/Perl/Perl学习笔记（1）-基础笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/Perl/Perl学习笔记（1）-基础笔记/" itemprop="url">Perl学习笔记（1）-基础语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-12T12:00:00+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Perl/" itemprop="url" rel="index">
                    <span itemprop="name">Perl</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,969
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在生物信息学方面，Python，R，Perl，Linux我觉得是必须要掌握的4个工具，以前学习一些Perl，只是不系统，笔记记得有点散，没有把它们总结起来。现在总结一下Perl的学习笔记。参考资料主要为：一、<a href="http://www.runoob.com/perl/perl-tutorial.html" target="_blank" rel="external">Perl教程|菜鸟教程</a>（这个是主要的，思路非常简洁，并且把原代码列了出来，非常适应初学者）；二、<a href="https://item.jd.com/10972653.html" target="_blank" rel="external">O’Reilly：Perl语言入门（第6版）（中文版）</a>（刚开始是想看小骆驼这本书的，但后来发现在案例操作上写得不太好）；三、百度搜索辅助。Linux的Ubuntu发行版中自带了Perl语句，输入<code>perl -v</code>就能够查看到Perl的版本，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ perl -v</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">This is perl 5, version 22, subversion 0 (v5.22.0) built for x86_64-linux-thread-multi</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">Copyright 1987-2015, Larry Wall</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">Perl may be copied only under the terms of either the Artistic License or the</span></div><div class="line"><span class="regexp">GNU General Public License, which may be found in the Perl 5 source kit.</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">Complete documentation for Perl, including FAQ lists, should be found on</span></div><div class="line"><span class="regexp">this system using "man perl" or "perldoc perl".  If you have access to the</span></div><div class="line"><span class="regexp">Internet, point your browser at http:/</span><span class="regexp">/www.perl.org/</span>, the Perl Home Page.</div></pre></td></tr></table></figure>
<h2 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h2><p>在Linux的shell中可以直接使用Perl进行交互式编程 ，格式为<code>perl -e 代码块，</code>如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">02</span>datatype$ perl -e <span class="string">'print "Hello,world\n"'</span></div><div class="line">Hello,world</div></pre></td></tr></table></figure>
<h2 id="一个简单的Perl程序"><a href="#一个简单的Perl程序" class="headerlink" title="一个简单的Perl程序"></a>一个简单的Perl程序</h2><p>先看一个简单的Perl程序，在Ubuntu中输入<code>vim helloworld.pl</code>建立一个perl程序，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl -w</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello, world!\n"</span>;</div><div class="line"><span class="comment"># this is comment</span></div></pre></td></tr></table></figure>
<p>从这一段代码中我们可以了解到这些内容：</p>
<ol>
<li>第一行的<code>#!/usr/bin/perl</code>是告诉系统，Perl的解释器位于哪里，这一段代码不要省略，<code>-w</code>不是必须的，加上<code>-w</code>参数表示提示警告；</li>
<li>每次输入一行代码后，要以分号（<code>;</code>）结尾；</li>
<li>Perl程序用井号（<code>#</code>）作为注释。</li>
</ol>
<p>按<code>Esc</code>键，输入<code>wq</code>，保存退出。在命令行模式输入<code>perl first.pl</code>后，按回车就可以运行，显示结果。再次按回车，运行结束，运行结果如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ perl first.pl</span></div><div class="line"><span class="regexp">This is my first perl program</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">biotest@ubuntu:~/perl</span>$</div></pre></td></tr></table></figure>
<p>其实Perl语句的扩展名也可以不用，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ mv helloworld.pl helloworld2</span></div><div class="line"><span class="regexp">biotest@ubuntu:~/perl</span>$ perl helloworld2</div><div class="line">This is <span class="keyword">my</span> first perl program</div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl$</span></div></pre></td></tr></table></figure>
<p>也可以更改权限，直接执行，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ chmod u+x helloworld2 </span></div><div class="line"><span class="regexp">biotest@ubuntu:~/perl</span>$ ./helloworld2 </div><div class="line">This is <span class="keyword">my</span> first perl program</div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl$</span></div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Perl程序除了使用井号作为单行注释外，还可以使用POD（Plain Old Documentations）来进行多行注释，格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">=pdo 注释</span></div><div class="line"><span class="comment">这是一个多行注释</span></div><div class="line"><span class="comment">这是一个多行注释</span></div><div class="line"><span class="comment">这是一个多行注释</span></div><div class="line"><span class="comment">这是一个多行注释</span></div><div class="line"><span class="comment">=cut</span></div></pre></td></tr></table></figure>
<p>看一个Perl程序（命令为multiple_comment.pl），如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"><span class="keyword">print</span> <span class="string">"This is my perl program \n"</span>;</div><div class="line"></div><div class="line"><span class="comment">=pdo</span></div><div class="line"><span class="comment">This is a multiple annotation;</span></div><div class="line"><span class="comment">THis is a multiline commnet;</span></div><div class="line"><span class="comment">=cut</span></div><div class="line"></div><div class="line">$a=&lt;&gt;;</div><div class="line"><span class="keyword">print</span> $a;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ perl multiple_comment.pl </span></div><div class="line"><span class="regexp">This is my perl program </span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">biotest@ubuntu:~/perl</span>$</div></pre></td></tr></table></figure>
<p>使用POD注释需要注意的是，①=pod、 =cut只能在行首；②以=开头，以=cut结尾；③=后面要紧接一个字符，=cut后面可以不用。</p>
<h2 id="Here文档"><a href="#Here文档" class="headerlink" title="Here文档"></a>Here文档</h2><p>Here可以向命令中传递大量的字符串，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">$a=<span class="number">10</span>;</div><div class="line">$var = &lt;&lt;<span class="string">"EOF"</span>;</div><div class="line">This is a Here Document instance using double quotation marks.</div><div class="line">You can input soma character <span class="keyword">and</span> variables,<span class="keyword">for</span> example:</div><div class="line">a = $a</div><div class="line">EOF</div><div class="line"><span class="keyword">print</span> <span class="string">"$var\n"</span>;</div><div class="line"></div><div class="line">$var=&lt;&lt;<span class="string">'EOF'</span>;</div><div class="line">This is another Here Document instance using single quotation marks.</div><div class="line"><span class="keyword">for</span> example:a=$a</div><div class="line">EOF</div><div class="line"><span class="keyword">print</span> <span class="string">"$var\n"</span>;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ perl here.pl </div><div class="line">This is a Here Document instance using double quotation marks.</div><div class="line">You can input soma character <span class="keyword">and</span> variables,<span class="keyword">for</span> example:</div><div class="line">a = <span class="number">10</span></div><div class="line"></div><div class="line">This is another Here Document instance using single quotation marks.</div><div class="line"><span class="keyword">for</span> example:a=$a</div></pre></td></tr></table></figure>
<p>从结果可以看出，here文档可以向一条命令传递大量的字符串，并且这些字符串中如果有变量，它也会显示出来。它的用法为：</p>
<ol>
<li>必须后接分号，否则编译通不过。</li>
<li>END可以用任意其它字符代替，只需保证结束标识与开始标识一致。</li>
<li>结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。</li>
<li>开始标识可以不带引号号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</li>
<li>当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义。</li>
</ol>
<h2 id="Perl关于空格的处理"><a href="#Perl关于空格的处理" class="headerlink" title="Perl关于空格的处理"></a>Perl关于空格的处理</h2><p>Perl 解释器不会关心有多少个空白，以下程序也能正常运行，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ cat blank.pl </span></div><div class="line"><span class="regexp">#!/usr</span><span class="regexp">/bin/perl</span></div><div class="line"><span class="keyword">print</span>      <span class="string">"Hello, world\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ perl blank.pl </span></div><div class="line"><span class="regexp">Hello, world</span></div><div class="line"><span class="regexp">biotest@ubunt</span></div></pre></td></tr></table></figure>
<p>但是如果出现了两行，就会原样输出，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello </span></div><div class="line"><span class="string">           world\n"</span>;</div><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ perl blank2.pl </span></div><div class="line"><span class="regexp">Hello </span></div><div class="line"><span class="regexp">           world</span></div></pre></td></tr></table></figure>
<p>其实这个也好理解，因为换行的时候有可能引入了一个换行符（虽然看不到），与原来只在一行时，中间有几个空格已经不同了。</p>
<h2 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h2><p>双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ cat quotation.pl </span></div><div class="line"><span class="regexp">#!/usr</span><span class="regexp">/bin/perl</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello, world\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">'Hello, world\n'</span>;</div><div class="line">$a=<span class="number">10</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"a=$a\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">'a=$a\n'</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"this is the end"</span></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl$ perl quotation.pl </span></div><div class="line"><span class="regexp">Hello, world</span></div><div class="line"><span class="regexp">Hello, world\na=10</span></div><div class="line"><span class="regexp">a=$a\nthis is the endbiotest@ubuntu:~/perl</span>$</div></pre></td></tr></table></figure>
<p>从结果可以看出，使用双引号，可以使用转义字符，如果是单引号，则无法使用转义字符，另外，还能发现，如果结尾没有转义字符，输出的内容就会连成一片，形成一行，不太美观，因此在前面的案例中，多数使用双引号，并在结尾部分引入<code>\n</code>转义字符。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>现在看一个实际运用中的案例，代码（脚本文件名为<code>example.pl</code>），如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line">@lines=<span class="string">`perldoc -u -f atan2`</span>;</div><div class="line"><span class="keyword">foreach</span>(@lines)&#123;</div><div class="line"><span class="keyword">s</span>/\w&lt;([^&gt;]+)&gt;<span class="regexp">/\U$1/g</span>;</div><div class="line"><span class="keyword">print</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在运行之前，先看一下直接在bash中运行<code>perldoc -u -f atan2</code>的结果，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ perldoc -u -f <span class="keyword">atan2</span>|cat</div><div class="line"><span class="comment">=over 8</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">=item atan2 Y,X</span></div><div class="line"><span class="comment">X&lt;atan2&gt; X&lt;arctangent&gt; X&lt;tan&gt; X&lt;tangent&gt;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">=for Pod::Functions arctangent of Y/X in the range -PI to PI</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Returns the arctangent of Y/X in the range -PI to PI.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">For the tangent operation, you may use the C&lt;Math::Trig::tan&gt;</span></div><div class="line"><span class="comment">function, or use the familiar relation:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    sub tan &#123; sin($_[0]) / cos($_[0])  &#125;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">The return value for C&lt;atan2(0,0)&gt; is implementation-defined; consult</span></div><div class="line"><span class="comment">your atan2(3) manpage for more information.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Portability issues: L&lt;perlport/atan2&gt;.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">=back</span></div></pre></td></tr></table></figure>
<p>再次运行刚才那段代码（代码名称为example.pl），如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ perl example.pl |cat</div><div class="line"><span class="comment">=over 8</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">=item atan2 Y,X</span></div><div class="line"><span class="comment">ATAN2 ARCTANGENT TAN TANGENT</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">=for Pod::Functions arctangent of Y/X in the range -PI to PI</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Returns the arctangent of Y/X in the range -PI to PI.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">For the tangent operation, you may use the MATH::TRIG::TAN</span></div><div class="line"><span class="comment">function, or use the familiar relation:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    sub tan &#123; sin($_[0]) / cos($_[0])  &#125;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">The return value for ATAN2(0,0) is implementation-defined; consult</span></div><div class="line"><span class="comment">your atan2(3) manpage for more information.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Portability issues: PERLPORT/ATAN2.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">=back</span></div></pre></td></tr></table></figure>
<p>现在解释一下原来的代码（<code>example.pl</code>）：</p>
<p>第一行：<code>#!/usr/bin/perl</code>：这是告诉Ubuntu，perl解释器位于<code>/usr/bin/perl</code>（每台电脑可能有所不同，但是必须是perl解释器所在的地址）；</p>
<p>第二行：<code>@lines=`perldoc -u -f atan2` </code>：这里有使用了一对反引号（<code>` </code>）来调用外部的命令，即<code>perldoc -u -f atan2</code>，在bash中直接运行这条命令，出来的结果是一文字，这个命令是用于阅读Perl及相关扩展和工具程序的说明文档，这里显示的是在Perl中如何使用三角函数atan2的一些信息。反引号输出的结果会一行行依次被储存在<code>@lines</code>这个数组变量中，接着代码启动了一个循环（这里的foreach就相当于bash中的for），依次对每行数据进行处理，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">foreach</span>(@lines)&#123;</div><div class="line"><span class="keyword">s</span>/\w&lt;([^&gt;]+)&gt;<span class="regexp">/\U$1/g</span>;</div><div class="line"><span class="keyword">print</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三到六行：其中最主要的是这么一段奇怪的符号，即<code>s/\w&lt;([^&gt;]+)&gt;/\U$1/g</code>，它的大概意思是：对每个包含一对尖括号（<code>&lt;&gt;</code>）的行进行相应的数据替换操作（跟bash shell中的sed有点类似）。</p>
<h2 id="Perl帮助文档的查阅"><a href="#Perl帮助文档的查阅" class="headerlink" title="Perl帮助文档的查阅"></a>Perl帮助文档的查阅</h2><p>Perl的帮助文档的函数是<code>perldoc -f 指令</code>，<code>perldoc -m 模块</code>，或者是<code>perldoc perldoc</code>（这个是教你怎么使用Perldoc），在使用<code>perl -f</code>之前，需要安装<code>perldoc</code>，否则会报错，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">You need to install the perl-doc <span class="keyword">package</span> to <span class="keyword">use</span> this program</div></pre></td></tr></table></figure>
<p>安装Perldoc的代码为：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install perl-doc</div></pre></td></tr></table></figure>
<p>现在使用一下帮助，查询一下<code>opendir</code>这个函数，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">03</span>condition$ perldoc -f <span class="keyword">opendir</span>|cat</div><div class="line">    <span class="keyword">opendir</span> DIRHANDLE,EXPR</div><div class="line">            Opens a directory named EXPR <span class="keyword">for</span> processing by <span class="string">"readdir"</span>,</div><div class="line">            <span class="string">"telldir"</span>, <span class="string">"seekdir"</span>, <span class="string">"rewinddir"</span>, <span class="keyword">and</span> <span class="string">"closedir"</span>. Returns true <span class="keyword">if</span></div><div class="line">            successful. DIRHANDLE may be an expression whose value can be used</div><div class="line">            as an indirect dirhandle, usually the real dirhandle name. If</div><div class="line">            DIRHANDLE is an undefined <span class="keyword">scalar</span> variable (<span class="keyword">or</span> array <span class="keyword">or</span> hash</div><div class="line">            element), the variable is assigned a reference to a new anonymous</div><div class="line">            dirhandle; that is, it<span class="string">'s autovivified. DIRHANDLEs have their own</span></div><div class="line"><span class="string">            namespace separate from FILEHANDLEs.</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">            See the example at "readdir".</span></div></pre></td></tr></table></figure>
<p>再查询一下<code>MIME::Base64</code>这个包，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ perldoc -<span class="keyword">m</span> MIME::Base64|head</div><div class="line"><span class="keyword">package</span> MIME::Base64;</div><div class="line"></div><div class="line"><span class="keyword">use</span> strict;</div><div class="line"><span class="keyword">use</span> vars <span class="string">qw(@ISA @EXPORT @EXPORT_OK $VERSION)</span>;</div><div class="line"></div><div class="line"><span class="keyword">require</span> Exporter;</div><div class="line">@ISA = <span class="string">qw(Exporter)</span>;</div><div class="line">@EXPORT = <span class="string">qw(encode_base64 decode_base64)</span>;</div><div class="line">@EXPORT_OK = <span class="string">qw(encode_base64url decode_base64url encoded_base64_length decoded_base64_length)</span>;</div></pre></td></tr></table></figure>
<h2 id="Perl的包"><a href="#Perl的包" class="headerlink" title="Perl的包"></a>Perl的包</h2><p>Perl 中每个包有一个单独的符号表，定义语法如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> mypack;</div></pre></td></tr></table></figure>
<p>这段代码定义了一个名为<code>mypack</code>的包，在此后定义的所有变量和函数的名称都储存在这个包关联的符号表中，直到遇到另外一个<code>package</code>为止。Perl中的这个包我觉得有点类型Python中的模块。</p>
<p>每个符号表有其自己的一组变量、函数，各组名字是不相关的，因此可以在不同的包中使用相同的变量名，而代表的是不同的变量。从一个包中访问另外一个包的变量，可通过<code>包名+双冒号(::)+变量名</code>的方式。存贮变量和函数的名字的默认符号表是与名为main的包相关联的。如果在程序里定义了其它的包，当你想切换回去使用默认的符号表，可以重新指定main包，如下所示</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main;</div></pre></td></tr></table></figure>
<p>这样，接下来的程序就好象从没定义过包一样，变量和子程序的名字象通常那样存贮。以下实例中文件有<code>main</code>和<code>Foo</code>包。特殊变量<code>__PACKAGE__</code>用于输出包名，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ cat package.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="comment"># This is "main" package</span></div><div class="line"><span class="keyword">print</span> <span class="string">"The name of package is: "</span>,__PACKAGE_<span class="number">_</span>,<span class="string">" $i\n"</span>;</div><div class="line"></div><div class="line"><span class="keyword">package</span> Foo;</div><div class="line"><span class="comment"># This is "Foo" package</span></div><div class="line">$i=<span class="number">10</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"The name of package is: "</span>,__PACKAGE_<span class="number">_</span>,<span class="string">" $i\n"</span>;</div><div class="line"></div><div class="line"><span class="keyword">package</span> main;</div><div class="line"><span class="comment"># Redirect "main" package</span></div><div class="line">$i =<span class="number">100</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"The name of package is: "</span>,__PACKAGE_<span class="number">_</span>, <span class="string">" $i\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"The name of package is: "</span>,__PACKAGE_<span class="number">_</span>,<span class="string">" $Foo::i\n"</span>;</div><div class="line"></div><div class="line"><span class="number">1</span>;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ perl package.pl </div><div class="line">The name of <span class="keyword">package</span> is: main </div><div class="line">The name of <span class="keyword">package</span> is: Foo <span class="number">10</span></div><div class="line">The name of <span class="keyword">package</span> is: main <span class="number">100</span></div><div class="line">The name of <span class="keyword">package</span> is: main <span class="number">10</span></div></pre></td></tr></table></figure>
<p>代码及结果解释：perl中默认的包是main包，因此在开头并没有定义这个main包，接着定义了一个Foo包，最后为了切换回main包，又需要对mian包重新指定。末尾要添加1；执行返回 TRUE，这是必须的，否则返回错误。</p>
<h2 id="BEGIN和END模块"><a href="#BEGIN和END模块" class="headerlink" title="BEGIN和END模块"></a>BEGIN和END模块</h2><p>Perl语言提供了两个关键字：BEGIN，END。它们可以分别包含一组脚本，用于程序体运行前或者运行后的执行，使用格式如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; ... &#125;</div><div class="line">END &#123; ... &#125;</div><div class="line">BEGIN &#123; ... &#125;</div><div class="line">END &#123; ... &#125;</div></pre></td></tr></table></figure>
<ol>
<li>每个<code>BEGIN</code>模块在Perl脚本载入和编译后但在其他语句执行前执行。</li>
<li>每个<code>END</code>语句块在解释器退出前执行。</li>
<li><code>BEGIN</code>和<code>END</code>语句块在创建Perl模块时特别有用。</li>
</ol>
<p>看下面的案例：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ cat begin_end.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> Foo;</div><div class="line"><span class="keyword">print</span> <span class="string">"Begin and Block instance\n"</span>;</div><div class="line"></div><div class="line">BEGIN&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"This is BEGIN statements blocks\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"This is END statements blocks\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="number">1</span>;</div><div class="line"></div><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ perl begin_end.pl </div><div class="line">This is BEGIN statements blocks</div><div class="line">Begin <span class="keyword">and</span> Block instance</div><div class="line">This is END statements blocks</div></pre></td></tr></table></figure>
<p>这段代码定义了一个叫<code>Foo</code>的包，在运行这个包的时候，先执行了<code>BEGIN</code>的代码，在运行这个包之后，又执行了<code>END</code>这一部分的代码。</p>
<h2 id="Perl模块的创建"><a href="#Perl模块的创建" class="headerlink" title="Perl模块的创建"></a>Perl模块的创建</h2><p>Perl模块是一个可重复使用的包，模块的名字与包名相同，定义的文件后缀为.pm。以下我们定义了一个模块<code>Foo.pm</code>，代码如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~<span class="regexp">/perl/</span><span class="number">01</span>basic$ cat module.pl </div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> Foo;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">bar</span> </span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"Hello $_[0]\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">blat</span> </span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"World $_[0]\n"</span>;</div><div class="line">&#125;</div><div class="line"><span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>关于这段代码以及Perl模块的解释：</p>
<ol>
<li>末尾1；执行返回TRUE，这是必须的，否则返回错误。</li>
<li>使用函数require和use载入一个模块。</li>
<li><code>require</code>和<code>use</code>函数调用eval函数来执行代码。</li>
<li><code>@IN</code>C是Perl内置的一个特殊数组，它包含指向库例程所在位置的目录路径。</li>
</ol>
<h2 id="包的调用函数require和use"><a href="#包的调用函数require和use" class="headerlink" title="包的调用函数require和use"></a>包的调用函数require和use</h2><p>Perl使用<code>require</code>函数来调用模块，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">require</span> Foo;</div><div class="line"></div><div class="line">Foo::bar(<span class="string">"a"</span>);</div><div class="line">Foo::blat(<span class="string">"b"</span>);</div></pre></td></tr></table></figure>
<p>Perl也可以使用use函数来调用要共模块，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="keyword">use</span> Foo;</div><div class="line"></div><div class="line">bar(<span class="string">"a"</span>);</div><div class="line">blat(<span class="string">"b"</span>);</div></pre></td></tr></table></figure>
<p>从这两个案例可以看出这些内容：</p>
<ol>
<li>require用于载入module或perl程序(.pm后缀可以省略，但.pl必须有)；</li>
<li>Perl use语句是编译时引入的，require是运行时引入的；</li>
<li>Perl use引入模块的同时，也引入了模块的子模块。而require则不能引入，要在重新声明；</li>
<li>USE是在当前默认的@INC里面去寻找,一旦模块不在@INC中的话,用USE是不可以引入的，但是require可以指定路径；</li>
<li>USE引用模块时，如果模块名称中包含<code>::</code>双冒号，该双冒号将作为路径分隔符，相当于Unix下的<code>/</code>或者Windows下的<code>\</code>。 例如<code>use MyDirectory::MyModule</code>。</li>
</ol>
<p>通过添加以下语句 use 模块就可以从模块中导出列表符号：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> Exporter;</div><div class="line">$ISA=<span class="string">qw(Exporter)</span>;</div></pre></td></tr></table></figure>
<p><code>@EXPORT</code>数组包含默认导出的变量和函数的名字，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Module;</div><div class="line"></div><div class="line"><span class="keyword">require</span> Exporter;</div><div class="line">@ISA = <span class="string">qw(Exporter)</span>;</div><div class="line">@EXPORT = <span class="string">qw(bar blat)</span>;  <span class="comment"># 默认导出的符号</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">bar</span> </span>&#123; <span class="keyword">print</span> <span class="string">"Hello $_[0]\n"</span> &#125;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">blat</span> </span>&#123; <span class="keyword">print</span> <span class="string">"World $_[0]\n"</span> &#125;</div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">splat</span> </span>&#123; <span class="keyword">print</span> <span class="string">"Not $_[0]\n"</span> &#125;  <span class="comment"># Not exported!</span></div><div class="line"></div><div class="line"><span class="number">1</span>;</div></pre></td></tr></table></figure>
<h2 id="Perl模块的安装"><a href="#Perl模块的安装" class="headerlink" title="Perl模块的安装"></a>Perl模块的安装</h2><p>由于Perl本身只带了核心的Perl模块数，如果要用到其他的Perl模块，还需要到CPAN上下载。CPAN是Perl的一个公共模块仓库，英文全称为Comprehensive Perl Archive Network。搜索相应模块的地址为：<a href="http://search.cpan.org/。Linux下安装Perl模块有两种方法：手工安装和自动安装。" target="_blank" rel="external">http://search.cpan.org/。Linux下安装Perl模块有两种方法：手工安装和自动安装。</a></p>
<h3 id="手工安装模块"><a href="#手工安装模块" class="headerlink" title="手工安装模块"></a>手工安装模块</h3><p>手工安装需要从CPAN上下载所需要的模块，手工编译、安装，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tar xvfz 某个模块.tar.gz</div><div class="line">cd 解压后的目录</div><div class="line">perl Makefile.PL</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>整个过程与Ubuntu编译安装软件类似，过程就是这个样子：</p>
<ol>
<li>首先运行 <code>perl Makefile.PL</code>在当前目录生成 <code>Makefile</code>；</li>
<li>然后运行 “make” 编译并创建所需的库文件；</li>
<li>之后用 “make test” 测试编译结果是否正确；最后运行 “make install” 将库文件安装到系统目录，至此整个编译过程结束。</li>
</ol>
<h3 id="自动安装模块"><a href="#自动安装模块" class="headerlink" title="自动安装模块"></a>自动安装模块</h3><p>第二种方法是联网安装，需要使用CPAN的模块自动完成下载、编译、安装，过程如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">perl -MCPAN -e shell <span class="comment">#进入cpan</span></div><div class="line">install 包名</div><div class="line"><span class="keyword">q</span> 退出</div></pre></td></tr></table></figure>
<h2 id="Perl模块的查看"><a href="#Perl模块的查看" class="headerlink" title="Perl模块的查看"></a>Perl模块的查看</h2><h3 id="第一种方法：使用perldoc-模块名"><a href="#第一种方法：使用perldoc-模块名" class="headerlink" title="第一种方法：使用perldoc + 模块名"></a>第一种方法：使用perldoc + 模块名</h3><p>有时候需要查看Perl的某个模块是否已经安装了，此时使用<code>perldoc</code>直接查看这个模块的文档即可，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perldoc Carp <span class="comment"># Check Carp module installed</span></div></pre></td></tr></table></figure>
<h3 id="第二种方法：perldoc-perllocal"><a href="#第二种方法：perldoc-perllocal" class="headerlink" title="第二种方法：perldoc + perllocal"></a>第二种方法：perldoc + perllocal</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perldoc Carp</div></pre></td></tr></table></figure>
<h3 id="第三种方法：使用instmodsh函数"><a href="#第三种方法：使用instmodsh函数" class="headerlink" title="第三种方法：使用instmodsh函数"></a>第三种方法：使用instmodsh函数</h3><p>直接在Shell中输入<code>instmodsh</code>，此时会出现命令提示行，如下所示：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Available commands are:</div><div class="line">   l            - List all installed modules</div><div class="line">   <span class="keyword">m</span> &lt;module&gt;   - Select a module</div><div class="line">   <span class="keyword">q</span>            - Quit the program</div><div class="line">cmd?</div></pre></td></tr></table></figure>
<p>系统会提示你输入相应的代码，输入<code>l</code>是查看已经安装的模块，输入<code>m 模块名</code>，查看具体的模块，输入<code>q</code>是退出。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/11/Linux/Linux-shell11-gawk进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/Linux/Linux-shell11-gawk进阶/" itemprop="url">Shell学习笔记（11）——gawk进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-11T12:00:01+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,416
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在gawk中使用变量"><a href="#在gawk中使用变量" class="headerlink" title="在gawk中使用变量"></a>在gawk中使用变量</h2><p>gawk支持两种变量，第一，内建变量；第二，自定义变量。gawk有一些内建变量，这些变量存放用来处理数据文件中的数据字段和记录的信息。用户也可以在gawk程序里创建自己的变量。</p>
<h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><h4 id="字段和记录分隔符变量"><a href="#字段和记录分隔符变量" class="headerlink" title="字段和记录分隔符变量"></a>字段和记录分隔符变量</h4><p>前面笔记提到过gawk中的一种内建变量类型是数据字段变量。数据字段变量允许用户使用美元符号（<code>$</code>）和字段在该记录中的位置值来引用记录对应的字段。因此，要引用记录中的第一个数据字段，就用变量<code>$1</code>；要引用第二个字段，就用<code>$2</code>，依次类推。数据字段是由字段分隔符来划定的。默认情况下，字段分隔符是一个空白字符，也就是空格符或者制表符。也可以在命令行下使用命令行参数<code>-F</code>或者在gawk程序中使用特殊的内建变量<code>FS</code>来更改字段分隔符。内建变量<code>FS</code>是一组内建变量中的一个，这组变量用于控制gawk如何处理输入输出数据中的字段和记录下表列出了这些内建变量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIELDWIDTHS</td>
<td>由空格分隔的一列数字，定义了每个数据字段确切宽度</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
</tbody>
</table>
</div>
<p>变量<code>FS</code>和<code>OFS</code>定义了gawk如何处理数据流中的数据字段，变量<code>FS</code>来定义记录中的字段分隔符。变量<code>OFS</code>具备相同的功能，只不过是用在<code>print</code>命令的输出上。默认情况下，gawk将<code>OFS</code>设成一个空格，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1.txt</div><div class="line">Data11,data12,data13,data14,data15</div><div class="line">data21,data22,data23,data24,data25</div><div class="line">data31,data32,data33,data34,data35</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=","&#125;&#123;print $1, $2,$3&#125;' data1.txt </div><div class="line">Data11 data12 data13</div><div class="line">data21 data22 data23</div><div class="line">data31 data32 data33</div></pre></td></tr></table></figure>
<p>在这个案例中，print命令会自动将<code>OFS</code>变量的值放置在输出中的每个字段间。通过设置<code>OFS</code>变量，可以在输出中使用任意字符串来分隔字段，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=",";OFS="-"&#125;&#123;print $1,$2,$3&#125;' data1.txt </div><div class="line">Data11-data12-data13</div><div class="line">data21-data22-data23</div><div class="line">data31-data32-data33</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=",";OFS="--"&#125;&#123;print $1,$2,$3&#125;' data1.txt </div><div class="line">Data11--data12--data13</div><div class="line">data21--data22--data23</div><div class="line">data31--data32--data33</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=",";OFS="&lt;--&gt;"&#125;&#123;print $1,$2,$3&#125;' data1.txt </div><div class="line">Data11&lt;--&gt;data12&lt;--&gt;data13</div><div class="line">data21&lt;--&gt;data22&lt;--&gt;data23</div><div class="line">data31&lt;--&gt;data32&lt;--&gt;data33</div></pre></td></tr></table></figure>
<p><code>FIELDWIDTHS</code>变量允许你不依靠字段分隔符来读取记录，从字面上很好理解，间隔宽度。在一些应用程序中，数据并没有使用字段分隔符，而是被放置在了记录中的特定列。这种情况下，必须设定<code>FIELDWIDTHS</code>变量来匹配数据在记录中的位置。一旦设置了<code>FIELDWIDTH</code>变量，gawk就会忽略<code>FS</code>变量，并根据提供的字段宽度来计算字段。下面是个采用字段宽度而非字段分隔符的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1b.txt </div><div class="line">1005.3247596.37</div><div class="line">115-2.349194.00</div><div class="line">05810.1298100.1</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FIELDWIDTHS="3 5 2 5 "&#125;&#123;print $1, $2, $3, $4&#125;' data1b.txt </div><div class="line">100 5.324 75 96.37</div><div class="line">115 -2.34 91 94.00</div><div class="line">058 10.12 98 100.1</div></pre></td></tr></table></figure>
<p><code>FIELDWIDTHS</code>变量定义了四个字段，即3 5 2 5 ，gawk依此来解析数据记录。每个记录中的数字串会根据已定义好的字段长度来分割。一旦设定了<code>FIELDWIDTHS</code>变量的值，就不能再改变了，这种方法并不适用于长的字段。</p>
<p>变量<code>RS</code>和<code>ORS</code>定义了gawk程序如何处理数据流中的字段。默认情况下，gawk将<code>RS</code>和<code>ORS</code>设为换行符。默认的<code>RS</code>值表明，输入数据流中的每行新文本就是一条新纪录。有时，你会在数据流中碰到占据多行的字段。典型的例子是包含地址和电话号码的数据，其中地址和电话号码各占一行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Riley Mullen </div><div class="line">123 Main Street </div><div class="line">Chicago, IL 60601 </div><div class="line">(312)555-1234</div></pre></td></tr></table></figure>
<p>如果用默认的<code>FS</code>和<code>RS</code>变量值来读取这组数据，gawk就会把每行作为一条单独的记录来读取，并将记录中的空格当作字段分隔符。这可不是你希望看到的。要解决这个问题，只需把<code>FS</code>变量设置成换行符。这就表明数据流中的每行都是一个单独的字段，每行上的所有数据都属于同一个字段。此时要判断一个新的数据行从何开始。对于这一问题，可以把<code>RS</code>变量设置成空字符串，然后在数据记录间留一个空白行。gawk会把每个空白行当作一个记录分隔符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data2.txt </div><div class="line">Riley Mullen</div><div class="line">123 Main Street</div><div class="line">Chicago, IL  60601</div><div class="line">(312)555-1234</div><div class="line"></div><div class="line">Frank Williams</div><div class="line">456 Oak Street</div><div class="line">Indianapolis, IN  46201</div><div class="line">(317)555-9876</div><div class="line"></div><div class="line">Haley Snell</div><div class="line">4231 Elm Street</div><div class="line">Detroit, MI 48201</div><div class="line">(313)555-4938</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS="\n";RS=""&#125; &#123;print $1,$4&#125;' data2.txt</div><div class="line">Riley Mullen (312)555-1234</div><div class="line">Frank Williams (317)555-9876</div><div class="line">Haley Snell (313)555-4938</div></pre></td></tr></table></figure>
<p>现在gawk把文件中的每行都当成一个字段，把空白行当作记录分隔符。</p>
<h4 id="数据变量"><a href="#数据变量" class="headerlink" title="数据变量"></a>数据变量</h4><p>gawk还有其他一些内建变量来帮助你了解数据发生了什 么变化，并提取shell环境的信息。下表列出了gawk中的其他内建变量。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ARGC</td>
<td>当前命令行参数个数</td>
</tr>
<tr>
<td>ARGIND</td>
<td>当前文件在 ARGV 中的位置</td>
</tr>
<tr>
<td>ARGV</td>
<td>包含命令行参数的数组</td>
</tr>
<tr>
<td>CONVFMT</td>
<td>数字的转换格式（参见 printf 语句），默认值为</td>
</tr>
<tr>
<td>ENVIRON</td>
<td>当前shell环境变量及其值组成的关联数组</td>
</tr>
<tr>
<td>ERRNO</td>
<td>当读取或关闭输入文件发生错误时的系统错误号</td>
</tr>
<tr>
<td>FILENAME</td>
<td>用作gawk输入数据的数据文件的文件名</td>
</tr>
<tr>
<td>FNR</td>
<td>当前数据文件中的数据行数</td>
</tr>
<tr>
<td>IGNORECASE</td>
<td>设成非零值时，忽略 gawk 命令中出现的字符串的字符大小写</td>
</tr>
<tr>
<td>NF</td>
<td>数据文件中的字段总数</td>
</tr>
<tr>
<td>NR</td>
<td>已处理的输入记录数</td>
</tr>
<tr>
<td>OFMT</td>
<td>数字的输出格式，默认值为 %.6 g</td>
</tr>
<tr>
<td>RLENGTH</td>
<td>由 match 函数所匹配的子字符串的长度</td>
</tr>
<tr>
<td>RSTART</td>
<td>由 match 函数所匹配的子字符串的起始位置</td>
</tr>
</tbody>
</table>
</div>
<p>ARGC和ARGV变量允许从shell中获得命令行参数的总数以及它们的值，需要注意的是，gawk并不会将程序脚本当成命令行参数的一部分，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1.txt</div><div class="line">Data11,data12,data13,data14,data15</div><div class="line">data21,data22,data23,data24,data25</div><div class="line">data31,data32,data33,data34,data35</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;print ARGC,ARGV[0]&#125;' data1.txt</div><div class="line">2 gawk</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;print ARGC,ARGV[1]&#125;' data1.txt</div><div class="line">2 data1.txt</div></pre></td></tr></table></figure>
<p>结果显示：ARGC的结果是2，表明命令行上有两个参数，这包括gawk命令和data1参数（记住，程序脚本并不算参数）。ARGV是包含命令行参数的数组，这个数组从索引0开始，代表的是命令，从结果可以看出，<code>ARGV[0]</code>是gawk，<code>ARGV[1]</code>的结果是data1，这是gawk命令后的第一个命令行参数。从代码可以看出，在脚本中引用gawk变量时，变量名前不加美元符。</p>
<p><code>ENVIRON</code>使用关联数组来提取shell环境变量。关联数组用文本作为数组的索引值，而不是数值。数组索引中的文本是shell环境变量名，而数组的值则是shell环境变量的值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '</div><div class="line"><span class="meta">&gt;</span> BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> print ENVIRON["HOME"]</div><div class="line"><span class="meta">&gt;</span> print ENVIRON["PATH"]</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">/home/biotest</div><div class="line">/home/biotest/miniconda2/bin:/home/miniconda2/bin:/home/bio/miniconda2/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/biotest/home/test:/home/biotest/home/biotest:/home/biotest:/home/biotest/</div></pre></td></tr></table></figure>
<p><code>ENVIRON[&quot;HOME&quot;]</code>变量从shell中提取了<code>HOME</code>环境变量的值。<code>ENVIRON[&quot;PATH&quot;]</code>提取了<code>PATH</code>环境变量的值。可以用这种方法来从shell中提取任何环境变量的值，以供gawk程序使用。当要在gawk程序中跟踪数据字段和记录时，就需要变量<code>FNR</code>、<code>NF</code>和<code>NR</code>，有时用户如果不知道记录中有多少个数据字段。<code>NF</code>变量可以让用户在不知道具体位置的情况下指定记录中的最后一个数据字段，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=":";OFS=":"&#125;&#123;print $1,$NF&#125;' /etc/passwd</div><div class="line">root:/bin/bash</div><div class="line">daemon:/usr/sbin/nologin</div><div class="line">bin:/usr/sbin/nologin</div><div class="line">sys:/usr/sbin/nologin</div><div class="line">sync:/bin/sync</div><div class="line">...</div><div class="line">usbmux:/bin/false</div><div class="line">biotest:/bin/bash</div><div class="line">userid:</div><div class="line">501:</div><div class="line">502:</div><div class="line">503:</div><div class="line">511:</div><div class="line">512:</div><div class="line">513:</div><div class="line">test001:</div></pre></td></tr></table></figure>
<p>NF变量含有数据文件中最后一个数据字段的数字值。可以在它前面加个美元符将其用作字段变量。</p>
<p><code>FNR</code>和<code>NR</code>变量虽然类似，但又略有不同。<code>FNR</code>变量含有当前数据文件中已处理过的记录数，<code>NR</code>变量则含有已处理过的记录总数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1.txt</div><div class="line">Data11,data12,data13,data14,data15</div><div class="line">data21,data22,data23,data24,data25</div><div class="line">data31,data32,data33,data34,data35</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=","&#125;&#123;print $1, "FNR="FNR&#125;' data1.txt data1.txt</div><div class="line">Data11 FNR=1</div><div class="line">data21 FNR=2</div><div class="line">data31 FNR=3</div><div class="line">Data11 FNR=1</div><div class="line">data21 FNR=2</div><div class="line">data31 FNR=3</div></pre></td></tr></table></figure>
<p>在这个例子中，gawk程序的命令行定义了两个输入文件（两次指定的是同样的输入文件）。这个脚本会打印第一个数据字段的值和FNR变量的当前值。注意，当gawk程序处理第二个数据文件时，FNR值被设回了1。接着看NR变量的案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '</div><div class="line"><span class="meta">&gt;</span> BEGIN &#123;FS=","&#125;</div><div class="line"><span class="meta">&gt;</span> &#123;print $1, "FNR="FNR,"NR="NR&#125;</div><div class="line"><span class="meta">&gt;</span> END&#123;print "There were",NR,"records processed"&#125;' data1.txt data1.txt</div><div class="line">Data11 FNR=1 NR=1</div><div class="line">data21 FNR=2 NR=2</div><div class="line">data31 FNR=3 NR=3</div><div class="line">Data11 FNR=1 NR=4</div><div class="line">data21 FNR=2 NR=5</div><div class="line">data31 FNR=3 NR=6</div><div class="line">There were 6 records processed</div></pre></td></tr></table></figure>
<p>FNR变量的值在gawk处理第二个数据文件时被重置了，而NR变量则在处理第二个数据文件时继续计数。结果就是：如果只使用一个数据文件作为输入，FNR和NR的值是相同的；如果使用多个数据文件作为输入，FNR的值会在处理每个数据文件时被重置，而NR的值则会继续计数直到处理完所有的数据文件。</p>
<p>由于gawk脚本通常会比shell脚本中的其他部分还要大一些，因此用户可以shell的多行特性直接在命令行上运行了gawk脚本。在shell脚本中使用gawk时，应该将不同的gawk命令放到不同的行，这样会比较容易阅读和理解，不要在shell脚本中将所有的命令都塞到同一行。如果要在不同的shell脚本中用到同样的gawk脚本，可以将这段gawk脚本放到一个单独的文件中，并用-f参数来在shell脚本中引用即可。</p>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><h4 id="在脚本中给变量赋值"><a href="#在脚本中给变量赋值" class="headerlink" title="在脚本中给变量赋值"></a>在脚本中给变量赋值</h4><p>在gawk程序中给变量赋值跟在shell脚本中赋值类似，都用赋值语句，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '</div><div class="line"><span class="meta">&gt;</span> BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> testing="This is a test"</div><div class="line"><span class="meta">&gt;</span> print testing</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">This is a test</div></pre></td></tr></table></figure>
<p>print语句的输出是testing变量的当前值。跟shell脚本变量一样，gawk变量可以保存数值或文本值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '</div><div class="line"><span class="meta">&gt;</span> BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> testing="This is a test"</div><div class="line"><span class="meta">&gt;</span> print testing</div><div class="line"><span class="meta">&gt;</span> testing=45</div><div class="line"><span class="meta">&gt;</span> print testing</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">This is a test</div><div class="line">45</div></pre></td></tr></table></figure>
<p>在这个案例中，testing变量开始是文本，后来是数字，赋值语句可以包含数学公式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;x=4;x=x*2+3;print x&#125;'</div><div class="line">11</div></pre></td></tr></table></figure>
<p>从结果可以看出，gawk包含了用来处理数字值的标准算数操作符，其中包括求余符号（%）和幂运算符号（^或**）。</p>
<h4 id="在命令行上给变量赋值"><a href="#在命令行上给变量赋值" class="headerlink" title="在命令行上给变量赋值"></a>在命令行上给变量赋值</h4><p>gawk命令行可以给程序中的变量赋值，这样用户就能在正常的代码之外赋值，即时改变变量的值，在下面的例子中，有入眠使用命令行变量来显示文件中特定数据字段，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat script1.sh </div><div class="line">BEGIN&#123;FS=","&#125;</div><div class="line">&#123;print $n&#125;</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -f script1.sh n=2 data1.txt</div><div class="line">data12</div><div class="line">data22</div><div class="line">data32</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -f script1.sh n=3 data1.txt</div><div class="line">data13</div><div class="line">data23</div><div class="line">data33</div></pre></td></tr></table></figure>
<p>第一个例子显示了文件的第二个数据字段（<code>n=2</code>），第二个例子显示了第三个数据字段（<code>n=3</code>），只要在命令行上设置n变量的值就行。这个特性可以让用户在不改变脚本代码的情况下就能够改变脚本的行为，使用命令行参数来定义变量值会有一个问题，就是当设置了变量后，这个值在代码的BEGIN部分不可用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat script2.sh </div><div class="line">BEGIN&#123;print "The starting value is",n; FS=","&#125;</div><div class="line">&#123;print $n&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1.txt</div><div class="line">Data11,data12,data13,data14,data15</div><div class="line">data21,data22,data23,data24,data25</div><div class="line">data31,data32,data33,data34,data35</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -f script2.sh n=3 data1.txt</div><div class="line">The starting value is </div><div class="line">data13</div><div class="line">data23</div><div class="line">data33</div></pre></td></tr></table></figure>
<p>如果要解决这个问题，可以用-v命令行参数，此参数允许你在BEGIN代码之前设定变量。在命令行上，<br>-v命令行参数必须放在脚本代码之前，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -v n=3 -f script2.sh data1.txt </div><div class="line">The starting value is 3</div><div class="line">data13</div><div class="line">data23</div><div class="line">data33</div></pre></td></tr></table></figure>
<p>从结果中可以看出，现在在BEGIN代码部分中的变量n的值已经是命令行上设定的那个值了。</p>
<h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><p>为了在单个变量中存储多个值，许多编程语言都提供数组。gawk编程语言使用关联数组提供数组功能。关联数组跟数字数组不同之处在于，关联数据的索引值可以是任意文本字符串（我觉得跟Python中的字典类似）。你不需要用连续的数字来标识数组中的数据元素。相反，关联数组用各种字符串来引用值。每个索引字符串都必须能够唯一地标识出赋给它的数据元素。</p>
<h3 id="定义数组变量"><a href="#定义数组变量" class="headerlink" title="定义数组变量"></a>定义数组变量</h3><p>可以用标准赋值语句来定义数组变量。数组变量赋值的格式为<code>var[index]=element</code>其中<code>var</code>是变量名，<code>index</code>是关联数组的索引值，<code>element</code>是数据元素值,在引用数组变量时，必须包含索引值来提取相应的数据元素值，下面是一些gawk中数组变量的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> capital["Zhengzhou"]="Henan"</div><div class="line"><span class="meta">&gt;</span> print capital["Zhengzhou"]</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">Henan</div></pre></td></tr></table></figure>
<p>代码解释：与<code>var[index]=element</code>对应的是：<code>capital</code>是一个变量名，<code>Zhengzhou</code>是一个索引值，<code>Henan</code>是数据元素值。</p>
<p>在引用数组变量时，会得到数据元素的值。数据元素值是数字值时也一样，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> var[1]=34</div><div class="line"><span class="meta">&gt;</span> var[2]=3</div><div class="line"><span class="meta">&gt;</span> total=var[1]+var[2]</div><div class="line"><span class="meta">&gt;</span> print total</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">37</div></pre></td></tr></table></figure>
<h3 id="遍历数组变量"><a href="#遍历数组变量" class="headerlink" title="遍历数组变量"></a>遍历数组变量</h3><p>关联数组变量的问题在于你可能无法知晓索引值是什么。跟使用连续数字作为索引值的数字数组不同，关联数组的索引可以是任何东西。如果要在gawk中遍历一个关联数组，可以用for语句的一种特殊形式，格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var in array)</div><div class="line">&#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个for语句会在每次循环时将关联数组array的下一个索引值赋给变量var，然后执行一遍statements。这个变量中存储的是索引值而不是数组元素值，可以将这个变量用作数组的索引，轻松地取出数据元素值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> var["a"]=1</div><div class="line"><span class="meta">&gt;</span> var["g"]=2</div><div class="line"><span class="meta">&gt;</span> var["m"]=3</div><div class="line"><span class="meta">&gt;</span> var["u"]=4</div><div class="line"><span class="meta">&gt;</span> for (test in var)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> print "Index:",test," - Value:",var[test]</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">Index: u  - Value: 4</div><div class="line">Index: m  - Value: 3</div><div class="line">Index: a  - Value: 1</div><div class="line">Index: g  - Value: 2</div></pre></td></tr></table></figure>
<p>从结果可以发现，索引值返回的顺序并没有按照变量的变量进行返回，不过它们都能够指向对应的数据元素值，这一点需要注意。</p>
<h3 id="删除数组变量"><a href="#删除数组变量" class="headerlink" title="删除数组变量"></a>删除数组变量</h3><p>从关联数组中删除数组索引的命令为<code>delete array[index]</code>，删除命令会从数组中删除关联索引值和相关的数据元素值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> var["a"]=1</div><div class="line"><span class="meta">&gt;</span> var["g"]=2</div><div class="line"><span class="meta">&gt;</span> for (test in var)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> print "Index:",test,"-Value:",var[test]</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> delete var["g"]</div><div class="line"><span class="meta">&gt;</span> print "---"</div><div class="line"><span class="meta">&gt;</span> for (test in var)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> print "Index:",test,"-Value:",var[test]</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">Index: a -Value: 1</div><div class="line">Index: g -Value: 2</div><div class="line">---</div><div class="line">Index: a -Value: 1</div></pre></td></tr></table></figure>
<p>一旦从关联数组中删除了索引值，你就没法再用它来提取元素值。 </p>
<h2 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h2><p>gawk程序支持多种类型的匹配模式来过滤数据记录，BEGIN和END关键字是用来在读取数据流之前或之后执行命令的特殊模式。类似地，用户可以创建其他模式在数据流中出现匹配数据时执行一些命令。 </p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>在使用正则表达式时，正则表达式必须出现在它要控制的程序脚本的左花括号前，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1.txt </div><div class="line">Data11,data12,data13,data14,data15</div><div class="line">data21,data22,data23,data24,data25</div><div class="line">data31,data32,data33,data34,data35</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=","&#125; /11/&#123;print $1&#125;' data1.txt</div><div class="line">Data11</div></pre></td></tr></table></figure>
<p>正则表达式<code>/11/</code>匹配了数据字段中含有字符串<code>11</code>的记录。gawk程序会用正则表达式对记录中所有的数据字段进行匹配，包括字段分隔符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=","&#125;/,d/&#123;print $1&#125;' data1.txt</div><div class="line">Data11</div><div class="line">data21</div><div class="line">data31</div></pre></td></tr></table></figure>
<p>这个例子使用正则表达式匹配了用作字段分隔符的逗号（<code>/,</code>）。但这可能会造成如下问题：当试图匹配某个数据字段中的特定数据时，这些数据又出现在其他数据字段中。如果需要用正则表达式匹配某个特定的数据实例，应该使用匹配操作符。</p>
<h3 id="匹配操作符"><a href="#匹配操作符" class="headerlink" title="匹配操作符"></a>匹配操作符</h3><p>匹配操作符（matching operator）允许将正则表达式限定在记录中的特定数据字段。匹配操作符是波浪线（<code>~</code>）。可以指定匹配操作符、数据字段变量以及要匹配的正则表达式。例如<code>＄1~/^data/</code>中，<code>$1</code>变量代表记录中的第1个数据字段，这个表达式会过滤出第1个字段以文本data开头的所有记录，下面是gawk使用匹配操作符的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1.txt</div><div class="line">Data11,data12,data13,data14,data15</div><div class="line">data21,data22,data23,data24,data25</div><div class="line">data31,data32,data33,data34,data35</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=","&#125; $2~/data2/&#123;print $0&#125;' data1.txt</div><div class="line">data21,data22,data23,data24,data25</div></pre></td></tr></table></figure>
<p>匹配操作符会用正则表达式<code>/^data2/</code>来比较第二个数据字段，该正则表达式指明字符串要以文本<code>data2</code>开头，常常利用gawk的这个特性来搜索相应的数据元素，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -F: '$1~/biotest/&#123;print $1,$NF&#125;' /etc/passwd</div><div class="line">biotest /bin/bash</div></pre></td></tr></table></figure>
<p>这段代码会在第一个数据字段中查找文本biotest。如果在记录中找到了这个模式，它会打印该记录的第一个和最后一个数据字段值。也可以用<code>!</code>符号来排除正则表达式的匹配，即<code>$1 !~/expression/</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -F: '$1 !~ /biotest/&#123;print $1, $NF&#125;' /etc/passwd</div><div class="line">root /bin/bash</div><div class="line">daemon /usr/sbin/nologin</div><div class="line">bin /usr/sbin/nologin</div><div class="line">sys /usr/sbin/nologin</div><div class="line">sync /bin/sync</div><div class="line">...</div></pre></td></tr></table></figure>
<p>在这段代码中，gawk程序脚本会打印<code>/etc/passwd</code>文件中与用户ID biotest不匹配的用户ID和登录shell。</p>
<h3 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h3><p>除了正则表达式，也可以在匹配模式中用数学表达式。这个功能在匹配数据字段中的数字值时非常方便。举个例子，如果你想显示所有属于root用户组（组ID为0）的系统用户，可以用以下的脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -F: '$4 ==0&#123;print $1&#125;' /etc/passwd</div><div class="line">root</div></pre></td></tr></table></figure>
<p>这段脚本会查看第四个数据字段含有值 0 的记录。在这个Linux系统中，有1个用户账户属于root用户组。 </p>
<p>可以使用任何常见的数学比较表达式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x == y ：值x等于y。 </div><div class="line">x &lt;= y ：值x小于等于y。 </div><div class="line">x &lt; y ：值x小于y。 </div><div class="line">x &gt;= y ：值x大于等于y。 </div><div class="line">x &gt; y ：值x大于y。</div></pre></td></tr></table></figure>
<p>也可以对文本数据使用表达式，但这一点与正则表达式不同，gawk的表达式必须完全匹配，数据必须跟模式严格匹配，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1.txt</div><div class="line">Data11,data12,data13,data14,data15</div><div class="line">data21,data22,data23,data24,data25</div><div class="line">data31,data32,data33,data34,data35</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -F, '$1=="data"&#123;print $1&#125;' data1.txt</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -F, '$1=="Data11"&#123;print $1&#125;' data1.txt</div><div class="line">Data11</div></pre></td></tr></table></figure>
<p>第一个测试没有匹配任何记录，因为第一个数据字段的值不在任何记录中。第二个测试用值Data11匹配了一条记录。</p>
<h2 id="结构化命令"><a href="#结构化命令" class="headerlink" title="结构化命令"></a>结构化命令</h2><p>gawk编程语言支持常见的结构化编程命令。</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>gawk编程语言支持标准的<code>if-then-else</code>格式的if语句。必须为if语句定义一个求值的条件，并将其用圆括号括起来。如果条件求值为<code>TRUE</code>，紧跟在if语句后的语句会执行。如果条件求值为<code>FALSE</code>，这条语句就会被跳过，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (conditon)</div><div class="line">    statement1</div><div class="line"><span class="meta">#</span> 或者放到一行上</div><div class="line">if (condition) statement1</div></pre></td></tr></table></figure>
<p>下面的例子就说明了这种用法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data4.txt10</div><div class="line">5</div><div class="line">13</div><div class="line">50</div><div class="line">34</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;if($1 &gt; 20) print $1&#125;' data4.txt</div><div class="line">50</div><div class="line">34</div></pre></td></tr></table></figure>
<p>如果需要在if语句中执行多条语句，就必须用花括号将它们括起来，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> if($1&gt;20)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> x=$1*2</div><div class="line"><span class="meta">&gt;</span> print x</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> &#125;' data4.txt</div><div class="line">100</div><div class="line">68</div></pre></td></tr></table></figure>
<p>gawk的if语句也支持else子句，允许在if语句条件不成立的情况下执行一条或多条语句，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> if ($1&gt;20)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> x=$1*2</div><div class="line"><span class="meta">&gt;</span> print x</div><div class="line"><span class="meta">&gt;</span> &#125; else</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> x=$1/2</div><div class="line"><span class="meta">&gt;</span> print x</div><div class="line"><span class="meta">&gt;</span> &#125;&#125;' data4.txt</div><div class="line">5</div><div class="line">2.5</div><div class="line">6.5</div><div class="line">100</div><div class="line">68</div></pre></td></tr></table></figure>
<p>可以在单行上使用else子句，但必须在if语句部分之后使用分号，格式为<code>if (condition) statement1; else statement2</code>，案例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;if ($1&gt;20) print $1*2;else print $1/2&#125;' data4.txt</div><div class="line">5</div><div class="line">2.5</div><div class="line">6.5</div><div class="line">100</div><div class="line">68</div></pre></td></tr></table></figure>
<h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>whlie语句的基本格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">while (conditoin)</div><div class="line">&#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>while循环可以遍历一组数据，并检查迭代的结束条件。如果在计算中必须使用每条记录中的多个数据值，就能够使用到while语句，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data5.txt </div><div class="line">130 120 135</div><div class="line">160 113 140 </div><div class="line">145 170 215</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> total=0</div><div class="line"><span class="meta">&gt;</span> i=1</div><div class="line"><span class="meta">&gt;</span> while(i&lt;4)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> total+=$i</div><div class="line"><span class="meta">&gt;</span> i++</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> avg=total/3</div><div class="line"><span class="meta">&gt;</span> print "Average:",avg</div><div class="line"><span class="meta">&gt;</span> &#125;' data5.txt</div><div class="line">Average: 128.333</div><div class="line">Average: 137.667</div><div class="line">Average: 176.667</div></pre></td></tr></table></figure>
<p>while语句会遍历记录中的数据字段，将每个值都加到total变量上，并将计数器变量i增值。当计数器值等于4时，while的条件变成了FALSE，循环结束，然后执行脚本中的下一条语句。这条语句会计算并打印出平均值。这个过程会在数据文件中的每条记录上不断重复。</p>
<p>gawk编程语言支持在while循环中使用<code>break</code>语句和<code>continue</code>语句，允许你从循环中跳出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> total=0</div><div class="line"><span class="meta">&gt;</span> i=1</div><div class="line"><span class="meta">&gt;</span> while(i&lt;4)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> total +=$i</div><div class="line"><span class="meta">&gt;</span> if(i==2)</div><div class="line"><span class="meta">&gt;</span> break</div><div class="line"><span class="meta">&gt;</span> i++</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> avg=total/2</div><div class="line"><span class="meta">&gt;</span> print "The average of the first two data elements is:",avg</div><div class="line"><span class="meta">&gt;</span> &#125;' data5.txt</div><div class="line">The average of the first two data elements is: 125</div><div class="line">The average of the first two data elements is: 136.5</div><div class="line">The average of the first two data elements is: 157.5</div></pre></td></tr></table></figure>
<p>break语句用来在i变量的值为2时从while循环中跳出。</p>
<h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h3><p><code>do-while</code>语句会在检查条件语句之前执行命令，下面是do-while语句的格式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">do</div><div class="line">&#123;</div><div class="line">    statements</div><div class="line">    &#125; while(condition)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种格式保证了语句会在条件被求值之前至少执行一次，当需要在求值条件前执行语句时，这个特性非常方便，案例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> total=0</div><div class="line"><span class="meta">&gt;</span> i=1</div><div class="line"><span class="meta">&gt;</span> do</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> total+=$i</div><div class="line"><span class="meta">&gt;</span> i++</div><div class="line"><span class="meta">&gt;</span> &#125; while (total&lt;150)</div><div class="line"><span class="meta">&gt;</span> print total&#125;' data5.txt</div><div class="line">250</div><div class="line">160</div><div class="line">315</div></pre></td></tr></table></figure>
<p>这个脚本会读取每条记录的数据字段并将它们加在一起，直到累加结果达到150。如果第一个数据字段大于150（就像在第二条记录中看到的那样），则脚本会保证在条件被求值前至少读取第一个数据字段的内容。</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>格式为<code>for (variable assignment; condition; iteration process)</code>，案例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> total=0</div><div class="line"><span class="meta">&gt;</span> for (i=1;i&lt;4;i++)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> total+=$i</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> avg=total/3</div><div class="line"><span class="meta">&gt;</span> print "Average:",avg</div><div class="line"><span class="meta">&gt;</span> &#125;' data5.txt</div><div class="line">Average: 128.333</div><div class="line">Average: 137.667</div><div class="line">Average: 176.667</div></pre></td></tr></table></figure>
<h3 id="格式化打印"><a href="#格式化打印" class="headerlink" title="格式化打印"></a>格式化打印</h3><p>gawk中的格式化打印命令是<code>printf</code>，格式为<code>printf &quot;format string&quot;,vaar1,var2...</code>，其中<code>format string</code>是关键部分，它会用文本元素和格式化指定符</p>
<p>来具体指定如何呈现格式化输出。格式化指定符是一种特殊的代码，会指明显示什么类型的变量以及如何显示。gawk程序会将每个格式化指定符作为占位符，供命令中的变量使用。第一个格式化指定符对应列出的第一个变量，第二个对应第二个变量，依此类推。格式化指定符的格式为<code>%[modifier] control-letter</code>，其中，<code>control-letter</code>是一个单字符代码，用于指明显示什么类型的数据，而<code>modifier</code>则定义了可选的格式化特性。下列出了可用在格式化指定符中的控制字母（其实很多编程语言的格式化输出大同小异）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制字母</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>将一个数作为ASCII字符显示</td>
</tr>
<tr>
<td>d</td>
<td>显示一个整数值</td>
</tr>
<tr>
<td>i</td>
<td>显示一个整数值（跟 d 一样）</td>
</tr>
<tr>
<td>e</td>
<td>用科学计数法显示一个数</td>
</tr>
<tr>
<td>f</td>
<td>显示一个浮点值</td>
</tr>
<tr>
<td>g</td>
<td>用科学计数法或浮点数显示（选择较短的格式）</td>
</tr>
<tr>
<td>o</td>
<td>显示一个八进制值</td>
</tr>
<tr>
<td>s</td>
<td>显示一个文本字符串</td>
</tr>
<tr>
<td>x</td>
<td>显示一个十六进制值</td>
</tr>
<tr>
<td>X</td>
<td>显示一个十六进制值，但用大写字母A~F</td>
</tr>
</tbody>
</table>
</div>
<p>因此，如果显示一个字符串变量，可以用格式化指定符<code>%s</code>。如果要显示一个整数值，可以用<code>%d</code>或<code>%i</code>（<code>%d</code>是十进制数的C风格显示方式）。如果你要用科学计数法显示很大的值，就用<code>%e</code>格式化指定符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> x=10*100</div><div class="line"><span class="meta">&gt;</span> printf "The answer is: %e\n",x</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">The answer is: 1.000000e+03</div></pre></td></tr></table></figure>
<p>除了控制字母外，还有3种修饰符可以用来进一步控制输出：</p>
<ol>
<li><code>width</code>：指定了输出字段最小宽度的数字值。如果输出短于这个值， printf 会将文本右 对齐，并用空格进行填充。如果输出比指定的宽度还要长，则按照实际的长度输出。  </li>
<li><code>prec</code>：这是一个数字值，指定了浮点数中小数点后面位数，或者文本字符串中显示的最 大字符数。  </li>
<li><code>- （减号）</code>：指明在向格式化空间中放入数据时采用左对齐而不是右对齐。 </li>
</ol>
<p>下面是一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data2.txt</div><div class="line">Riley Mullen</div><div class="line">123 Main Street</div><div class="line">Chicago, IL  60601</div><div class="line">(312)555-1234</div><div class="line"></div><div class="line">Frank Williams</div><div class="line">456 Oak Street</div><div class="line">Indianapolis, IN  46201</div><div class="line">(317)555-9876</div><div class="line"></div><div class="line">Haley Snell</div><div class="line">4231 Elm Street</div><div class="line">Detroit, MI 48201</div><div class="line">(313)555-4938</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS="\n";RS=""&#125;&#123;print $1,$4&#125;' data2.txt</div><div class="line">Riley Mullen (312)555-1234</div><div class="line">Frank Williams (317)555-9876</div><div class="line">Haley Snell (313)555-4938</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS="\n";RS=""&#125;&#123;printf "%s %s\n",$1,$4&#125;' data2.txt</div><div class="line">Riley Mullen (312)555-1234</div><div class="line">Frank Williams (317)555-9876</div><div class="line">Haley Snell (313)555-4938</div><div class="line"><span class="meta">#</span> printf会产生跟print命令相同的输出。printf命令用%s格式化指定符来作为这两个字符串值的占位符。</div></pre></td></tr></table></figure>
<p>在printf命令的末尾手动添加换行符来生成新行。没添加的话，printf命令会继续在同一行打印后续输出。如果需要用几个单独的printf命令在同一行上打印多个输出，这就会非常有用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=","&#125;&#123;printf "%s ",$1&#125;' data1.txt</div><div class="line">Data11 data21 data31 biotest@ubuntu:~/advance_gawk$ gawtf "%s ",$1&#125; END&#123;printf "\n"&#125;' data1.txt</div><div class="line">Data11 data21 data31 </div><div class="line">biotest@ubuntu:~/advance_gawk$</div></pre></td></tr></table></figure>
<p>从结果可以看出，第一次命令没有加换行符，结果出来后直接就是命令提示符，即<code>biotest@ubuntu:~/advance_gawk$</code>，如果加换行符后，就正常了，再看一个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data2.txtRiley Mullen</div><div class="line">123 Main Street</div><div class="line">Chicago, IL  60601</div><div class="line">(312)555-1234</div><div class="line"></div><div class="line">Frank Williams</div><div class="line">456 Oak Street</div><div class="line">Indianapolis, IN  46201</div><div class="line">(317)555-9876</div><div class="line"></div><div class="line">Haley Snell</div><div class="line">4231 Elm Street</div><div class="line">Detroit, MI 48201</div><div class="line">(313)555-4938</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS="\n";RS=""&#125;&#123;printf "%16s %s\n",$1,$4&#125;' data2.txt</div><div class="line">    Riley Mullen (312)555-1234</div><div class="line">  Frank Williams (317)555-9876</div><div class="line">     Haley Snell (313)555-4938</div></pre></td></tr></table></figure>
<p>通过添加一个值为16的修饰符，这表示强制第一个字符串的输出宽度为16个字符。默认情况下，printf命令使用右对齐来将数据放到格式化空间中。要改成左对齐，只需给修饰符加一个减号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS="\n";RS=""&#125;&#123;printf "%-16s %s\n",$1,$4&#125;' data2.txt</div><div class="line">Riley Mullen     (312)555-1234</div><div class="line">Frank Williams   (317)555-9876</div><div class="line">Haley Snell      (313)555-4938</div></pre></td></tr></table></figure>
<p>printf命令也能处理浮点值，通过为变量指定一个格式，可以让输出看起来更统一，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data5.txt</div><div class="line">130 120 135</div><div class="line">160 113 140 </div><div class="line">145 170 215</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> total=0</div><div class="line"><span class="meta">&gt;</span> for (i=0;i&lt;4;i++)</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> total+=$i</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> avg=total/3</div><div class="line"><span class="meta">&gt;</span> printf "Average: %5.1f\n",avg</div><div class="line"><span class="meta">&gt;</span> &#125;' data5.txt</div><div class="line">Average: 171.7</div><div class="line">Average: 191.0</div><div class="line">Average: 225.0</div></pre></td></tr></table></figure>
<p>可以使用<code>%5.1f</code>格式指定符来强制printf命令输出5位的浮点数，并且将浮点值近似到小数点后一位。</p>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>gawk内置了一些处理数字、字符串以及时间的函数。</p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>atan2(x, y)</td>
<td>x/y的反正切，x和y以弧度为单位</td>
</tr>
<tr>
<td>cos(x)</td>
<td>x的余弦，x以弧度为单位</td>
</tr>
<tr>
<td>exp(x)</td>
<td>x的指数函数</td>
</tr>
<tr>
<td>int(x)</td>
<td>x的整数部分，取靠近零一侧的值，5.6取5，-5.6取-5。</td>
</tr>
<tr>
<td>log(x)</td>
<td>x的自然对数</td>
</tr>
<tr>
<td>rand( )</td>
<td>比0大比1小的随机浮点值，创建随机数</td>
</tr>
<tr>
<td>sin(x)</td>
<td>x的正弦，x以弧度为单位</td>
</tr>
<tr>
<td>sqrt(x)</td>
<td>x的平方根</td>
</tr>
<tr>
<td>srand(x)</td>
<td>为计算随机数指定一个种子值</td>
</tr>
</tbody>
</table>
</div>
<p>gawk语言对于它能够处理的数值有一个限定区间，如果超出了这个区间，就会得到一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;x=exp(100);print x&#125;'</div><div class="line">26881171418161356094253400435962903554686976</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;x=exp(1000);print x&#125;'</div><div class="line">gawk: cmd. line:1: warning: exp: argument 1000 is out of range</div><div class="line">inf</div></pre></td></tr></table></figure>
<p>第一个例子会计算e的100次幂，虽然数值很大，但尚在系统的区间内。第二个例子尝试计算e的1000次幂，已经超出了系统的数值区间，所以就生成了一条错误消息。</p>
<p>gawk还有一些按位操作数据的函数，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>and(v1,v2)</td>
<td>执行值v1和v2的按位与运算。</td>
</tr>
<tr>
<td>compl(val)</td>
<td>执行val的补运算。</td>
</tr>
<tr>
<td>lshift(val,count)</td>
<td>将值val左移count位</td>
</tr>
<tr>
<td>or(v1,v2)</td>
<td>执行值v1和v2的按位或运算</td>
</tr>
<tr>
<td>rshift(val,count)</td>
<td>将值val右移count位。</td>
</tr>
<tr>
<td>xor(v1,v2)</td>
<td>执行值v1和v2的按位异或运算。</td>
</tr>
</tbody>
</table>
</div>
<p>位操作函数通常用于听任二进制值时。</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>gawk的字符串函数如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>asort(s[,d])</td>
<td>将数组s按数据元素值排序。索引值会被替换成表示新的排序顺序的连续数字。另外，如果指定了d，则排序后的数组会存储在数组d中</td>
</tr>
<tr>
<td>asorti(s[,d])</td>
<td>将数组s按索引值排序。生成的数组会将索引值作为数据元素值，用连续数字索引来表明排序顺序。另外如果指定了d，排序后的数组会存储在数组d中</td>
</tr>
<tr>
<td>gensub(r,s,h[,t])</td>
<td>查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果h是一个以g或G开头的字符串，就用s替换掉匹配的文本。如果h是一个数字，它表示要替换掉第h处r匹配的地方</td>
</tr>
<tr>
<td>gsub(r,s[,t])</td>
<td>查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果找到了，就全部替换成字符串s</td>
</tr>
<tr>
<td>index(s,t)</td>
<td>返回字符串t在字符串s中的索引值，如果没找到的话返回0</td>
</tr>
<tr>
<td>length([s])</td>
<td>返回字符串s的长度；如果没有指定的话，返回$0的长度</td>
</tr>
<tr>
<td>match(s,r[,a])</td>
<td>返回字符串s中正则表达式r出现位置的索引。如果指定了数组a，它会存储s中匹配正则表达式的那部分</td>
</tr>
<tr>
<td>split(s,a[,r])</td>
<td>将s用FS字符或正则表达式r（如果指定了的话）分开放到数组a中。返回字段的总数</td>
</tr>
<tr>
<td>sprintf(format,variables)</td>
<td>用提供的format和variables返回一个类似于printf输出的字符串</td>
</tr>
<tr>
<td>sub(r,s[,t])</td>
<td>在变量$0或目标字符串t中查找正则表达式r的匹配。如果找到了，就用字符串s替换掉第一处匹配</td>
</tr>
<tr>
<td>substr(s,i[,n])</td>
<td>返回s中从索引值i开始的n个字符组成的子字符串。如果未提供n，则返回s剩下的部分</td>
</tr>
<tr>
<td>tolower(s)</td>
<td>将s中的所有字符转换成小写</td>
</tr>
<tr>
<td>toupper(s)</td>
<td>将s中的所有字符转换成大写</td>
</tr>
</tbody>
</table>
</div>
<p>下面是一个案例:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;x="testing";print toupper(x);print length(x)&#125;'</div><div class="line">TESTING</div><div class="line">7</div></pre></td></tr></table></figure></p>
<p>但一些字符串函数的用法相当复杂。asort和asorti函数是新加入的gawk函数，允许你基于数据元素值（asort）或索引值（asorti）对数组变量进行排序。这里有个使用asort的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;</div><div class="line">var["a"]=11</div><div class="line">var["g"]=2</div><div class="line">var["m"]=31</div><div class="line">var["u"]=14</div><div class="line">asort(var,test)</div><div class="line">for(i in test)</div><div class="line">print "Index:",i," - value:",test[i]</div><div class="line">&#125;'</div><div class="line">Index: 1  - value: 2</div><div class="line">Index: 2  - value: 11</div><div class="line">Index: 3  - value: 14</div><div class="line">Index: 4  - value: 31</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;</div><div class="line">var["a"]=11</div><div class="line">var["g"]=2</div><div class="line">var["m"]=31</div><div class="line">var["u"]=14</div><div class="line">asorti(var,test)</div><div class="line">for(i in test)</div><div class="line">print "Index:",i," - value:",test[i]</div><div class="line">&#125;'</div><div class="line">Index: 1  - value: a</div><div class="line">Index: 2  - value: g</div><div class="line">Index: 3  - value: m</div><div class="line">Index: 4  - value: u</div></pre></td></tr></table></figure>
<p>从结果可以看出，新数组test含有排序后的原数组的数据元素，但索引值现在变为表明正确顺序的数字值了。asort是对数组的值进行排序；而asorti是对数组的索引进行排序。</p>
<p>split 函数是将数据字段放到数组中以供进一步处理的好办法，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data1.txt</div><div class="line">Data11,data12,data13,data14,data15</div><div class="line">data21,data22,data23,data24,data25</div><div class="line">data31,data32,data33,data34,data35</div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;FS=","&#125;&#123;</div><div class="line"><span class="meta">&gt;</span> split($0,var)</div><div class="line"><span class="meta">&gt;</span> print var[1],var[5]</div><div class="line"><span class="meta">&gt;</span> &#125;' data1.txt</div><div class="line">Data11 data15</div><div class="line">data21 data25</div><div class="line">data31 data35</div></pre></td></tr></table></figure></p>
<p>新数组使用连续数字作为数组索引，从含有第一个数据字段的索引值 1 开始。 </p>
<h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><p>gawk的时间是函数下如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mktime(datespec)</td>
<td>将一个按YYYY MM DD HH MM SS [DST]格式指定的日期转换成时间戳值</td>
</tr>
<tr>
<td>strftime(format [,timestamp])</td>
<td>将当前时间的时间戳或timestamp（如果提供了的话）转化格式化日期（采用shell函数date()的格式）</td>
</tr>
<tr>
<td>systime( )</td>
<td>返回当前时间的时间戳</td>
</tr>
</tbody>
</table>
</div>
<p>时间函数常用来处理日志文件，而日志文件则常含有需要进行比较的日期。通过将日期的文本表示形式转换成epoch时间（自1970-01-0100:00:00UTC到现在的秒数），可以轻松地比较日期。下面是在gawk程序中使用时间函数的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk 'BEGIN&#123;</div><div class="line"><span class="meta">&gt;</span> date=systime()</div><div class="line"><span class="meta">&gt;</span> day=strftime("%A,%B %d,%Y",date)</div><div class="line"><span class="meta">&gt;</span> print day</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">Tuesday,May 15,2018</div></pre></td></tr></table></figure>
<p>该例用systime函数从系统获取当前的epoch时间戳，然后用strftime函数将它转换成用户可读的格式，转换过程中使用了shell命令date的日期格式化字符。</p>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>自定义函数需要用到function关键字，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function name([variables])</div><div class="line">&#123;</div><div class="line">    statements    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面看一个简单的函数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function printthird()</div><div class="line">&#123;</div><div class="line">    print $3</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数会打印记录中的第3个数据字段，函数还可以使用return语句返回值，即<code>return value</code>，值可以是变量，也可以是表达，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">funciotn myrand(limit)</div><div class="line">&#123;</div><div class="line">    return int(limit*rand())</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以将函数的返回值赋值给gawk程序中的一个变量，例如<code>x=myrand(100)</code>，这个变量包含函数的返回值。</p>
<h3 id="自定义函数使用"><a href="#自定义函数使用" class="headerlink" title="自定义函数使用"></a>自定义函数使用</h3><p>在定义函数时，它必须出现在所有代码块之前（包括BEGIN代码块）。这种形式有助于将函数代码与gawk程序的其他部分分开，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ gawk '</div><div class="line"><span class="meta">&gt;</span> function myprint()</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> printf "%-16s - %s\n",$1,$4</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line"><span class="meta">&gt;</span> BEGIN&#123;FS="\n";RS=""&#125;</div><div class="line"><span class="meta">&gt;</span> &#123;</div><div class="line"><span class="meta">&gt;</span> myprint()</div><div class="line"><span class="meta">&gt;</span> &#125;' data2.txt</div><div class="line">Riley Mullen     - (312)555-1234</div><div class="line">Frank Williams   - (317)555-9876</div><div class="line">Haley Snell      - (313)555-4938</div></pre></td></tr></table></figure></p>
<p>这个函数定义了myprint()函数，它会格式化记录中的第一个和第四个数据字段以供打印输出。gawk程序然后用该函数显示出数据文件中的数据。一旦定义了函数，就能在程序的代码中随意使用。在涉及很大的代码量时，这会省去许多工作。</p>
<h3 id="创建函数库"><a href="#创建函数库" class="headerlink" title="创建函数库"></a>创建函数库</h3><p>gawk提供了一种途径来将多个函数 放到一个库文件中，这样能在所有的gawk程序中使用了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cat funclib </div><div class="line">function myprint()</div><div class="line">&#123;</div><div class="line">   printf "%-16s-%s\n",$1,$4</div><div class="line">&#125;</div><div class="line"></div><div class="line">function myrand(limit)</div><div class="line">&#123;</div><div class="line">   return int(limit*rand())</div><div class="line">&#125;</div><div class="line"></div><div class="line">function printthird()</div><div class="line">&#123;</div><div class="line">   print $3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>funclib文件含有三个函数定义。需要使用<code>-f</code>命令行参数来使用它们。但不能将<code>-f</code>命令行参数和内联gawk脚本放到一起使用，不过可以在同一个命令行中使用多个<code>-f</code>参数。因此，要使用库，只要创建一个含有你的gawk程序的文件，然后在命令行上同时指定库文件和程序文件就行了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cat script4.sh</div><div class="line">BEGIN&#123; FS="\n";RS=""&#125;</div><div class="line">&#123;</div><div class="line">   myprint()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat data2.txt </div><div class="line">Riley Mullen</div><div class="line">123 Main Street</div><div class="line">Chicago, IL  60601</div><div class="line">(312)555-1234</div><div class="line"></div><div class="line">Frank Williams</div><div class="line">456 Oak Street</div><div class="line">Indianapolis, IN  46201</div><div class="line">(317)555-9876</div><div class="line"></div><div class="line">Haley Snell</div><div class="line">4231 Elm Street</div><div class="line">Detroit, MI 48201</div><div class="line">(313)555-4938</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_gawk$ gawk -f funclib.sh -f script4.sh data2.txt</div><div class="line">Riley Mullen    -(312)555-1234</div><div class="line">Frank Williams  -(317)555-9876</div><div class="line">Haley Snell     -(313)555-4938</div></pre></td></tr></table></figure></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>现在有一个数据文件，其中包含了两支队伍（每队两名选手）的保龄球比赛 得分情况，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ cat scores.txt </div><div class="line">Rich Blum, team1, 100,115,95</div><div class="line">Barbara Blum, team1, 110, 115,100</div><div class="line">Christine Bresnahan, team2, 120, 115,118</div><div class="line">Time Bresnahan, team2, 125, 112, 116</div></pre></td></tr></table></figure>
<p>每位选手都有三场比赛的成绩，这些成绩都保存在数据文件中，每位选手由位于第二列的队名来标识。下面的脚本对每队的成绩进行了排序，并计算了总分和平均分，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for team in $(gawk 'BEGIN&#123;FS=","&#125;&#123;print $2&#125;' scores.txt| uniq)</div><div class="line">do</div><div class="line">    gawk -v team=$team 'BEGIN&#123;FS=",";total=0&#125;</div><div class="line">    &#123;</div><div class="line">        if($2==team)</div><div class="line">        &#123;</div><div class="line">            total+=$3+$4+$5;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">     END &#123;</div><div class="line">         avg=total/6;</div><div class="line">         print "Total for",team, "is",total,",the average is",avg</div><div class="line">&#125;' scores.txt</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_gawk$ bash bowling.sh </div><div class="line">Total for team1 is 635 ,the average is 105.833</div><div class="line">Total for team2 is 706 ,the average is 117.667</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/10/Linux/Linux-shell10-sed进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/Linux/Linux-shell10-sed进阶/" itemprop="url">Shell学习笔记（10）——sed进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-10T12:12:54+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,053
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  41
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多行命令"><a href="#多行命令" class="headerlink" title="多行命令"></a>多行命令</h2><p>sed编辑器包含了三个可用来处理多行文本的特殊命令，其中：</p>
<ol>
<li><code>N</code>：将数据流中的下一行加进来创建一个多行组（multiline group）来处理；</li>
<li><code>D</code>：删除多行组中的一行</li>
<li><code>P</code>：打印多行组中的一行。</li>
</ol>
<h3 id="next-命令"><a href="#next-命令" class="headerlink" title="next 命令"></a>next 命令</h3><p>小写的n命令（n表示next）会告诉sed编辑器移动到数据流中的下一文本行，而不用重新回到命令的最开始再执行一遍。通常sed编辑器在移动到数据流中的下一文本行之前，会在当前行上执行完所有定义好的命令。单行next命令改变了这个流程。在下面的这个例子中，你有个数据文件，共有5行内容，其中的两行是空的。目标是删除首行之后的空白行，而留下最后一行之前的空白行。如果写一个删掉空白行的sed脚本，你会删掉两个空白行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data1.txt</div><div class="line">THis is the header line.</div><div class="line"></div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/^$/d' data1.txt</div><div class="line"><span class="meta">#</span> 删除空行，^$表示空行</div><div class="line">THis is the header line.</div><div class="line">This is a data line.</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>如果只是删除第1行之后的空行，就要用到n命令，在下面的脚本中，首先要查找含有单词header的那一行。找到之后，n命令会让sed编辑器移动到文本的下一行，也就是那个空行，删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed '/header/&#123;n;d&#125;' data1.txt</div><div class="line">THis is the header line.</div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>这时，sed编辑器会继续执行命令列表，该命令列表使用d命令来删除空白行。sed编辑器执行完命令脚本后，会从数据流中读取下一行文本，并从头开始执行命令脚本。因为sed编辑器再也找不到包含单词header的行了。所以也不会有其他行会被删掉，如果再给文添加上一行，里面含有header字符串，之后再留1个空格，也会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data1a.txt </div><div class="line">THis is the header line.</div><div class="line"></div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is another line containing string 'header'. #这行文中也含有header，随后跟了一个空行</div><div class="line"></div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/header/&#123;n;d&#125;' data1a.txt # 这个命令会删除含有header之后的空行</div><div class="line"></div><div class="line">THis is the header line.</div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is another line containing string 'header'. # 后面的空行删除了</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<h4 id="合并文本行"><a href="#合并文本行" class="headerlink" title="合并文本行"></a>合并文本行</h4><p>单行next命令会将数据流中的下一文本行移动到sed编辑器的工作空间（称为模式空间）。多行版本的next命令（用大写N）会将下一文本行添加到模式空间中已有的文本后。这样的作用是将数据流中的两个文本行合并到同一个模式空间中。文本行仍然用换行符分隔，但sed编辑器现在会将两行文本当成一行来处理。下面的例子演示了<code>N</code>命令的工作方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txtThis is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/first/&#123;N;s/\n/ / &#125;' data2.txt</div><div class="line">This is the first data line. This is the second data line.</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>在这段代码中，<code>sed &#39;/first/{N;s/line/replace/ }&#39; data2.txt</code>查找含有单词first的那行文本，找到该行后，使用N命令，将下一行合并到那行，然后用替换命令将换行符替换为空格。</p>
<p>如果要在数据文件中查找一个可能会分散在两行中的文本短语的话，这是个很实用的应用程序，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data3.txt </div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line">Thank you for your attendance.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N; s/System Administrator/Desktop User/' data3.txt</div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div><div class="line">Thank you for your attendance.</div></pre></td></tr></table></figure>
<p>替换命令会在文本文件中查找特定的双词短语System Administrator。如果短语在一行中的话，事情很好处理，替换命令可以直接替换文本。但如果短语分散在两行中的话，替换命令就没法识别匹配的模式了，在这个案例中，是第1行中有一个System，第2行有一个Administrator，使用System administrator时，这种情况下就无法匹配，此时就需要使用N命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data3.txt </div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line">Thank you for your attendance.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N;s/System.Administrator/Desktop User/' data3.txt</div><div class="line">On Tuesday, the Linux Desktop User's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div><div class="line">Thank you for your attendance.</div></pre></td></tr></table></figure>
<p>在这段代码中，使用N命令将发现第一个单词的那行和下一行合并后，即使短语内出现了换行，你仍然可以找到它。注意，替换命令在System和Administrator之间用了通配符模式（.）来匹配空格和换行符这两种情况。但当它匹配了换行符时，它就从字符串中删掉了换行符，导致两行合并成一行。这可能不是你想要的。要解决这个问题，可以在sed编辑器脚本中用两个替换命令：一个用来匹配短语出现在多行中的情况，一个用来匹配短语出现在单行中的情况，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N</div><div class="line">s/System\nAdministrator/Desktop\nUser/</div><div class="line"><span class="meta">&gt;</span> s/System Administrator/Desktop User/</div><div class="line"><span class="meta">&gt;</span> ' data3.txt</div><div class="line"></div><div class="line">On Tuesday, the Linux Desktop</div><div class="line">User's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div><div class="line">Thank you for your attendance.</div></pre></td></tr></table></figure>
<p>第一个替换命令专门查找两个单词间的换行符，并将它放在了替换字符串中。这样你就能在第一个替换命令专门在两个检索词之间寻找换行符，并将其纳入替换字符串。这样就允许你在新文本的同样位置添加换行符了。但这个脚本中仍有个小问题。这个脚本总是在执行sed编辑器命令前将下一行文本读入到模式空间。当它到了最后一行文本时，就没有下一行可读了，所以N命令会叫sed编辑器停止。如果要匹配的文本正好在数据流的最后一行上，命令就不会发现要匹配的数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data4.txt</div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N</div><div class="line">s/System\nAdministrator/Desktop\nUser/</div><div class="line">s/System Administrator/Desktop User/</div><div class="line">' data4.txt</div><div class="line"></div><div class="line">On Tuesday, the Linux Desktop</div><div class="line">User's group meeting will be held.</div><div class="line">All System Administrators should attend.</div></pre></td></tr></table></figure>
<p>在这个案例中，匹配的文正好在数据流的最后一行，并没有发生文本的替换，<code>N</code>命令会错过它，因为没有其他行可读入到模式空间跟这行合并。如果要解决这个问题，就要将单行命令放到N命令前面，并将多行命令放到N命令后面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed '</div><div class="line"><span class="meta">&gt;</span> s/System Administrator/Desktop User/</div><div class="line"><span class="meta">&gt;</span> N</div><div class="line"><span class="meta">&gt;</span> s/System\nAdministrator/Desktop\nUser/</div><div class="line"><span class="meta">&gt;</span> ' data4.txt</div><div class="line"></div><div class="line">On Tuesday, the Linux Desktop</div><div class="line">User's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div></pre></td></tr></table></figure>
<p>现在，查找单行中短语的替换命令在数据流的最后一行也能正常工作，多行替换命令则会负责短语出现在数据流中间的情况。 </p>
<h3 id="多行删除命令"><a href="#多行删除命令" class="headerlink" title="多行删除命令"></a>多行删除命令</h3><p>单行删除命令（d）和N命令一起使用时，需要注意，看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data4.txt</div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N; /System\nAdministrator/d' data4.txt</div><div class="line">All System Administrators should attend.</div></pre></td></tr></table></figure>
<p>删除命令会在不同的行中查找单词System和Administrator，然后在模式空间中将两行都删掉。sed编辑器提供了多行删除命令D，它只删除模式空间中的第一行。该命令会删除到换行符（含换行符）为止的所有字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N;/System\nAdministrator/D' data4.txt</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div></pre></td></tr></table></figure>
<p>文本的第二行被N命令加到了模式空间，最终结果只是删除了第1行，第2行但仍然完好。如果遇到一种情况，即需要删掉目标数据字符串所在行的前一文本行，此时就能派得上用场，看下面的一个案例，在这个案例中，它会删除数据流中出现在第一行前的空白行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data5.txt </div><div class="line">                         # 这里是一个空行</div><div class="line">This is the header line.</div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/^$/&#123;N;/header/D&#125;' data5.txt</div><div class="line">This is the header line.</div><div class="line">This is a data line.</div><div class="line"></div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>sed编辑器脚本会查找空白行，然后用N命令来将下一文本行添加到模式空间。如果新的模式空间内容含有单词header，则D命令会删除模式空间中的第一行。如果不结合使用N命令和D命令，就不可能在不删除其他空白行的情况下只删除第一个空白行。</p>
<h3 id="多行打印命令"><a href="#多行打印命令" class="headerlink" title="多行打印命令"></a>多行打印命令</h3><p>多行打印命令（P）只打印多行模式空间中的第一行，这包括模式空间中直到换行符为止的所有字符。当你用-n选项来阻止脚本输出时，它和显示文本的单行p命令的用法大同小异，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data3.txt </div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line">Thank you for your attendance.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n 'N;/System\nAdministrator/P' data3.txt</div><div class="line">On Tuesday, the Linux System</div></pre></td></tr></table></figure>
<p>当多行匹配出现时，P命令只会打印模式空间中的第一行。</p>
<p>多行P命令的强大之处在和N命令及D命令组合使用时才能显现出来。D命令的独特之处在于强制sed编辑器返回到脚本的起始处，对同一模式空间中的内容重新执行这些命令（它不会从数据流中读取新的文本行）。在命令脚本中加入N命令，你就能单步扫过整个模式空间，将多行一起匹配。接下来，使用P命令打印出第一行，然后用D命令删除第一行并绕回到脚本的起始处。一旦返回，N命令会读取下一行文本并重新开始这个过程。这个循环会一直继续下去，直到数据流结束。</p>
<h2 id="保持空间"><a href="#保持空间" class="headerlink" title="保持空间"></a>保持空间</h2><p>模式空间（pattern space）是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本。但它并不是sed编辑器保存文本的唯一空间。sed编辑器有另一块称作保持空间（hold space）的缓冲区域。在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。有5条命令可用来操作保持空间，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命    令</th>
<th>描     述</th>
</tr>
</thead>
<tbody>
<tr>
<td>h</td>
<td>将模式空间复制到保持空间</td>
</tr>
<tr>
<td>H</td>
<td>将模式空间附加到保持空间</td>
</tr>
<tr>
<td>g</td>
<td>将保持空间复制到模式空间</td>
</tr>
<tr>
<td>G</td>
<td>将保持空间附加到模式空间</td>
</tr>
<tr>
<td>x</td>
<td>交换模式空间和保持空间的内容</td>
</tr>
</tbody>
</table>
</div>
<p>这些命令用来将文本从模式空间复制到保持空间。这可以清空模式空间来加载其他要处理的字符串。通常，在使用h或H命令将字符串移动到保持空间后，最终还要用g、G或x命令将保存的字符串移回模式空间。由于有两个缓冲区域，弄明白哪行文本在哪个缓冲区域有时会比较麻烦。这里有个简短的例子演示了如何用h和g命令来将数据在sed编辑器缓冲空间之间移动，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '/first/&#123;h;p;n;p;g;p&#125;' data2.txt</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the first data line.</div></pre></td></tr></table></figure>
<p>代码与结果解释：</p>
<ol>
<li>sed脚本在地址中使用正则表达式来过滤出含有单词first的行；</li>
<li>当含有单词first的行出现时，h命令将该行放到保持空间；</li>
<li>p命令打印模式空间的内容，也就是第一个数据行的内容；</li>
<li>n命令提取数据流中的下行（<code>This is the second data line</code>），并将它放到模式空间</li>
<li>p命令打印模式空间的内容，现在是第二个数据行；</li>
<li>g命令将保持空间的内容（<code>This is the first data line</code>）放回模式空间，替换当前文本；</li>
<li>p命令打印模式空间的当前内容，现在变回第一个数据行。</li>
</ol>
<p>通过使用保持空间来回移动文本行，可以强制输出中第一个数据行出现在第二个数据行后面。如果丢掉了第一个p命令，可以以相反的顺序输出这两行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '/first/&#123;h;n;p;g;p&#125;' data2.txt</div><div class="line">This is the second data line.</div><div class="line">This is the first data line.</div></pre></td></tr></table></figure>
<p>代码及结果解释；</p>
<ol>
<li>sed过滤出含有单词first的行，打到<code>This is the first data line</code>后，将它保存到保持空间；</li>
<li>接着使用n命令，提取这一行的下一行，即<code>This is the second data line</code>，打印这一行的内容；</li>
<li>使用g命令，将保持空间的内容提取出来，进入模式空间，接着用p命令打印这一行，即<code>This is the first data line.</code>。</li>
</ol>
<p>从上面的例子可以看出，保持空间就相当于一个临时的储存空间，可以把匹配到的文本暂时放在这里面，随后再取出来。</p>
<h2 id="排除命令"><a href="#排除命令" class="headerlink" title="排除命令"></a>排除命令</h2><p>感叹号命令（!）用来排除（negate）命令，也就是让原本会起作用的命令不起作用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txtThis is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '/header/p' data2.txt</div><div class="line">This is the header line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '/header/!p' data2.txt</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>普通p命令只打印data2文件中包含单词header的那行。加了感叹号之后，情况就相反了：除了包含单词header那一行外，文件中其他所有的行都被打印出来了。感叹号在有些应用中用起来很方便。在前面内容中的案例里，sed编辑器无法处理数据流中最后一行文本，因为之后再没有其他行了。可以用感叹号来解决这个问题，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data4.txt </div><div class="line">On Tuesday, the Linux System</div><div class="line">Administrator's group meeting will be held.</div><div class="line">All System Administrators should attend.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'N</div><div class="line"><span class="meta">&gt;</span> s/System\nAdministrator/Desktop\nUser/</div><div class="line"><span class="meta">&gt;</span> s/System Administrator/Desktop User/</div><div class="line"><span class="meta">&gt;</span> ' data4.txt</div><div class="line">On Tuesday, the Linux Desktop # 这一行进行了修改</div><div class="line">User's group meeting will be held.</div><div class="line">All System Administrators should attend. # 这一行无法修改</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '$!N;</div><div class="line">s/System\nAdministrator/Desktop\nUser/</div><div class="line">s/System Administrator/Desktop User/</div><div class="line">' data4.txt</div><div class="line">On Tuesday, the Linux Desktop</div><div class="line">User's group meeting will be held.</div><div class="line">All Desktop Users should attend.</div></pre></td></tr></table></figure>
<p>这个例子演示了如何配合使用感叹号与N命令以及与美元符特殊地址。美元符表示数据流中的最后一行文本，所以当sed编辑器到了最后一行时，它没有执行N命令，但它对所有其他行都执行了这个命令。</p>
<p>利用这种方法，可以反转数据流中文本行的顺序。要实现这个效果（先显示最后一行，最后显示第一行），需要像如下顺序那样利用模式空间： </p>
<ol>
<li>在模式空间中放置一行； </li>
<li>将模式空间中的行放到保持空间中； </li>
<li>在模式空间中放入下一行； </li>
<li>将保持空间附加到模式空间后； </li>
<li>将模式空间中的所有内容都放到保持空间中； </li>
<li>重复执行第3~5步，直到所有行都反序放到了保持空间中； </li>
<li>提取并打印行。 </li>
</ol>
<p>这个顺序的示意图如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180513/Bj5caEliC8.png?imageslim" alt="mark"></p>
<p>在使用这种方法时，如果不想在处理时打印行可以使用sed的-n命令行选项。下一步是决定如何将保持空间文本附加到模式空间文本后面。这可以用<code>G</code>命令完成。唯一的问题是你不想将保持空间附加到要处理的第一行文本后面。这可以用感叹号命令解决，即<code>1!G</code>。下一步是将新的模式空间（含有已反转的行）放到保持空间，使用<code>h</code>命令，将模式𡫊的整个数据流都反转了之后，打印结果，当到达数据流中的最后一行时，就已经得到了模式空间的整个数据流，打印结果需要用到<code>$p</code>命令，现在看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '&#123;1!G;h;$p&#125;' data2.txt</div><div class="line">This is the last line.</div><div class="line">This is the second data line.</div><div class="line">This is the first data line.</div><div class="line">This is the header line.</div></pre></td></tr></table></figure>
<p>Linux中也有反转文本的命令，就是<code>tac</code>，它就是<code>cat</code>反过来写。</p>
<h2 id="改变流"><a href="#改变流" class="headerlink" title="改变流"></a>改变流</h2><p>通常，sed编辑器会从脚本的顶部开始，一直执行到脚本的结尾（D命令是个例外，它会强制sed编辑器返回到脚本的顶部，而不读取新的行）。sed编辑器提供了一个方法来改变命令脚本的执行流程，其结果与结构化编程类似。</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>sed编辑器可以基于地址、地址模式或地址区间排除一整块命令。这允许用户只对数据流中的特定 行执行一组命令。，分支（branch）命令<code>b</code>的格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address]b [label]</div></pre></td></tr></table></figure>
<p>address参数决定了哪些行的数据会触发分支命令。label参数定义了要中转到的位置，如下果没有label参数，跳转命令会跳转到脚本的结尾，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;2,3b;s/This is/Is this/;s/line./test?/&#125;' data2.txt</div><div class="line">Is this the header test?</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">Is this the last test?</div></pre></td></tr></table></figure>
<p>分支命令在数据流中的第2行和第3行处跳过了两个替换命令，也就是说，不在第2行与第3行进行替换，保持原样，此时没有加入label，因此就跳转到结尾。如果不不想直接跳到脚本的结尾，可以为分支命令定义一个要跳转到的标签。标签以冒号开始，最多可以是7个字符长度，格式为<code>:label2</code>，如果要指定标签，将它加到b命令后即可。使用标签允许你跳过地址匹配处的命令，但仍然执行脚本中的其他命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt </div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;/first/b jump1;s/This is the/No jump on/</div><div class="line">:jump1</div><div class="line">s/This is the/Jump here on/&#125;' data2.txt</div><div class="line"></div><div class="line">No jump on header line.</div><div class="line">Jump here on first data line.</div><div class="line">No jump on second data line.</div><div class="line">No jump on last line.</div></pre></td></tr></table></figure>
<p>跳转命令指定如果文本行中出现了first，程序应该跳到标签为jump1的脚本行，即<code>s/This is the/Jump here on/</code>进行执行，执行完后，再跳回原来的脚本行，即<code>s/This is the/No jump on</code>。如果这里的分支命令的模式没有匹配，sed编辑器就会继续执行脚本中的命令，包括分支标签后的命令（因此，所有的替换命令都会在不匹配分支模式的行上执行）。如果某行匹配了分支模式，sed编辑器就会跳转到带有分支标签的那行。因此，只有最后一个替换命令会执行。在这个例子中，就演示了跳转到sed脚本后面的标签上。也可以跳转到脚本中靠前面的标签上，这样就达到了循环的效果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "This, is, a, test, to, remove, commas."|sed -n '&#123;</div><div class="line"><span class="meta">&gt;</span> :start</div><div class="line"><span class="meta">&gt;</span> s/,//1p</div><div class="line"><span class="meta">&gt;</span> b start</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">This is, a, test, to, remove, commas.</div><div class="line">This is a, test, to, remove, commas.</div><div class="line">This is a test, to, remove, commas.</div><div class="line">This is a test to, remove, commas.</div><div class="line">This is a test to remove, commas.</div><div class="line">This is a test to remove commas.</div></pre></td></tr></table></figure>
<p>从结果来看，每一代运行，就删除了一个逗号，如果把命令写到一行，是这样的，即<code>sed -n &#39;{:start s/,//1p b start }&#39;</code>，其中<code>:start</code>是一个标签；<code>s/,//1p</code>表示，将第1行中的逗号删除，并显示第1行，s是替换，1p表示显示第1行。这个脚本有个问题：它永远不会结束。这就形成了一个无穷循环，不停地查找逗号，直到使用Ctrl+C组合键发送一个信号，手动停止这个脚本。要防止这个问题，可以为分支命令指定一个地址模式来查找。如果没有模式，跳转就应该结束，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "This, is, a, test, to, remove, commas."|sed -n '&#123;</div><div class="line">:start</div><div class="line">s/,//1p</div><div class="line">/,/b start</div><div class="line">&#125;'</div><div class="line">This is, a, test, to, remove, commas.</div><div class="line">This is a, test, to, remove, commas.</div><div class="line">This is a test, to, remove, commas.</div><div class="line">This is a test to, remove, commas.</div><div class="line">This is a test to remove, commas.</div><div class="line">This is a test to remove commas.</div></pre></td></tr></table></figure>
<p>现在分支命令只会在行中有逗号的情况下跳转。在最后一个逗号被删除后，分支命令不会再执行，脚本也就能正常停止了。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试（test）命令（t）也可以用来改变sed编辑器脚本的执行流程。测试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转。如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令未能匹配指定的模式，测试命令就不会跳转。测试命令使用与分支命令相同的格式，即<code>[address]t [label]</code>。</p>
<p>跟分支命令一样，在没有指定标签的情况下，如果测试成功，sed会跳转到脚本的结尾。测试命令提供了对数据流中的文本执行基本的if-then语句的一个低成本办法。举个例子，如果已经做了一个替换，不需要再做另一个替换，那么测试命令能帮上忙，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt </div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;</div><div class="line">s/first/matched/</div><div class="line">t</div><div class="line">s/This is the/No mathch on/</div><div class="line">&#125;' data2.txt</div><div class="line">No mathch on header line.</div><div class="line">This is the matched data line.</div><div class="line">No mathch on second data line.</div><div class="line">No mathch on last line.</div></pre></td></tr></table></figure>
<p>第一个替换命令会查找模式文本first,如果匹配了行中的模式，它就会替换文本，也就是将first替换为matched，如果第一个替换命令未能匹配模式，第二个替换命令就会被执行。</p>
<p>有了测试命令，就能结束之前用分支命令形成的无限循环，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "This, is, a, test, to, remove, commas."|sed -n '&#123;</div><div class="line"><span class="meta">&gt;</span> :start</div><div class="line"><span class="meta">&gt;</span> s/,//1p</div><div class="line"><span class="meta">&gt;</span> t start</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">This is, a, test, to, remove, commas.</div><div class="line">This is a, test, to, remove, commas.</div><div class="line">This is a test, to, remove, commas.</div><div class="line">This is a test to, remove, commas.</div><div class="line">This is a test to remove, commas.</div><div class="line">This is a test to remove commas.</div></pre></td></tr></table></figure>
<p>当无需替换时，测试命令不会跳转而是继续执行剩下的脚本。 </p>
<h2 id="模式替代"><a href="#模式替代" class="headerlink" title="模式替代"></a>模式替代</h2><p>在使用通配符时，很难知道到底哪些文本会匹配模式。举个例子，如果想在行中匹配的单词两边上放上引号，只是要匹配模式中的一个单词的话，就比较简单，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "The cat sleeps in his hat."|sed 's/cat/"cat"/'</div><div class="line">The "cat" sleeps in his hat.</div></pre></td></tr></table></figure>
<p>如果要匹配多个单词，可能就会出问题了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"|sed 's/.at/".at"/g'</div><div class="line">The ".at" sleeps in his ".at".</div></pre></td></tr></table></figure>
<p>实际上，我想匹配的结果是<code>The &quot;cat&quot; sleeps in his &quot;hat&quot;.</code>这样的，但是使用了通配符后，把原来的字符串也给替换掉了，不符合预期。</p>
<h3 id="amp-符号"><a href="#amp-符号" class="headerlink" title="&amp;符号"></a><code>&amp;</code>符号</h3><p>为了解决上述问题，sed中有一个<code>&amp;</code>符号可以达到这个目的，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "The cat sleeps in his hat."|sed 's/.at/"&amp;"/g'</div><div class="line">The "cat" sleeps in his "hat".</div></pre></td></tr></table></figure>
<p>当模式匹配了单词<code>cat</code>，<code>&quot;cat&quot;</code>就会出现在了替换后的单词里。当它匹配了单词<code>hat</code>，<code>&quot;hat&quot;</code>就出现在了替换后的单词中。</p>
<h3 id="替代单独的单词"><a href="#替代单独的单词" class="headerlink" title="替代单独的单词"></a>替代单独的单词</h3><p><code>&amp;</code>符号会提取匹配替换命令中指定模式的整个字符串。有时你只想提取这个字符串的一部分。当然可以这么做，只是要稍微花点心思而已。sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。sed编辑器会给第一个子模式分配字符<code>\1</code>，给第二个子模式分配字符<code>\2</code>，依此类推。当在替换命令中使用圆括号时，必须用转义字符将它们标示为分组字符而不是普通的圆括号。这跟转义其他特殊字符正好相反，看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "The System Administrator manual" | sed '</div><div class="line">s/\(System\) Administrator/\1 User/'</div><div class="line">The System User manual</div></pre></td></tr></table></figure>
<p>代码及结果解释：这个替换命令用一对圆括号将单词System括起来，将其标示为一个子模式。然后它在替代模式中使用\1来提取第一个匹配的子模式。这没什么特别的，但在处理通配符模式时却特别有用。如果需要用一个单词来替换一个短语，而这个单词刚好是该短语的子字符串，但那个子字符串碰巧使用了通配符，这时使用子模式会方便很多，再看两个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "That furry cat is pretty" |sed 's/furry \(.at\)/\1/'</div><div class="line">That cat is pretty</div><div class="line">biotest@ubuntu:~/advance_sed$ echo "That furry hat is pretty"|sed 's/furry \(.at\)/\1/'</div><div class="line">That hat is pretty</div></pre></td></tr></table></figure>
<p>代码及结果解释：<code>&#39;s/furry \(.at\)/\1/&#39;</code>表示，将原来文本中的<code>furry cat</code>替换为<code>cat</code>，<code>\1</code>是子模式1。</p>
<p>当需要在两个或多个子模式间插入文本时，这个特性尤其有用，在下面的这个案例中，使用子模式在大数字中插入逗号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ echo "1233456" |sed '&#123;</div><div class="line"><span class="meta">&gt;</span> :start</div><div class="line"><span class="meta">&gt;</span> s/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/</div><div class="line"><span class="meta">&gt;</span> t start</div><div class="line"><span class="meta">&gt;</span> &#125;'</div><div class="line">1,233,456</div></pre></td></tr></table></figure>
<p>这段代码将匹配模式分成了2个部分，分别为<code>.*[0-9]</code>和<code>[0-9]{3}</code>。第一个子模式是以数字结尾的任意长度的字符。第二个子模式是若干组三位数字。如果这个模式在文本中找到了，替代文本会在两个子模式之间加一个逗号，每个子模式都会通过其位置来标示。这个脚本使用测试命令来遍历这个数字，直到放置好所有的逗号。</p>
<h2 id="在脚本中使用sed"><a href="#在脚本中使用sed" class="headerlink" title="在脚本中使用sed"></a>在脚本中使用sed</h2><p>在shell脚本中也可以使用sed编辑器。</p>
<h3 id="使用包装脚本"><a href="#使用包装脚本" class="headerlink" title="使用包装脚本"></a>使用包装脚本</h3><p>实现sed编辑器脚本的过程很烦琐，尤其是脚本很长的话。此时可以将sed编辑器命令放到shell包装脚本（wrapper）中，不用每次使用时都重新键入整个脚本。包装脚本充当着sed编辑器脚本和命令行之间的中间人角色。</p>
<p>在shell脚本中，可以将普通的shell变量及参数和sed编辑器脚本一起使用。下面有个将命令行参数变量作为sed脚本输入的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat reverse.sh #!/bin/bash</div><div class="line"><span class="meta">#</span> Shell wrapper for sed editor script.</div><div class="line"><span class="meta">#</span> to reverse text file lines.</div><div class="line"></div><div class="line">sed -n '&#123;1!G;h;$p&#125;' $1</div><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt </div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ bash ./reverse.sh data2.txt</div><div class="line">This is the last line.</div><div class="line">This is the second data line.</div><div class="line">This is the first data line.</div><div class="line">This is the header line.</div></pre></td></tr></table></figure>
<p>此时，就能在任何文件上轻松使用这个sed编辑器脚本，再不用每次都在命令行上重新输入了。 </p>
<h3 id="重定向-sed-的输出"><a href="#重定向-sed-的输出" class="headerlink" title="重定向 sed 的输出"></a>重定向 sed 的输出</h3><p>默认情况下，sed编辑器会将脚本的结果输出到STDOUT上。在shell脚本中，可以使用各种标准方法对sed编辑器的输出进行重定向。可以在脚本中用<code>$()</code>将sed编辑器命令的输出重定向到一个变量中，以备后用，在下面的例子中，就是使用sed脚本来向数值计算结果添加逗号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Add commas to number in factorial answer</div><div class="line"></div><div class="line">factorial=1</div><div class="line">counter=1</div><div class="line">number=$1</div><div class="line"></div><div class="line">while [ $counter -le $number ]</div><div class="line">do</div><div class="line">    factorial=$[ $factorial*$counter ]</div><div class="line">    counter=$[ $counter + 1 ]</div><div class="line">done</div><div class="line"></div><div class="line">result=$(echo $factorial | sed '&#123;</div><div class="line">:start</div><div class="line">s/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/</div><div class="line">t start</div><div class="line">&#125;')</div><div class="line"></div><div class="line">echo "The result is $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ bash ./fact.sh 20</div><div class="line">The result is 2,432,902,008,176,640,000</div></pre></td></tr></table></figure>
<p>在使用普通的阶乘计算脚本后，脚本的结果会被作为sed编辑器脚本的输入，它会给结果加上逗号。然后echo语句使用这个值产生最终结果。</p>
<h2 id="创建sed实用工具"><a href="#创建sed实用工具" class="headerlink" title="创建sed实用工具"></a>创建sed实用工具</h2><h3 id="加倍行间距"><a href="#加倍行间距" class="headerlink" title="加倍行间距"></a>加倍行间距</h3><p>下面是一个向文本文件的行间插入空白行的简单sed脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt </div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed 'G' data2.txt </div><div class="line">This is the header line.</div><div class="line"></div><div class="line">This is the first data line.</div><div class="line"></div><div class="line">This is the second data line.</div><div class="line"></div><div class="line">This is the last line.</div><div class="line">                        #这里有个空行</div></pre></td></tr></table></figure>
<p>G命令会简单地将保持空间内容附加到模式空间内容后。当启动sed编辑器时，保持空间只有一个空行。将它附加到已有行后面，你就在已有行后面创建了一个空白行。你可能已经注意到了，这个脚本在数据流的最后一行后面也加了一个空白行，使得文件的末尾也产生了一个空白行。如果你不想要这个空白行，可以用排除符号（!）和尾行符号（$）来确保脚本不会将空白行加到数据流的最后一行后面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed '$!G' data2.txt </div><div class="line">This is the header line.</div><div class="line"></div><div class="line">This is the first data line.</div><div class="line"></div><div class="line">This is the second data line.</div><div class="line"></div><div class="line">This is the last line.  # 这一行后面已经没有了空行</div></pre></td></tr></table></figure>
<p>代码解释：只要该行不是最后一行， G 命令就会附加保持空间内容。当sed编辑器到了最后一行时，它会跳过 G 命令。</p>
<h3 id="对可能含有空白行的文件加倍行间距"><a href="#对可能含有空白行的文件加倍行间距" class="headerlink" title="对可能含有空白行的文件加倍行间距"></a>对可能含有空白行的文件加倍行间距</h3><p>再进一步探索上面的例子：如果文本文件已经有一些空白行，但你想给所有行加倍行间距要怎么办呢？如果用前面的脚本，有些区域会有两个餞行，因为每个已有的空白行也会被加倍，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data6.txt</div><div class="line">This is line one.</div><div class="line">This is line two.</div><div class="line"></div><div class="line">This is line three.</div><div class="line">This is line four.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '$!G' data6.txt</div><div class="line">This is line one.</div><div class="line"></div><div class="line">This is line two.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">This is line three.</div><div class="line"></div><div class="line">This is line four.</div></pre></td></tr></table></figure>
<p>原来空白行的位置有了三个空白行。这个问题的解决办法是，首先删除数据流中的所有空白行，然后用G命令在所有行后插入新的空白行。要删除已有的空白行，需要将d命令和一个匹配空白行的模式一起使用，即使用<code>/^$/d</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="给文件中的行编号"><a href="#给文件中的行编号" class="headerlink" title="给文件中的行编号"></a>给文件中的行编号</h3><p>等号可以显示数据流中的数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt</div><div class="line">This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '=' data2.txt</div><div class="line">1</div><div class="line">This is the header line.</div><div class="line">2</div><div class="line">This is the first data line.</div><div class="line">3</div><div class="line">This is the second data line.</div><div class="line">4</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>虽然添加了行号，但是不太美观，行号在文本的上方，比较好看的方式就是将等号与文本放在同一行。在获得了等号命令的输出之后，可以通过管道将输出传给另一个sed编辑器脚本，它会使用N命令来合并这两行。还需要用替换命令将换行符更换成空格或制表符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data2.txt This is the header line.</div><div class="line">This is the first data line.</div><div class="line">This is the second data line.</div><div class="line">This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '=' data2.txt | sed 'N; s/\n/ /'</div><div class="line">1 This is the header line.</div><div class="line">2 This is the first data line.</div><div class="line">3 This is the second data line.</div><div class="line">4 This is the last line.</div></pre></td></tr></table></figure>
<p> 在bash中，<code>nl</code>命令也可以添加行号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ nl data2.txt </div><div class="line">     1	This is the header line.</div><div class="line">     2	This is the first data line.</div><div class="line">     3	This is the second data line.</div><div class="line">     4	This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$ cat -n data2.txt</div><div class="line">     1	This is the header line.</div><div class="line">     2	This is the first data line.</div><div class="line">     3	This is the second data line.</div><div class="line">     4	This is the last line.</div><div class="line">biotest@ubuntu:~/advance_sed$</div></pre></td></tr></table></figure>
<p>通过<code>nl</code>添加行号时会在前面添加一个间隔。</p>
<h3 id="打印末尾行"><a href="#打印末尾行" class="headerlink" title="打印末尾行"></a>打印末尾行</h3><p>美元符代表数据流中最后一行，所以只显示最后一行很容易，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed -n '$p' data2.txt</div><div class="line">This is the last line.</div></pre></td></tr></table></figure>
<p>如果要用美元符来显示数据流末尾的若干行，就需要创建滚动窗口。滚动窗口是检验模式空间中文本行块的常用方法，它使用N命令将这些块合并起来。N命令将下一行文本附加到模式空间中已有文本行后面。一旦你在模式空间有了一个10行的文本块，你可以用美元符来检查你是否已经处于数据流的尾部。如果不在，就继续向模式空间增加行，同时删除原来的行（记住，D命令会删除模式空间的第一行），如下所示：</p>
<p>通过循环N命令和D命令，在向模式空间的文本行块增加新行的同时也删除了旧行。分支命令非常适合这个循环。要结束循环，只要识别出最后一行并用q命令退出就可以了如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data7.txt</div><div class="line">This is line 1.</div><div class="line">This is line 2.</div><div class="line">This is line 3.</div><div class="line">This is line 4.</div><div class="line">This is line 5.</div><div class="line">This is line 6.</div><div class="line">This is line 7.</div><div class="line">This is line 8.</div><div class="line">This is line 9.</div><div class="line">This is line 10.</div><div class="line">This is line 11.</div><div class="line">This is line 12.</div><div class="line">This is line 13.</div><div class="line">This is line 14.</div><div class="line">This is line 15.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;</div><div class="line"><span class="meta">&gt;</span> :start</div><div class="line"><span class="meta">&gt;</span> $q;N;11,$D</div><div class="line"><span class="meta">&gt;</span> b start</div><div class="line"><span class="meta">&gt;</span> &#125;' data7.txt</div><div class="line">This is line 6.</div><div class="line">This is line 7.</div><div class="line">This is line 8.</div><div class="line">This is line 9.</div><div class="line">This is line 10.</div><div class="line">This is line 11.</div><div class="line">This is line 12.</div><div class="line">This is line 13.</div><div class="line">This is line 14.</div><div class="line">This is line 15.</div></pre></td></tr></table></figure>
<p>这个脚本会首先检查这行是不是数据流中最后一行。如果是，退出（quit）命令会停止循环。N命令会将下一行附加到模式空间中当前行之后。如果当前行在第10行后面，11,$D命令会删除模式空间中的第一行。这就会在模式空间中创建出滑动窗口效果。因此，这个sed程序脚本只会显示出data7.txt文件最后10行。</p>
<h3 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h3><h4 id="删除连续的空白行"><a href="#删除连续的空白行" class="headerlink" title="删除连续的空白行"></a>删除连续的空白行</h4><p>删除连续空白行的最简单办法是用地址区间来检查数据流。通过在地址中使用区间，sed编辑器会对所有匹配指定地址区间的行执行该命令。删除连续空白行的关键在于创建包含一个非空白行和一个空白行的地址区间。如果sed编辑器遇到了这个区间，它不会删除行。但对于不匹配这个区间的行（两个或更多的空白行），它会删除这些行，使用的主要代码是<code>/./,/^$/!d</code>，这段代码的的模式是<code>/./</code>到<code>/^$/</code>，这个区间的开始地址会匹配任何含有至少一个字符的行，区间的结束地址会匹配一个窄，在这个区间内的行不会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>结果显示，无论文件的数据行之间出现了多少空白行，在输出中只会在行间保留一个空白行。 </p>
<h4 id="删除开头的空白行"><a href="#删除开头的空白行" class="headerlink" title="删除开头的空白行"></a>删除开头的空白行</h4><p>主要的脚本是<code>/./,$!d</code>，这个脚本用地址区间来决定哪些行需要删掉，这个区间从含有字符的行开始，一直到数据流结束，在这个区间内的任何行都不会从输出中删除，这表明，含有字符的第一行之前的任何行都会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data9.txt </div><div class="line"></div><div class="line"></div><div class="line">This is line one.</div><div class="line"></div><div class="line">This is line two.</div><div class="line">biotest@ubuntu:~/advance_sed$ sed '/./,$!d' data9.txt </div><div class="line">This is line one.</div><div class="line"></div><div class="line">This is line two.</div></pre></td></tr></table></figure>
<p>测试文件在数据行之前有两个空白行。这个脚本成功地删除了开头的两个空白行，保留了数据中的空白行。 </p>
<h4 id="删除结尾的空白行"><a href="#删除结尾的空白行" class="headerlink" title="删除结尾的空白行"></a>删除结尾的空白行</h4><p>删除结尾的空白行主要是通过循环来实验，脚本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed '&#123;</div><div class="line">:start</div><div class="line">/^\n*$/&#123;$d;N; b start &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure>
<p>在正常脚本的花括号里还有花括号。这允许你在整个命令脚本中将一些命令分组。该命令组会被应用在指定的地址模式上。地址模式能够匹配只含有一个换行符的行。如果找到了这样的行，而且还是最后一行，删除命令会删掉它。如果不是最后一行，N命令会将下一行附加到它后面，分支命令会跳到循环起始位置重新开始，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data10.txt </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$ sed '&#123;</div><div class="line">:start</div><div class="line">/^\n*$/&#123;$d; N; b start &#125;</div><div class="line">&#125;' data10.txt</div><div class="line">This is the first line.</div><div class="line">This is the second line.</div></pre></td></tr></table></figure>
<h3 id="删除-HTML-标签"><a href="#删除-HTML-标签" class="headerlink" title="删除 HTML 标签"></a>删除 HTML 标签</h3><p>标准的HTML Web页面包含一些不同类型的HTML标签，标明了正确显示页面信息所需要的格式化功能，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ cat data11.txt</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;This is the page title&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;</div><div class="line">This is the &lt;b&gt;first&lt;/b&gt; line in the Web page.</div><div class="line">This should provide some &lt;i&gt;useful&lt;/i&gt;</div><div class="line">information to use in our sed script.</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>HTML标签由小于号和大于号来识别。大多数HTML标签都是成对出现的：一个起始标签（比如<code>&lt;b&gt;</code>用来加粗），以及另一个结束标签（比如<code>&lt;/b&gt;</code>用来结束加粗）。但如果不够小心的话，删除HTML标签可能会带来问题，因为按照常规思路，用户可能认为删除HTML标签的办法就是查找以小于号（<code>&lt;</code>）开头、大于号（<code>&gt;</code>）结尾且其中有数据的文本字符串，即<code>s/&lt;.*.//g</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 's/&lt;.*&gt;//g' data11.txt</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">This is the  line in the Web page.</div><div class="line">This should provide some </div><div class="line">information to use in our sed script.</div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$</div></pre></td></tr></table></figure>
<p>从结果来看，标题文本以及加粗和倾斜的文本都不见了。sed编辑器将这个脚本理解为小于号和大于号之间的任何文本，且包括其他的小于号和大于号。每次文本出现在HTML标签中（比如<code>&lt;b&gt;first&lt;/b&gt;</code>），这个sed脚本都会删掉整个文本。这个问题的解决办法是让sed编辑器忽略掉任何嵌入到原始标签中的大于号。要这么做的话，你可以创建一个字符组来排除大于号。脚本改为如下所示代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 's/&lt;[^&gt;]*&gt;//g' data11.txt</div><div class="line"></div><div class="line"></div><div class="line">This is the page title</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">This is the first line in the Web page.</div><div class="line">This should provide some useful</div><div class="line">information to use in our sed script.</div><div class="line"></div><div class="line"></div><div class="line">biotest@ubuntu:~/advance_sed$</div></pre></td></tr></table></figure>
<p>现在就能正常删除了，此外，还可以添加一条删除多余空白行的命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/advance_sed$ sed 's/&lt;[^&gt;]*&gt;//g; /^$/d'  data11.txt</div><div class="line">This is the page title</div><div class="line">This is the first line in the Web page.</div><div class="line">This should provide some useful</div><div class="line">information to use in our sed script.</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/09/Linux/Linux-shell09-正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/Linux/Linux-shell09-正则表达式/" itemprop="url">Shell学习笔记（9）——正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T12:12:54+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,862
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  37
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="正则表达式定义"><a href="#正则表达式定义" class="headerlink" title="正则表达式定义"></a>正则表达式定义</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>正则表达式是你所定义的模式模板（pattern template），Linux工具可以用它来过滤文本。Linux工具（比如sed编辑器或gawk程序）能够在处理数据时使用正则表达式对数据进行模式匹配。如果数据匹配模式，它就会被接受并进一步处理；如果数据不匹配模式，它就会被滤掉。下图描述了这个过程。</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180509/gJmc5KFHBB.png?imageslim" alt="mark"></p>
<p>正则表达式模式利用通配符来描述数据流中的一个或多个字符。Linux中有很多场景都可以使用通配符来描述不确定的数据。星号通配符允许你只列出满足特定条件的文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ ls data*</div><div class="line">data10.cpp  data1b.txt  data3.txt</div><div class="line">data11.txt  data1.txt   data4.txt</div><div class="line">data12.txt  data2.txt   data9.txt</div></pre></td></tr></table></figure>
<p><code>data*</code> 参数会让 ls 命令只列出名字以da开头的文件。文件名中da之后可以有任意多个字符（包括什么也没有）。</p>
<p>正则表达式通配符模式的工作原理与之类似。正则表达式模式含有文本或特殊字符，为sed编辑器和gawk程序定义了一个匹配数据时采用的模板。可以在正则表达式中使用不同的特殊字符来定义特定的数据过滤模式。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>使用正则表达式最大的问题在于有不止一种类型的正则表达式。Linux中的不同应用程序可能会用不同类型的正则表达式。这其中包括编程语言（Java、Perl和Python）、Linux实用工具（比如sed编辑器、gawk程序和grep工具）以及主流应用（比如MySQL和PostgreSQL数据库服务器）。正则表达式是通过正则表达式引擎（regular expression engine）实现的。正则表达式引擎是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。在Linux中，有两种流行的正则表达式引擎：</p>
<p>第一，POSIX基础正则表达式（basic regular expression，BRE）引擎；</p>
<p>第二，POSIX扩展正则表达式（extended regular expression，ERE）引擎 </p>
<p>大多数Linux工具都至少符合POSIXBRE引擎规范，能够识别该规范定义的所有模式符号。遗憾的是，有些工具（比如sed编辑器）只符合了BRE引擎规范的子集。这是出于速度方面的考虑导致的，因为sed编辑器希望能尽可能快地处理数据流中的文本。POSIXBRE引擎通常出现在依赖正则表达式进行文本过滤的编程语言中。它为常见模式提供了高级模式符号和特殊符号，比如匹配数字、单词以及按字母排序的字符。gawk程序用ERE引擎来处理它的正则表达式模式。</p>
<h2 id="定义BRE模式"><a href="#定义BRE模式" class="headerlink" title="定义BRE模式"></a>定义BRE模式</h2><p>最基本的BRE模式是匹配数据流中的文本字符。</p>
<h3 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h3><p>下面演示一下如何在sed编辑器和gawk程序中用标准文本字符串来过滤数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/test/p'</div><div class="line">This is a test</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/trial/p'</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|gawk '/test/&#123;print $0&#125;'</div><div class="line">This is a test</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|gawk '/trial/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>第一个模式定义了一个单词test。sed编辑器和gawk程序脚本用它们各自的print命令打印出匹配该正则表达式模式的所有行。由于echo语句在文本字符串中包含了单词test，数据流文本能够匹配所定义的正则表达式模式，因此sed编辑器显示了该行。</p>
<p>第二个模式也定义了一个单词，这次是trial。因为echo语句文本字符串没包含该单词，所以正则表达式模式没有匹配，因此sed编辑器和gawk程序都没打印该行。你可能注意到了，正则表达式并不关心模式在数据流中的位置。它也不关心模式出现了多少次。一旦正则表达式匹配了文本字符串中任意位置上的模式，它就会将该字符串传回Linux工具。关键在于将正则表达式模式匹配到数据流文本上。重要的是记住正则表达式对匹配的模式非常挑剔。第一条原则就是：正则表达式模式都区分大小写。这意味着它们只会匹配大小写也相符的模式。</p>
<h4 id="正则表达式区分大小写"><a href="#正则表达式区分大小写" class="headerlink" title="正则表达式区分大小写"></a>正则表达式区分大小写</h4><p>看个例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/this/p'</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/This/p'</div><div class="line">This is a test</div></pre></td></tr></table></figure>
<p>第一次尝试没能匹配成功，因为 this 在字符串中并不都是小写，而第二次尝试在模式中使用大写字母，所以能正常工作。<br>在正则表达式中，你不用写出整个单词。只要定义的文本出现在数据流中，正则表达式就能够匹配，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "The books are expensive"|sed -n '/book/p'</div><div class="line">The books are expensive</div></pre></td></tr></table></figure>
<p>尽管数据流中的文本是books，但数据中含有正则表达式book，因此正则表达式模式跟数据匹配。当然，反之正则表达式就不成立了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "The book is expensive"|sed -n '/books/p'</div><div class="line"><span class="meta">#</span> 完整的正则表达式文本并未在数据流中出现，因此匹配失败，sed编辑器不会显示任何文本。</div></pre></td></tr></table></figure>
<p>可以在正则表达式中使用空格和数字，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is line number 1"|sed -n '/ber 1/p'</div><div class="line">This is line number 1</div><div class="line"><span class="meta">#</span> 空格也能匹配</div></pre></td></tr></table></figure>
<p>在正则表达式中，空格和其他的字符并没有什么区别，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is line number1"|sed -n '/ber 1/p'</div><div class="line">biotest@ubuntu:~/regx$ </div><div class="line"><span class="meta">#</span> number1之间没有空格，/ber 1/p就无法匹配，因此也不显示</div></pre></td></tr></table></figure>
<p>如果你在正则表达式中定义了空格，那么它必须出现在数据流中。甚至可以创建匹配多个连续空格的正则表达式模式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data1.txt </div><div class="line">This is a normal line of text.</div><div class="line">This is  a line with too many spaces.</div><div class="line">biotest@ubuntu:~/regx$ sed -n '/  /p' data1.txt </div><div class="line">This is  a line with too many spaces.</div><div class="line"><span class="meta">#</span> This  is这之间有两个空格</div></pre></td></tr></table></figure>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>正则表达式识别的特殊字符包括： <code>.*[]^${}\+?|()</code>，在文本模式中不要单独使用这些字符，如果要用某个特殊字符作为文本字符，就必须转义，在转义特殊字符时，你需要在它前面加一个反斜线（\），如下所示： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data2.txt </div><div class="line">The cost is $4.00</div><div class="line">biotest@ubuntu:~/regx$ sed -n '/\$/p' data2.txt </div><div class="line">The cost is $4.00</div><div class="line"><span class="meta">#</span> 这里添加了反斜线对美元符号进行转义</div></pre></td></tr></table></figure>
<p>如果要匹配反斜线，需要用反斜线本身对基进行转义，也就是两个反斜线，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "\ is a special character" |sed -n '/\\/p'</div><div class="line">\ is a special character</div><div class="line"><span class="meta">#</span> 在这个案例中，匹配的是\，因此需要需要一个/来进行匹配，就成了//</div></pre></td></tr></table></figure>
<p>需要注意的是，虽然<code>/</code>不是正则表达式的特殊字符，但是也也需要<code>\</code>进行匹配，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "3/2"|sed -n '/\//p'</div><div class="line">3/2</div><div class="line"><span class="meta">#</span> 匹配模式就是/文本/命令；这里的文本就是/，添加上转义字符就是\/，整体来看就是/\//p。</div></pre></td></tr></table></figure>
<h3 id="锚字符"><a href="#锚字符" class="headerlink" title="锚字符"></a>锚字符</h3><p>当指定一个正则表达式模式时，只要模式出现在数据流中的任何地方，它就能匹配。有两个特殊字符可以用来将模式锁定在数据流中的行首或行尾。</p>
<h4 id="锁定在行首"><a href="#锁定在行首" class="headerlink" title="锁定在行首"></a>锁定在行首</h4><p>脱字符（<code>^</code>）定义从数据流中文本行的行首开始的模式。如果模式出现在行首之外的位置，正则表达式模式则无法匹配，如果要使用脱字符，就必须将它放到正则表达式中指定的模式前面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "The book store"|sed -n '/^book/p'</div><div class="line"><span class="meta">#</span> book不是首个单词，加了帽子的book无法匹配</div><div class="line">biotest@ubuntu:~/regx$ echo "Books are great"|sed -n '/^Book/p'</div><div class="line">Books are great</div><div class="line"><span class="meta">#</span> Books是首个单词，加了帽子的Books能够匹配</div></pre></td></tr></table></figure>
<p>脱字符会在每个由换行符决定的新数据行的行首检查模式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data3.txt </div><div class="line">This is a test line.</div><div class="line">this is another test line.</div><div class="line">A line that tests this feature.</div><div class="line">Yet more testing of this</div><div class="line">biotest@ubuntu:~/regx$ sed -n '/^this/p' data3.txt</div><div class="line">this is another test line.</div><div class="line"><span class="meta">#</span> 只要模式出现在新行的行首，脱字符就能够发现它。</div></pre></td></tr></table></figure>
<p>如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This ^ is a test"|sed -n '/This ^/p'</div><div class="line">This ^ is a test</div><div class="line"><span class="meta">#</span> 这里匹配的是This ^，这里不用转义</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ echo "This ^is a test"|sed -n '/\^is/p'</div><div class="line">This ^is a test</div><div class="line"><span class="meta">#</span> 这里匹配的是^is，由于^后面有字符，因此需要转义，如果不转义，匹配时会认为是只匹配首个单词</div></pre></td></tr></table></figure>
<p>需要注意的是，如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。但如果你在模式中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符。 </p>
<h4 id="锁定在行尾"><a href="#锁定在行尾" class="headerlink" title="锁定在行尾"></a>锁定在行尾</h4><p>特殊字符美元符（<code>$</code>）定义了行尾锚点。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "This is a good book"|sed -n '/book$/p'</div><div class="line">This is a good book</div><div class="line">biotest@ubuntu:~/regx$ echo "This book is good"|sed -n '/book$/p'</div><div class="line">biotest@ubuntu:~/regx$ echo "There are a lot of good books"|sed -n '/book$/p'</div><div class="line"><span class="meta">#</span> 无法完成匹配，因为原文本是books，而美元符号前面是book,可以理解为，原文本最后两个是ks，而美元符号是ok，肯定不能匹配了</div></pre></td></tr></table></figure>
<h4 id="组合锚点"><a href="#组合锚点" class="headerlink" title="组合锚点"></a>组合锚点</h4><p>在一些常见情况下，可以在同一行中将行首锚点和行尾锚点组合在一起使用。在第一种情况中，假定你要查找只含有特定文本模式的数据行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data4.txt </div><div class="line">this is a test of using both anchors</div><div class="line">I said this is a test</div><div class="line">this is a test</div><div class="line">I'm sure this is a test.</div><div class="line">biotest@ubuntu:~/regx$ sed -n '/^this is a test$/p' data4.txt</div><div class="line">this is a test</div><div class="line"><span class="meta">#</span> sed编辑器忽略了那些不单单包含指定的文本的行，例如I said this is a test</div></pre></td></tr></table></figure>
<p>将两个锚点直接组合在一起，之间不加任何文本，这样过滤出数据流中的空白行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data5.txt </div><div class="line">No.1 This is one test line.</div><div class="line"></div><div class="line"></div><div class="line">No.2 This is another test line.</div><div class="line"></div><div class="line">No.3 This third test line.</div><div class="line">biotest@ubuntu:~/regx$ sed '/^$/d' data5.txt</div><div class="line">No.1 This is one test line.</div><div class="line">No.2 This is another test line.</div><div class="line">No.3 This third test line.</div><div class="line"><span class="meta">#</span> 定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行</div></pre></td></tr></table></figure>
<p>定义的正则表达式模式会查找行首和行尾之间什么都没有的那些行。由于空白行在两个换行符之间没有文本，刚好匹配了正则表达式模式。sed编辑器用删除命令d来删除匹配该正则表达式模式的行，因此删除了文本中的所有空白行。这是从文档中删除空白行的有效方法。</p>
<h3 id="点号字符"><a href="#点号字符" class="headerlink" title="点号字符"></a>点号字符</h3><p>特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。来看一些在正则表达式模式中使用点号字符的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data6.txt </div><div class="line">This is a test of a line.</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line">at ten o'clock we'll go home.:wq</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/.at/p' data6.txt </div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line"><span class="meta">#</span> 在第四行中，at前面有一个空格，这也是一个字符，因此能够匹配。</div></pre></td></tr></table></figure>
<h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>如果要限定待匹配的具体字符的话，在正则表达式中，这称为字符组（characterclass）。可以定义用来匹配文本模式中某个位置的一组字符。如果字符组中的某个字符出现在了数据流中，那它就匹配了该模式。使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符。然后你可以在模式中使用整个组，就跟使用其他通配符一样，看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sed -n '/[ch]at/p' data6.txt</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div></pre></td></tr></table></figure>
<p>匹配这个模式的单词只有 cat 和 hat 。还要注意以 at 开头的行也没有匹配。字符组中必须有个字符来匹配相应的位置。</p>
<h4 id="不区分大小写"><a href="#不区分大小写" class="headerlink" title="不区分大小写"></a>不区分大小写</h4><p>有时候这种方法在不清楚大小写的时候很有用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "Yes" | sed -n '/[Yy]es/p'</div><div class="line">Yes</div><div class="line">biotest@ubuntu:~/regx$ echo "yes"|sed -n '/[Yy]es/p'</div><div class="line">yes</div><div class="line">biotest@ubuntu:~/regx$ echo "Yes"|sed -n '/[Yy][Ee][Ss]/p'</div><div class="line">Yes</div><div class="line">biotest@ubuntu:~/regx$ echo "yEs"|sed -n '/[Yy][Ee][Ss]/p'</div><div class="line">yEs</div><div class="line">biotest@ubuntu:~/regx$ echo "yeS"|sed -n '/[Yy][Ee][Ss]/p'</div><div class="line">yeS</div></pre></td></tr></table></figure>
<h4 id="使用数字"><a href="#使用数字" class="headerlink" title="使用数字"></a>使用数字</h4><p>字符组不必只含有字母，也可以在其中使用数字，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data6.txt</div><div class="line">This is a test of a line.</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line">at ten o'clock we'll go home.:wq</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/[0123]/p' data7.txt </div><div class="line">THis line has 1 number on it.</div><div class="line">THis line a number 2 on it.</div><div class="line"><span class="meta">#</span> 这个正则表达式模式匹配了任意含有数字0、1、2或3的行。含有其他数字以及不含有数字的行都会被忽略掉。</div></pre></td></tr></table></figure>
<h4 id="匹配某一位数的数字"><a href="#匹配某一位数的数字" class="headerlink" title="匹配某一位数的数字"></a>匹配某一位数的数字</h4><p>有时候需要将字级组组合在一起，以检查数字是否具备正确的格式，比如电话号码和邮编。但当你尝试匹配某种特定格式时，必须小心。这里有个匹配邮编出错的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data8.txt </div><div class="line">46201</div><div class="line">60633</div><div class="line">223001</div><div class="line">4353</div><div class="line">22203</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '</div><div class="line"><span class="meta">&gt;</span> /[0123456789][0123456789][0123456789][0123456789][0123456789]/p</div><div class="line"><span class="meta">&gt;</span> ' data8.txt</div><div class="line">46201</div><div class="line">60633</div><div class="line">223001</div><div class="line">22203</div></pre></td></tr></table></figure>
<p>从结果可以看出，它滤过了4353，因为正则表达式中定义了5个字符组，4位的4353只有4个数字，最后一个数字无法匹配，就滤过了。但是223001这个6位数也通过了。因此正则表达式模式可见于数据流中文本的任何位置，因此我们设定过滤5个数字时，4个数字肯定能滤过去，但是大于5个数字的也能通过，因此如果要确保只匹配五位数，就必须将匹配的字符和其他字符分开，要么用空格，要么像这个例子中这样，指明它们就在行首和行尾，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sed -n '</div><div class="line">/^[0123456789][0123456789][0123456789][0123456789][0123456789]$/p</div><div class="line">' data8.txt</div><div class="line">46201</div><div class="line">60633</div><div class="line">22203</div></pre></td></tr></table></figure>
<h4 id="检查拼写"><a href="#检查拼写" class="headerlink" title="检查拼写"></a>检查拼写</h4><p>字符组的一个极其常见的用法是解析拼错的单词，比如用户表单输入的数据。你可以创建正则表达式来接受数据中常见的拼写错误，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data9.txt </div><div class="line">I need to have some maintenence done on my car.</div><div class="line">I'll pay that in a seperate invoice.</div><div class="line">After I pay for the maintenance my car will be as good as new.</div><div class="line">biotest@ubuntu:~/regx$ sed -n '</div><div class="line">/maint[ea]n[ae]nce/p</div><div class="line">/sep[ea]r[ea]te/p</div><div class="line">' data9.txt</div><div class="line">I need to have some maintenence done on my car.</div><div class="line">I'll pay that in a seperate invoice.</div><div class="line">After I pay for the maintenance my car will be as good as new.</div></pre></td></tr></table></figure>
<p>本例中的两个sed打印命令利用正则表达式字符组来帮助找到文本中拼错的单词maintenance和separate。同样的正则表达式模式也能匹配正确拼写的maintenance。</p>
<h3 id="排除型字符组"><a href="#排除型字符组" class="headerlink" title="排除型字符组"></a>排除型字符组</h3><p>在正则表达式模式中，也可以反转字符组的作用。可以寻找组中没有的字符，而不是去寻找组中含有的字符。要这么做的话，只要在字符组的开头加个脱字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data6.txt </div><div class="line">This is a test of a line.</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line">at ten o'clock we'll go home.:wq</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/[^ch]at/p' data6.txt</div><div class="line">This test is at line four.</div></pre></td></tr></table></figure>
<p>通过排除型字符组，正则表达式模式会匹配c或h之外的任何字符以及文本模式。由于空格字符属于这个范围，它通过了模式匹配。但即使是排除，字符组仍然必须匹配一个字符，所以以at开头的行仍然未能匹配模式。</p>
<h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p>如果必须要在每个字符组中列出所有可能的数字，有点麻烦，单破折线符号在字符组中表示字符区间。只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了，正则表达式会包括此区间内的任意字符，可以通过指定数字区间来简化邮编的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data8.txt</div><div class="line">46201</div><div class="line">60633</div><div class="line">223001</div><div class="line">4353</div><div class="line">22203</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8.txt</div><div class="line">46201</div><div class="line">60633</div><div class="line">22203</div></pre></td></tr></table></figure>
<p>这样可是节省了不少的键盘输入，每个字符组都会匹配0~9的任意数字。</p>
<p>这种方法也适用于字母，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ cat data6.txt</div><div class="line">This is a test of a line.</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">This test is at line four.</div><div class="line">at ten o'clock we'll go home.:wq</div><div class="line"></div><div class="line">biotest@ubuntu:~/regx$ sed -n '/[c-h]at/p' data6.txt</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div></pre></td></tr></table></figure>
<p>新的模式[c-h]at匹配了首字母在字母c和字母h之间的单词。这种情况下，只含有单词at的行将无法匹配该模式。还可以在单个字符组指定多个不连续的区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sed -n '/[a-ch-m]at/p' data6.txtThe cat is sleeping.</div><div class="line">That is a very nice hat.</div></pre></td></tr></table></figure>
<p>该字符组允许区间a~c、h~m中的字母出现在at文本前，但不允许出现d~g的字母。</p>
<h3 id="特殊的字符组"><a href="#特殊的字符组" class="headerlink" title="特殊的字符组"></a>特殊的字符组</h3><p>除了定义自己的字符组外，BRE还包含了一些特殊的字符组，可用来匹配特定类型的字符。下表是可用的BRE特殊的字符组。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[[:alpha:]]</td>
<td>匹配任意字母字符，不管是大写还是小写</td>
</tr>
<tr>
<td>[[:alnum:]]</td>
<td>匹配任意字母数字字符0~9、A</td>
</tr>
<tr>
<td>[[:blank:]]</td>
<td>匹配空格或制表符</td>
</tr>
<tr>
<td>[[:digit:]]</td>
<td>匹配0~9之间的数字</td>
</tr>
<tr>
<td>[[:lower:]]</td>
<td>匹配小写字母字符a~z</td>
</tr>
<tr>
<td>[[:print:]]</td>
<td>匹配任意可打印字符</td>
</tr>
<tr>
<td>[[:punct:]]</td>
<td>匹配标点符号</td>
</tr>
<tr>
<td>[[:space:]]</td>
<td>匹配任意空白字符：空格、制表符、NL、FF、VT和CR</td>
</tr>
<tr>
<td>[[:upper:]]</td>
<td>匹配任意大写字母字符A~Z</td>
</tr>
</tbody>
</table>
</div>
<p>可以在正则表达式模式中将特殊字符组像普通字符组一样使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "abc"|sed -n '/[[:digit:]]/p'</div><div class="line">biotest@ubuntu:~/regx$ echo "abc"|sed -n '/[[:alpha:]]/p'</div><div class="line">abc</div><div class="line">biotest@ubuntu:~/regx$ echo "abc123"| sed -n '/[[:digit:]]/p'</div><div class="line">abc123</div><div class="line">biotest@ubuntu:~/regx$ echo "This is , a test"|sed -n '/[[:punct:]]/p'</div><div class="line">This is , a test</div><div class="line">biotest@ubuntu:~/regx$ echo "This is a test"|sed -n '/[[:punct:]]/p'</div></pre></td></tr></table></figure>
<p>使用特殊字符组可以很方便地定义区间。可以用<code>[[:digit:]]</code>来代替区间<code>[0-9]</code>。 </p>
<h3 id="星号"><a href="#星号" class="headerlink" title="星号"></a>星号</h3><p>在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "ik"|sed -n '/ie*k/p'</div><div class="line">ik</div><div class="line">biotest@ubuntu:~/regx$ echo "iek"|sed -n '/ie*k/p'</div><div class="line">iek</div><div class="line">biotest@ubuntu:~/regx$ echo "ieek"|sed -n '/ie*k/p'</div><div class="line">ieek</div><div class="line">biotest@ubuntu:~/regx$ echo "ieeek"|sed -n '/ie*k/p'</div><div class="line">ieeek</div></pre></td></tr></table></figure>
<p>这个模式符号广泛用于处理有常见拼写错误或在不同语言中有拼写变化的单词。举个例子，如果需要写个可能用在美式或英式英语中的脚本，可以这么写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "I'm getting a color TV"|sed -n '/colou*r/p'</div><div class="line">I'm getting a color TV</div><div class="line">biotest@ubuntu:~/regx$ echo "I'm getting a colour TV"|sed -n '/colou*r/p'</div><div class="line">I'm getting a colour TV</div></pre></td></tr></table></figure>
<p>模式中的 <code>u*</code> 表明字母u可能出现或不出现在匹配模式的文本中。类似地，如果你知道一个单 词经常被拼错，你可以用星号来允许这种错误，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "I ate a potatoe with my lunch."|sed -n '/potatoe*/p'</div><div class="line">I ate a potatoe with my lunch.</div><div class="line">biotest@ubuntu:~/regx$ echo "I ate a potato with my lunch."|sed -n '/potatoe*/p'</div><div class="line">I ate a potato with my lunch.</div></pre></td></tr></table></figure>
<p>在可能出现的额外字母后面放个星号将允许接受拼错的单词。另一个方便的特性是将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "this is a regular pattern expression"|sed -n '</div><div class="line"><span class="meta">&gt;</span> /regular.*expression/p'</div><div class="line">this is a regular pattern expression</div></pre></td></tr></table></figure>
<p>可以使用这个模式轻松查找可能出现在数据流中文本行内任意位置的多个单词。星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|sed -n '/b[ae]*t/p'</div><div class="line">bt</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|sed -n '/b[ae]*t/p'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|sed -n '/b[ae]*t/p'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "btt"|sed -n '/b[ae]*t/p'</div><div class="line">btt</div><div class="line">biotest@ubuntu:~/regx$ echo "baat"|sed -n '/b[ae]*t/p'</div><div class="line">baat</div><div class="line">biotest@ubuntu:~/regx$ echo "baaeeet"|sed -n '/b[ae]*t/p'</div><div class="line">baaeeet</div></pre></td></tr></table></figure>
<p>只要a和e字符以任何组合形式出现在b和t字符之间（就算完全不出现也行），模式就能够匹配。如果出现了字符组之外的字符，该模式匹配就会不成立。</p>
<h2 id="正则表达式扩展"><a href="#正则表达式扩展" class="headerlink" title="正则表达式扩展"></a>正则表达式扩展</h2><p>POSIX  ERE模式包括了一些可供Linux应用和工具使用的额外符号。gawk程序能够识别ERE模式，但sed编辑器不能。 记住，sed编辑器和gawk程序的正则表达式引擎之间是有区别的。gawk程序可以使用大多数扩展正则表达式模式符号，并且能提供一些额外过滤功能，而这些功能都是sed编辑器所不具备的。但正因为如此，gawk程序在处理数据流时通常才比较慢。</p>
<h3 id="问号"><a href="#问号" class="headerlink" title="问号"></a>问号</h3><p>问号类似于星号，不过有点细微的不同。问号表明前面的字符可以出现0次或1次，但只限于此。它不会匹配多次出现的字符。问号类似于星号，不过有点细微的不同。问号表明前面的字符可以出现0次或1次，但只限于此。它不会匹配多次出现的字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk '/be?t/&#123;print $p&#125;'</div><div class="line">bt</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk '/be?t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk '/be?t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "beeet"|gawk '/be?t/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 如果字符 e 并未在文本中出现，或者它只在文本中出现了1次，那么模式会匹配。</div></pre></td></tr></table></figure>
<p>问号与星号一样，也能与字符组一起使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">bt</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bot"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "baet"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "beat"|gawk '/b[ae]?t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk '/b[ae]?t/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>如果字符组中的字符出现了0次或1次，模式匹配就成立。但如果两个字符都出现了，或者其中一个字符出现了2次，模式匹配就不成立。 </p>
<h3 id="加号"><a href="#加号" class="headerlink" title="加号"></a>加号</h3><p>加号表明前面的字符可以出现1次或多次，但必须至少出现1次。如果该字符没有出现，那么模式就不会匹配，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk '/be+t/&#123;print $0&#125;'</div><div class="line">beet</div><div class="line">biotest@ubuntu:~/regx$ echo "beeet"|gawk '/be+t/&#123;print $0&#125;'</div><div class="line">beeet</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk '/be+t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk '/be+t/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>如果字符e没有出现，模式匹配就不成立。加号同样适用于字符组，与星号和问号的使用方式相同，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beat"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">beat</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">beet</div><div class="line">biotest@ubuntu:~/regx$ echo "beeat"|gawk '/b[ae]+t/&#123;print $0&#125;'</div><div class="line">beeat</div></pre></td></tr></table></figure>
<p>这次如果字符组中定义的任一字符出现了，文本就会匹配指定的模式。 </p>
<h3 id="花括号"><a href="#花括号" class="headerlink" title="花括号"></a>花括号</h3><p>ERE中的花括号允许你为可重复的正则表达式指定一个上限。这通常称为间隔（interval）。可以用两种格式来指定区间，其中<code>m</code>是正则表达式出现m次；<code>m,n</code>表现表达式至少出现m次，最多出现n次。这个特性可以精确调整字符或字符集在模式中具体出现的次数。 ，gawk程序不会识别正则表达式间隔。必须指定gawk程序的<code>--re- interval</code>命令行选项才能识别正则表达式间隔，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk --re-interval '/be&#123;1&#125;t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk --re-interval '/be&#123;1&#125;t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk --re-interval '/be&#123;1&#125;t/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>通过指定间隔为1，限定了该字符在匹配模式的字符串中出现的次数。如果该字符出现多次，模式匹配就不成立。</p>
<p>可以同时指定下限和上限，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk --re-interval '/be&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk --re-interval '/be&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk --re-interval '/be&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">beet</div><div class="line">biotest@ubuntu:~/regx$ echo "beeet"|gawk --re-interval '/be&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 在这个例子中，字符 e 可以出现1次或2次，这样模式就能匹配；否则，模式无法匹配。</div></pre></td></tr></table></figure>
<p>间隔模式匹配同样适用于字符组，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "bt"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bet"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">bet</div><div class="line">biotest@ubuntu:~/regx$ echo "beat"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">beat</div><div class="line">biotest@ubuntu:~/regx$ echo "beet"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">beet</div><div class="line">biotest@ubuntu:~/regx$ echo "baeet"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "baeaet"|gawk --re-interval '/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 如果字母a或e在文本模式中只出现了1~2次，则正则表达式模式匹配；否则，模式匹配失败。</div></pre></td></tr></table></figure>
<h3 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号"></a>管道符号</h3><p>管道符号允许你在检查数据流时，用逻辑OR方式指定正则表达式引擎要用的两个或多个模式。如果任何一个模式匹配了数据流文本，文本就通过测试。如果没有模式匹配，则数据流文本匹配失败。使用管道符号的格式为<code>expr1|expr2</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "The cat is asleep"|gawk '/cat|dog/&#123;print $0&#125;'</div><div class="line">The cat is asleep</div><div class="line">biotest@ubuntu:~/regx$ echo "The dog is asleep"|gawk '/cat|dog/&#123;print $0&#125;'</div><div class="line">The dog is asleep</div><div class="line">biotest@ubuntu:~/regx$ echo "The sheep is asleep"|gawk '/cat|dog/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 这个例子会在数据流中查找正则表达式cat或dog。正则表达式和管道符号之间不能有空格，否则它们也会被认为是正则表达式模式的一部分。</div></pre></td></tr></table></figure>
<p>管道符号两侧的正则表达式可以采用任何正则表达式模式（包括字符组）来定义文本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "He has a hat."|gawk '/[ch]at|dog/&#123;print $0&#125;'</div><div class="line">He has a hat.</div><div class="line"><span class="meta">#</span> 这个例子会匹配数据流文本中的 cat 、 hat 或 dog 。</div></pre></td></tr></table></figure>
<h3 id="表达式分组"><a href="#表达式分组" class="headerlink" title="表达式分组"></a>表达式分组</h3><p>正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一个标准字符。可以像对普通字符一样给该组使用特殊字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "Sat"|gawk '/Sat(urday)?/&#123;print $0&#125;'</div><div class="line">Sat</div><div class="line">biotest@ubuntu:~/regx$ echo "Saturday"|gawk '/Sat(urday)?/&#123;print $0&#125;'</div><div class="line">Saturday</div><div class="line"><span class="meta">#</span> 结尾的urday分组以及问号，使得模式能够匹配完整的 Saturday 或缩写 Sat 。</div></pre></td></tr></table></figure>
<p>将分组和管道符号一起使用来创建可能的模式匹配组是很常见的做法，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo "cat"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">cat</div><div class="line">biotest@ubuntu:~/regx$ echo "cab"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">cab</div><div class="line">biotest@ubuntu:~/regx$ echo "bat"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">bat</div><div class="line">biotest@ubuntu:~/regx$ echo "bab"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">bab</div><div class="line">biotest@ubuntu:~/regx$ echo "tab"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line">biotest@ubuntu:~/regx$ echo "tac"|gawk '/(c|b)a(b|t)/&#123;print $0&#125;'</div><div class="line"><span class="meta">#</span> 模式 (c|b)a(b|t) 会匹配第一组中字母的任意组合以及第二组中字母的任意组合。</div></pre></td></tr></table></figure>
<h2 id="正则表达式实战"><a href="#正则表达式实战" class="headerlink" title="正则表达式实战"></a>正则表达式实战</h2><h3 id="第一案例：目录文件计数"><a href="#第一案例：目录文件计数" class="headerlink" title="第一案例：目录文件计数"></a>第一案例：目录文件计数</h3><p>目标：对<code>PATH</code>环境变量中定义的目录的可执行文件进行计数。</p>
<p>第一步：查看<code>PATH</code>中的目录名，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ echo $PATH</div><div class="line">/home/biotest/miniconda2/bin:/home/miniconda2/bin:/home/bio/miniconda2/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/biotest/home/test:/home/biotest/home/biotest:/home/biotest:/home/biotest/</div></pre></td></tr></table></figure>
<p>从结果可以看出，<code>PATH</code>中的每个路径都是由冒号分隔的，如果要获取目录列表，就需要用空格来替换冒号。</p>
<p>第二步：用空格替换冒号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 用空格替换冒号</div><div class="line">biotest@ubuntu:~/regx$ echo $PATH | sed 's/:/ /g'</div><div class="line">/home/biotest/miniconda2/bin /home/miniconda2/bin /home/bio/miniconda2/bin /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/games /usr/local/games /snap/bin /home/biotest/home/test /home/biotest/home/biotest /home/biotest /home/biotest/</div></pre></td></tr></table></figure>
<p>第三步：用<code>for</code>语句遍历每个目录，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mypath=$(echo $PATH |sed 's/:/ /g')</div><div class="line">for directory in $mypath </div><div class="line">do </div><div class="line">.# 代码先略过</div><div class="line">done</div></pre></td></tr></table></figure>
<p>第四步：一旦获得了单个目录，就可以用 ls 命令来列出每个目录中的文件，并用另一个 for 语句来遍历每个文件，为文件计数器增值。 这个脚本的最终版本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> count number of files in your PATH</div><div class="line">mypath=$(echo $PATH | sed 's/:/ /g')</div><div class="line">count=0</div><div class="line">for directory in $mypath</div><div class="line">do</div><div class="line">    check=$(ls $directory)</div><div class="line">    for item in $check</div><div class="line">    do</div><div class="line">        count=$[ $count+1 ]</div><div class="line">    done</div><div class="line">    echo "$directory - $count"</div><div class="line">    count=0</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sudo bash countfiles.sh </div><div class="line">/usr/local/sbin - 0</div><div class="line">/usr/local/bin - 2</div><div class="line">/usr/sbin - 200</div><div class="line">/usr/bin - 1744</div><div class="line">/sbin - 188</div><div class="line">/bin - 167</div><div class="line">ls: cannot access '/snap/bin': No such file or directory</div><div class="line">/snap/bin - 0</div></pre></td></tr></table></figure>
<h3 id="第二案例：验证电话号码"><a href="#第二案例：验证电话号码" class="headerlink" title="第二案例：验证电话号码"></a>第二案例：验证电话号码</h3><p>在这个案例中，使用的验证的美国的电话号码，美国的电话号码有这几种形式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(123)456-7890 </div><div class="line">(123) 456-7890 </div><div class="line">123-456-7890 </div><div class="line">123.456.7890</div></pre></td></tr></table></figure>
<p>这样用户在表单中输入的电话号码就有4种可能。</p>
<p>第一步：左括号。在构建正则表达式时，最好从左手边开始，然后构建用来匹配可能遇到的字符的模式。在这个例子中，电话号码中可能有也可能没有左圆括号。这可以用<code>^/(?</code>这个模式来匹配，脱字符用来表明数据的开始。由于左圆括号是个特殊字符，因此必须将它转义成普通字符。问号表明左圆括号可能出现，也可能不出现。 </p>
<p>第二步：三个连续数字。紧接着就是3位区号。在美国，区号以数字2开始（没有以数字0或1开始的区号），最大可到9。要匹配区号，可以用<code>[2-9][0-9]{2}</code>进行匹配，这要求第一个字符是2~9的数字，后跟任意两位数字。</p>
<p>第三步：右括号。在区号后面，收尾的右圆括号可能存在，也可能不存在。，使用<code>\)?</code>进行匹配。</p>
<p>第四步：在区号后，存在如下可能：有一个空格，没有空格，有一条单破折线或一个点。你可以对它们使用管道符号，并用圆括号进行分组，匹配模式为<code>(| |-|\.)</code>，这表示第一个管道符号紧跟在左圆括号后，用来匹配没有空格的情形。你必须将点字符转义，否则它会被解释成可匹配任意字符。 </p>
<p>第五步：匹配3位电话交换机号码，模式为<code>[0-9]{3}</code>。</p>
<p>第六步：在电话交换机号码之后，你必须匹配一个空格、一条单破折线或一个点（这次不用考虑匹配没有空格的情况，因为在电话交换机号码和其余号码间必须有至少一个空格）。，模式为<code>( |-|\.)</code>。</p>
<p>第七步：最后，必须在字符串尾部匹配4位本地电话分机号，匹配模式为`[0-9]{4}$。</p>
<p>完整的模式为<code>^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}$</code>。</p>
<p>在gawk程序中用这个正则表达式模式来过滤掉不符合格式的电话号码。现在只需要在gawk程序中创建一个使用该正则表达式的简单脚本，然后用这个脚本来过滤电话薄。记住，在gawk程序中使用正则表达式间隔时，必须使用—re-interval命令行选项，否则就没法得到正确的结果，代码如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> script to filter out bad phone numbers</div><div class="line">gawk --re-interval '/^\(?[2-9][0-9]&#123;2&#125;\)?(| |-|\.)[0-9]&#123;3&#125;( |-|\.)[0-9]&#123;4&#125;/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ chmod u+x isphone.sh </div><div class="line">biotest@ubuntu:~/regx$ sudo echo "317-555-1234" |./isphone.sh</div><div class="line">317-555-1234</div></pre></td></tr></table></figure>
<h3 id="第三案例：-解析邮件地址"><a href="#第三案例：-解析邮件地址" class="headerlink" title="第三案例： 解析邮件地址"></a>第三案例： 解析邮件地址</h3><p>电子邮件的基本格式为<code>username$hostname</code>，除此之外，还有可能含有点号，单破折线，加号，下划线等。而邮件的地址<code>hostname</code>部分是由一个或多个域名和一个服务器名组成。服务器名和域名也必须遵照严格的命名规则，只允许字母<br>数字字符以及点号或下划线组成。</p>
<p>第一步：顶级域名的数量在过去十分有限，正则表达式模式编写者会尝试将它们都加到验证模式中。然而遗憾的是，随着互联网的发展，可用的顶级域名也增多了。这种方法已经不再可行。从左侧开始构建这个正则表达式模式。我们知道，用户名中可以有多个有效字符。这个相当容易，匹配模式为<code>^([a-zA-Z0-9_\-\.\+]+)@</code>，这个匹配模式指定了用户名中允许的字符，加号表明必须有至少一个字符，最后一个字符是<code>@</code>。</p>
<p>第二步：hostname 模式使用同样的方法来匹配服务器名和子域名，即<code>([a-zA-Z0-9_\-\.]+)</code>，这个模式可以匹配文本。</p>
<p>第三步：顶级域名。对于顶级域名，有一些特殊的规则。顶级域名只能是字母字符，必须不少于二个字符（国家或地区代码中使用），并且长度上不得超过五个字符。级级域名用的正则表达式模式为<code>\.([a-zA-Z]{2,5})$</code>。</p>
<p>整个匹配模式就是<code>^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\-\.]+)\.(a-zA-Z]{2,5})$</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> script to filter out bad mail</div><div class="line">gawk '/^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]&#123;2,5&#125;)$/&#123;print $0&#125;'</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/regx$ sudo echo "rich@here.now" | ./ismail.sh</div><div class="line">rich@here.now</div><div class="line">biotest@ubuntu:~/regx$ sudo echo "rich#here.now" | ./ismail.sh</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/08/BioInformation/生信-测序原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/BioInformation/生信-测序原理/" itemprop="url">二代测序原理笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T00:00:01+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物信息学/" itemprop="url" rel="index">
                    <span itemprop="name">生物信息学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,963
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽然我对二代测序的原理知道一些，但也仅限于知道一些而已，并没有一个十分清楚的理解，当时实验室买Illumina的测序仪时，参加过培训，但是时间过去太久了，当时也没有记笔记，现在网上找了一些资料，总结一下。</p>
<p>Illumina的测序芯片叫flowcell，长得如下所示：</p>
<p>flowcell的样子如下所示：<br><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/6lbe0aG5a1.jpg?imageslim" alt="mark"><br><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/GdFGk20bmK.jpg?imageslim" alt="mark"></p>
<p>flowcell的构成为例：</p>
<ol>
<li><p>每个flowcell（中文意思是流动池）有8个泳道，一个泳道称为一个Lane（中文意思是通道），每条Lane上有两列，每列有多个有小格子，叫一个tile（中文意思是瓦片），平时我们如果自己建库，送公司测序的话，样品发如果比较多，通常就会直接买测序公司的一条lane，例如我们测了12个样本，在建库时，每个样本加上自己独有的index，送到测序公司，例如泛生子，直接告诉公司，我买一条测序仪上的一条lane就行了。</p>
</li>
<li><p>每一个flowcell上都有8条泳道，用于测序反应，可以添加试剂，洗脱等等。</p>
</li>
<li>tile是每一次测序荧光扫描的最小单位</li>
</ol>
<h2 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h2><p>建库的流程如下图所示：<br><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/dj9l6l81D3.png?imageslim" alt="mark"><br>第一步：Shear Genomic DNA or begin with cDNA。这一步是将基因组打断为300~500bp的片段，采用的手段通常是超声波。</p>
<p>第二步：End Repair（Blunt ends）。由于打断后，DNA的片段的末端会呈现不平整的情况，因此需要用酶来补平，在这一步中，片段的末端都是平末端。</p>
<p>第三步：Add 3’ A Tail。完成补平以后，在3’端使用酶加上一个特异的碱基A。</p>
<p>第四步：Ligate Adapters。第三步中加A就是为了这一步加上adapter（接头），这个adapter分为两个部分，一部分是测序的时候所需的引物序列，另一部分是建库扩增的时候需要的引物序列，加接头的过程，以及加完接头的结构如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/E1Lmc67hKg.png?imageslim" alt="mark"><br>从上图可以看到，接头的一边含有T，正好与第三步中加了A的片段连接。</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/3EEaA7jhe9.png?imageslim" alt="mark"><br><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/DhL9FliI48.png?imageslim" alt="mark"></p>
<p>第五步：Enrich/Linearize with PCR。这一步通过PCR扩增，使第四步中完成的接头扩增到足够的浓度。index也是在这一步加进去的，完成后的文库结构如下所示（网上找了好几个，不过都大同小异）：<br><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/hI2fcJJ813.png?imageslim" alt="mark"></p>
<p>现在说明一下这个结构（有的文库是双index结构）：</p>
<ol>
<li>两端是P5与P7片段，这两个片段与lane上的片段进行互补，与P5互补的的接头称为P5’，与P7互补的称为P7’；</li>
<li>Rd1 SP和Rd2 SP是测序的引物；</li>
<li>DNA Insert就是我们要测序的片段；</li>
<li>Index是用于区分不同样品的，通常是6个碱基，因为一条lane通常可以测多个样品，因此用Index将不同的样品区分开来。</li>
</ol>
<p>如果是双index结构的话，如下所示：<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/kLE8FH6IlJ.png?imageslim" alt="mark"></p>
<p>这里使用index1和index2是为了区别paired-end测序得到的双端reads。</p>
<h2 id="桥式PCR"><a href="#桥式PCR" class="headerlink" title="桥式PCR"></a>桥式PCR</h2><p>建库以后，将这些文库加到flowcell中，再加入相应的测序试剂，就可以进行测序了，Illumina的测序原理主要是SBS。SBS指的是Sequencing by Synthesis，中文称为边测序连合成。</p>
<p>flowcell上随机分布了两种不同的序列，分别是P5’和P7，其中P5’与P5互补，P7序列与文库上的P7序列是一样的，当文库加入到flowcell时，先通过P5与flowcell上的P5’序列互补杂交，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/baj6lBcfe1.png?imageslim" alt="mark"></p>
<p>此时，开始PCR，从P5’端开始延伸，完成延伸，为了方便理解，我们将这条新生成的链称为A链，A链与flowcell结合的一端是P5’，另外一端是P7’，此时再用NaOH变性，解开双链，冲走文库片段，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/67bBm6HAjC.png?imageslim" alt="mark"><br>因为A链的一端（P5’）在flowcell上，它不会被冲走，再加上flowcell上带有P7序列，A链的一端是能与P7序列互补的P7’序列，因此它能形成一个单链的拱形结构，如下图左图所示。此时再进行PCR，为了方便理解，我们称以A链为模板生成的链为B链，生成的这个B链一端是P7（就是flowcell上的那个序列），另外一端是P5，这就形成了一个双链的拱形结构，这个过程通常叫做桥式PCR，如下图右图所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/hH0FAcCHG0.png?imageslim" alt="mark"></p>
<p>桥式PCR不会只进行一次，而是进行许多次，大量生成A链与B链。现在总结一下A链与B链的结构：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/giG54AcL2c.png?imageslim" alt="mark"></p>
<p>在生成足够多的双链数目时（这个反应次数大概是35次），用NaOH水解掉双链，只剩下单链的A链与B链，如下图右图所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/l7JLlHjFEe.png?imageslim" alt="mark"></p>
<p>此时利用甲酰胺基嘧啶糖苷酶（Fpg）对8-氧鸟嘌呤糖苷（8-oxo-G）的选择性切断作用，选择性地将P5’与链的连接切断，留下与Flowcell上P7连接的链，也就是Forward strand。因为flowcell上的P5’的第4和第5位的C分别加入了一个-OH，形成的是一个8-oxo-G。在切除8-oxo-G的同时，游离的3’端被阻断，防止不必要的DNA延伸，如下图所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/BDml30ic12.png?imageslim" alt="mark"></p>
<h2 id="测序"><a href="#测序" class="headerlink" title="测序"></a>测序</h2><h3 id="边合成边测序"><a href="#边合成边测序" class="headerlink" title="边合成边测序"></a>边合成边测序</h3><p>此时就可以进行测序了。首先测序引物（sequencing primer）结合到靠近P5的测序引物结合位点1（sequencing primer binding site 1）上，在系统中加入四种dNTP和DNA聚合酶。这里的dNTP有两个特点，第一，它是有荧光基团标记的，<br>每种碱基标记的荧光基团不一样。第二，它的3’末端连了一个叠氮基。这个叠氮基能够阻断后面的碱基与它相连，如下图所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/75f89CC0Jh.png?imageslim" alt="mark"></p>
<p>在聚合酶的作用下，与Forward strand相应位置碱基配对的dNTP就会结合到新合成的链上，而由于叠氮基的存在，后面的dNTP无法继续连接。这时用水将剩余的dNTP和酶给冲掉，对Flowcell进行扫描，扫描出来的荧光对应的碱基的配对碱基即是该链该位置的碱基。同时在这个Flowcell上有成千上万个cluster也在进行同样的反应，因此一个循环就能同时检测多个样本。这个循环完成后，加入化学试剂把叠氮基和标记的荧光基团切掉，进行下一个循环（碱基的连接、检测与切除）。如此重复直至所有链的碱基序列被检测出，也就是Forward read 序列。</p>
<h3 id="index1测序"><a href="#index1测序" class="headerlink" title="index1测序"></a>index1测序</h3><p>当所有的循环结束后，read products 被洗掉，index1 primer与链上index primer1 结合位点杂交配对，进行index1的合成及检测，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/ai797E1Alf.png?imageslim" alt="mark"></p>
<p>index1测序完成后，洗脱测序产物，此时测序仪已经通过荧光得到了index1的序列。</p>
<h3 id="index2测序"><a href="#index2测序" class="headerlink" title="index2测序"></a>index2测序</h3><p>Forward strand（B链）顶端的P5序列与Flowcell上的P5’杂交配对，进行index2测序。测序完成后洗脱产物，切掉P7，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/Ilgh9h9bi0.png?imageslim" alt="mark"></p>
<h3 id="PE测序（即对Reverse-strand测序）"><a href="#PE测序（即对Reverse-strand测序）" class="headerlink" title="PE测序（即对Reverse strand测序）"></a>PE测序（即对Reverse strand测序）</h3><p>洗脱index2后，以Flowcell上的P5’为引物，Forward strand为模板进行桥式扩增，得到双链，经变性，洗脱后，如下所示：<img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/BBF9df06ae.png?imageslim" alt="mark"></p>
<p>接着的测序就与测B链的过程类似，readprimer2结合到靠近P7’的read primer binding site 2开始对Reverse strand的测<br>序。测序完成后即可得到Reverse read序列，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180508/b0CKdaidjl.png?imageslim" alt="mark"></p>
<p>未完待续。。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/seallama/article/details/23446865" target="_blank" rel="external">1. 测序发展小结</a><br><a href="https://www.illumina.com.cn/technology/next-generation-sequencing/paired-end-sequencing_assay.html" target="_blank" rel="external">2. 双端测序</a><br><a href="https://blog.csdn.net/sixu_9days/article/details/78948914" target="_blank" rel="external">3. Illumina SBS测序详解</a><br><a href="http://v.youku.com/v_show/id_XMTI1MjA5Mzg5Mg==.html?spm=a2h0k.8191407.0.0&amp;from=s1.8-1-1.2" target="_blank" rel="external">4. Illumina的SBS技术</a><br><a href="https://zhuanlan.zhihu.com/p/20702684" target="_blank" rel="external">5. 孟浩巍.20160405 illumina 测序原理介绍</a><br><a href="http://tucf-genomics.tufts.edu/home/faq" target="_blank" rel="external">6.建库流程</a><br><a href="https://zhuanlan.zhihu.com/p/35278810" target="_blank" rel="external">7.测序之前篇： NGS测序中，接头是如何添加上的，以及如何去接头</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/06/Linux/Linux-shell08-sed与gawk(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/Linux/Linux-shell08-sed与gawk(1)/" itemprop="url">Shell学习笔记（8）——sed与gawk基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T12:12:54+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,879
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  41
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="sed与gawk的基本用法"><a href="#sed与gawk的基本用法" class="headerlink" title="sed与gawk的基本用法"></a>sed与gawk的基本用法</h2><p>Linux系统中有两个常用的命令行编辑器，分别为<code>sed</code>和<code>gawk</code>。</p>
<h3 id="sed编辑器"><a href="#sed编辑器" class="headerlink" title="sed编辑器"></a>sed编辑器</h3><p>sed编辑器被称作流编辑器（streameditor），和普通的交互式文本编辑器有所不同。在交互式文本编辑器中（比如vim），用户可以用键盘命令来交互式地插入、删除或替换数据中的文本。而流编辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。sed编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。可以简单地理解为，流编辑器像一种滤器，数据进入后，会以一定标准的格式出来，sed编辑器会执行下列操作：</p>
<ol>
<li>一次从输入中读取一行数据。</li>
<li>根据所提供的编辑器命令匹配数据。</li>
<li>按照命令修改流中的数据。</li>
<li>将新的数据输出到STDOUT。</li>
</ol>
<p>在流编辑器将所有命令与一行数据匹配完毕后，它会读取下一行数据并重复这个过程。在流编辑器处理完流中的所有数据行后，它就会终止。由于命令是按顺序逐行给出的，sed编辑器只需对数据流进行一遍处理就可以完成编辑操作。</p>
<p>sed命令的格式如下为<code>sed options script file</code>，其中sed的选项如下所示： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e script</td>
<td>在处理输入时，将script中指定的命令添加到已有的命令中</td>
</tr>
<tr>
<td>-f file</td>
<td>在处理输入时，将file中指定的命令添加到已有的命令中</td>
</tr>
<tr>
<td>-n</td>
<td>不产生命令输出，使用print命令来完成输出</td>
</tr>
</tbody>
</table>
</div>
<p>script参数指定了应用于流数据上的单个命令。如果需要用多个命令，要么使用-e选项在命令行中指定，要么使用-f选项在单独的文件中指定。</p>
<h4 id="在命令行定义编辑器命令"><a href="#在命令行定义编辑器命令" class="headerlink" title="在命令行定义编辑器命令"></a>在命令行定义编辑器命令</h4><p>默认情况下，sed编辑器会将指定的命令应用到STDIN输入流上。这样你可以直接将数据通过管道输入sed编辑器处理，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This is a test"|sed 's/test/big test/'</div><div class="line">This is a big test</div></pre></td></tr></table></figure>
<p>在这个例子中，sed编辑器使用了s命令。s命令会用斜线间指定的第二个文本字符串（这里是big test）来替换第一个文本字符串（test）模式。在本例中是big test替换了test。在运行这个例子时，结果应该立即就会显示出来，再看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dogs.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed 's/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>sed命令几乎瞬间就执行完并返回数据。在处理每行数据的同时，结果也显示出来了。可以在sed编辑器处理完整个文件之前就开始观察结果。需要注意的是，sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT，也可以发送到某个文件。如果你查看原来的文本文件，它仍然保留着原始数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/dog/cat/' data1.txt &gt; data1b.txt</div><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">biotest@ubuntu:~/sed$ cat data1b.txt</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h4 id="在命令行使用多个编辑器命令"><a href="#在命令行使用多个编辑器命令" class="headerlink" title="在命令行使用多个编辑器命令"></a>在命令行使用多个编辑器命令</h4><p>要在sed命令行上执行多个命令时，只要用-e选项就可以了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -e 's/brown/green/;s/dog/cat/' data1.txt</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>两个命令都作用到文件中的每行数据上。命令之间必须用分号隔开，并且在命令末尾和分号之间不能有空格。如果不想用分号，也可以用bash shell中的次提示符来分隔命令。只要输入第一个单引号标示出sed程序脚本的起始（sed编辑器命令列表），bash会继续提示你输入更多命令，直到输入了标示结束的单引号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -e '</div><div class="line"><span class="meta">&gt;</span> s/brown/green/</div><div class="line"><span class="meta">&gt;</span> s/fox/elephant/</div><div class="line"><span class="meta">&gt;</span> s/dog/cat/' data1.txt</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h4 id="从文件中读取编辑器命令"><a href="#从文件中读取编辑器命令" class="headerlink" title="从文件中读取编辑器命令"></a>从文件中读取编辑器命令</h4><p>如果有大量要处理的sed命令，那么将它们放进一个单独的文件中，可以在sed命令中用-f选项来指定文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script1.sed</div><div class="line">s/brown/green/</div><div class="line">s/fox/elephant/</div><div class="line">s/dog/cat/</div><div class="line">biotest@ubuntu:~/sed$ sed -f script1.sed data1.txt</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>在这种情况下，不用在每条命令后面放一个分号。sed编辑器知道每行都是一条单独的命令。跟在命令行输入命令一样，sed编辑器会从指定文件中读取命令，并将它们应用到数据文件中的每一行上。</p>
<h3 id="gawk-程序"><a href="#gawk-程序" class="headerlink" title="gawk 程序"></a>gawk 程序</h3><p>gawk程序是另外的一个处理文本文件的工具，它是Unix原始awk程序的GUN版本，它能提供一个类编程环境来修改和重新组织文件中的数据。 gawk的强大之处在于程序脚本，用户可以写脚本来读取文本行的数据，然后处理并显示数据，创<br>建任何类型的输出报告。 Ubuntu本身并没有带gawk工具，需要自己安装，即<code>get apt install gawk</code>。在gawk编程语言中，用户可以做下面的事情：</p>
<ol>
<li>定义变量来保存数据； </li>
<li>使用算术和字符串操作符来处理数据； </li>
<li>使用结构化编程概念（比如 if-then 语句和循环）来为数据处理增加处理逻辑； </li>
<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。 </li>
</ol>
<p>gawk程序通常用来从大文本文件中提取数据元素，并将它们格式化成可读的报告。其中最常用的就是格式化日志文件。在日志文件中找出错误行会很难，gawk程序可以让用户从日志文件中过滤出需要的数据元素，然后将其格式化，使得重要的数据更易于阅读。</p>
<h4 id="gawk的用法"><a href="#gawk的用法" class="headerlink" title="gawk的用法"></a>gawk的用法</h4><p>gawk的使用格式为<code>gawk options program file</code>，可用选项如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F fs</td>
<td>指定行中划分数据字段的字段分隔符</td>
</tr>
<tr>
<td>-f file</td>
<td>从指定的文件中读取程序</td>
</tr>
<tr>
<td>-v var=value</td>
<td>定义gawk程序中的一个变量及其默认值</td>
</tr>
<tr>
<td>-mf N</td>
<td>指定要处理的数据文件中的最大字段数</td>
</tr>
<tr>
<td>-mr N</td>
<td>指定数据文件中的最大数据行数</td>
</tr>
<tr>
<td>-W keyword</td>
<td>指定gawk的兼容模式或警告等级</td>
</tr>
</tbody>
</table>
</div>
<h4 id="从命令行读取程序脚本"><a href="#从命令行读取程序脚本" class="headerlink" title="从命令行读取程序脚本"></a>从命令行读取程序脚本</h4><p>gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号（{}）中。如果你错误地使用了圆括号来包含gawk脚本，就会得到一条类似于下面的错误提示，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '(print "Hello World!"&#125;'</div><div class="line">gawk: cmd. line:1: (print "Hello World!"&#125;</div><div class="line">gawk: cmd. line:1:                     ^ syntax error</div></pre></td></tr></table></figure>
<p>由于gawk命令行假定脚本是单个文本字符串，必须将脚本放到单引号中。下面的例子在命令行上指定了一个简单的gawk程序脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;print "Hello World!"&#125;'</div><div class="line">Hello World!</div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>这个程序脚本定义了一个命令：print命令。这个命令会将文本打印到STDOUT。如果尝试运行这个命令，什么都不会发生。原因在于没有在命令行上指定文件名，所以gawk程序会从STDIN接收数据。在运行这个程序时，它会一直等待从STDIN输入的文本。如果输入一行文本并按下回车键，gawk会对这行文本运行一遍程序脚本。跟sed编辑器一样，gawk程序会针对数据流中的每行文本执行程序脚本。由于程序脚本被设为显示一行固定的文本字符串，因此不管在数据流中输入什么文本，都会得到同样的文本输出。</p>
<p>要终止这个gawk程序，你必须表明数据流已经结束了。bash shell提供了一个组合键来生成EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk程序并返回到命令行界面提示符下。</p>
<h4 id="使用数据字段变量"><a href="#使用数据字段变量" class="headerlink" title="使用数据字段变量"></a>使用数据字段变量</h4><p>gawk的主要特性之一是其处理文本文件中数据的能力。它会自动给一行中的每个数据元素分配一个变量。默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段：</p>
<ol>
<li><code>$0</code> 代表整个文本行； </li>
<li><code>$1</code> 代表文本行中的第1个数据字段； </li>
<li><code>$2</code> 代表文本行中的第2个数据字段； </li>
<li><code>$n</code> 代表文本行中的第n个数据字段。 </li>
</ol>
<p>在文本行中，每个数据字段都是通过字段分隔符划分的。gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符）。在下面的例子中，gawk程序读取文本文件，只显示第1个数据字段的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data2.txt</div><div class="line">One line of test text.</div><div class="line">Two lines of test text.</div><div class="line">Three lines of test text.</div><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;print $1&#125;' data2.txt</div><div class="line">One</div><div class="line">Two</div><div class="line">Three</div></pre></td></tr></table></figure>
<p>该程序用$1字段变量来仅显示每行文本的第1个数据字段。如果你要读取采用了其他字段分隔符的文件，可以用-F选项指定，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk -F: '&#123;print $1&#125;' /etc/passwd</div><div class="line">root</div><div class="line">daemon</div><div class="line">bin</div><div class="line">sys</div><div class="line">sync</div><div class="line">games</div><div class="line">man</div><div class="line">lp</div><div class="line">mail</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个简短的程序显示了系统中密码文件的第1个数据字段。由于/<code>etc/passwd</code>文件用冒号来分隔数字字段，因而如果要划分开每个数据元素，则必须在gawk选项中将冒号指定为字段分隔符，其中<code>-F:</code>就是指定冒号为分隔符。</p>
<h4 id="在程序脚本中使用多个命令"><a href="#在程序脚本中使用多个命令" class="headerlink" title="在程序脚本中使用多个命令"></a>在程序脚本中使用多个命令</h4><p>gawk编程语言允许多条命令组合成一个正常的程序。要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "My name is Zhang" |gawk '&#123;$4="Li";print $0&#125;'</div><div class="line">My name is Li</div></pre></td></tr></table></figure>
<p>第一条命令会给字段变量<code>$4</code>赋值。第二条命令会打印整个数据字段。注意，gawk程序在输出中已经将原文本中的第四个数据字段替换成了新值。也可以用次提示符一次一行地输入程序脚本命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> $4="Li"</div><div class="line"><span class="meta">&gt;</span> print $0&#125;'</div><div class="line">My name is Zhang</div><div class="line">My name is Li</div></pre></td></tr></table></figure>
<p>在用了表示起始的单引号后，bashs hell会使用次提示符来提示你输入更多数据。可以每次在每行加一条命令，直到输入了结尾的单引号。因为没有在命令行中指定文件名，gawk程序会从STDIN中获得数据。当运行这个程序的时候，它会等着读取来自STDIN的文本。要退出程序，只需按下Ctrl+D组合键来表明数据结束。</p>
<h4 id="从文件中读取程序"><a href="#从文件中读取程序" class="headerlink" title="从文件中读取程序"></a>从文件中读取程序</h4><p>gawk编辑器允许将程序存储到文件中，然后再在命令行中引用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script2.gawk</div><div class="line">&#123;print $1 "'s home directory is " $6&#125;</div><div class="line">biotest@ubuntu:~/sed$ gawk -F: -f script2.gawk /etc/passwd</div><div class="line">root's home directory is /root</div><div class="line">daemon's home directory is /usr/sbin</div><div class="line">bin's home directory is /bin</div><div class="line">sys's home directory is /dev</div><div class="line">sync's home directory is /bin</div><div class="line">......</div></pre></td></tr></table></figure>
<p>在这个案例中，script2.gawk程序脚本会再次使用print命令打印/etc/passwd文件的主目录数据字段（字段变量<code>$6），以及userid数据字段（字段变量</code>$1`）。可以在程序文件中指定多条命令。要这么做的话，只要一条命令放一行即可，不需要用分号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script3.gawk </div><div class="line">&#123;</div><div class="line">text = "'s home directory is " # 变量未使用美元符号，需要注意</div><div class="line">print $1 text $6</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ gawk -F: -f script3.gawk /etc/passwd</div><div class="line">root's home directory is /root</div><div class="line">daemon's home directory is /usr/sbin</div><div class="line">bin's home directory is /bin</div><div class="line">sys's home directory is /dev</div><div class="line">sync's home directory is /bin</div></pre></td></tr></table></figure>
<p>script3.gawk程序脚本定义了一个变量来保存print命令中用到的文本字符串。注意，gawk程序在引用变量值时并未像shell脚本一样使用美元符。</p>
<h4 id="在处理数据前运行脚本"><a href="#在处理数据前运行脚本" class="headerlink" title="在处理数据前运行脚本"></a>在处理数据前运行脚本</h4><p>gawk可以指定程序脚本何时运行。默认情况下，gawk会从输入中读取一行文本，然后针对该行的数据执行程序脚本。有时可能需要在处理数据前运行脚本，比如为报告创建标题。BEGIN关键字就是用来做这个的。它会强制gawk在读取数据前执行BEGIN关键字后指定的程序脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;print "Hello World!"&#125;'</div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>这次print命令会在读取数据前显示文本。但在它显示了文本后，它会快速退出，不等待任何数据。如果想使用正常的程序脚本中处理数据，必须用另一个脚本区域来定义程序，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;pirnt "The data3 File Contents:"&#125;</div><div class="line"><span class="meta">&gt;</span> &#123;print $0&#125;' data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div></pre></td></tr></table></figure>
<p>在gawk执行了BEGIN脚本后，它会用第二段脚本来处理文件数据。这么做时要小心，两段脚本仍然被认为是gawk命令行中的一个文本字符串。你需要相应地加上单引号。</p>
<h4 id="在处理数据后运行脚本"><a href="#在处理数据后运行脚本" class="headerlink" title="在处理数据后运行脚本"></a>在处理数据后运行脚本</h4><p>与BEGIN关键字类似，END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;pirnt "The data3 File Contents:"&#125;</div><div class="line"><span class="meta">&gt;</span> &#123;print $0&#125;</div><div class="line"><span class="meta">&gt;</span> END &#123;print "End of FIle"&#125;' data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div><div class="line">End of FIle</div></pre></td></tr></table></figure>
<p>当gawk程序打印完文件内容后，它会执行END脚本中的命令。这是在处理完所有正常数据后给报告添加页脚的最佳方法。可以将所有这些内容放到一起组成一个脚本文件，用它从一个简单的数据文件中创建一份完整的报告，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script4.gawk </div><div class="line">BEGIN &#123;</div><div class="line">print "The latest list of users and shells"</div><div class="line">print " UserID \t Shell"</div><div class="line">print "-------- \t --------"</div><div class="line">FS=":"</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">print $1 "        \t " $7</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">print "This concludes the listing"</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~/sed$ gawk -f script4.gawk /etc/passwd</div><div class="line">The latest list of users and shells</div><div class="line"> UserID 	 Shell</div><div class="line">-------- 	 --------</div><div class="line">root        	 /bin/bash</div><div class="line">daemon        	 /usr/sbin/nologin</div><div class="line">bin        	 /usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>这个脚本用BEGIN脚本来为报告创建标题。它还定义了一个叫作FS的特殊变量。这是定义字段分隔符的另一种方法。这样就不用依靠脚本用户在命令行选项中定义字段分隔符了。BEGIN脚本创建了标题，程序脚本处理特定数据文件（<code>/etc/passwd）</code>中的信息，END脚本生成页脚。 </p>
<h2 id="sed-编辑器基础"><a href="#sed-编辑器基础" class="headerlink" title="sed 编辑器基础"></a>sed 编辑器基础</h2><h3 id="更多的替换选项"><a href="#更多的替换选项" class="headerlink" title="更多的替换选项"></a>更多的替换选项</h3><p>s命令（substitute）用来在行中替换文本。这个命令还有另外一些选项。</p>
<h4 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h4><p>先看一个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data4.txt </div><div class="line">This is a test of the test script.</div><div class="line">This is the second test of the test script.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/' data4.txt </div><div class="line">This is a trial of the test script.</div><div class="line">This is the second trial of the test script.</div></pre></td></tr></table></figure>
<p>替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记（substitution flag）。替换标记会在替换命令字符串之后设置，格式为<code>s/pattern/replacement/flags</code>，有4种可用的替换标记：</p>
<ol>
<li>数字，表明新文本将替换第几处模式匹配的地方； </li>
<li>g ，表明新文本将会替换所有匹配的文本； </li>
<li>p ，表明原先行的内容要打印出来； </li>
<li>w file ，将替换的结果写到文件中。 </li>
</ol>
<h5 id="数字替换标记"><a href="#数字替换标记" class="headerlink" title="数字替换标记"></a>数字替换标记</h5><p>在第一类替换中，可以指定sed编辑器用新文本替换第几处模式匹配的地方，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/2' data4.txt </div><div class="line">This is a test of the trial script.</div><div class="line">This is the second test of the trial script.</div></pre></td></tr></table></figure>
<p>这个脚本运行的结果是：sed编辑器只替换每行中第2次出现的匹配模式。</p>
<h5 id="g替换标记"><a href="#g替换标记" class="headerlink" title="g替换标记"></a>g替换标记</h5><p>g替换标记使你能替换文本中匹配模式所匹配的每处地方，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/g' data4.txt</div><div class="line">This is a trial of the trial script.</div><div class="line">This is the second trial of the trial script.</div></pre></td></tr></table></figure>
<p>如结果所示，使用了g替换标记后，文本中所有的地方都被替换了。</p>
<h5 id="p替换标记"><a href="#p替换标记" class="headerlink" title="p替换标记"></a>p替换标记</h5><p>p替换标记会打印与替换命令中指定的模式匹配的行。这通常会和sed的-n选项一起使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test5.txt</div><div class="line">This is a test line.</div><div class="line">This is a different line.</div><div class="line">biotest@ubuntu:~/sed$ sed -n 's/test/trial/p' test5.txt</div><div class="line">This is a trial line.</div></pre></td></tr></table></figure>
<p>-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是只输出被替换命令修改过的行，第二行并没有被替换，也就不输出了。</p>
<h5 id="w替换标记"><a href="#w替换标记" class="headerlink" title="w替换标记"></a>w替换标记</h5><p>w 替换标记会产生同样的输出，不过会将输出保存到指定文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/w test.txt' test5.txt </div><div class="line">This is a trial line.</div><div class="line">This is a different line.</div><div class="line">biotest@ubuntu:~/sed$ cat test.txt</div><div class="line">This is a trial line.</div></pre></td></tr></table></figure>
<p>sed编辑器的正常输出是在STDOUT中，而只有那些包含匹配模式的行才会保存在指定的输出文件中。</p>
<h4 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h4><p>有时会在文本字符串中遇到一些不太方便在替换模式中使用的字符。Linux中一个常见的例子就是正斜线（/）。替换文件中的路径名会比较麻烦。比如想用C shell替换/etc/passwd文件中的bash shell，必须这么做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/csh</div><div class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</div><div class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</div><div class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>由于正斜线通常用作字符串分隔符，因而如果它出现在了模式文本中的话，必须用反斜线来转义。这通常会带来一些困惑和错误。 要解决这个问题，sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's!/bin/bash!/bin/csh!' /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/csh</div><div class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</div><div class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>在这个例子中，感叹号被用作字符串分隔符，这样路径名就更容易阅读和理解了。 </p>
<h4 id="使用地址"><a href="#使用地址" class="headerlink" title="使用地址"></a>使用地址</h4><p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（lineaddressing）。在sed编辑器中有两种形式的行寻址：第一，以数字形式表示区间；第二，用文本模式来过滤出行。两种形式都使用相同的格式来指定地址： </p>
<p><code>[address] command</code>或者是将特定地址的多个命令分组，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">address &#123;</div><div class="line">    command1</div><div class="line">    command2</div><div class="line">    command3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sed编辑器会将指定的每条命令作用到匹配指定地址的行上。本节将会演示如何在sed编辑器脚本中使用两种寻址方法。</p>
<h5 id="第一，数字方式的行寻址。"><a href="#第一，数字方式的行寻址。" class="headerlink" title="第一，数字方式的行寻址。"></a>第一，数字方式的行寻址。</h5><p>当使用数字方式的行寻址时，可以用行在文本流中的行位置来引用。sed编辑器会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号。在命令中指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围内的行。这里有个sed命令作用到指定行号的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>sed编辑器只修改地址指定的第二行的文本。这里有另一个例子，这次使用了行地址区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,3s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>如果需要将命令作用到文本从某行开始的所有行，可以使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,$s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h5 id="第二，使用文本模式过滤器"><a href="#第二，使用文本模式过滤器" class="headerlink" title="第二，使用文本模式过滤器"></a>第二，使用文本模式过滤器</h5><p>另一种限制命令作用到哪些行上的方法会稍稍复杂一些。sed编辑器允许指定文本模式来过滤出命令要作用的行。格式为<code>/pattern/command，</code>必须用正斜线将要指定的pattern封起来。sed编辑器会将该命令作用到包含指定文本模式的行上。举个例子，如果你想只修改用户test001的默认shell，可以使用sed命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ grep biotest /etc/passwd</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/csh</div></pre></td></tr></table></figure>
<p>该命令只作用到匹配文本模式的行上。虽然使用固定文本模式能帮你过滤出特定的值，就跟上面这个用户名的例子一样，但其作用难免有限。sed编辑器在文本模式中支持正则表达式（regular expression）。</p>
<h5 id="第三，命令组合"><a href="#第三，命令组合" class="headerlink" title="第三，命令组合"></a>第三，命令组合</h5><p>如果需要在单行上执行多条命令，可以用花括号将多条命令组合在一起，sed编辑器会处理地址行处列出的每条命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed '2&#123;</div><div class="line"><span class="meta">&gt;</span> s/fox/elephant/</div><div class="line"><span class="meta">&gt;</span> s/dog/cat/</div><div class="line"><span class="meta">&gt;</span> &#125;' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown elephant jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>两条命令都会作用到该地址上，也可以在一组命令前指定一个地址区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '3,$&#123;</div><div class="line"><span class="meta">&gt;</span> s/brown/green/</div><div class="line"><span class="meta">&gt;</span> s/lazy/active/</div><div class="line"><span class="meta">&gt;</span> &#125;' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick green fox jumps over the active dog.</div><div class="line">The quick green fox jumps over the active dog.</div></pre></td></tr></table></figure>
<h3 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h3><p>在sed中，删除使用的是<code>d</code>参数，使用此命令需要谨慎，如果用户忘记加入寻址模式的话，流中所有的文都会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt # 原始文本</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '3d' test6.txt # 删除第3行</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '2,3d' test6.txt # 删除第2，3行</div><div class="line">This is line number 1.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '3,$d' test6.txt # 删除第3行及3行以下</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">biotest@ubuntu:~/sed$ sed '/number 1/d' test6.txt # 删除第1行</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/3/d' test6.txt # 删除1到3行</div><div class="line">This is line number 4.</div><div class="line"><span class="meta">#</span> 指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed编辑器会删除两个指定行之间的所有行</div></pre></td></tr></table></figure>
<p>只要sed编辑器在数据流中匹配到了开始模式，删除功能就会打开。这可能会导致意外的结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test7.txt </div><div class="line">This is line number 1.</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is line number 1 again.</div><div class="line">THis is text you want to keep.</div><div class="line">This is the last line in the file.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/3/d' test7.txt</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>在这段代码中，第二个出现数字“1”的行再次触发了删除命令，因为没有找到停止模式，所以就将数据流中的剩余行全部删除了。如果你指定了一个从未在文本中出现的停止模式，显然会出现另外一个问题，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/5/d' test7.txt</div><div class="line">biotest@ubuntu:~/sed$</div></pre></td></tr></table></figure>
<p>在这段代码中，因为删除功能在匹配到第一个模式的时候打开了，但一直没匹配到结束模式，所以整个数据流都被删掉了。 </p>
<h3 id="插入和附加文本"><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h3><p>sed编辑器可以向数据流插入和附加文本行。它有两种操作：第一，插入（insert）：命令（i）会在指定行前增加一个新行；第二，追加（append）命令（a）会在指定行后增加一个新行。这两条命令在使用格式上有些特殊，它们不能在单个命令行上使用。用户必须指定是要将行插入还是附加到另一行。格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed '[address] command\</div><div class="line">new line'</div></pre></td></tr></table></figure>
<p>其中，<code>new line</code>中的文本将会出现在sed编辑器输出中指定的位置。记住，当使用插入命令时，文本会出现在数据流文本的前面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "Test Line2"|sed 'i\Test Line 1' # 在第2行之前插入文本</div><div class="line">Test Line 1</div><div class="line">Test Line2</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ echo "Test Line2"|sed 'a\Test Line 1' # 在第2行之后插入文本 </div><div class="line">Test Line2</div><div class="line">Test Line 1</div></pre></td></tr></table></figure>
<p>在命令行界面提示符上使用sed编辑器时，用户会看到次提示符来提醒输入新的行数据。用户必须在该行完成sed编辑器命令。一旦你输入了结尾的单引号，bash shell就会执行该命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "Test Line 2"|sed 'i\</div><div class="line"><span class="meta">&gt;</span> Test Line 1'</div><div class="line">Test Line 1</div><div class="line">Test Line 2</div></pre></td></tr></table></figure>
<p>前面所述的方法只能给数据流中的文本前面或后面添加文本，但有时候还需要向一行的前后添加文本，要向数据流行内部插入或附加数据，必须用寻址来告诉sed编辑器想让数据出现在什么位置。可以在用这些命令时只指定一个行地址。可以匹配一个数字行号或文本模式，但不能用地址区间（因为用户只能将文本插入或附加到单个行的前面或后面，而不是行区间的前面或后面），在下面的例子中，用户将一个新行插入到数据流第三行前。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt </div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line"></div><div class="line"><span class="meta">#</span> 将一个新行插入到数据流第三行前</div><div class="line">biotest@ubuntu:~/sed$ sed '3i\ </div><div class="line"><span class="meta">&gt;</span> This is an inserted line.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is an inserted line.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line"></div><div class="line"><span class="meta">#</span>将一个新行附加到数据流中第三行后</div><div class="line">biotest@ubuntu:~/sed$ sed '3a\ </div><div class="line"><span class="meta">&gt;</span> This is an appended line.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is an appended line.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>如果有一个多行数据流，需要将新行追加到数据流的末决，只要用代表数据最后一行的美元符号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '$a\</div><div class="line"><span class="meta">&gt;</span> This is a new line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is a new line of text.</div></pre></td></tr></table></figure>
<p>同样的方法也适用于要在数据流起始位置增加一个新行。只要在第一行之前插入新行即可。要插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后一行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '1i\</div><div class="line"><span class="meta">&gt;</span> This ia one line of new text.\</div><div class="line"><span class="meta">&gt;</span> This is another line of new text.' test6.txt</div><div class="line">This ia one line of new text.</div><div class="line">This is another line of new text.</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<h3 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h3><p>sed可以对文本进行修改，使用的参数是<code>c</code>，意思为修改（change）。这个参数允许修改数据流中整行文本的内容。它跟插入和附加命令的工作机制一样，必须在sed命令中单独指定新行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '3c\</div><div class="line"><span class="meta">&gt;</span> This is a change line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is a change line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>在这个例子中，sed编辑器会修改第三行中的文本。也可以用文本模式来寻址，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/number 3/c\</div><div class="line"><span class="meta">&gt;</span> This is a changed line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is a changed line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>文本模式修改命令会修改它匹配的数据流中的任意文本行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test8.txt</div><div class="line">This is line number 1. </div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is line number 1 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file. </div><div class="line">biotest@ubuntu:~/sed$ sed '/number 1/c\</div><div class="line"><span class="meta">&gt;</span> This is a changed line of text.' test8.txt</div><div class="line">This is a changed line of text.</div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is a changed line of text.</div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file.</div></pre></td></tr></table></figure>
<p>在修改命令中使用地址区间，结果就会出问题，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,3c\</div><div class="line"><span class="meta">&gt;</span> This is a new line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is a new line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>sed编辑器会用这一行文本来替换数据流中的两行文本，而不是逐一修改这两行文本。 </p>
<h3 id="转换命令"><a href="#转换命令" class="headerlink" title="转换命令"></a>转换命令</h3><p>sed中还有一个转换命令，参数是<code>y</code>，转换（ transform ）可以处理单个字符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address]y/inchars/outchars/</div></pre></td></tr></table></figure>
<p>转换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转换为outchars中的第一个字符，第二个字符会被转换成outchars中的第二个字符。这个映射过程会一直持续到处理完指定字符。如果inchars和outchars的长度不同，则sed编辑器会产生一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test8.txt</div><div class="line">This is line number 1. </div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is line number 1 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file. </div><div class="line">biotest@ubuntu:~/sed$ sed 'y/123/789/' test8.txt</div><div class="line">This is line number 7. </div><div class="line">This is line number 8. </div><div class="line">This is line number 9. </div><div class="line">This is line number 4. </div><div class="line">This is line number 7 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file.</div></pre></td></tr></table></figure>
<p>在这个案例中，<code>inchars</code>械中指定的字符的每个实例都会被替换成<code>outchars</code>模式中相同位置的那个字符，转换命令是一个全局命令，它会在文本行中找到所有指定字符自动进行转换，而不会考虑它们出现的位置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This 1 is a test of 1 try."|sed 'y/123/456/'</div><div class="line">This 4 is a test of 4 try.</div></pre></td></tr></table></figure>
<p>sed编辑器转换了在文本行中匹配到的字符1的两个实例。你无法限定只转换在特定地方出现的字符。</p>
<h3 id="回顾打印"><a href="#回顾打印" class="headerlink" title="回顾打印"></a>回顾打印</h3><p>有3个命令可以打印文本行，分别为：</p>
<ol>
<li>p命令用来打印文本行；</li>
<li>等号（=）用于打印行号；</li>
<li>l（小写的L）用于列出行。</li>
</ol>
<h4 id="打印行"><a href="#打印行" class="headerlink" title="打印行"></a>打印行</h4><p>这里的<code>p</code>参业与替换中的<code>p</code>参数类似，它可以打印sed编译器输出中的一行，如果只使用这个命令，就是显示这一行命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This is a test"|sed 'p'</div><div class="line">This is a test</div><div class="line">This is a test</div></pre></td></tr></table></figure>
<p><code>p</code>参数就是打印已有的数据文本，打印命令常用的用法就是打印包含匹配文本模式的行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed -n '/number 3/p' test6.txt</div><div class="line">This is line number 3.</div></pre></td></tr></table></figure>
<p>在命令行上用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。也可以用它来快速打印数据流中的某些行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '2,3p' test6.txt</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div></pre></td></tr></table></figure>
<p>如果需要在修改之前查看行，也可以使用打印命令，比如与替换或修改命令一起使用。可以创建一个脚本在修改行之前显示该行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '/3/&#123;</div><div class="line"><span class="meta">&gt;</span> p</div><div class="line"><span class="meta">&gt;</span> s/line/test/p</div><div class="line"><span class="meta">&gt;</span> &#125;' test6.txt</div><div class="line">This is line number 3.</div><div class="line">This is test number 3.</div></pre></td></tr></table></figure>
<p>sed编辑器命令会查找包含数字3的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。 </p>
<h4 id="打印行号"><a href="#打印行号" class="headerlink" title="打印行号"></a>打印行号</h4><p>等号命令会打印行在数据流中的当前行号。行号由数据流中的换行符决定。每次数据流中出现一个换行符，sed编辑器会认为一行文本结束了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">biotest@ubuntu:~/sed$ sed '=' data1.txt</div><div class="line">1</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">2</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">3</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">4</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>sed编辑器在实际的文本行出现前打印了行号。如果你要在数据流中查找特定文本模式的话，等号命令用起来非常方便，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '/number 4/&#123;</div><div class="line"><span class="meta">&gt;</span> =</div><div class="line"><span class="meta">&gt;</span> p</div><div class="line"><span class="meta">&gt;</span> &#125;' test6.txt</div><div class="line">4</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>利用 -n 选项，你就能让sed编辑器只显示包含匹配文本模式的行的行号和文本。 </p>
<h4 id="列出行"><a href="#列出行" class="headerlink" title="列出行"></a>列出行</h4><p>列出（list）命令（l）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\t，来代表制表符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data9.txt </div><div class="line">This	line	contains	tabs.</div><div class="line">biotest@ubuntu:~/sed$ sed -n 'l' data9.txt</div><div class="line">This\tline\tcontains\ttabs.$</div></pre></td></tr></table></figure>
<p>制表符的位置使用\t来显示。行尾的美元符表示换行符。</p>
<h3 id="使用sed处理文件"><a href="#使用sed处理文件" class="headerlink" title="使用sed处理文件"></a>使用sed处理文件</h3><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p><code>w</code>选项用于向文件写入行，该选项的命令格式为<code>[address] w filename</code>，其中<code>filename</code>可以使用相对路径或绝对路径，并且用户要有文件的写权限，地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</p>
<p>下面的例子是将数据流中的前两行打印到一个文本文件中。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '1,2w test.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ cat test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ cat test.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div></pre></td></tr></table></figure>
<p>如果不想让行显示到STDOUT上，可以用sed命令的-n选项。如果要根据一些公用的文本值从主文件中创建一份数据文件，比如下面的邮件列表中的，那么w命令会非常好用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data11.txt</div><div class="line">Zhang San</div><div class="line">Li Si</div><div class="line">Wang Er</div><div class="line">Liu Qi</div><div class="line">biotest@ubuntu:~/sed$ sed -n '/Zhang/w Zhang.txt' data11.txt</div><div class="line">biotest@ubuntu:~/sed$ cat Zhang.txt </div><div class="line">Zhang San</div></pre></td></tr></table></figure>
<p>sed编辑器会只将包含文本模式的数据写入目标文件。</p>
<h4 id="从文件读取数据"><a href="#从文件读取数据" class="headerlink" title="从文件读取数据"></a>从文件读取数据</h4><p>取（read）命令（r）允许用户将一个独立文件中的数据插入到数据流中。读取命令的格式为<code>[address]r filename</code>，其中filename参数指定了数据文件的绝对路径或相对路径，在读取命令中使用地址区间，只能指定单独一个行号或文本模式地址。sed编辑器会将文件中的文本插入到指定地址后，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data12.txt</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">biotest@ubuntu:~/sed$ sed '3r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>使用文本模式进行读取，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/number 2/r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>如果需要在数据流的末尾添加文件，需要使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '$r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div></pre></td></tr></table></figure>
<p>读取命令的另一个很有用的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。举例来说，假定你有一份套用信件保存在文本文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat notice.std </div><div class="line">Would the following people:</div><div class="line">LIST</div><div class="line">please report to the ship's captain.</div></pre></td></tr></table></figure>
<p>套用信件将通用占位文本 LIST 放在人物名单的位置。要在占位文本后插入名单，只需读取 命令就行了。但这样的话，占位文本仍然会留在输出中。要删除占位文本的话，你可以用删除命 令。结果如下： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/LIST/&#123;</div><div class="line"><span class="meta">&gt;</span> r data11.txt</div><div class="line"><span class="meta">&gt;</span> d</div><div class="line"><span class="meta">&gt;</span> &#125;' notice.std</div><div class="line">Would the following people:</div><div class="line">Zhang San</div><div class="line">Li Si</div><div class="line">Wang Er</div><div class="line">Liu Qi</div><div class="line">please report to the ship's captain.</div></pre></td></tr></table></figure>
<p>现在占位文本已经被替换成了数据文件中的名单。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/06/Experiment/病毒包装笔记(7)-第三代慢病毒包装笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/Experiment/病毒包装笔记(7)-第三代慢病毒包装笔记/" itemprop="url">病毒包装笔记(7)-第三代慢病毒</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T12:02:00+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物实验笔记/" itemprop="url" rel="index">
                    <span itemprop="name">生物实验笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,283
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在国内某公司买了一个慢病毒质粒，公司的人说可以用来包慢病毒，也可以用来瞬转。但是我发现这个质粒上没有<code>3&#39;UTR</code>和<code>5&#39; UTR</code>，我怀疑不能用来包慢病毒，公司说可以，但要用他们的试剂盒。我问了一下师兄，师兄说，这种质粒可能是第三代慢病毒包装质粒，试剂盒里的主要试剂就是包含三种包装质粒的混合液。我们实验室用的是第二代病毒包装系统，两个包装质粒，一个目的质粒，因此我对这种质粒包装系统并不清楚。现在查了一些三代包装系统的资料，现在总结如下。</p>
<h2 id="慢病毒的成分"><a href="#慢病毒的成分" class="headerlink" title="慢病毒的成分"></a>慢病毒的成分</h2><p>现在的慢病毒包装系统通常包括几个质粒，这几个质粒上分别含有慢病毒复制的成分，这样做的目的就是为了增加安全性，毕竟如果只用一个成分的话，危险系数很高，人一旦接触这种病毒就有可能遇到危险。而把这几个成分分散在几个质粒中，很难在体外形成危险的病毒颗粒。第二代慢病毒包装系统含有3个质粒，第3代慢病毒包装系统含有4个质粒。这两代病毒包装系统都含有以下相同的成分：</p>
<p>第一，编码目的蛋白或转录目的基因的转移质粒。其实就是你自己的目的质粒，也就是通常需要自己做载体的质粒。目的基因的两侧都含有长末端重复序列（LTR，long terminal repeat），LTR的作用就是辅助目的基因插入到宿主细胞的基因组。许多慢病毒质粒都是基于HIV-1病毒改造的。为了安全目的，这些目的质粒的复能能力并不完全，它们的<code>3&#39;LTR</code>有所删减，这样病毒插入到基因组后会自我失活（self-inactivating）（SIN）。</p>
<p>第二，包装质粒，毒包装的结构蛋白编码质粒。</p>
<p>第三，包膜质粒，编码蛋白质外壳。</p>
<p>第二代慢病毒利用病毒的LTR启动子用于基因的表达，第三代慢病毒利用一个杂合的LTR启动子进行基因表达。</p>
<h2 id="第二代慢病毒"><a href="#第二代慢病毒" class="headerlink" title="第二代慢病毒"></a>第二代慢病毒</h2><p>下图是第二代慢病毒系统：</p>
<p><img src="https://media.addgene.org/data/easy-thumbnails/filer_public/cms/filer_public/56/36/563610a3-a100-4f87-9d10-309cf106dfe7/geneticorganizationoflentiviruses_1.jpg__450x255_q85_subsampling-2_upscale.png" alt=""></p>
<p>这个系统含有3个质粒，第1个质粒：包装质粒，它编码Gag，PoI，Rev与Tat基因。第2个质粒：包膜质粒，含有VSV-G，编码蛋白Env。第3个质粒：目的质粒，含有病毒的LTRs和psi包装信号（图片未画出），除非有内部启动子，否则这个目的质粒的目的基因是由<code>5&#39;LTR</code>驱动的，它是一个弱启动子，需要Tat元件 的来激活它。所有的第2代慢病毒目的质粒必须要用第2代慢病毒包装系统，因此它的LTR是Tat依赖性的。</p>
<h2 id="第三代慢病毒"><a href="#第三代慢病毒" class="headerlink" title="第三代慢病毒"></a>第三代慢病毒</h2><p>第3代慢病毒如下所示：</p>
<p><img src="https://media.addgene.org/data/easy-thumbnails/filer_public/cms/filer_public/7f/54/7f549fd8-1c37-4448-a2d3-227e5c24c550/3rdgenerationplasmids.png__350x194_q85_subsampling-2_upscale.png" alt=""></p>
<p>设计第3代病毒的目的主要还是提高安全性。在第3代病毒中，将第2代病毒的包装质粒分成了2个质粒，一个编码Rev，另外一个编码Gag和PoI。虽然第3代病毒更加安全了，但是它的效率却降低了。除此之外，第3代病毒删除了Tat元件，并且在目的质粒中引入了一个嵌合了<code>5&#39;LTR</code>的异源启动子。这种目的质粒基因的启动子并不依赖于Tat元件。第3代病毒的目的质粒可以使用第2代或第3代的包装质粒，也就是说第3代慢病毒的目的质粒兼容第2代的包装系统。</p>
<h2 id="第二代慢病毒与第第三代病毒的区别"><a href="#第二代慢病毒与第第三代病毒的区别" class="headerlink" title="第二代慢病毒与第第三代病毒的区别"></a>第二代慢病毒与第第三代病毒的区别</h2><div class="table-container">
<table>
<thead>
<tr>
<th>特点</th>
<th>第2代慢病毒</th>
<th>第3代慢病毒</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的质粒</td>
<td>只能被含有TAT的2代病毒包装</td>
<td>可以被第2代和第3代病毒包装系统包装</td>
</tr>
<tr>
<td>包装质粒</td>
<td>一个质粒上含有Gag，PoI，Rev，Tat（也就是psPAX2）</td>
<td>2个质粒，一个编码Gag和PoI；另外一个质粒编码Rev（也就是pMDLg/pRRE和pRSV-Rev）</td>
</tr>
<tr>
<td>包膜质粒</td>
<td>可替换，通常用于编码VSV-G（pMD2G）</td>
<td>可替换，通常用于编码VSV-G（pMD2G）</td>
</tr>
<tr>
<td>案例性</td>
<td>安全。复能能力不完全，使用编码各种HIV基因的3个质粒。</td>
<td>更安全，复制能力不完全，有自身失活性（SIN）。使用4个质粒来替换2代慢病毒的3个质粒，删除了Tat元件。</td>
</tr>
<tr>
<td>LTR病毒启动子</td>
<td>广泛型</td>
<td>杂合：删除了部分的5’LTR，与另外一个异源增强子/启动子融合，例如CMV或RSV。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第三代病毒包装系统的过程"><a href="#第三代病毒包装系统的过程" class="headerlink" title="第三代病毒包装系统的过程"></a>第三代病毒包装系统的过程</h2><p>其实买的目的质粒虽然是三代病毒包装系统的，但是完全可以用二代慢病毒包装系统来替代，用PMD2G和psPAX2，外加目的质粒进行转染。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.addgene.org/viral-vectors/lentivirus/lenti-guide/" target="_blank" rel="external">https://www.addgene.org/viral-vectors/lentivirus/lenti-guide/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/05/Linux/Linux-shell07-构建函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/Linux/Linux-shell07-构建函数/" itemprop="url">Shell学习笔记（7）——构建函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-05T12:12:54+08:00">
                2018-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,347
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本的脚本函数"><a href="#基本的脚本函数" class="headerlink" title="基本的脚本函数"></a>基本的脚本函数</h2><p>函数是一个脚本代码块，用户可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。</p>
<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>创建函数有2种方式：第一种，使用关键字<code>function</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function name&#123;</div><div class="line">    commands</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。</p>
<p>第二种构建函数的格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name() &#123; </div><div class="line">    commands </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数名后的空括号表明正在定义的是一个函数。这种格式的命名规则和之前定义shell脚本函数的格式一样。 </p>
<h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><p>要在脚本中使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a function in a script</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">     echo "This is an example of a function"</div><div class="line">&#125;</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    func1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">echo "This is the end of the loop"</div><div class="line">func1</div><div class="line">echo "Now this is the end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test1.sh</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is the end of the loop</div><div class="line">This is an example of a function</div><div class="line">Now this is the end of the script</div></pre></td></tr></table></figure>
<p>每次引用函数名func1时，bash shell会找到func1函数的定义并执行你在那里定义的命令。如果在函数被定义前使用函数，会收到一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a function located in the middle of a script</div><div class="line"></div><div class="line">count=1</div><div class="line">echo "This line comes before the function definition"</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is an example of a function"</div><div class="line">&#125;</div><div class="line"></div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    func1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "This is the end of the loop"</div><div class="line">func2</div><div class="line">echo "Now this is the end of the scripts"</div><div class="line"></div><div class="line">function func2 &#123;</div><div class="line">   echo "This is an example of a function"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test2.sh</div><div class="line">This line comes before the function definition</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is the end of the loop</div><div class="line">test2.sh: line 17: func2: command not found</div><div class="line">Now this is the end of the scripts</div></pre></td></tr></table></figure>
<p>第一个函数func1的定义出现在脚本中的几条语句之后，运行起来没问题。当func1函数 在脚本中被使用时，shell知道去哪里找它。 脚本试图在func2函数被定义之前使用它。由于func2函数还没有定义，脚本运行函数调用处时，产生了一条错误消息。 此外，还需要注意函数名，函数名必须是唯一的，否则也会有问题。如果你重定义了函数，新定义会覆盖原来函数的定义，这一切不会产生任何错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing using a duplicate function name</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is the first definition of the function name"</div><div class="line">&#125;</div><div class="line"></div><div class="line">func1</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is a repeat of the same function name"</div><div class="line">&#125;</div><div class="line">func1</div><div class="line">echo "This is end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test3.sh</div><div class="line">This is the first definition of the function name</div><div class="line">This is a repeat of the same function name</div><div class="line">This is end of the script</div></pre></td></tr></table></figure>
<p>func1函数最初的定义工作正常，但重新定义该函数后，后续的函数调用都会使用第二个定义。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成退出状态码。</p>
<h3 id="默认退出状态码"><a href="#默认退出状态码" class="headerlink" title="默认退出状态码"></a>默认退出状态码</h3><p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the exit status of a function</div><div class="line"></div><div class="line">func1() &#123;</div><div class="line">   echo "Trying to display a non-existent file"</div><div class="line">   ls -l badfile</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo "testing the function:  "</div><div class="line">func1</div><div class="line">echo "The exit status is : $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test4.sh</div><div class="line">testing the function:  </div><div class="line">Trying to display a non-existent file</div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">The exit status is : 2</div></pre></td></tr></table></figure>
<p>函数的退出状态码是2，这是因为函数中的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行。看下面的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the exit status of a fucntion </div><div class="line"></div><div class="line">func1() &#123;</div><div class="line">    ls -l badfile</div><div class="line">    echo "This was a test of a bad command"</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo "Testing the function: "</div><div class="line">func1</div><div class="line">echo "The exit status is:  $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test4b.sh</div><div class="line">Testing the function: </div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">This was a test of a bad command</div><div class="line">The exit status is:  0</div></pre></td></tr></table></figure>
<p>在这个案例中，由于函数最后一条语句echo运行成功，该函数的退出状态码就是0，尽管其中有一条 命令并没有正常运行。使用函数的默认退出状态码是很危险的。在bash shell中，有几种办法可以解决这个问题。</p>
<h3 id="使用return命令"><a href="#使用return命令" class="headerlink" title="使用return命令"></a>使用return命令</h3><p>bash shell使用return命令来退出函数并返回特定的退出状态码。return命令允许指定一个 整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the return command in a function</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    read -p "Enter a value:" value</div><div class="line">    echo "doubling the value"</div><div class="line">    return $[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">dbl</div><div class="line">echo "The new value is $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5.sh</div><div class="line">Enter a value:5</div><div class="line">doubling the value</div><div class="line">The new value is 10</div></pre></td></tr></table></figure>
<p>dbl函数会将<code>$value</code>变量中用户输入的值翻倍，然后用return命令返回结果。脚本用<code>$?</code>变量显示了该值。但当用这种方法从函数中返回值时，需要注意两点：第一，函数一结束就取返回值；第二，退出状态码必须是0~255。如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。<code>$?</code>变量会返回执行的最后一条命令的退出状态码。第二个问题界定了返回值的取值范围。由于退出状态码必须小于256，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5.sh</div><div class="line">Enter a value:200</div><div class="line">doubling the value</div><div class="line">The new value is 144</div></pre></td></tr></table></figure>
<h3 id="使用函数的输出"><a href="#使用函数的输出" class="headerlink" title="使用函数的输出"></a>使用函数的输出</h3><p>将函数的份输出保存到shell变量中，就能获取任何类型的函数输出，例如<code>result=&#39;dbl</code>就是将dbl函数的输出赋值给<code>$result</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the return command in a function</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    read -p "Enter a value:" value</div><div class="line">    echo $[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">result=$(dbl)</div><div class="line"></div><div class="line">echo "The new value is $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5b.sh</div><div class="line">Enter a value:200</div><div class="line">The new value is 400</div></pre></td></tr></table></figure>
<p>新函数会用echo语句来显示计算的结果。该脚本会获取dbl函数的输出，而不是查看退出状态码。在这个例子中，dbl函数实际上输出了两条消息。read命令输出了一条简短的消息来向用户询问输入值。bash shell脚本并不将其作为STDOUT输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中。通过这种技术，还可以返回浮点值和字符串值。</p>
<h2 id="在函数中使用变量"><a href="#在函数中使用变量" class="headerlink" title="在函数中使用变量"></a>在函数中使用变量</h2><p>在test5例子的脚本里，在函数里用了一个叫作$value的变量来保存处理后的值。在函数中使用变量时，用户需要注意它们的定义方式以及处理方式。这是shell脚本中常见错误的根源。</p>
<h3 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h3><p>函数使用两种类型的变量，分别为全局变量和局部变量。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局变量是在shell脚本中任何地方都有效的变量。如果在脚本的主体部分定义了一个全局 变量，那么可以在函数内读取它的值。同样的，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。 默认情况下，在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a global variable to pass a value</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    value=$[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">read -p "Enter a vluae: " value</div><div class="line">dbl</div><div class="line">echo "The new value is :  $value"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test8.sh</div><div class="line">Enter a vluae: 300</div><div class="line">The new value is :  600</div></pre></td></tr></table></figure>
<p><code>$value</code>变量在函数外定义并被赋值。当dbl函数被调用时，该变量及其值在函数中都依然有效。如果变量在函数内被赋予了新值，那么在脚本中引用该变量时，新值也依然有效。但这操作其实很危险，因为如果是不同的脚本都使用该函数，有可能造成冲突，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating a bad use of variable</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    temp=$[ $value+5 ]</div><div class="line">    result=$[ $temp*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">temp=4</div><div class="line">value=6</div><div class="line"></div><div class="line">func1</div><div class="line">echo "The result is $result"</div><div class="line">if [ $temp -gt $value ]</div><div class="line">then</div><div class="line">    echo "temp is larger"</div><div class="line">else</div><div class="line">    echo "temp is smaller"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest2.sh </div><div class="line">The result is 22</div><div class="line">temp is larger</div></pre></td></tr></table></figure>
<p>由于函数中用到了<code>$temp</code>变量，它的值在脚本中使用时受到了影响，产生了意想不到的后果。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在函数内部，通常无需使用全局变量，使用局部变量即可，要实现这一点，只要在变量声明的前面加上 local 关键字就可以了，例如<code>local temp</code>，local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量， 那么shell将会保持这两个变量的值是分离的。现在你就能很轻松地将函数变量和脚本变量隔离开了，只共享需要共享的变量。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test9.sh</div><div class="line">The result is 22</div><div class="line">temp is smaller</div></pre></td></tr></table></figure>
<p>在 func1 函数中使用<code>$temp</code>变量时，并不会影响在脚本主体中赋给 <code>$temp</code>变量的值。</p>
<h2 id="数组变量和函数"><a href="#数组变量和函数" class="headerlink" title="数组变量和函数"></a>数组变量和函数</h2><h3 id="向函数传数组参数"><a href="#向函数传数组参数" class="headerlink" title="向函数传数组参数"></a>向函数传数组参数</h3><p>如果你试图将该数组变量作为函数参数，函数只会取数组变量的第一个值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Trying to pass an arraya variable</div><div class="line"></div><div class="line">function testit &#123;</div><div class="line">    echo "The parameters are: $@"</div><div class="line">    thisarray=$1</div><div class="line">    echo "The received array is $&#123;thisarray[*]&#125;"</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5)</div><div class="line">echo "The original array is: $&#123;myarray[*]&#125;"</div><div class="line">testit $myarray</div></pre></td></tr></table></figure>
<p> 结果运行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest3b.sh</div><div class="line">The original array is: 1 2 3 4 5</div><div class="line">The parameters are: 1</div><div class="line">The received array is 1</div></pre></td></tr></table></figure>
<p>要解决上述问题，用户必须将该数组变量的值分解成单个的值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ cat test10.sh</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> array variable to function test</div><div class="line">function testit &#123; </div><div class="line">   local newarray </div><div class="line">   newarray=($(echo "$@")) </div><div class="line">   echo "The new array value is: $&#123;newarray[*]&#125;" </div><div class="line">&#125; </div><div class="line"> </div><div class="line">myarray=(1 2 3 4 5) </div><div class="line">echo "The original array is $&#123;myarray[*]&#125;" </div><div class="line">testit $&#123;myarray[*]&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test10.sh</div><div class="line">The original array is 1 2 3 4 5</div><div class="line">The new array value is: 1 2 3 4 5</div></pre></td></tr></table></figure>
<p>该脚本用<code>$myarray</code>变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> adding values in an array</div><div class="line"></div><div class="line">function addarray &#123;</div><div class="line">    local sum=0</div><div class="line">    local newarray</div><div class="line">    newarray=($(echo "$@"))</div><div class="line">    for value in $&#123;newarray[*]&#125;</div><div class="line">    do</div><div class="line">        sum=$[ $sum+$value ]</div><div class="line">    done</div><div class="line">    echo $sum</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5)</div><div class="line">echo "The original array is : $&#123;myarray[*]&#125;"</div><div class="line">arg1=$(echo $&#123;myarray[*]&#125;)</div><div class="line">result=$(addarray $arg1)</div><div class="line">echo "The result is $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test11.sh</div><div class="line">The original array is : 1 2 3 4 5</div><div class="line">The result is 15</div></pre></td></tr></table></figure>
<p>addarray函数会遍历所有的数组元素，将它们累加在一起。你可以在myarray数组变量中放置任意多的值，addarry函数会将它们都加起来。</p>
<h3 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h3><p>从函数里向shell脚本传回数组变量也用类似的方法。函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span>returning an array value</div><div class="line"></div><div class="line">function arraydblr &#123;</div><div class="line">    local origarray</div><div class="line">    local newarray</div><div class="line">    local elements</div><div class="line">    local i</div><div class="line">    origarray=($(echo "$@"))</div><div class="line">    newarray=($(echo "$@"))</div><div class="line">    elements=$[ $# -1 ]</div><div class="line">    for (( i=0;i&lt;=$elements;i++))</div><div class="line">    &#123;</div><div class="line">        newarray[$i]=$[ $&#123;origarray[$i]&#125;*2 ]</div><div class="line">    &#125;</div><div class="line">    echo $&#123;newarray[*]&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5 )</div><div class="line">echo "The original array is: $&#123;myarray[*]&#125;"</div><div class="line">arg1=$(echo $&#123;myarray[*]&#125;)</div><div class="line">result=($(arraydblr $arg1))</div><div class="line">echo "The new array is: $&#123;result[*]&#125;"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test12.sh</div><div class="line">The original array is: 1 2 3 4 5</div><div class="line">The new array is: 2 4 6 8 10</div></pre></td></tr></table></figure>
<p>该脚本用<code>$arg1</code>变量将数组值传给arraydblr函数。arraydblr函数将该数组重组到新的数 组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并 将结果存入函数中该数组变量的副本。 arraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来 重新生成一个新的数组变量。</p>
<h2 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h2><p>函数可以调用函数自身，这个过程就称为函数的递归。下面看一个函数，这个函数就是通过递归来计算阶乘，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using recursion</div><div class="line"></div><div class="line">function factorial &#123;</div><div class="line">    if [ $1 -eq 1 ]</div><div class="line">    then</div><div class="line">        echo 1</div><div class="line">    else</div><div class="line">        local temp=$[ $1 -1 ]</div><div class="line">        local result=$(factorial $temp)</div><div class="line">        echo $[ $result*$1 ]</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">read -p "Enter value: " value</div><div class="line">result=$(factorial $value)</div><div class="line">echo "The factorial of $value is: $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test13.sh</div><div class="line">Enter value: 5</div><div class="line">The factorial of 5 is: 120</div></pre></td></tr></table></figure>
<p>在创建了函数后，可以在其他的脚本中调用。</p>
<h2 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h2><p>如果用户要在多个脚本中使用同一段代码的话，这就需要创建函数库文件，然后在多个脚本中引用该库文件。这个过程的第一步是创建一个包含脚本中所需函数的公用库文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> my script functions </div><div class="line"></div><div class="line">function addem &#123;</div><div class="line">    echo $[ $1+$2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">function multem &#123;</div><div class="line">    echo $[ $1*$2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">function divem &#123;</div><div class="line">    if [ $2 -ne 0 ]</div><div class="line">    then</div><div class="line">        echo $[ $1/$2 ]</div><div class="line">    else</div><div class="line">        echo -1</div><div class="line">    fi</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下一步是在用到这些函数的脚本文件中包含myfuncs库文件。从这里开始，事情就变复杂了。问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。这同样适用于脚本。如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a library file the wrong way</div><div class="line">bash myfuncs.sh</div><div class="line"></div><div class="line">result=$(addem 10 15)</div><div class="line">echo "The result is $result"</div></pre></td></tr></table></figure>
<p>运行后如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest4.sh </div><div class="line">badtest4.sh: line 5: addem: command not found</div><div class="line">The result is</div></pre></td></tr></table></figure>
<p>使用函数库的需要用到<code>source</code>命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。source命令有个快捷的别名，称作<code>点操作符（dotoperator）</code>。要在shell脚本中运行myfuncs库文件，只需添加这一行，即<code>. ./myfuncs</code>(两个点之间有空格），这个例子是假定myfuncs库文件与shell脚本位于同一目录，如果不是，则需要输入全路径。使用source命令的脚本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a library file the wrong way</div><div class="line">. ./myfuncs.sh</div><div class="line"></div><div class="line">value1=10</div><div class="line">value2=5</div><div class="line">result1=$(addem $value1 $value2)</div><div class="line">result2=$(multem $value1 $value2)</div><div class="line">result3=$(divem $value1 $value2)</div><div class="line">echo "The result of adding them is: $result1"</div><div class="line">echo "The result of multiplying them is: $result2"</div><div class="line">echo "The result of dividing them is: $result3"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test14.sh</div><div class="line">The result of adding them is: 15</div><div class="line">The result of multiplying them is: 50</div><div class="line">The result of dividing them is: 2</div></pre></td></tr></table></figure>
<h2 id="在命令行上使用函数"><a href="#在命令行上使用函数" class="headerlink" title="在命令行上使用函数"></a>在命令行上使用函数</h2><p>在命令行界面中也可以使用函数，一旦在shell中定义了函数，用户就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。</p>
<h3 id="在命令行上创建函数"><a href="#在命令行上创建函数" class="headerlink" title="在命令行上创建函数"></a>在命令行上创建函数</h3><h4 id="第1种方法：直接定义函数"><a href="#第1种方法：直接定义函数" class="headerlink" title="第1种方法：直接定义函数"></a>第1种方法：直接定义函数</h4><p>这一种方法使用的是单行试，需要函数主体部分的每个命令后面加上分号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function divem &#123; echo $[ $1/$2 ]; &#125;</div><div class="line">biotest@ubuntu:~/funciton$ divem 100 5</div><div class="line">20</div></pre></td></tr></table></figure>
<p>再看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function doubleit &#123; read -p "Enter value: " value; echo $[ $value*2 ]; &#125;</div><div class="line">biotest@ubuntu:~/funciton$ doubleit</div><div class="line">Enter value: 12</div><div class="line">24</div></pre></td></tr></table></figure>
<h4 id="第2种方法：多行形式"><a href="#第2种方法：多行形式" class="headerlink" title="第2种方法：多行形式"></a>第2种方法：多行形式</h4><p>还可以采用多行方式定义函数，此种情况下，bash shell会用提示符提示输入更多的命令，此种方法不需要在命令后面加分号，直接回车就行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function multem &#123;</div><div class="line"><span class="meta">&gt;</span> echo $[ $1*$2 ]</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line">biotest@ubuntu:~/funciton$ multem 2 5</div><div class="line">10</div></pre></td></tr></table></figure>
<h3 id="在-bashrc文件中定义函数"><a href="#在-bashrc文件中定义函数" class="headerlink" title="在.bashrc文件中定义函数"></a>在<code>.bashrc</code>文件中定义函数</h3><p>在命令行上直接定义shell函数的明显缺点是退出shell时，函数就消失了。对于复杂的函数来说，这种形式并不常用。解决这个问题的方式就是将函数定义在一个特定的位置，这个位置在每次启动一个新shell的时候，都会由shell重新载入。最佳地点就是.bashrc文件。bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。</p>
<h4 id="直接定义函数"><a href="#直接定义函数" class="headerlink" title="直接定义函数"></a>直接定义函数</h4><p>打开<code>.bashrc</code>文件，下拉在文件的末尾处写入函数即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if [ -r /etc/bashrc ];then</div><div class="line">        . /etc/bashrc</div><div class="line">fi</div><div class="line"></div><div class="line">function addem &#123;</div><div class="line">    echo $[ $1 + $2 ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ addem 10 2</div><div class="line">12</div></pre></td></tr></table></figure>
<p>也可以将库文件写入到<code>.bashrc</code>文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if [ -r /etc/bashrc ];then</div><div class="line">        . /etc/bashrc</div><div class="line">fi</div><div class="line"></div><div class="line">. /home/biotest/funciton/myfuncs.sh</div></pre></td></tr></table></figure>
<p>然后<code>source ~/.bashrc，</code>这样在shell中就可以使用myfuncs.sh中的函数了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ addem 10 5</div><div class="line">15</div><div class="line">biotest@ubuntu:~/funciton$ multem 10 5</div><div class="line">50</div><div class="line">biotest@ubuntu:~/funciton$ divem 10 5</div><div class="line">2</div></pre></td></tr></table></figure>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>shtool库提供了一些简单的shell脚本函数，可以用来完成日常的shell功能，例如处理临时文件和目录或者格式化输出显示。</p>
<h3 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget ftp://ftp.gnu.org/gnu/shtool/shtool-2.0.8.tar.gz</div><div class="line">tar -zxvf shtool-2.0.8.tar.gz</div></pre></td></tr></table></figure>
<h3 id="构建库"><a href="#构建库" class="headerlink" title="构建库"></a>构建库</h3><p>shtool文件必须针对特定的Linux环境进行配置。配置工作必须使用标准的configure和make命令，这两个命令常用于C编程环境。要构建库文件，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ ./configure</div><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ make</div></pre></td></tr></table></figure>
<p>configure命令会检查构建shtool库文件所必需的软件。一旦发现了所需的工具，它会使用工具路径修改配置文件。make命令负责构建shtool库文件。最终的结果（shtool）是一个完整的库软件包。也可以使用make命令测试这个库文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make test</div></pre></td></tr></table></figure>
<p>测试模式会测试shtool库中所有的函数。如果全部通过测试，就可以将库安装到Linux系统中的公用位置，这样所有的脚本就都能够使用这个库了。要完成安装，需要使用make命令的install选项。不过需要以root用户的身份运行该命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ sudo make install</div></pre></td></tr></table></figure>
<p> 现在就能在自己的shell脚本中使用这些函数了。 </p>
<h3 id="shtool-库函数"><a href="#shtool-库函数" class="headerlink" title="shtool 库函数"></a>shtool 库函数</h3><p>shtool库提供了大量方便的、可用于shell脚本的函数。如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arx</td>
<td>创建归档文件（包含一些扩展功能）</td>
</tr>
<tr>
<td>Echo</td>
<td>显示字符串，并提供了一些扩展构件</td>
</tr>
<tr>
<td>fixperm</td>
<td>改变目录树中的文件权限</td>
</tr>
<tr>
<td>install</td>
<td>安装脚本或文件</td>
</tr>
<tr>
<td>mdate</td>
<td>显示文件或目录的修改时间</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建一个或更多目录</td>
</tr>
<tr>
<td>Mkln</td>
<td>使用相对路径创建链接</td>
</tr>
<tr>
<td>mkshadow</td>
<td>创建一棵阴影树</td>
</tr>
<tr>
<td>move</td>
<td>带有替换功能的文件移动</td>
</tr>
<tr>
<td>Path</td>
<td>处理程序路径</td>
</tr>
<tr>
<td>platform</td>
<td>显示平台标识</td>
</tr>
<tr>
<td>Prop</td>
<td>显示一个带有动画效果的进度条</td>
</tr>
<tr>
<td>rotate</td>
<td>转置日志文件</td>
</tr>
<tr>
<td>Scpp</td>
<td>共享的C预处理器</td>
</tr>
<tr>
<td>Slo</td>
<td>根据库的类别，分离链接器选项</td>
</tr>
<tr>
<td>Subst</td>
<td>使用sed的替换操作</td>
</tr>
<tr>
<td>Table</td>
<td>以表格的形式显示由字段分隔（field</td>
</tr>
<tr>
<td>tarball</td>
<td>从文件和目录中创建tar文件</td>
</tr>
<tr>
<td>version</td>
<td>创建版本信息文件</td>
</tr>
</tbody>
</table>
</div>
<p>shtool函数的使用格式为<code>shtool [options] [function [options] [args]]</code>。</p>
<h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>下面是一个在shell脚本中使用platform函数的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">shtool platform</div></pre></td></tr></table></figure>
<p>运行后如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test16.sh</div><div class="line">Ubuntu 16.04 (AMD64)</div></pre></td></tr></table></figure>
<p>platform函数会返回Linux发行版以及系统所使用的CPU硬件的相关信息。还有一个函数是prop函数。它可以使用\、|、/和-字符创建一个旋转的进度条。可以告诉shell脚本用户目前正在进行一些后台处理工作。要使用prop函数，只需要将希望监看的输出管接到shtool脚本就行了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ ls -al /usr/bin | shtool prop -p "waiting..."</div><div class="line">waiting...</div></pre></td></tr></table></figure>
<p>prop函数会在处理过程中不停地变换进度条字符。在本例中，输出信息来自于ls命令。你能看到多少进度条取决于CPU能以多快的速度列出/usr/bin中的文件，-p选项允许你定制输出文本，这段文本会出现在进度条字符之前。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">114</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">91</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共438.1k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  










  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine@1.1.4/dist/Valine.min.js"></script>
  <script type="text/javascript">
    new Valine({
        av: AV,
        el: '#vcomments' ,
        verify: true,
        notify: true,
        app_id: '4ORLDMxXCFDLSHPJ4wSSDkkw-gzGzoHsz',
        app_key: 'HSWpCY7XlN0pGV5DCrKoC0ic',
        placeholder: 'Comment input placeholder'
    });
  </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
