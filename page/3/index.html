<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/3/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/3/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/04/Linux-shell06-控制脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/Linux-shell06-控制脚本/" itemprop="url">Shell学习笔记（6）——控制脚本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T12:12:54+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,083
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="控制信号">控制信号</h2>
<p>Linux利用信号与运行在系统中的进程进行通信。通过对脚本进行编程，使其在收到特定信号时执行某些命令，从而控制shell脚本的操作。Linux系统和应用程序可以生成超过30个信息，下表是常见的Linux系统信号：</p>
<h3 id="常见的信号">常见的信号</h3>
<table>
<thead>
<tr class="header">
<th>信号</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>SIGHUP</td>
<td>挂起进程</td>
</tr>
<tr class="even">
<td>2</td>
<td>SIGINF</td>
<td>终止进程</td>
</tr>
<tr class="odd">
<td>3</td>
<td>SIGQUIT</td>
<td>停止进程</td>
</tr>
<tr class="even">
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程</td>
</tr>
<tr class="odd">
<td>15</td>
<td>SIGTERM</td>
<td>尽可能终止进程</td>
</tr>
<tr class="even">
<td>17</td>
<td>SIGSTOP</td>
<td>无条件停止进程，但不是终止进程</td>
</tr>
<tr class="odd">
<td>18</td>
<td>SIGTSTP</td>
<td>停止或暂停进程，但不终止进程</td>
</tr>
<tr class="even">
<td>19</td>
<td>SIGCONT</td>
<td>继续运行停止的进程</td>
</tr>
</tbody>
</table>
<p>默认情况下，bash shell会忽略收到的任何 SIGQUIT (3) 和 SIGTERM (5) 信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的 SIGHUP (1) 和 SIGINT (2) 信号。如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。通过SIGINT信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这种情况发生时，shell会将SIGINT信号传给所有由它所启动的进程，以此告知出现的状况。你可能也注意到了，shell会将这些信号传给shell脚本程序来处理。而shell脚本的默认行为是忽略这些信号。它们可能会不利于脚本的运行。要避免这种情况，你可以脚本中加入识别信号的代码，并执行命令来处理信号。</p>
<h3 id="生成信号">生成信号</h3>
<p>使用键盘上的组合键可以生成2种基本的Linux信号。</p>
<h4 id="中断进程">中断进程</h4>
<p>Ctrl<code>+</code>C<code>会生成</code>SIGINT`信号，将其发送给当前在shell运行中的所有进程，停止shell当前运行的进程，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 500</div><div class="line">^C</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$</div></pre></td></tr></table></figure>
<h4 id="暂停进程">暂停进程</h4>
<p><code>Ctrl</code>+<code>Z</code>可以生成一个SIGTSTP信号，停止shell运行的任何进程，停止进程（stopping）与终止（terminating）进程不同，停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 100</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 sleep 100</div></pre></td></tr></table></figure>
<p>结果中的方括号里的数字是shell分配的作业号（job number），shell将运行中的每个进程称为作为，并为每个作业分配有唯一的作业号，第一个作业分配的是作业号1，第二个是2。如果shell会话中有一个已经停止的作业，在退出shell时，bash会提醒用户，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 100</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 sleep 100</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ^C</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ exit</div><div class="line">exit</div><div class="line">There are stopped jobs.</div></pre></td></tr></table></figure>
<p>通过ps命令可以查看已经停止的作业，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ps -l</div><div class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">0 S  1000  10009  10002  0  80   0 -  5700 wait   pts/4    00:00:01 bash</div><div class="line">0 T  1000  28664  10009  0  80   0 -  1822 signal pts/4    00:00:00 sleep</div><div class="line">0 R  1000  28674  10009  0  80   0 -  7229 -      pts/4    00:00:00 ps</div></pre></td></tr></table></figure>
<p>在S列（进程状态），ps命令将已经停止作业的状态显示为T，这说明命令要么被跟踪，要么被停止了。如果在有已停止作业存在的情况下，你仍旧想退出shell，只要再输入一遍 exit 命令就行了。shell会退出，终止已停止作业。或者，既然你已经知道了已停止作业的PID，就可以用 kill 命令来发送一个 SIGKILL 信号来终止它(-9表示强迫终止）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ kill -9 28664</div><div class="line">[1]+  Killed                  sleep 100</div></pre></td></tr></table></figure>
<h3 id="捕获信号">捕获信号</h3>
<p>在信号出现时捕获它们并执行其他命令时用<code>trap</code>，此命令可以指定shell脚本要监视并从shell中拦截的Linux信号，如果脚本收到了trap命令中列出的信号，此信号不再由shell处理，则是交给本地处理，trap的用法为<code>trap commands signals</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing signla trapping</div><div class="line"></div><div class="line">trap "echo ' Sorry! I have trapped Ctrl-C'" SIGINT</div><div class="line"></div><div class="line">echo This is a test script</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">echo "This is the end of the test script"</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test1.sh </div><div class="line">This is a test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #6</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #7</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #8</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #9</div><div class="line">Loop #10</div><div class="line">This is the end of the test script</div></pre></td></tr></table></figure>
<p>在这个案例中，使用了trap命令，在检测到SIGINT信号时，就会显示一行简单的文本消息，捕获这些信号会阻止用户使用bash shell组合键<code>Ctrl</code>+<code>C</code>来停止程序。也就是说每次使用组合键<code>Ctrl</code>+<code>C</code>时，脚本就都会执行<code>trap</code>命令中指定的<code>echo</code>语句，而不是处理该信号并允许shell停止该脚本。</p>
<h3 id="捕获脚本退出">捕获脚本退出</h3>
<p>shell脚本在退出时也能进行捕获，这是在shell完成任务时执行命令的一种简便方法，用法是在trap命令后加上EXIT信号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Trapping the script exit</div><div class="line"><span class="meta">#</span></div><div class="line">trap "echo Goodbye..." EXIT</div><div class="line"><span class="meta">#</span></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test2.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Goodbye...</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ bash test2.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">^CGoodbye...</div></pre></td></tr></table></figure>
<p>当脚本运行到正常的退出位置时，捕获就被触发了，shell会执行在trap命令行指定的命令。如果提前退出脚本，同样能够捕获到EXIT。这是因为SIGINT信号并没有出现在trap命令的捕获列表中，当按下Ctrl+C组合键发送SIGINT信号时，脚本就退出了。但在脚本退出前捕获到了EXIT，于是shell执行了trap命令。</p>
<h3 id="修改或移除捕获">修改或移除捕获</h3>
<p>要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Modifying a set trap</div><div class="line"></div><div class="line">trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">trap "echo 'I modified the trap!'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Second Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test3.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">^C Sorry...Ctrl-C is trapped.</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Second Loop #1</div><div class="line">^CI modified the trap!</div><div class="line">Second Loop #2</div><div class="line">Second Loop #3</div><div class="line">Second Loop #4</div><div class="line">Second Loop #5</div></pre></td></tr></table></figure>
<p>修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的 trap 命令进行处理。 也可以删除已设置好的捕获。只需要在 trap 命令与希望恢复默认行为的信号列表之间加上两个破折号就行了。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> removing a set trap</div><div class="line"></div><div class="line">trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">   echo "Loop #$count"</div><div class="line">   sleep 1</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span> Remove the trap</div><div class="line">trap -- SIGINT</div><div class="line">echo "I just removed the trap"</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">   echo "Second Loop #$count"</div><div class="line">   sleep 1</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test3b.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">^C Sorry...Ctrl-C is trapped.</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">I just removed the trap</div><div class="line">Second Loop #1</div><div class="line">Second Loop #2</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>移除信号捕获后，脚本按照默认行为来处理 SIGINT 信号，也就是终止脚本运行。但如果信号是在捕获被移除前接收到的，那么脚本会按照原先 trap 命令中的设置进行处理。 在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，脚本会照旧执行 trap 中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。</p>
<h2 id="后台模式运行脚本">后台模式运行脚本</h2>
<p>有些脚本不会在终端的显示器上显示，而是在后台（background）运行，在后台模式中，进行运行不会与STDIN、STDOUT以及STDERR发生关联。</p>
<h3 id="后台运行脚本">后台运行脚本</h3>
<p>打开后台模式运行脚本霜肆在脚本后面添加上<code>&amp;</code>符号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> test running in the background</div><div class="line"><span class="meta">#</span></div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count + 1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test4.sh &amp;</div><div class="line">[1] 28920</div><div class="line">biotest@ubuntu:~/signal$ ps </div><div class="line">   PID TTY          TIME CMD</div><div class="line"> 10009 pts/4    00:00:01 bash</div><div class="line"> 28920 pts/4    00:00:00 bash</div><div class="line"> 28923 pts/4    00:00:00 sleep</div><div class="line"> 28924 pts/4    00:00:00 ps</div><div class="line"> </div><div class="line"> # 按回车键</div><div class="line"> biotest@ubuntu:~/signal$ </div><div class="line">[1]+  Done                    bash test4.sh</div></pre></td></tr></table></figure>
<p>从结果可以看出，当 &amp; 符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后 台进程运行。显示的第一行是[1] 28920，其中[1]是shell分配给后台进程的作业号。28920是进程号。在运行结束后，按回车键，脚本会在终端显示消息（<code>[1]+ Done...</code>），就是结果的最后一部分，这表明了作业的作业号以及作业状态（Done）。当脚本在后台运行时，它仍然会使用终端显示器来显示STDOUT和STDERR，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Test running in the background with output</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span></div><div class="line">echo "Start the test script"</div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 5</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"><span class="meta">#</span></div><div class="line">echo "Test script is complete"</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test5.sh &amp;</div><div class="line">[1] 28986</div><div class="line">biotest@ubuntu:~/signal$ Start the test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Test script is complete</div><div class="line"></div><div class="line">[1]+  Done                    bash test5.sh</div></pre></td></tr></table></figure>
<p>在这个案例中，脚本test5.sh的输出与shell提示符混杂在一歧异，这也是为什么Start the test script会出现在提示符普边的原因。在显示输出的同时，仍然可以运行命令，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ Start the test script</div><div class="line">Loop #1</div><div class="line">ls</div><div class="line">test1.sh  test2.sh  test3b.sh  test3.sh  test4.sh  test5.sh</div></pre></td></tr></table></figure>
<p>当脚本test5.sh运行在后台模式时，输入了命令ls。脚本输出、输入的命令以及命令输出全都混在了一起。针对这种情况，最好是将后台运行的脚本的STDOUT和STDERR进行重定向，避免这种杂乱的输出。</p>
<h3 id="运行多个后台作业">运行多个后台作业</h3>
<p>可以在命令行提示符下同时启动多个后台作业，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test6.sh &amp;</div><div class="line">[2] 29019</div><div class="line">[1]   Done                    bash test5.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test6.sh: No such file or directory</div><div class="line">bash test7.sh &amp;</div><div class="line">[3] 29020</div><div class="line">[2]   Exit 127                bash test6.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test7.sh: No such file or directory</div><div class="line">bash test8.sh &amp;</div><div class="line">[4] 29021</div><div class="line">[3]   Exit 127                bash test7.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test8.sh: No such file or directory</div><div class="line">ps</div><div class="line">   PID TTY          TIME CMD</div><div class="line"> 10009 pts/4    00:00:01 bash</div><div class="line"> 29022 pts/4    00:00:00 ps</div><div class="line">[4]+  Exit 127                bash test8.sh</div></pre></td></tr></table></figure>
<p>每次启动新作业时，Linux系统都会为其分配一个新的作业号和PID。通过 ps 命令，可以看到所有脚本处于运行状态。 在终端会话中使用后台进程时一定要小心。注意，在ps命令的输出中，每一个后台进程都和终端会话（pts/0）终端联系在一起。如果终端会话退出，那么后台进程也会随之退出。</p>
<h2 id="nohup命令">nohup命令</h2>
<p>在有些情况下，用户会终端会话中启动shell脚本，即使退出了终端会话，脚本也会一直在后台模式运行，直到结束。这可以用nohup命令来实现。nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会话时阻止进程退出。nohup命令的格式为<code>nohup commands &amp;</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nohup bash test1.sh &amp;</div><div class="line">[1] 29325</div><div class="line">biotest@ubuntu:~/signal$ nohup: ignoring input and appending output to 'nohup.out'</div></pre></td></tr></table></figure>
<p>shell会给命令分配一个作业号，Linux系统会为其分配一个PID号。与shell中的普通进程相比，区 别在于，当使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号。 由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。 为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为 nohup.out的文件中。如果使用nohup运行了另一个命令，该命令的输出会被追加到已有的nohup.out文件中。因此，当运行位于同一个目录中的多个命令时一定要小心，因为所有的输出都会被发送到同一个nohup.out文件中，结果会让人摸不清头脑。</p>
<p>nohup.out文件包含了通常会发送到终端显示器上的所有输出。在进程完成运行后，你可以查 看nohup.out文件中的输出结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ ls</div><div class="line">nohup.out  test1.sh  test2.sh  test3b.sh  test3.sh  test4.sh  test5.sh</div><div class="line">biotest@ubuntu:~/signal$ cat nohup.out </div><div class="line">This is a test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Loop #6</div><div class="line">Loop #7</div><div class="line">Loop #8</div><div class="line">Loop #9</div><div class="line">Loop #10</div><div class="line">This is the end of the test script</div></pre></td></tr></table></figure>
<h2 id="作业控制">作业控制</h2>
<p>在作业停止后，Linux系统会让用户选择是终止还是重启。用户可以用kill命令终止该进程。要重启停止的进程需要向其发送一个SIGCONT信号。启动、停止、终止以及恢复作业的这些功能统称为<strong>作业控制</strong>。通过作业控制，就能完全控制shell环境中所有进程的运行方式。</p>
<h3 id="查看作业">查看作业</h3>
<p>查看作业的命令是<code>jobs</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> test job control</div><div class="line"></div><div class="line">echo "Script process ID: $$"</div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 10</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "End of script ..."</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh</div><div class="line">Script process ID: 29360</div><div class="line">Loop #1</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10.out &amp;</div><div class="line">[2] 29364</div><div class="line">biotest@ubuntu:~/signal$ jobs</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line">[2]-  Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[1]+ 29360 Stopped                 bash test10.sh</div><div class="line">[2]- 29364 Running                 bash test10.sh &gt; test10.out &amp;</div></pre></td></tr></table></figure>
<p>代码及结果解释：脚本使用<code>$$</code>变量业显示Linux系统分配给此脚本的PID，然后进入循环，每次迭代都休眠10秒，可以从命令行中启动脚本，然后使用<code>Ctrl</code>+<code>Z</code>停止脚本。随后又使用了<code>&amp;</code>操作将另外一个作用设为后台进程启动，出于简化目的，在这个案例中，脚本的输出被重定向到文件中，避免出现在屏幕上。<code>jobs</code>命令可以查看分配给Shell的作用，jobs命令显示了2个已经停止/运行中的作用，以及它们的作业号和作业中使用的命令。如果使用<code>job -l</code>则会业显示作用的PID，有关jobs命令的一些参数，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-l</td>
<td>列出进程的PID以及作业号</td>
</tr>
<tr class="even">
<td>-n</td>
<td>只列出上次shell发出的通知后改变了状态的作业</td>
</tr>
<tr class="odd">
<td>-p</td>
<td>只列出作业的PID</td>
</tr>
<tr class="even">
<td>-r</td>
<td>只列出运行中的作业</td>
</tr>
<tr class="odd">
<td>-s</td>
<td>只列出已停止的作业</td>
</tr>
</tbody>
</table>
<p>jobs命令输出中有加号和减号。带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候，不管shell中有多少个正在运行的作业，shell中都只有一个带加号的作业和一个带减号的作业。</p>
<p>下面例子说明了队列中的下一个作业在默认作业移除时是如何成为默认作业的。有3个独立的进程在后台被启动。jobs命令显示出了这些进程、进程的PID及其状态。注意，默认进程（带有加号的那个）是最后启动的那个进程，也就是3号作业。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10a.out &amp;</div><div class="line">[2] 29402</div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10.out &amp;</div><div class="line">[3] 29404</div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10c.out &amp;</div><div class="line">[4] 29409</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[2]+ 29402 Running                 bash test10.sh &gt; test10a.out &amp;</div><div class="line">[3]  29404 Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">[4]- 29409 Running                 bash test10.sh &gt; test10c.out &amp;</div><div class="line">biotest@ubuntu:~/signal$ kill 29402</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[3]+ 29404 Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">[4]- 29409 Terminated              bash test10.sh &gt; test10c.out</div><div class="line">biotest@ubuntu:~/signal$ kill 29404</div><div class="line"><span class="meta">#</span> 调用了 kill 命令向默认进程发送了一个 SIGHUP 信号，终止了该作业。在接下来的 jobs</div><div class="line"><span class="meta">#</span> 命令输出中，先前带有减号的作业成了现在的默认作业，减号也变成了加号。</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[3]+ 29409 Terminated              bash test10.sh &gt; test10.out</div></pre></td></tr></table></figure>
<h3 id="重启停止的作业">重启停止的作业</h3>
<p>在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你当前工作的终端，所以在使用该功能时要小心，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh</div><div class="line">Script process ID: 29612</div><div class="line">Loop #1</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line">biotest@ubuntu:~/signal$ bg</div><div class="line">[1]+ bash test10.sh &amp;</div><div class="line">biotest@ubuntu:~/signal$ jobs</div><div class="line">[1]+  Running                 bash test10.sh &amp;</div></pre></td></tr></table></figure>
<p>因为该作业是默认作业（从加号可以看出），只需要使用bg命令就可以将其以后台模式重启。 注意，当作业被转入后台模式时，并不会列出其PID。如果有多个作业，需要在<code>bg</code>命令后加上作业号，如果要以前台模式恢复运行，则用<code>fg</code>加上作业号。</p>
<h2 id="调整优先级">　调整优先级</h2>
<p>在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。调度优先级是个整数值，从20（最高优先级）到+19（最低优先级）。默认情况下，bashshell以优先级0来启动所有进程。</p>
<p>有时用户要改变一个shell脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他 进程过多的处理能力），还是给予它更高的优先级（这样它就能获得更多的处理时间），都可以通过<code>nice</code>这个命令达到目的。</p>
<h3 id="nice命令">nice命令</h3>
<p>nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice的-n命令行来指定新的优先级级别。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -n 10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[2] 29646</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29646 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line">[2]-  Done                    nice -n 10 bash test4.sh &gt; test4.out</div></pre></td></tr></table></figure>
<p>注意，必须将nice命令和要启动的命令放在同一行中。ps命令的输出验证了谦让度值（NI列）已经被调整到了10。</p>
<p>nice命令会让脚本以更低的优先级运行。但如果想提高某个命令的优先级，普通用户则无法实现,如下所示:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -n -10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[2] 29677</div><div class="line">biotest@ubuntu:~/signal$ nice: cannot set niceness: Permission denied</div></pre></td></tr></table></figure>
<p>nice命令阻止普通系统用户来提高命令的优先级。注意，指定的作业的确运行了，但是试图使用nice命令提高其优先级的操作却失败了,这很好,理解计算机的资源是有限有，用户可以将自己的作业推后，但是你不能提前。nice命令的-n选项并不是必须的，只需要在破折号后面跟上优先级就行了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[3] 29691</div><div class="line">[2]   Done                    nice -n -10 bash test4.sh &gt; test4.out</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29691 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line">[3]-  Done                    nice -10 bash test4.sh &gt; test4.out</div></pre></td></tr></table></figure>
<h3 id="renice命令">renice命令</h3>
<p><code>renice</code>命令可以改变系统上已经运行命令的优先级，它允许用户指定运行进程的PID来改变它的优先级，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &amp;</div><div class="line">[2] 29718</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29718 -o pid,Loop #3</div><div class="line">ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line"> 29718  10009   0 bash test10.sh</div><div class="line">biotest@ubuntu:~/signal$ renice -n 10 -p 29718</div><div class="line">29718 (process ID) old priority 0, new priority 10</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29718 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line"> 29718  10009  10 bash test10.sh</div></pre></td></tr></table></figure>
<p>renice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一些限制：第一，只能对属于用户自身的进程执行renice；只能通过renice降低进程的优先级；root用户可以通过renice来任意调整进程的优先级。如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令。</p>
<h2 id="定时运行作业">定时运行作业</h2>
<p><code>at</code>命令和<code>cron</code>表可以指定用户在某个时间运行脚本。</p>
<h3 id="at命令"><code>at</code>命令</h3>
<p>at命令允许指定Linux系统何时运行脚本。at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程atd会以后台模式运行，检查作业队列来运行作业。atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下，atd守护进程会每60秒检查一下这个目录。有作业时，atd守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配，atd守护进程就会运行此作业。</p>
<h4 id="at命令的格式">at命令的格式</h4>
<p>at命令的格式at命令的基本格式为：<code>at [-f filename ] time</code></p>
<p>默认情况下，at命令会将STDIN的输入放到队列中。用户可以用-f参数来指定用于读取命令（脚本文件）的文件名。time参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过，at命令会在第二天的那个时间运行指定的作业。at命令能识别多种不同的时间格式。</p>
<ol style="list-style-type: decimal">
<li>标准的小时和分钟格式，比如10:15。</li>
<li>AM/PM指示符，比如10:15 PM。</li>
<li>特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。 除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。</li>
<li>标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。</li>
<li>文本日期，比如Jul 4或Dec 25，加不加年份均可。</li>
<li>可以指定时间增量（例如当前时间+25min；明天10:15 PM；10:15 + 7days）。</li>
</ol>
<p>在使用at命令时，该作业会被提交到作业队列（jobqueue）。作业队列会保存通过at命令提交的待处理的作业。针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a<sub>z和大写字母A</sub>Z来指代。作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的作业会被提交到a作业队列。如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。</p>
<h4 id="获取作业的输出">获取作业的输出</h4>
<p>当作业在Linux系统上运行时，显示器并不会关联到该作业。取而代之的是，Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给该用户。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>注：Ubuntu上可能没有安装<code>at</code>，需要自己手动安装。at命令会显示分配给作业的作业号以及为作业安排的运行时间。-f选项指明使用哪个脚本 文件，now指示at命令立刻执行该脚本。</p>
<p>使用e-mail作为at命令的输出极其不便。at命令利用sendmail应用程序来发送邮件。如果你的系统中没有安装sendmail，那就无法获得任何输出，因此在使用at命令时，最好在脚本中对STDOUT和STDERR进行重定向，如下例所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Test using at command</div><div class="line"></div><div class="line">echo "This script ran at $(date +%B%d,%T)" &gt; test13b.out</div><div class="line">echo &gt;&gt; test13b.out</div><div class="line">sleep 5</div><div class="line">echo "This is the script's end ..." &gt;&gt; test13b.out</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ chmod u+x test13b.sh</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh now</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 3 at Sun May  6 05:10:00 2018</div><div class="line">biotest@ubuntu:~/signal$ cat test13b.out</div><div class="line">This script ran at May06,05:10:51</div><div class="line"></div><div class="line">This is the script's end ...</div></pre></td></tr></table></figure>
<p>如果不想在at命令中使用邮件或重定向，最好加上-M选项来屏蔽作业产生的输出信息。</p>
<h4 id="列出等待的作业">列出等待的作业</h4>
<p>atq命令可以查看系统中有哪些作业在等待，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh teatime</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 4 at Sun May  6 16:00:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh tomorrow</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 5 at Mon May  7 05:16:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh 13:30</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 6 at Sun May  6 13:30:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh now</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 7 at Sun May  6 05:16:00 2018</div><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">2	Sun May  6 05:06:00 2018 = biotest</div><div class="line">7	Sun May  6 05:16:00 2018 = biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div></pre></td></tr></table></figure>
<p>作业列表中显示了作业号、系统运行该作业的日期和时间及其所在的作业队列。</p>
<h4 id="删除作业">删除作业</h4>
<p>一旦知道了哪些作业在作业队列中等待，就能用 atrm 命令来删除等待中的作业。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">2	Sun May  6 05:06:00 2018 = biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div><div class="line">biotest@ubuntu:~/signal$ atrm 2</div><div class="line">Warning: deleting running job</div><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div></pre></td></tr></table></figure>
<h3 id="cron时间表">cron时间表</h3>
<p>如果用户需要脚本在每天的同一时间运行或是每周一次、每月一次运行，就要使用cron程序来安排要定期执行的作业。cron程序会在后台运行并检查一个特殊的表（被称作cron时间表），以获知已安排执行的作业。</p>
<h4 id="cron时间表-1">cron时间表</h4>
<ol style="list-style-type: decimal">
<li>cron时间表采用一种特别的格式来指定作业何时运行。其格式为<code>min hour dayofmonth month dayofweek command</code>，cron时间表允许你用特定值、取值范围（比如1~5）或者是通配符（星号）来指定条目。</li>
<li>例如，如果想在每天的10:15运行一个命令，可以用cron时间表条目：<code>15 10 * * * command</code>，在<code>dayofmonth</code>、<code>month</code>以及<code>dayofweek</code>字段中使用了通配符，表明cron会在每个月每天的10:15执行该命令。要指定在每周一4:15PM运行的命令，可以用这样的命令，即<code>15 16 * * 1 command</code>。</li>
<li>可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）来指定dayofweek表项。 再看一个例子，如果要在每个月的第一天中午12点执行命令。可以用这样的命令，即<code>00 12 1 * * command</code>，dayofmonth表项指定月份中的日期值（1~31）。</li>
<li>如何设置一个在每个月的最后一天执行的命令，因为无法设置dayofmonth的值来涵盖所有的月份。常用的方法是加一条使用date 命令的 if-then 语句来检查明天的日期是不是01，如下所示：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 12 * * * if [ ` date +%d -d tomorrow `  = 01 ] ; then ; command</div></pre></td></tr></table></figure>
<p>上述这段代码会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。</p>
<ol start="5" style="list-style-type: decimal">
<li>命令列表必须指定要运行的命令或脚本的全路径名。你可以像在普通的命令行中那样，添加任何想要的命令行参数和重定向符号。 <code>15 10 * * * /home/biotest/test4.sh &gt; test4out</code>，cron程序会用提交作业的用户账户运行该脚本。因此，用户必须有访问该命令和命令中指定的输出文件的权限。</li>
</ol>
<h4 id="构建cron时间表">构建cron时间表</h4>
<p>每个系统用户（包括root用户）都可以用自己的cron时间表来运行安排好的任务。Linux提供了crontab命令来处理cron时间表。要列出已有的cron时间表，可以用-l选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ crontab -l</div><div class="line">no crontab for biotest</div></pre></td></tr></table></figure>
<p>默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。 在添加条目时，crontab命令会启用一个文本编辑器，使用已有的cron时间表作为文件内容，如果时间表不存在的话，它会新建一个空文件。</p>
<h4 id="浏览cron目录">浏览cron目录</h4>
<p>如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个基本目录：hourly、daily、monthly和weekly。 Ubuntu无此目录，略过。</p>
<h4 id="anacron程序">anacron程序</h4>
<p>cron程序的唯一问题是它假定Linux系统是7×24小时运行的。如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问题，许多Linux发行版还包含了anacron程序。如果anacron知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果Linux系统关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行。这个功能常用于进行常规日志维护的脚本。如果系统在脚本应该运行的时间刚好关机，日志文件就不会被整理，可能会变很大。通过anacron，至少可以保证系统每次启动时整理日志文件。anacron程序只会处理位于cron目录的程序，比如/etc/cron.monthly。它用时间戳来决定作业是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/anacron，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ sudo cat /var/spool/anacron/cron.monthly</div><div class="line">[sudo] password for biotest: </div><div class="line">20180427</div></pre></td></tr></table></figure>
<p>anacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ sudo cat /etc/anacrontab </div><div class="line"><span class="meta">#</span> /etc/anacrontab: configuration file for anacron</div><div class="line"></div><div class="line"><span class="meta">#</span> See anacron(8) and anacrontab(5) for details.</div><div class="line"></div><div class="line">SHELL=/bin/sh</div><div class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">HOME=/root</div><div class="line">LOGNAME=root</div><div class="line"></div><div class="line"><span class="meta">#</span> These replace cron's entries</div><div class="line">1	5	cron.daily	run-parts --report /etc/cron.daily</div><div class="line">7	10	cron.weekly	run-parts --report /etc/cron.weekly</div><div class="line">@monthly	15	cron.monthly	run-parts --report /etc/cron.monthly</div></pre></td></tr></table></figure>
<p>anacron时间表的基本格式和cron时间表略有不同，前者的格式为<code>period delay identifier command。</code></p>
<p>period条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。command条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的任何脚本。注意，anacron不会运行位于/etc/cron.hourly的脚本。这是因为anacron程序不会处理执行时间需求小于一天的脚本。identifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误邮件中的作业。</p>
<h2 id="使用新-shell-启动脚本">使用新 shell 启动脚本</h2>
<p>如果每次运行脚本的时候都能够启动一个新的bashshell（即便只是某个用户启动了一个bashshell），将会非常的方便。有时候，用户希望为shell会话设置某些shell功能，或者只是为了确保已经设置了某个文件。用户登入bashshell时需要运行的启动文件基本上依照下列顺序所找到的第一个文件会被运行，其余的文件会被忽略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$HOME/.bash_profile </div><div class="line">$HOME/.bash_login </div><div class="line">$HOME/.profile</div></pre></td></tr></table></figure>
<p>因此，应该将需要在登录时运行的脚本放在上面第一个文件中。每次启动一个新shell时，bash shell都会运行.bashrc文件。可以这样来验证：在主目录下的.bashrc文件中加入一条简单的echo语句，然后启动一个新shell。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> source global definitions</div><div class="line">if [ -f /etc/bashrc ]; then</div><div class="line">          . /etc/bashrc</div><div class="line">fi</div><div class="line"><span class="meta">#</span> User specific aliases and functions</div><div class="line">echo "I'm in a new shell!"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash</div><div class="line">I&apos;m in a new shell!</div><div class="line">biotest@ubuntu:~$ exit</div><div class="line">exit</div></pre></td></tr></table></figure>
<p>.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是当你登入bashshell时，另一次是当你启动一个bashshell时。如果你需要一个脚本在两个时刻都得以运行，可以把这个脚本放进该文件中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/03/Linux-shell05-理解shell的重定向/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/Linux-shell05-理解shell的重定向/" itemprop="url">Shell学习笔记（5）——理解Shell的重定向</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T00:00:01+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,079
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解输入与输出">理解输入与输出</h2>
<p>脚本的两种显示方法就是：第一，在显示器屏幕上显示输出；第二，将输出重定向到文件。这篇笔记主要是理解Linux如何处理输入与输出的。</p>
<h3 id="标准文件描述符">标准文件描述符</h3>
<p>Linux系统将每个对象当作文件处理，这就包括了输入和输出过程，Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，每个进程最多可以有9个文件描述符，而bash shell保留了前3个文件描述符，即0、1和2。</p>
<table>
<thead>
<tr class="header">
<th>文件描述符</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr class="even">
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr class="odd">
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
<p>这三个特殊文件描述符会处理脚本中的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</p>
<h3 id="stdin">STDIN</h3>
<p>STDIN文件描述符代表了shell的标准输入，对于终端来说，标准输入就是键盘，shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上的键输入的。许多bash命令能接受STDIN的输入，尤其是在命令行上指定文件的话。下面看一下<code>cat</code>这个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat</div><div class="line">test cat command</div><div class="line">test cat command</div><div class="line">cat command can input from keyboard</div><div class="line">cat command can input from keyboard</div></pre></td></tr></table></figure>
<p>当在命令行上只输入<code>cat</code>时，它会从<code>STDIN</code>接受僌，输入一行，<code>cat</code>命令就会显示出一行。但也可以通过<code>STDIN</code>重定向符号强制<code>cat</code>命令接受来自另一个非<code>STDIN</code>文件的输入，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat testfile </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div><div class="line">biotest@ubuntu:~/input$ cat &lt; testfile </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div></pre></td></tr></table></figure>
<p>这个结果显示，cat命令会用testfile文件中的行作为输入。</p>
<h3 id="stdout">STDOUT</h3>
<p><code>STDOUT</code>文件描述符代表shell的标准输出。在终端界面上，标准输出应时终显示器。Shell的所有输出（包括shell文中运行的程序和脚本）会被定向到标准输出中，也就是显示器。默认情况下，大多数bash命令会将输出导向STDOUT文件描述符，也可以使用输出重定向来改变，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -l &gt; test2</div><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div></pre></td></tr></table></figure>
<p>使用<code>&gt;&gt;</code>符号可以向一个文件中追加数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div><div class="line">biotest@ubuntu:~/input$ who</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">biotest@ubuntu:~/input$ who &gt;&gt; test2</div><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div></pre></td></tr></table></figure>
<p>当某个主文件不存在时，无产进行重定向，但会生成要重定向的文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al badfile &gt; test3</div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">biotest@ubuntu:~/input$ cat test3</div></pre></td></tr></table></figure>
<p>由于不存在badfile文件，因此bash无法获取里面的信息，也无法将其信息重定向到test3，但是test3这个文件会被创建，只是里面是空的。</p>
<h3 id="stderr">STDERR</h3>
<p><code>STDERR</code>文件描述符被设成2，可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al badfile 2&gt; test3</div><div class="line">biotest@ubuntu:~/input$ cat test3</div><div class="line">ls: cannot access 'badfile': No such file or directory</div></pre></td></tr></table></figure>
<p>此时，错误消息不会出现在屏幕上，该命令生怕任何错误消息都会保存在输出文件中，用这种方法，shell只重定向错误消息，而非普通数据。下面的一个案例是将<code>STDOUT</code>和<code>STDERR</code>消息混杂在同一个输出中的例子，如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test badtest test2 2&gt; test5</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">biotest@ubuntu:~/input$ cat test5</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div></pre></td></tr></table></figure>
<p>ls命令的正常<code>STDOUT</code>输出仍然公改善到默认的<code>STDOUT</code>文件描述符，也就是显示器，由于该命令将文件描述符2的输出（<code>STDERR</code>）重定向到了一个输出文件，shell将生成的所有错误消息直接改善到指定的重定向文件中。</p>
<h4 id="重定向错误和数据">重定向错误和数据</h4>
<p>如果想重定向错误和正常输出，需要用2个重定向符号，需要在符号前放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</div><div class="line">biotest@ubuntu:~/input$ cat test6</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div><div class="line">biotest@ubuntu:~/input$ cat test7</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest  55 May  5 19:48 test3</div></pre></td></tr></table></figure>
<p>在这个案例中，shell利用<code>1&gt;</code>符号将ls命令的正常输出重定向到了<code>test7</code>文件，而这些输出本该是进入<code>STDOUT</code>的。所有本该输出到<code>STDERR</code>的错误消息通过<code>2&gt;</code>符号被重定向到了<code>test6</code>文件。 这种方法哦可以将脚本的正常输出和脚本的错误消息分离开来。</p>
<p>除此之外，还可以将<code>STDERR</code>和<code>STDOUT</code>的输出重定向到同一个输出文件，可以使用特殊的重定向符号<code>$&gt;</code>，如下所示：：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test test2 test3 badtest &amp;&gt; test7</div><div class="line">biotest@ubuntu:~/input$ cat test7</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest  55 May  5 19:48 test3</div></pre></td></tr></table></figure>
<p>当使用<code>&amp;&gt;</code>符号哩主，命令生成的所有输出都会改善到同一位置，包括数据和错误。bash shell会自动赋予错误消息更高的优先级，在输出文件的最开头部分显示错误消息。</p>
<h2 id="在脚本中重定向输出">在脚本中重定向输出</h2>
<p>有2种方法在脚本中重定向输出，第一，临时重定向行输出；第二，永久重定向脚本中的所有命令。</p>
<h3 id="临时重定向">临时重定向</h3>
<p>如果脚本中意外生成错误消息，可以将单独的一行输出重定向到<code>STDERR</code>，在重定向到文件描述符时，需要在文件描述符前面添加一具<code>&amp;</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing STDERR messages</div><div class="line"></div><div class="line">echo "This is an error" &gt;&amp;2</div><div class="line">echo "This is normal output"</div></pre></td></tr></table></figure>
<p>运行过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test8.sh</div><div class="line">biotest@ubuntu:~/input$ ./test8.sh</div><div class="line">This is an error</div><div class="line">This is normal output</div><div class="line">biotest@ubuntu:~/input$ ./test8.sh 2&gt;test9</div><div class="line">This is normal output</div><div class="line">biotest@ubuntu:~/input$ cat test9</div><div class="line">This is an error</div></pre></td></tr></table></figure>
<p>从结果可以看出，STDOUT显示的文件会出现在屏幕上，而发送给STDERR的echo语句的文本则被重定向到了输出文件。这个方便适合在脚本中生成错误的消息。</p>
<h3 id="永久重定向">永久重定向</h3>
<p>如果脚本中有大量数据需要重定向，则可以使用<code>exec</code>命令告诉shell脚本执行期间重定向某个特定文件的描述符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting all output to a file</div><div class="line">exec 1&gt; testout</div><div class="line"></div><div class="line">echo "This is a test of redirecting all output"</div><div class="line">echo "from a script to another file."</div><div class="line">echo "without having to redirect every individual line"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test10.sh</div><div class="line">biotest@ubuntu:~/input$ ./test10.sh</div><div class="line">biotest@ubuntu:~/input$ cat testout</div><div class="line">This is a test of redirecting all output</div><div class="line">from a script to another file.</div></pre></td></tr></table></figure>
<p><code>exec</code>命令会启动一个新的shell，并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。可以在脚本执行过程中重定向STDOUT，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting output to different locatons</div><div class="line"></div><div class="line">exec 2&gt; testerror</div><div class="line"></div><div class="line">echo "This is the start of the script"</div><div class="line">echo "now redirecting all output to another location"</div><div class="line"></div><div class="line">exec 1&gt; testout</div><div class="line"></div><div class="line">echo "THis output should go to the testout file"</div><div class="line">echo "but this should go to the testerror file" &gt;&amp;2</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test11.sh</div><div class="line">biotest@ubuntu:~/input$ ./test11.sh</div><div class="line">This is the start of the script</div><div class="line">now redirecting all output to another location</div><div class="line">biotest@ubuntu:~/input$ cat testerror</div><div class="line">but this should go to the testerror file</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将发给STDERR的输出重定向到了文件testerror，接下来，脚本用echo语句向STDOUT显示了几行文本，随后再次使用exec命令来将STDOUT重定向到了testout文件，虽然STDOUT被重定向了，但仍然可以将echo语句的输出发给STDERR，在此案例中，重定向到了testerror文件。</p>
<h2 id="在脚本中重定向输入">在脚本中重定向输入</h2>
<p>在脚本中可以使用与重向STDOUT和STDERR同样的方法来将STDIN从键盘重定向到其他位置。exec命令可以将STDIN重定向到linux系统上的文件中，用法是<code>exec 0&lt; testfile</code>，这个命令会告诉shell应该从文件testfile中获得输入，而不是<code>STDIN</code>，这个重定向只要在脚本需要输入时就会作用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting fiel input</div><div class="line"></div><div class="line">exec 0&lt; testfile</div><div class="line">count=1</div><div class="line"></div><div class="line">while read line</div><div class="line">do</div><div class="line">    echo "Line #$count: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test12.sh</div><div class="line">biotest@ubuntu:~/input$ ./test12.sh</div><div class="line">Line #1: This is the first line.</div><div class="line">Line #2: This is the second line.</div><div class="line">Line #3: This is the third line.</div></pre></td></tr></table></figure>
<p>将<code>STDIN</code>重定向到文件后，当read命令试图从STDIN读入数据时，它会到文件中去读取数据，而不是键盘。</p>
<h2 id="创建自己的重定向">创建自己的重定向</h2>
<p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符（即0，1和2）。shell中最多可以有9个打开的文件描述符。其他6个从 3 ~ 8 的文件描述符均可用作输入或输出重定向。用户可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>
<h3 id="创建输出文件描述符">创建输出文件描述符</h3>
<p>exec 命令可以给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using an alternative file descriptor</div><div class="line"></div><div class="line">exec 3&gt;test13out</div><div class="line"></div><div class="line">echo "This should display on the monitor"</div><div class="line">echo "and this should be stored in the file" &gt;&amp;3</div><div class="line">echo "Then this shold be back on the monitor"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test13.sh</div><div class="line">biotest@ubuntu:~/input$ ./test13.sh</div><div class="line"></div><div class="line">This should display on the monitor</div><div class="line">Then this shold be back on the monitor</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat test13out</div><div class="line">and this should be stored in the file</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内容会像预想中那样显示在STDOUT 上。但你重定向到文件描述符3 的那行echo语句的输出却进入了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如日志文件）。 也可以不用创建文件，使用exec命令来将输出追加到现有文件早，例如<code>exec 3&gt;&gt; test13out</code>。</p>
<h3 id="重定向文件描述符">重定向文件描述符</h3>
<p>看一个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> storing STDOUT, then coming back to it</div><div class="line"></div><div class="line">exec 3&gt;&amp;1 # 将文件描述符3重定向到文件描述符1的位置，也就是STDOUT，这意味着任何发送给文件描述符3的输出都将会出现在显示器上</div><div class="line"></div><div class="line">exec 1&gt; test14out # 将STDOUT重定向到文件，shell现在会将改善给STDOUT的输出直接重定向到输出文件上，但文件描述符3仍然指向STDOUT原来的位置，也就是显示器，如果此时将输出数据改善给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了</div><div class="line"></div><div class="line">echo "This should store in the output file"</div><div class="line">echo "along with this line."</div><div class="line"></div><div class="line">exec 1&gt;&amp;3</div><div class="line"><span class="meta">#</span> 在向STDOUT发送一些输出后，脚本将STDOUT重定向到文件描述符3的当前位置（显示器），这意味着现在STDOUT又指向了原来的位置，即显示器</div><div class="line"></div><div class="line">echo "Now things should be back to normal"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test14.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test14.sh </div><div class="line">Now things should be back to normal</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat test14out </div><div class="line">This should store in the output file</div><div class="line">along with this line.</div></pre></td></tr></table></figure>
<h3 id="创建输入文件描述符">创建输入文件描述符</h3>
<p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将 STDIN 文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将 STDIN 恢复到它原来的位置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting input file descriptors</div><div class="line"></div><div class="line">exec 6&lt;&amp;0</div><div class="line"></div><div class="line">exec 0&lt; testfile</div><div class="line"></div><div class="line">count=1</div><div class="line">while read line </div><div class="line">do</div><div class="line">    echo "Line #$cont: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">exec 0&lt;&amp;6</div><div class="line">read -p "Are you done now " answer</div><div class="line">case $answer in </div><div class="line">Y|y) echo "Goodbye";;</div><div class="line">N|n) echo "Sorry, this is the end.";;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test15.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test15.sh</div><div class="line">Line #: This is the first line.</div><div class="line">Line #: This is the second line.</div><div class="line">Line #: This is the third line.</div><div class="line">Are you done now Y</div><div class="line">Goodbye</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test15.sh</div><div class="line">Line #: This is the first line.</div><div class="line">Line #: This is the second line.</div><div class="line">Line #: This is the third line.</div><div class="line">Are you done now n</div><div class="line">Sorry, this is the end.</div></pre></td></tr></table></figure>
<p>在这个案例中，文件描述符6用来保存STDIN的位置，然后脚本将STDIN重定向到一个文件，read命令的所有输入都来自重定向后的STDIN（也就是输入文件），在读取了所有行之后，脚本将STDIN重定向到文件描述符6，从而将STDIN恢复到原来的位置，该脚本用了另外一个read命令来测试STDIN是否恢复正常，这将它等待键盘的输入。</p>
<h3 id="创建读写文件描述符">创建读写文件描述符</h3>
<p>在bash shell中，可以打开单个文件描述符来作为输入和输出，可以用一个文件描述符对同一个文件进行读写，不过使用这种方法需要谨慎，由于用户是对一个文件进行数据读写，shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始，如果不够小心，会生成严重的后果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing input/output file descriptor</div><div class="line"></div><div class="line">exec 3&lt;&gt; testfile</div><div class="line">read line &lt;&amp;3</div><div class="line">echo "Read: $line"</div><div class="line">echo "This is a test line" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test16.sh </div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test16.sh</div><div class="line">Read: This is the first line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is a test line</div><div class="line">ine.</div><div class="line">This is the third line.</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将文件描述符分配文件testfile以进行文件读写，接下来，通过使用分配好的文件描述符，使read命令读取文件中的第一行，然后将这一行显示在STDOUT上，最后使用echo语句将一行数据写入由同一个文件描述符打开的文件中。在运行结果中，开始运行正常，输出内容表明脚本读取了testfile文件中的第一行，如果脚本运行完毕，查看testfile文件时发现，写入文件中的数据覆盖了已有的数据。原因是，当脚本向中文件中写入数据时，它会从文件指针所处的位置开始，read命令读取了第一行数据，所以它使得文件指针指向了第二行数据的第一个字符，在echo语句将数据输出到文件时，它会将数据放在文件指针的当前位置，覆盖了该位置的已有数据。</p>
<h3 id="关闭文件描述符">关闭文件描述符</h3>
<p>如果用户创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们，有些情况下需要在脚本关闭之前手动关闭文件描述符，要关闭文件描述符，将它重定向到特殊符号<code>&amp;-</code>，在脚本中是这样的<code>exec 3&gt;&amp;-</code>，这条语句会关闭文件描述符3，不再脚本中使用它，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing closing file descriptors</div><div class="line"></div><div class="line">exec 3&gt; tets17file</div><div class="line"></div><div class="line">echo "This is a test line of data " &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">echo "This won't work" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash badtest2.sh </div><div class="line">badtest2.sh: line 9: 3: Bad file descriptor</div></pre></td></tr></table></figure>
<p>一旦关闭了文件描述符，就无法在脚本中写入任何数据，否则shell会生成错误消息。在关闭文件描述符时还需要注意，如果在随后的脚本中打开了同一个输出文件，shell会用一个新文件来替换已有的文件，这就意味着，如果输出数据，它就会覆盖已有鹰爪，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing closing file descriptors</div><div class="line"></div><div class="line">exec 3&gt; test17file</div><div class="line">echo "This is a test line of test" &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">cat test17file</div><div class="line"></div><div class="line">exec 3&gt;test17file</div><div class="line">echo "This will be bad" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test17.sh</div><div class="line">This is a test line of test</div><div class="line">biotest@ubuntu:~/input$ cat test17file</div><div class="line">This will be bad</div></pre></td></tr></table></figure>
<p>在向test17file文件发送一个数据字符串并关闭该文件描述符之后，脚本用了 cat 命令来显示文件的内容。下一步，脚本重新打开了该输出文件并向它发送了另一个数据字符串。当显示该输出文件的内容时，你所能看到的只有第二个数据字符串。shell覆盖了原来的输出文件。</p>
<h2 id="列出打开的文件描述符">列出打开的文件描述符</h2>
<p>bash shell中有一个<code>lsof</code>命令，这个命令会列出整个Linux系统打开的所有文件描述符，<code>lsof</code>命令位于<code>/usr/sbin</code>目录中，这个命令会产生大量的输出，它会显示Linux系统中打开的每个文件的有产信息，这包括后台运行的所有进程，以及登录到系统的任何用户。<code>lsof</code>有各种命令选项和参数可以使用，最常用的是<code>-p</code>和<code>-d</code>，前者用于指定进程ID（即PID），后者用于指定显示的文件描述符编号，如果要知道进程的当前PID，可以使用特殊的环境变量<code>$$</code>（shell会将它设为当前PID），<code>-a</code>选项用来对其他两个选项的结果执行布尔<code>AND</code>运算，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ lsof -a -p $$ -d 0,1,2</div><div class="line">COMMAND   PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</div><div class="line">bash    10009 biotest    0u   CHR  136,4      0t0    7 /dev/pts/4</div><div class="line">bash    10009 biotest    1u   CHR  136,4      0t0    7 /dev/pts/4</div><div class="line">bash    10009 biotest    2u   CHR  136,4      0t0    7 /dev/pts/4</div></pre></td></tr></table></figure>
<p>结果显示了当前进程的国俯文件描述符（0、1和2），lsof的默认输出有7列信息，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COMMAND</td>
<td>正在运行的命令名的前9个字符</td>
</tr>
<tr class="even">
<td>PID</td>
<td>进程的PID</td>
</tr>
<tr class="odd">
<td>USER</td>
<td>进程属主的登录名</td>
</tr>
<tr class="even">
<td>FD</td>
<td>文件描述符号以及访问类型（r代表读，w代表写，u代表读写）</td>
</tr>
<tr class="odd">
<td>TYPE</td>
<td>文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）</td>
</tr>
<tr class="even">
<td>DEVICE</td>
<td>设备的设备号（主设备号和从设备号）</td>
</tr>
<tr class="odd">
<td>SIZE</td>
<td>如果有的话，表示文件的大小</td>
</tr>
<tr class="even">
<td>NODE</td>
<td>本地文件的节点号</td>
</tr>
<tr class="odd">
<td>NAME</td>
<td>文件名</td>
</tr>
</tbody>
</table>
<p>与 STDIN 、 STDOUT 和 STDERR 关联的文件类型是字符型。因为 STDIN 、 STDOUT 和 STDERR 文 件描述符都指向终端，所以输出文件的名称就是终端的设备名。现在看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing lsof with file descriptors</div><div class="line"></div><div class="line">exec 3&gt; test18file1</div><div class="line">exec 6&gt; test18file2</div><div class="line">exec 7&lt; testfile</div><div class="line"></div><div class="line">lsof -a -p $$ -d0,1,2,3,6,7</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test18.sh</div><div class="line">COMMAND   PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</div><div class="line">bash    28264 biotest    0u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    1u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    2u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    3w   REG    8,1        0 928519 /home/biotest/input/test18file1</div><div class="line">bash    28264 biotest    6w   REG    8,1        0 928521 /home/biotest/input/test18file2</div><div class="line">bash    28264 biotest    7r   REG    8,1       73 928491 /home/biotest/input/testfile</div></pre></td></tr></table></figure>
<p>这个脚本创建了3个替代性文件描述符，两个是输出（3和6），一个是输入（7），在脚本运行了<code>lsof</code>命令时，可以在输出中看到新的文件描述符，如果去掉输出中的第一部分，就会看到文件名的结果，文件名显示了文件描述符所使用的文件的完整路径名，它将每个文件都显示成了REG类型，这就说明它们是文件系统中的常规文件。</p>
<h2 id="阻止命令输出">阻止命令输出</h2>
<p>有些情况下，用户不想显示脚本的输出。这在将脚本作为后台进程运行时很常见，如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al &gt; /dev/null</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null</div><div class="line">biotest@ubuntu:~/input$ ls -al badfile2 test16.sh 2&gt; /dev/null</div><div class="line">-rwxrw-r-- 1 biotest biotest 135 May  5 23:28 test16.sh</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null</div><div class="line">biotest@ubuntu:~/input$</div></pre></td></tr></table></figure>
<p>也可以在输入重定向中将<code>dev/null</code>作为输入文件，由于<code>dev/null</code>文件不含有任何内容，用户通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is a test line</div><div class="line">ine.</div><div class="line">This is the third line.</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null &gt; testfile</div><div class="line">biotest@ubuntu:~/input$ cat testfile</div></pre></td></tr></table></figure>
<p>文件testfile仍然存在于系统上，但现在是空文件，这是清除日志文件的一个常用的方法。</p>
<h2 id="创建临时文件">创建临时文件</h2>
<p>Linux系统有特殊的目录，专供临时文件使用。Linux使用/tmp目录来存放不需要永久保留的文件。系统上的任何用户账户都有权限在读写/tmp目录中的文件。这个特性为用户提供了一种创建临时文件的简单方法，而且还不用操心清理工作。有个特殊命令可以用来创建临时文件。mktemp命令可以在/tmp目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的umask值（参见第7章）。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。一旦创建了文件，你就在脚本中有了完整的读写权限，但其他人没法访问它（当然，root用户除外）。</p>
<h3 id="创建本地临时文件">创建本地临时文件</h3>
<p>默认情况下，<code>mktemp</code>会在本地目录中创建一个文件，要用<code>mktemp</code>在本地目录中创建一个临时文件，只要指定一个文件名模板就行了，模板可以包含任意文本文件名，在文件名末尾加上6个x就行了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.ATlZBX</div><div class="line">biotest@ubuntu:~/input$ ls -al testing*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:32 testing.ATlZBX</div></pre></td></tr></table></figure>
<p><code>mktemp</code>命令会用6个字符码替换这6个x，从而保证文件名在目录中是唯一的。用户可以创建多个临床文件，这种用法可以使每个文件名都是唯一的。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.EWLscI</div><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.Y6pjo8</div><div class="line">biotest@ubuntu:~/input$ ls -al testing*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:32 testing.ATlZBX</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:37 testing.EWLscI</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:37 testing.Y6pjo8</div></pre></td></tr></table></figure>
<p>在脚本中使用<code>mktemp</code>命令可以将文件名保存到变量中，这样就可以在后面的脚本中引用了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> creating and using a temp file</div><div class="line"></div><div class="line">tempfile=$(mktemp test19.XXXXXX)</div><div class="line"></div><div class="line">exec 3&gt;$tempfile</div><div class="line">echo "This script writes to temp file $tempfile"</div><div class="line"></div><div class="line">echo "This is the first line" &gt;&amp;3</div><div class="line">echo "This is the second line" &gt;&amp;3</div><div class="line">echo "This is the last line" &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">echo "Done creating temp file. The contents are: "</div><div class="line">cat $tempfile</div><div class="line">rm -f $tempfile 2&gt; /dev/null</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test19.sh</div><div class="line">This script writes to temp file test19.RyVPfD</div><div class="line">Done creating temp file. The contents are: </div><div class="line">This is the first line</div><div class="line">This is the second line</div><div class="line">This is the last line</div><div class="line">biotest@ubuntu:~/input$ ls -al test19*</div><div class="line">-rw-rw-r-- 1 biotest biotest 354 May  6 00:40 test19.sh</div></pre></td></tr></table></figure>
<p>在这个脚本中，使用mktemp命令创建临时文件，并将文件名赋给<code>$tempfile</code>变量，接着将这个临时文件作为文件描述3的输出重定向文件，在将临时文件名显示在STDOUT之后，向中临时文件中写入了几行文本，然后关闭了文件描述符，最后显示出临时文件的内容，并用<code>rm</code>命令将其删除。</p>
<h3 id="在tmp目录创建临时文件">在<code>/tmp</code>目录创建临时文件</h3>
<p><code>-t</code>选项会强制mktemp命令在系统的临时目录来创建文件，在使用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不是仅有文件名，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp -t test.XXXXXX</div><div class="line">/tmp/test.oL5jbT</div><div class="line">biotest@ubuntu:~/input$ ls -al /tmp/test*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:45 /tmp/test.oL5jbT</div></pre></td></tr></table></figure>
<p>由于mktemp返回了全路径，因此用户可以在Linux系统的任意目录下引用该临时文件，不管目录在哪里，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> creating a temp file in /tmp</div><div class="line"></div><div class="line">tempfile=$(mktemp -t tmp.XXXXXX)</div><div class="line"></div><div class="line">echo "This is a test file." &gt; $tempfile</div><div class="line">echo "This is the second line of the test." &gt;&gt; $tempfile</div><div class="line"></div><div class="line">echo "The temp file is located at: $tempfile"</div><div class="line">cat $tempfile</div><div class="line">rm -f $tempfile</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test20.sh</div><div class="line">The temp file is located at: /tmp/tmp.4hLOyR</div><div class="line">This is a test file.</div><div class="line">This is the second line of the test.</div></pre></td></tr></table></figure>
<p>mktemp创建了临时文件时，它会返回全路径给变量，这样就可以在任何命令中使用该值来引用临时变量了。</p>
<h3 id="创建临时目录">创建临时目录</h3>
<p><code>-d</code>选项告诉mktemp命令来创建一个临时目录，而不是临时文件，这样就能用此目录进行任何需要的操作，体积如创建其他的临时文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a temporary directory</div><div class="line"></div><div class="line">tempdir=$(mktemp -d dir.XXXXXX)</div><div class="line">cd $tempdir</div><div class="line">tempfile1=$(mktemp temp.XXXXXX)</div><div class="line">tempfile2=$(mktemp temp.XXXXXX)</div><div class="line">exec 7&gt; $tempfile1</div><div class="line">exec 8&gt; $tempfile2</div><div class="line"></div><div class="line">echo "Sending data to directory $tempdir"</div><div class="line">echo "This is a test line of data for $tempfile1" &gt;&amp;7</div><div class="line">echo "This is a test line of data for $tempfile2" &gt;&amp;8</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test21.sh</div><div class="line">Sending data to directory dir.4ZeP0T</div><div class="line">biotest@ubuntu:~/input$ ls -al</div><div class="line">drwx------  2 biotest biotest 4096 May  6 01:02 dir.4ZeP0T</div><div class="line">... ...</div><div class="line">-rw-rw-r--  1 biotest biotest   29 May  5 23:41 tets17file</div><div class="line">biotest@ubuntu:~/input$ cd dir.4ZeP0T</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ls</div><div class="line">temp.7KoQoD  temp.jj2vb1</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat temp.7KoQoD </div><div class="line">This is a test line of data for temp.7KoQoD</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat temp.jj2vb1 </div><div class="line">This is a test line of data for temp.jj2vb1</div></pre></td></tr></table></figure>
<p>这段脚本在当前目录创建了一个目录，然后它用cd命令进入该目录，并创建了两个临时文件。之后这两个临时文件被分配给文件描述符，用来存储脚本的输出。</p>
<h2 id="记录消息">记录消息</h2>
<p>有时候需要将输出同时发送到显示器和日志文件，此时需要<code>tee</code>命令。tee在英文就是T的意思，在Linux中，这个命令相当于管道一个T接头，它将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是tee命令所指定的文件名<code>tee filename</code>，由于tee会重定向来自STDIN的数据，可以用它配合管道命令来重定向命令输出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ date | tee testfile2</div><div class="line">Sun May  6 01:12:57 PDT 2018</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">Sun May  6 01:12:57 PDT 2018</div></pre></td></tr></table></figure>
<p>输出出现在了STDOUT中，同时也写入了指定的文件中，默认情况下，tee命令会在每次使用时覆盖输出文件的内容，如下挂满：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ who | tee testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div></pre></td></tr></table></figure>
<p>如果需要追加数据，则要使用<code>-a</code>参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ date | tee -a testfile2</div><div class="line">Sun May  6 01:14:55 PDT 2018</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">Sun May  6 01:14:55 PDT 2018</div></pre></td></tr></table></figure>
<p>看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the tee command for logging </div><div class="line"></div><div class="line">tempfile=test22file</div><div class="line"></div><div class="line">echo "This is the start of the test" |tee $tempfile</div><div class="line">echo "This is the second line of the test" | tee -a $tempfile</div><div class="line">echo "This is the end of the test" | tee -a $tempfile</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ bash test22.sh</div><div class="line">This is the start of the test</div><div class="line">This is the second line of the test</div><div class="line">This is the end of the test</div><div class="line"></div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat test22file</div><div class="line">This is the start of the test</div><div class="line">This is the second line of the test</div><div class="line">This is the end of the test</div></pre></td></tr></table></figure>
<p>从结果可以看出，用户显示输出的同时，还能保存一份输出内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/02/Linux-shell03-break几层循环的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Linux-shell03-break几层循环的理解/" itemprop="url">break n层循环的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T12:13:54+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物信息学/" itemprop="url" rel="index">
                    <span itemprop="name">生物信息学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  590
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Shell脚本的break与continue语句时，有一些困惑，就是<code>break n</code>可以跳出几层循环的问题，continue也是如此。不过弄懂了<code>break n</code>的问题，<code>continue n</code>的问题应该也清楚了。</p>
<p>第一步：<code>break 1</code>。</p>
<p>新建一个<code>loop.sh</code>脚本，输入以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 1</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 1 the out cycle is 2,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 2,and inner cycle is 2</div><div class="line">The m cycle is 1 the out cycle is 3,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 3,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 2,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 2,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 3,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 3,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>第二步：<code>break 2</code>。</p>
<p>现在将<code>break 1</code>改为<code>break 2</code>，运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 2</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>第三步，<code>break 3</code>。</p>
<p>现在将<code>break 2</code>改为<code>break 3</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 3</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>从上面的结果可以看出来：①最内层的是第1层循环，再次是第2层循环，最外层就是第3层循环。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/02/Linux-shell04-处理用户输入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Linux-shell04-处理用户输入/" itemprop="url">Shell学习笔记（4）——处理用户输入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T12:12:54+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,003
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="命令行参数">命令行参数</h2>
<p>脚本还可以接受一些参数。向shell脚本传递数据的最基本方法是使用命令行参数，命令行参数就像是一些常规的Linux命令一样，例如<code>head -20 file001.sh</code>，在一条命令上，head命令就能接收一个<code>-20</code>的参数，用户自己定义的脚本，也可以接收一定的参数。</p>
<h3 id="读取参数">读取参数</h3>
<h4 id="第1个案例读取1个参数">第1个案例：读取1个参数</h4>
<p>bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数，这也包括shell所执行的脚本名称，位于参数变量是标准的数据，其中，<code>$0</code>是程序名，<code>$1</code>是第1个参数，<code>$2</code>是第2个参数，直到第9个参数，即<code>$9</code>。下面的案例是shell脚本中使用单个命令行参数的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using one command line parameter</div><div class="line"><span class="meta">#</span> </div><div class="line"></div><div class="line">factorial=1</div><div class="line"></div><div class="line">for (( number=1; number &lt;= $1;number++ )) </div><div class="line"><span class="meta">#</span> 这里的$1指的是脚本运行过程中输入的参数，在后面的运行过程中，输入5</div><div class="line"> do</div><div class="line">    factorial=$[ $factorial*$number ]</div><div class="line"> done</div><div class="line"> echo The factorial of $1 is $factorial</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test1.sh 5</div><div class="line">The factorial of 5 is 120</div></pre></td></tr></table></figure>
<p>运行过程：第1次：factorial=1，number=1；第2次：n=2，f=2；第3次：n=3，f=6；第4次：n=4,f=24；第5次：n=5；f=120。</p>
<h4 id="第2个案例读取2个及以上参数">第2个案例：读取2个及以上参数</h4>
<p>如果要读取更多的参数，需要将每个参数用空格分开，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing two command line parameters</div><div class="line"><span class="meta">#</span></div><div class="line">total=$[ $1*$2 ]</div><div class="line">echo The first parameter is $1.</div><div class="line">echo The second parameter is $2.</div><div class="line">echo The total value is $total.</div></pre></td></tr></table></figure>
<p>运行结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The first parameter is 2.</div><div class="line">The second parameter is 5.</div><div class="line">The total value is 10.</div></pre></td></tr></table></figure></p>
<h4 id="第3个案例使用字符串作为变量">第3个案例，使用字符串作为变量</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> testing string parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo Hello $1, glad to meet you.</div></pre></td></tr></table></figure>
<p>运行结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh Zhang</div><div class="line">Hello Zhang, glad to meet you.</div></pre></td></tr></table></figure></p>
<p>在这个案例中，使用了字符串作为脚本的参数，但是，如果参数中含有空格，则会出现问题，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh Zhang San</div><div class="line">Hello Zhang, glad to meet you.</div></pre></td></tr></table></figure></p>
<p>脚本只识别了Zhang，没有识别出完整的Zhang San，因为shell脚本会把空格分隔开的字符串当成两个参数，如果要使含有空格的字符串当成一个，需要添加引号，如下所示；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh &apos;Zhang San&apos;</div><div class="line">Hello Zhang San, glad to meet you.</div></pre></td></tr></table></figure>
<h4 id="第4个案例参数大于9个">第4个案例：参数大于9个</h4>
<p>如果脚本需要的命令行参数大于9个，此时需要在变量数字周围加上花括号，例如<code>${``10``}</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> handling lots of paramerters</div><div class="line"><span class="meta">#</span></div><div class="line">total=$[ $&#123;10&#125;*$&#123;11&#125; ]</div><div class="line">echo The tenth parameter is $&#123;10&#125;</div><div class="line">echo The eleventh parameter is $&#123;11&#125;</div><div class="line">echo The total is $total</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test4.sh 1 2 3 4 5 6 7 8 9 10 11 12</div><div class="line">The tenth parameter is 10</div><div class="line">The eleventh parameter is 11</div><div class="line">The total is 110</div></pre></td></tr></table></figure></p>
<h4 id="第5个案例读取脚本名">第5个案例：读取脚本名</h4>
<h5 id="参数的意义"><code>$0</code>参数的意义。</h5>
<p><code>$0</code>参数用于获取shell在命令行启动的脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing the $0 parameter</div><div class="line"><span class="meta">#</span></div><div class="line">echo The zero parameter is set to:$0</div></pre></td></tr></table></figure>
<p>需要注意的是，如果使用完整路径运行脚本，则<code>$0</code>就是完整脚本，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash /home/biotest/userdata/test5.sh</div><div class="line">The zero parameter is set to:/home/biotest/userdata/test5.sh</div></pre></td></tr></table></figure>
<h5 id="basename命令可以补充0参数的局限"><code>basename</code>命令可以补充<code>$0</code>参数的局限</h5>
<p>如果要写一个根据脚本名来执行不同功能的脚本，则就需要注意把脚本的运行路径给剥离掉，shell中有一个命令可以考虑，即<code>basename</code>命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Using basename with the $0 parameter</div><div class="line"><span class="meta">#</span></div><div class="line">name=$(basename $0)</div><div class="line">echo</div><div class="line">echo The script name is: $name</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test5b.sh</div><div class="line">The script name is: test5b.sh</div><div class="line">biotest@ubuntu:~/userdata$ bash /home/biotest/userdata/test5b.sh</div><div class="line">The script name is: test5b.sh</div></pre></td></tr></table></figure>
<p>从结果可以看出来，使用了<code>basename</code>命令后，即使运行脚本时输入全路径，<code>$0</code>也只是脚本的名称。</p>
<h5 id="相对路径与绝对路径的案例">相对路径与绝对路径的案例</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing a Multi-function script</div><div class="line"><span class="meta">#</span></div><div class="line">name=$(basename $0)</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $name = "addem" ]</div><div class="line">then</div><div class="line">    total=$[ $1 + $2 ]</div><div class="line"><span class="meta">#</span></div><div class="line">elif [ $name = "multem" ]</div><div class="line">then</div><div class="line">    total=$[ $1*$2 ]</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">echo The calculated value is $total</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cp test6.sh addem</div><div class="line">biotest@ubuntu:~/userdata$ chmod u+x addem</div><div class="line">biotest@ubuntu:~/userdata$ ln -s test6.sh multem</div><div class="line">biotest@ubuntu:~/userdata$ ls -l *em</div><div class="line">-rwxrw-r-- 1 biotest biotest 224 May  1 10:48 addem</div><div class="line">lrwxrwxrwx 1 biotest biotest   8 May  1 10:48 multem -&gt; test6.sh</div><div class="line">biotest@ubuntu:~/userdata$ bash addem 2 5</div><div class="line">The calculated value is 7</div><div class="line">biotest@ubuntu:~/userdata$ sudo bash ./multem 2 5</div><div class="line">The calculated value is 10</div></pre></td></tr></table></figure>
<p>结果解释：第一，<code>cp test6.sh addem</code>复制<code>test6.sh</code>脚本，新生成的文件命令为<code>addem</code>；第二，<code>chmod u+x addem</code>，将<code>addem</code>文件权限更改为可执行；第三，<code>ln -s test6.sh multem</code>，其中<code>ln</code>是为文件创建链接，<code>-s</code>表示软连接，可以理解为Linux的快捷方式；第四，当执行<code>addem 2 5</code>时，执行<code>total=$[ $1 + $2 ]</code>语句，如果是<code>bash ./multem 2 5</code>，则执行<code>total=$[ 41*$2 ]</code>语句。</p>
<h4 id="测试参数">测试参数</h4>
<p>当脚本认为参数变量中会有数据，而实际上没有时，脚本就有可能会产生错误消息。通常要避免这种脚本的写法，在使用参数前一定要检查其中是否存在为数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat test7.sh</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing parameters befoire user</div><div class="line"><span class="meta">#</span></div><div class="line"> if [ -n "$1" ]</div><div class="line">then</div><div class="line">    echo Hello $1, gload to meet you.</div><div class="line">else</div><div class="line">    echo "Sorry you did not identify yourself."</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test7.sh Zhang</div><div class="line">Hello Zhang, gload to meet you.</div><div class="line">biotest@ubuntu:~/userdata$ bash test7.sh</div><div class="line">Sorry you did not identify yourself.</div></pre></td></tr></table></figure>
<p>代码解释：在<code>if</code>语句中使用了<code>if [ -n &quot;$1&quot; ]</code>语句，这里的<code>-n</code>是用于判断<code>$1</code>中是否有数据。</p>
<h2 id="特殊参数变量">特殊参数变量</h2>
<p>在bash shell中有一些变量，它们会记录命令行参数。</p>
<h3 id="参数统计基本用法">参数统计基本用法</h3>
<p>bash shell有一个特殊的变量，可以记录命令行中输入了多少个参数，其中这个特殊变量就是<code>$#</code>，哦可以肝脚本中任何地方使用这个特殊的变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> getting the number of parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo There were $# parameters supplied.</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh</div><div class="line">There were 0 parameters supplied.</div><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh 1 2 3 4 5 6 7</div><div class="line">There were 7 parameters supplied.</div><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh &quot;Zhang San&quot;</div><div class="line">There were 1 parameters supplied.</div></pre></td></tr></table></figure>
<h3 id="参数统计案例">参数统计案例</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>/bin/bash</div><div class="line"><span class="meta">#</span> Testing parameters</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $# -ne 2 ] # -ne测试命令行参数的数量，-ne是检查$#是否不等于2，ne相当于non-equal</div><div class="line">then</div><div class="line">    echo</div><div class="line">    echo Usage: test9..sh a b</div><div class="line">    echo</div><div class="line">else</div><div class="line">    total=$[ $1 + $2 ]</div><div class="line">    echo</div><div class="line">    echo The total is $total</div><div class="line">    echo</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh </div><div class="line">Usage: test9..sh a b</div><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh 10</div><div class="line">Usage: test9..sh a b</div><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh 10 10 15</div><div class="line">Usage: test9..sh a b</div></pre></td></tr></table></figure>
<p>需要注意的是，如果认为<code>$#</code>变量含有参数的总数，而变量<code>$\{$#\}</code>代表了最后一个命令行参数变量，那就会出错，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing grabbing last parameter</div><div class="line"><span class="meta">#</span></div><div class="line">echo The last parameter was $&#123;$#&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash badtest1.sh 10</div><div class="line">The last parameter was 19343</div></pre></td></tr></table></figure>
<p>结果是19343，这说明，在花括号内不能使用美元符号，除非按照下面的方式进行修改，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Grabbing the last parameter</div><div class="line"><span class="meta">#</span></div><div class="line">params=$#</div><div class="line">echo</div><div class="line">echo The last parameter is $params</div><div class="line">echo The last parameter is $&#123;!#&#125;</div><div class="line">echo</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test10.sh 1 2 3 4 5 6</div><div class="line">The last parameter is 6</div><div class="line">The last parameter is 6</div><div class="line"></div><div class="line">biotest@ubuntu:~/userdata$ bash test10.sh</div><div class="line">The last parameter is 0</div><div class="line">The last parameter is test10.sh</div></pre></td></tr></table></figure>
<p>从结果来看，如果将<code>$#</code>变量的值赋给了变量<code>params</code>，然后也按特殊命令行参数变量的格式（即使用<code>$/{!#/}</code>）使用了该变量，结果就能正常显示。但是，当脚本没有参数时，<code>$#</code>的值为0，params变量的值也一样，但<code>$\{!#\}</code>变量的返回值则是脚本名本身。</p>
<h3 id="抓取所有的数据">抓取所有的数据</h3>
<p>有时候需要抓取命令行上提供的所有参数，这时候不需要先用<code>$#</code>变量来判断命令行上有多少参数，然后再进行遍历，可以使用其他的特殊变量来解决这个问题，其中<code>$*</code>和<code>$@</code>变量可以访问所有的参数，这两个变量都能够在单个变量中存储所有的命令行参数。</p>
<p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存，这个单词包含了命令行中出现的每一个参数，基本上<code>$*</code>变量会将这些参数视为一个整体，而不是单独的个体。而<code>$@</code>变量会将命令行上提供的所有参数当作同一字符串中多个独立的单词，这样可以遍历所有的参数值，得到每个参数，这通常使用for命令完成。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing $* and $@</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">echo "Using the \$* method: $*"</div><div class="line">echo</div><div class="line">echo "Using the \$@ mehtods: $@"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biostudy@ubuntu18:~/script$ bash test11.sh Zhang Li Wang</div><div class="line">Using the $* method: Zhang Li Wang</div><div class="line">Using the $@ mehtods: Zhang Li Wang</div></pre></td></tr></table></figure>
<p>从结果来看，<code>$*</code>和<code>$@</code>在形式上并没有区别。但是下面的例子则能看出区别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing $* and $@</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">count=1</div><div class="line"></div><div class="line">for param in "$*"</div><div class="line">do</div><div class="line">    echo "\$ Parameter # $count=$param"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line"></div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">    echo "\$@ Parameter # $count=$param"</div><div class="line">    ecount=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test12.sh Zhang Li Wang</div><div class="line"></div><div class="line">$ Parameter # 1=Zhang Li Wang</div><div class="line">$@ Parameter # 1=Zhang</div><div class="line">$@ Parameter # 1=Li</div><div class="line">$@ Parameter # 1=Wang</div></pre></td></tr></table></figure>
<p>从结果可以看出来，使用for遍历这两个特殊的变量时，<code>$*</code>会将所有参数当成单个参数，而<code>$@</code>变量会单独处理所有的参数。</p>
<h2 id="移动变量">移动变量</h2>
<p>bash shell中的<code>shift</code>命令可以操作命令行参数，<code>shift</code>可以根据它们的相对位置来移动命令行参数。当使用该命令时，它会将每个参数变量向左移动一个位置。因此，变量<code>$3</code>的值会移到<code>$2</code>，变量<code>$2</code>的值会移到<code>$1</code>，而变量<code>$1</code>的值则会被删除（因为<code>$0</code>的值是程序名，不会改变）。这是遍历命令行参数的一个方法，当用户不矢科有多少个参数时，可以只操作第1个参数，移动参数，然后继续操作下一个参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating the shift command</div><div class="line"></div><div class="line">echo</div><div class="line">count=1</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    echo "Parameter #$count=$1"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">    shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[000.DESKTOP-FS88S5S] &gt; bash test13.sh Zhang Li Wang Tian</div><div class="line"></div><div class="line">Parameter #1=Zhang</div><div class="line">Parameter #2=Li</div><div class="line">Parameter #3=Wang</div><div class="line">Parameter #4=Tian</div></pre></td></tr></table></figure>
<p>代码及结果解释： -n 测试来检查命令行参数<code>$1</code>中是否有数据。如果不是0，就执行，一直执行到<code>$1</code>参数为0为止。也可以为shift提供一个参数，指明要移动的位置数即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating a multi-positon shift</div><div class="line"><span class="meta">#</span></div><div class="line">echo "The original parameters: $*"</div><div class="line">shift 2</div><div class="line">echo "Here's the new first parameter: $1"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[000.DESKTOP-FS88S5S] &gt; bash test14.sh 1 2 3 4 5</div><div class="line">The original parameters: 1 2 3 4 5</div><div class="line">Here&apos;s the new first parameter: 3</div></pre></td></tr></table></figure>
<p>从上述案例可知，通过使用shfit的参数可以跳过不想要的参数。</p>
<h2 id="处理选项">处理选项</h2>
<p>选项指的是这样的一种情况，在命令后面的短横线的单个字母 ，例如 <code>ls -a</code>，其中<code>-a</code>就是选项。</p>
<h3 id="查找选项">查找选项</h3>
<p>在提取每个单独参数时用<code>case</code>语句来判断某个参数是否为选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting command line options as parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in </div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) echo "Found the -b option";;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">    esac</div><div class="line">    shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test15.sh -a -b -c -d</div><div class="line">Found the -a option</div><div class="line">Found the -b option</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>case语句会检查每个参数是不是有效选项。如果是的话，就运行对应case语句中的命令，无论选项按什么顺序出现在命令行上，这种方法都适用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test15.sh -d -c -a</div><div class="line">-d is not an option</div><div class="line">Found the -c option</div><div class="line">Found the -a option</div></pre></td></tr></table></figure>
<p>case语句在命令行参数中找到一个选项，就处理一个选项，如果命令行上的还提供了其他参数，就可以在case语句的通用情况处理部分中处理。</p>
<h3 id="分离参数和选项">分离参数和选项</h3>
<p>在shell脚本中同时使用选项有参数时，Linux处理这种问题的标准方式是用特殊字符，也就是双破折号（<code>--</code>）将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。在双破折线之后，脚本可以将剩下的命令行参数当作参数，而不是选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting options and parameters</div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in</div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) echo "Found the -b option";;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">        --) shift</div><div class="line">            break;;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">    esac</div><div class="line">    shift</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line">for param in $@</div><div class="line">do</div><div class="line">   echo "Parameter #$count: $param"</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test16.sh -c -a -b test1 test2 test3</div><div class="line">Found the -c option</div><div class="line">Found the -a option</div><div class="line">Found the -b option</div><div class="line">test1 is not an option</div><div class="line">test2 is not an option</div><div class="line">test3 is not an option</div></pre></td></tr></table></figure>
<p>当脚本遇到双破折号时，它会停止处理选项，并将剩下的参数都当作命令行参数。</p>
<h3 id="处理带值的选项">处理带值的选项</h3>
<p>有些选项会带上额外的参数值，例如像这样的<code>bash testing.sh -a test1 -b -c -d test2</code>，如果例行选项中带有额外的参数，脚本必须要能检测到，并且进行处理，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting command line options and values</div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in </div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) param="$2"</div><div class="line">            echo "Found the -b option, with parameter value $param"</div><div class="line">           shift;;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">        --) shift</div><div class="line">            break;;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">     esac</div><div class="line">     shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -a -b test1 -d</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with parameter value test1</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>代码及结果解释：在这案例中，<code>case</code>语句定义了3个安要处理的选项，其中<code>-b</code>选项还需要一个额外的参数值，由于要处理的参数是<code>$1</code>，额外的参数值就应该位于<code>$2</code>位置上（因为所有的参数在处理完后就会被移出），只要将参数值从<code>$2</code>变量中提取出来就行，因为这个选项占了2个参数位，因此还需要<code>shift</code>命令多移动一个位置。只用这些基本的特性，整个过程就能正常工作，不管按什么顺序放置选项（但要记住包含每个选项相应的选项参数）。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -b test1 -a -d</div><div class="line">Found the -b option, with parameter value test1</div><div class="line">Found the -a option</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>此时，shell脚本就有了处理例行选项的基本能力，但还一些限制，例如，想要多个选项放一个参数时，就像<code>ls -lh</code>这个命令这样，脚本就无法正常工作，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -ac</div><div class="line">-ac is not an option</div></pre></td></tr></table></figure>
<p>此时需要<code>getopt</code>命令。</p>
<h3 id="使用getopt命令">使用getopt命令</h3>
<h4 id="getopt命令基本用法">getopt命令基本用法</h4>
<p><code>getopt</code>命令是一个在处理命令行选项和参数时非常方便的工具，它能够识别命令行参数，从而在脚本中解析它们时更方便。<code>getopt</code>命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换为适当的格式，它的使用方法为<code>getopt optstring parameters</code>，其中，<code>optstring</code>定义了命令行有效的选项字符，不这它义了哪些选项字母需要参数值。首先在<code>optstring</code>中列出要在脚本中用到的每个命令行选项字母，然后在每个需要参数值的选项字母后面加一个冒号，<code>getopt</code>命令会基于定义的<code>optstring</code>解析提供的参数。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt ab:cd -a -b test1 -cd test2 test3</div><div class="line"> -a -b test1 -c -d -- test2 test3</div></pre></td></tr></table></figure>
<p>optstring定义了4个有效选项字母，a、b、c和d。冒号（<code>：</code>）被放到了字母b的后面，因为b选项需要一个参数值，当<code>getopt</code>命令运行时，它会检查提供的参数列表（-a -b test1 -cd test2 test3），并基于提供的<code>optstring</code>进行解析。此时，它会自动将<code>-cd</code>选项分成两个单独的选项，并插入双破折线来分隔行中的额外参数，如果指定了一个不在<code>optstring</code>中的选项，默认情况下，<code>getopt</code>会产生一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt ab:cd -a -b test1 -cde test2 test3</div><div class="line">getopt: invalid option -- 'e'</div><div class="line"> -a -b test1 -c -d -- test2 test3</div></pre></td></tr></table></figure>
<p>如果需要忽略这条错误消息，可以在命令后加<code>-q</code>选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt -q ab:cd -a -b test1 -cde test2 test3</div><div class="line"> -a -b 'test1' -c -d -- 'test2' 'test3'</div></pre></td></tr></table></figure>
<p>注意：getopt命令选项必须出现在optstring之间。</p>
<h4 id="在脚本中使用getopt">在脚本中使用getopt</h4>
<p>在脚本中使用<code>getopt</code>来格式化脚本所携带的任何选项或参数时，方法就是使用<code>getopt</code>命令生成的格式化后的版本替换已有的命令行选项的参数。这其中要用到<code>set</code>命令。<code>set</code>命令的选项之一就是双破折线（<code>--</code>），它会将命令行参数值的成set命令的命令行值。该方法会将原始脚本的命令行参数传给<code>getopt</code>命令，之后再将<code>getopt</code>命令的输出传给<code>set</code>命令，用<code>getopt</code>格式化后的命令行参数来替换原始的命令行参数，看起来就像这样的<code>set --$(getopt -q ab:cd &quot;$@&quot;)</code>,此时，原始命令行参数变量的值会被<code>getopt</code>命令的输出替换，而<code>getopt</code>已经格式化好了命令行参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Extract command line options and values with getop</div><div class="line"><span class="meta">#</span> </div><div class="line">set --$(getopt -q ab:cd "$@")</div><div class="line"><span class="meta">#</span></div><div class="line">echo </div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in</div><div class="line">    -a) echo "Found the -a option";;</div><div class="line">    -b) param="$2"</div><div class="line">        echo "Found the -b option, with paraeter value $param"</div><div class="line">        shift;;</div><div class="line">    -c) echo "Found the -c option";;</div><div class="line">    --) shift</div><div class="line">        break;;</div><div class="line">     *) echo "$1 is not an option";;</div><div class="line">     esac</div><div class="line">  shift</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">    echo "Parameter $count: $param"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -ac</div><div class="line">Found the -a option</div><div class="line">Found the -c option</div><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -a -b test1 -cd test2 test3 test4</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with paraeter value &apos;test1&apos;</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div><div class="line">Parameter 1: &apos;test2&apos;</div><div class="line">Parameter 2: &apos;test3&apos;</div><div class="line">Parameter 3: &apos;test4&apos;</div><div class="line"></div><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -a -b test1 -cd &quot;test2 test3&quot; test4</div><div class="line">Found the -a option</div><div class="line">Found the -b option, with paraeter value &apos;test1&apos;</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div><div class="line">Parameter 1: &apos;test2</div><div class="line">Parameter 2: test3&apos;</div><div class="line">Parameter 3: &apos;test4</div></pre></td></tr></table></figure>
<p>从运行结果来看，第一个与第二个没有问题，第三个出现了问题，在第三个运行过程中，参数选项其中人有<code>&quot;test2 test3&quot;</code>，用了双引号，由于<code>getopt</code>命令不擅长处理带空格和引号的参数值，它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。此时就需要另外一个命令，即<code>getopts</code>，这个命令是在<code>getopt</code>后面加了一个<code>s</code>。</p>
<h3 id="使用getopts命令注意后面加了s">使用getopts命令（注意后面加了s）</h3>
<p><code>getopts</code>命令能够与已有的shell参数变量进行配合。每调用它时，它一次只处理命令行上检测到的一个参数，处理完所有的参数后，它会退回一个大于0的退出状态码，因此这个命令很适合解析命令行所有参数的循环。它的用法为<code>getopts optstring variable</code>。<code>optstring</code>中储存的是有效的选项字母，如果选项字母要求有个参数值，就要加一个冒号，要去年错误消息的话，可以在<code>optstring</code>之前加一个冒号，<code>getopts</code>命令将当前参数保存在命令行中定义的<code>variable</code>中。<code>getopts</code>命令会用到两个环境变量，如果选项需要跟一个参数值，<code>OPTARG</code>环境变量会保存这个值，<code>OPTIND</code>环境变量保存了参数列表中<code>getopts</code>正在处理的参数位置。这样能够在处理完选项之后继续处理其他命令行参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> simple demonstration of the getopts command</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">while getopts :ab:c opt</div><div class="line">do</div><div class="line">    case "$opt" in </div><div class="line">        a) echo "Found the -a option";;</div><div class="line">        b) echo "Found the -b option, with value $OPTARG";;</div><div class="line">        c) echo "Found the -c option";;</div><div class="line">        *) echoi "Unknown options:$opt";;</div><div class="line">    esac</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -ab test1 -c</div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div><div class="line">Found the -c option</div></pre></td></tr></table></figure>
<p>while语句定义了<code>getopts</code>命令，指明了要查找哪些命令选项，以及每次迭代中储存它们的变量名（<code>opt</code>）。此时<code>case</code>语句的用法有些不同，getopts命令解析命令行选项时会移除开头的单破拆线，所以在case定义中不用单破折线。getopts命令的参数值中可以包含空格，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Found the -b option, with value test1 test2</div><div class="line">Found the -a option</div></pre></td></tr></table></figure>
<p>还可以将选项字母和参数值放在一起使用，而不用加空格，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -abtest1</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div></pre></td></tr></table></figure>
<p><code>getopts</code>命令能够从<code>-b</code>选项中正确解析出<code>test1</code>值。除此之外，<code>getopts</code>还能够将命令行上找到的所有未定义的选项统一输出成问号，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -d</div><div class="line"></div><div class="line">Unknown options:?</div><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -acde</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -c option</div><div class="line">Unknown options:?</div><div class="line">Unknown options:?</div></pre></td></tr></table></figure>
<p><code>optstring</code>中未定义的选项字母会以问号形式发给代码。<code>getopts</code>命令知道何时停止处理选项，并将参数留给用户处理，在使用<code>getopts</code>处理每个选项时，它会将<code>OPTIND</code>环境变量值增一。在<code>getopts</code>完成处理时，用户可以使用<code>shift</code>命令和<code>OPTIND</code>值来移动参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Processing options and parameters with getopts</div><div class="line"></div><div class="line">echo </div><div class="line">while getopts :ab:cd opt</div><div class="line">do</div><div class="line">    case "$opt" in </div><div class="line">    a) echo "Found the -a option";;</div><div class="line">    b) echo "Found the -b option, with value $OPTARG";;</div><div class="line">    c) echo "Found the -c option";;</div><div class="line">    c) echo "Found the 0d option";;</div><div class="line">    *) echo "Unknown option: $opt";;</div><div class="line">    esac</div><div class="line">done</div><div class="line"></div><div class="line">shift $[ $OPTIND - 1 ]</div><div class="line"></div><div class="line">echo</div><div class="line">count=1</div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">   echo "Parameter $count: $param"</div><div class="line">   coiunt=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test20.sh -a -b test1 -d test2 test3 test4</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div><div class="line">Unknown option: d</div><div class="line"></div><div class="line">Parameter 1: test2</div><div class="line">Parameter 1: test3</div><div class="line">Parameter 1: test4</div></pre></td></tr></table></figure>
<h2 id="选项标准化">选项标准化</h2>
<p>在Linux系统中，一些字母选项已经拥有了某种程度的标准含义，因此在写bash shell脚本时，用户自己脚本中如果要使用一些选项参数的话，最好与Linux系统中的保持一致，一些常用的linux命令选项如下所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-a</td>
<td>显示所有对象</td>
</tr>
<tr class="even">
<td>-c</td>
<td>生成一个计数</td>
</tr>
<tr class="odd">
<td>-d</td>
<td>指定一个目录</td>
</tr>
<tr class="even">
<td>-e</td>
<td>扩展一个对象</td>
</tr>
<tr class="odd">
<td>-f</td>
<td>指定读入数据的文件</td>
</tr>
<tr class="even">
<td>-h</td>
<td>显示命令的帮助信息</td>
</tr>
<tr class="odd">
<td>-i</td>
<td>忽略文本大小写</td>
</tr>
<tr class="even">
<td>-l</td>
<td>产生输出的长格式版本</td>
</tr>
<tr class="odd">
<td>-n</td>
<td>使用非交互模式（批处理）</td>
</tr>
<tr class="even">
<td>-o</td>
<td>将所有输出重定向到的</td>
</tr>
<tr class="odd">
<td>-q</td>
<td>以安静模式运行</td>
</tr>
<tr class="even">
<td>-r</td>
<td>递归地处理目录和文件</td>
</tr>
<tr class="odd">
<td>-s</td>
<td>以安静模式运行</td>
</tr>
<tr class="even">
<td>-v</td>
<td>生成详细输出</td>
</tr>
<tr class="odd">
<td>-x</td>
<td>排除某个对象</td>
</tr>
<tr class="even">
<td>-y</td>
<td>对所有问题回答yes</td>
</tr>
</tbody>
</table>
<h3 id="获得用户输入">获得用户输入</h3>
<p>虽然命令行选项和参数可以从脚本用户处获得输入，但还有一种情况下，需要读取用户的一些信息，例如在运行某个脚本时，需要用户输入自己的用户名。bash shell为此提供了<code>read</code>命令。</p>
<h3 id="read的基本用法"><code>read</code>的基本用法</h3>
<p><code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入，在收入输入后，<code>read</code>命令会将数据放进一个变量，下面是<code>read</code>命令的一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the read command</div><div class="line"><span class="meta">#</span></div><div class="line">echo -n "Enter your name: "</div><div class="line">read name</div><div class="line">echo "Hello, $name, welcome to my program."</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行后结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test21.sh</div><div class="line">Enter your name: Zhang San</div><div class="line">Hello, Zhang San, welcome to my program.</div></pre></td></tr></table></figure>
<p>代码及结果解释：生成提示的echo使用了<code>-n</code>选项，该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。<code>read</code>命令还包含了<code>-p</code>选项，可以直接在<code>read</code>命令行指定指示符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the read -p option</div><div class="line"><span class="meta">#</span></div><div class="line">read -p "Please enter your age: " age</div><div class="line">days=$[ $age*365 ]</div><div class="line">echo "That makes your over $days days old!"</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test22.sh</div><div class="line">Please enter your age: 20</div><div class="line">That makes your over 7300 days old!</div></pre></td></tr></table></figure>
<p>代码及结果解释，在第一个例子中当有名字输入时，<code>read</code>命令会将姓和名保存在同一个变量中，<code>read</code>命令会将提示符后输入的所有数据分配给单个变量，要么用户指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span> entering multiple varibales</div><div class="line">read -p "Enter your name:    " first last</div><div class="line">echo "Checking data for $last, $first..."</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test23.sh</div><div class="line">Enter your name:    Zhang San</div><div class="line">Checking data for San, Zhang...</div></pre></td></tr></table></figure>
<p>如果<code>read</code>命令行中不指定变量，<code>read</code>命令会将它收到的任何数据都放到特殊环境变量<code>REPLY</code>中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing the REPLY Environemnt variable</div><div class="line"><span class="meta">#</span></div><div class="line">read -p "Enter uyuour name: "</div><div class="line">echo</div><div class="line">echo Hello $REPLY, welcome to my program.</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test24.sh</div><div class="line">Enter uyuour name: Zhang</div><div class="line"></div><div class="line">Hello Zhang, welcome to my program.</div></pre></td></tr></table></figure>
<p><code>REPLY</code>环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。</p>
<h3 id="超时">超时</h3>
<p>在使用<code>read</code>命令时需要注意，脚本很有可能会一直等着用户的输入，如果不管是否有数据输入，脚本都必须继续执行，可以使用<code>-t</code>选项来指定个计时器，<code>-t</code>选项指定了<code>read</code>命令等待输入的秒数，当计时器过期后，<code>read</code>命令会返回一个非零退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> timing the data entry</div><div class="line"><span class="meta">#</span> </div><div class="line">if read -t 5 -p "Please enter your name:  " name</div><div class="line">then</div><div class="line">    echo "Hello $name, welcome to my script"</div><div class="line">else</div><div class="line">    echo</div><div class="line">    echo "Sorry, too slow!"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test25.sh</div><div class="line">Please enter your name:  Zhang</div><div class="line">Hello Zhang, welcome to my script</div><div class="line">biotest@ubuntu:~/userdata$ bash test25.sh</div><div class="line">Please enter your name:  </div><div class="line">Sorry, too slow!</div></pre></td></tr></table></figure>
<p>代码及结果解释：如果计时器过期，<code>read</code>命令会以非零退出状态码退出，可以使用如<code>if-then</code>语句或<code>while</code>循环这种标准的结构化语句所发生的具体情况，在这个例子中，<code>if</code>语句不成立，shell会执行else部分的命令。也可以不进行诸，让<code>read</code>命令来统计输入的字符数，当输入的字符数达到预设的字符数时，就自动退出，将输入的数据赋给变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> getting just one character of input</div><div class="line"><span class="meta">#</span></div><div class="line">read -n1 -p "Do you want to continue [Y/N]? " answer</div><div class="line">case $answer in </div><div class="line">Y|y) echo</div><div class="line">     echo "fine, continue on...";;</div><div class="line">N|n) echo</div><div class="line">     echo OK, goodbye</div><div class="line">     exit;;</div><div class="line">esac</div><div class="line">echo "This is the end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test26.sh</div><div class="line">Do you want to continue [Y/N]? Y</div><div class="line">fine, continue on...</div><div class="line">This is the end of the script</div><div class="line">biotest@ubuntu:~/userdata$ bash test26.sh</div><div class="line">Do you want to continue [Y/N]? n</div><div class="line">OK, goodbye</div></pre></td></tr></table></figure>
<p>在这个案例中，将<code>-n选项</code>和值<code>1</code>一起使用，告诉<code>read</code>命令在接受单个字符后退出，只要按下单个字符回答后，<code>read</code>命令就会接受输入并将它传给变量，无需按回车键。</p>
<h3 id="隐藏方式读取">隐藏方式读取</h3>
<p>有时候需要从脚本用户处得到输入，在屏幕上显示输入信息。但有种例外，就是输入密码，需要隐藏输入的信息。在<code>read</code>命令使用时，使用<code>-s</code>选项可以避免在<code>read</code>命令中输入的数据出现在显示器上（其实数据是会显示的，只是<code>read</code>命令将文本的颜色设成了跟背景色一样），下面是一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> hiding input data from the monitor</div><div class="line"><span class="meta">#</span></div><div class="line">read -s -p "Enter your passwd:  " pass</div><div class="line">echo</div><div class="line">echo "Is your password really $pass?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test27.sh</div><div class="line">Enter your passwd:  </div><div class="line">Is your password really dsfdf?</div></pre></td></tr></table></figure>
<p>输入提示符输入的数据不会出现在屏幕上，但会赋值给变量，以便在脚本中使用。</p>
<h3 id="从文件中读取数据">从文件中读取数据</h3>
<p><code>read</code>可以用于读取文件中的数据，每次调用<code>read</code>命令时，它就会从文件中读取一行文本。当文件中再没有内容时，<code>read</code>命令就会退出，并返回非零退出状态码。通常使用<code>cat</code>命令将数据中的文件传给含有<code>read</code>命令的<code>while</code>命令，看一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> reading data from a file</div><div class="line"></div><div class="line">count=1</div><div class="line">cat test|while read line</div><div class="line">do</div><div class="line">    echo "Line $count: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "Finished processing the file"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat test</div><div class="line">The quick brown dog jumps over the lazy fox.</div><div class="line">This is a test, this is only a test.</div><div class="line">O Romeo, Romeo! Wherefore art thou Romeo?</div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/01/Linux-shell03-for、while和until语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/Linux-shell03-for、while和until语句/" itemprop="url">Shell学习笔记（3）——for、while和until语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-01T12:10:54+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,875
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记的参考资料是（<a href="https://item.jd.com/12010266.html" target="_blank" rel="external">《Linux命令行与shell脚本编程大全》</a>（第3版），外加百度辅助，本篇笔记的主要内容是循环语句，即for、while和until语句。</p>
<h2 id="for命令">for命令</h2>
<p>如果遇到这样的场景：重复一组命令直到某个特定条件，例如处理某个目录下的所有文件、系统上所有用户或是某个文本文件中的所有行。此时就会用到<code>for</code>命令，for命令可以创建一个遍历一系列值的的循环，每次迭代就会使用其中一个值来执行已定义好的一组命令，for命令的格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for var in list</div><div class="line">do </div><div class="line">    commands</div><div class="line">done</div></pre></td></tr></table></figure>
<p>格式解释：</p>
<p>第一，在list参数中，用户需要提供推荐中要用到的一系列值；</p>
<p>第二，在每次迭代时，变量var会包含列表中的当前值，第一次迭代使用列表中的第1个值，第2次使用第2个值，以此类推；</p>
<p>第三，在<code>do</code>和<code>done</code>语句之间输入的命令可以是一条或多条标准的bash sehll命令，在这些命令中，<code>$var</code>变量包含着这次迭代对应的当前列表项的中值。</p>
<h3 id="第1案例读取列表中的值">第1案例：读取列表中的值</h3>
<p>for命令最基本的用法就是遍历for命令自身所定义的一系列值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> basic for command</div><div class="line">for test in Apple Pear Banana Orange Onion</div><div class="line">do</div><div class="line">    echo The next fruit is $test</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The next fruit is Apple</div><div class="line">The next fruit is Pear</div><div class="line">The next fruit is Banana</div><div class="line">The next fruit is Orange</div><div class="line">The next fruit is Onion</div></pre></td></tr></table></figure>
<p>每次for命令遍历值列表，它都会将列表中的下个值赋给<code>$test</code>变量，<code>$test</code>变量可以像for命令语句中的其他脚本变量一样使用，在最后一次迭代后，<code>$test</code>变量的值会在shell脚本的剩余部分一直保持有效，它会一直保持最后一次迭代的值，除非再次为变量赋值，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the for variable after the looping</div><div class="line"></div><div class="line">for test in Apple Pear Banana Orange Onion</div><div class="line">do</div><div class="line">    echo The next fruit is $test</div><div class="line">done</div><div class="line"></div><div class="line">echo "The last fruit we visited was $test"</div><div class="line">test=Watermelon</div><div class="line">echo "Wait, now we're visiting $test"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test1b.sh</div><div class="line">The next fruit is Apple</div><div class="line">The next fruit is Pear</div><div class="line">The next fruit is Banana</div><div class="line">The next fruit is Orange</div><div class="line">The next fruit is Onion</div><div class="line">The last fruit we visited was Onion</div><div class="line">Wait, now we&apos;re visiting Watermelon</div></pre></td></tr></table></figure>
<h3 id="转义字符的使用">转义字符的使用</h3>
<p>for中有可能会遇到比较复杂的值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> another example of how not to use the for command</div><div class="line"></div><div class="line">for test in I don't know if this'll work</div><div class="line">do</div><div class="line">    echo "word:$test"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果运行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test1c.sh</div><div class="line">word:I</div><div class="line">word:dont know if thisll</div><div class="line">word:work</div></pre></td></tr></table></figure>
<p>从结果中可以看出，如果for的列表中存在单引号，则在迭代中会出错误，它会把单引号去掉，并把单引号中间的字符串当作是一个值，如果要解决这个问题，可以使用两种方法：第一，使用转义字符来将单引号转义；第二，使用双引号来定义用到的单引号的值。</p>
<p>现在用这两种方法来解决这个问题，第一个引用用第一种方法，第二个引号用第二种方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># another example of how not to use the for command</div><div class="line"></div><div class="line">for test in I don\&apos;t know if this\&apos;ll work</div><div class="line">do</div><div class="line">    echo &quot;word:$test&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test1c1.sh</div><div class="line">word:I</div><div class="line">word:don&apos;t</div><div class="line">word:know</div><div class="line">word:if</div><div class="line">word:this&apos;ll</div><div class="line">word:work</div></pre></td></tr></table></figure>
<p>从结果可以看出两个单引号都能正常工作了。</p>
<h3 id="多个词的分割">多个词的分割</h3>
<p>在for循环中，每个值都是用空格进行分割的，如果某个值包含空格，就会比较麻烦，如下面的案例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> another example of how not to user the for command</div><div class="line">for test in Nevada New Hampshire New Mexico New York North Carolina</div><div class="line">do</div><div class="line">    echo "Now going to $test"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash bedtest2 </div><div class="line">Now going to Nevada</div><div class="line">Now going to New</div><div class="line">Now going to Hampshire</div><div class="line">Now going to New</div><div class="line">Now going to Mexico</div><div class="line">Now going to New</div><div class="line">Now going to York</div><div class="line">Now going to North</div><div class="line">Now going to Carolina</div></pre></td></tr></table></figure>
<p>从结果来看有问题，如果想要把含有空格的数值正确地迭代出来，必须使用双引号将这些值给圈起来，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> another example of how not to user the for command</div><div class="line">for test in Nevada "New Hampshire" " New Mexico" "New York" "North Carolina"</div><div class="line">do</div><div class="line">    echo "Now going to $test"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash bedtest2 </div><div class="line">Now going to Nevada</div><div class="line">Now going to New Hampshire</div><div class="line">Now going to  New Mexico</div><div class="line">Now going to New York</div><div class="line">Now going to North Carolina</div></pre></td></tr></table></figure>
<h3 id="从变量读取列表">从变量读取列表</h3>
<p>在shell脚本中会遇到这样的情况：将一系列的值都储存在了一个变量中，然后需要遍历变量中的整个列表。这种情况下，可以使用for命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a variable to hold the list</div><div class="line"><span class="meta">#</span></div><div class="line">list="Henan Chongqing Hebei Jiangsu"</div><div class="line">list=$list" Heilongjiang"</div><div class="line">for province in $list</div><div class="line">do</div><div class="line">    echo "Have you ever visited $province?"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test4.sh</div><div class="line">Have you ever visited Henan?</div><div class="line">Have you ever visited Chongqing?</div><div class="line">Have you ever visited Hebei?</div><div class="line">Have you ever visited Jiangsu?</div><div class="line">Have you ever visited Heilongjiang?</div></pre></td></tr></table></figure>
<p>代码解释，在代码中有一行这样的代码，即<code>list=$list&quot; Heilongjiang&quot;</code>，它表示在原来的列表中添加一个元素。</p>
<h3 id="从命令读取值">从命令读取值</h3>
<p>生成列表中所需要值的另外一个途径就是使用命令的输出，可以用命令替换来执行任何能产生输出的 命令，然后在for命令中使用该命令的输出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> reading values from a file</div><div class="line"></div><div class="line">file="province"</div><div class="line"></div><div class="line">for province in $(cat $file)</div><div class="line">do</div><div class="line">    echo "Visit beautifull $province"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ cat province</div><div class="line">Henan</div><div class="line">Chongqing</div><div class="line">Hubei</div><div class="line">Jiansu</div><div class="line">Guangdong</div><div class="line">Guangxi</div><div class="line">biotest@ubuntu:~/loop$ bash test5.sh</div><div class="line">Visit beautifull Henan</div><div class="line">Visit beautifull Chongqing</div><div class="line">Visit beautifull Hubei</div><div class="line">Visit beautifull Jiansu</div><div class="line">Visit beautifull Guangdong</div><div class="line">Visit beautifull Guangxi</div></pre></td></tr></table></figure>
<p>在这个案例中，使用了cat命令来输出文件province的内容，在province文件中，每一行有一个省，其中最后一行是China HongKong，中间有一个空格。然后在输出时，for命令把China HongKong分开了。这是因为，在bash shell中，空格，换行符，制表符都是分割符，因此会被分开。</p>
<h3 id="更改字段分割符">更改字段分割符</h3>
<p>for在迭代变量时，使用空格作为分割符，这是因为存在一个特殊的环境就是IFS，它的全称是internal field separator，中文名是内部字段分割符。IFS环境变量定义了bash shell用作字段分割符的一系列字符。默认情况下，bash shell会将以下字符当作是字段分割符，其中包括①空格；②制表符；③换行符。bash shell会将数据中的这些字符都当成分割符，因此在处理含有空格的数据（例如某些文件名）时非常麻烦。如果要解决这个问题，需要修改IFS的值，例如，想让bash shell只识别换行符，就当IFS更改为<code>IFS=$'/n'</code>。将这个语句加入到脚本中，就会告诉bash shell在数据中忽略空格和制表符，还以上面的案例为基础，看一下这段代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> reading values from a file</div><div class="line"></div><div class="line">file="province"</div><div class="line"></div><div class="line">IFS=$'\n'</div><div class="line">for province in $(cat $file)</div><div class="line">do</div><div class="line">    echo "Visit beautifull $province"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test5a.sh </div><div class="line">Visit beautifull Henan</div><div class="line">Visit beautifull Chongqing</div><div class="line">Visit beautifull Hubei</div><div class="line">Visit beautifull Jiansu</div><div class="line">Visit beautifull Guangdong</div><div class="line">Visit beautifull Guangxi</div><div class="line">Visit beautifull China HongKong</div></pre></td></tr></table></figure>
<p>现在结果一切正常。如果处理的代码量比较大时，可能在一个地方需要修改IFS的值，然后忽略这次悠，在脚本的其他地方继续没用IFS的默认值，这个时候需要在改变IFS之前保存原来的IFS值，之后再恢复它，这种做法习惯是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IFS.OLD=$IFS</div><div class="line">IFS=$'\n'</div><div class="line">&lt;在代码中使用新的IFS值&gt;</div><div class="line">IFS=$IFS.OLD</div></pre></td></tr></table></figure>
<p>此外，还有一种情况，如果某个文件中的分割隔都是冒号（:），例如<code>etc/passwd</code>文件中就是这样，此时也可以将IFS的值更改炒冒号，就像这样<code>IFS=:</code>，如果需要指定多个IFS字符，只要将它们在赋值行中一并输入就行，例如<code>IFS=$'\n':;&quot;</code>，这个赋值就是将换行符、冒号、分号和双引号作为字段分隔符。</p>
<h3 id="使用通配符读取目录">使用通配符读取目录</h3>
<p>使用for命令可以自动遍历目录中的文件，进行操作时，必须要在文件名或路径名中使用通配符，它会强制shell使用文件扩展匹配，文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程，如果不清楚所有的文件名，这个特性在处理上当中的文件时很好用，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> iterate throught all the files in a directory</div><div class="line"></div><div class="line">for file in /home/biotest/test/*</div><div class="line">do</div><div class="line"></div><div class="line">    if [ -d "$file" ]</div><div class="line">    then</div><div class="line">        echo "$file is a directory"</div><div class="line">    elif [ -f "$file" ]</div><div class="line">    then</div><div class="line">        echo "$file is a file"</div><div class="line">    fi</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行后结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test6.sh|head</div><div class="line">/home/biotest/test/badtest2.sh is a file</div><div class="line">/home/biotest/test/badtest.sh is a file</div><div class="line">/home/biotest/test/cheat is a directory</div><div class="line">/home/biotest/test/contrast_file.sh is a file</div><div class="line">/home/biotest/test/directest.sh is a file</div><div class="line">/home/biotest/test/group.sh is a file</div><div class="line">/home/biotest/test/hockey is a file</div><div class="line">/home/biotest/test/object_exist.sh is a file</div><div class="line">/home/biotest/test/owner.sh is a file</div><div class="line">/home/biotest/test/sentinel is a file</div></pre></td></tr></table></figure>
<p>代码及结果解释：for命令遍历<code>/home/biotest/test/*</code>输出的结果，此代码使用了test命令测试了每个目录，以查看它是目录（-d参数）还是文件（-f参数）。在上面的代码中，<code>if [ -d &quot;$file&quot; ]</code>这里比较特殊，因此它加了引号，因为目录名和文件中包含空格非常常见，因此为了适应这种情况，需要将<code>$file</code>变量用双引号圈起来，如果不圈起来，就会输出错误，如下所示：</p>
<p>现在在<code>/home/biotest/test</code>目录中添加一个目录，命令为<code>a b</code>（中间有空格），再把上面的代码中的<code>if [ -d &quot;$file&quot; ]</code>的引号去掉，运行，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test6a.sh</div><div class="line">test6a.sh: line 7: [: /home/biotest/test/a: binary operator expected</div></pre></td></tr></table></figure>
<p>这里就显示出错。因为在test命令方面，bash shell会将额外的单词当作参数，从而造成错误。</p>
<p>在for命令中可以列出多个目录通配符，将目录查找和列表合并到同一个for语句中，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> iterating through multiple directories</div><div class="line"></div><div class="line">for file in /home/biotest/.b*  /home/biotest/testing</div><div class="line">do</div><div class="line">    if [ -d "$file" ]</div><div class="line">    then</div><div class="line">        echo "$file is a directory"</div><div class="line">    elif [ -f "$file" ]</div><div class="line">    then</div><div class="line">        echo "$file is a file"</div><div class="line">    else</div><div class="line">        echo "$file doesn't exist"</div><div class="line">    fi</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test7.sh</div><div class="line">/home/biotest/.bash_history is a file</div><div class="line">/home/biotest/.bash_logout is a file</div><div class="line">/home/biotest/.bashrc is a file</div><div class="line">/home/biotest/testing is a directory</div></pre></td></tr></table></figure>
<p>for语句使用了文件扩展匹配来遍历通配符生成的文件列表，然后它会遍历列表中的下一个文件。</p>
<h2 id="c语言风格的for命令">C语言风格的for命令</h2>
<h3 id="简单的c风格for命令">简单的C风格for命令</h3>
<p>在C语言中，它的for命令有一个用来指明变量的特定方法，一个必须保持成立才能继续迭代的条件。以及另一个在每个迭代中改变变量的方法，当指定的条件不成立时，for循环就会停止，条件等式通过标准的数学符号定义，例如下面的C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"The next number is %d\n"</span>,i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码会产生一个简单的迭代循环，其中变量<code>i</code>作为计数器，第一部分将一个默认值赋给该变量，中间的部分定义了循环重复的条件。当定义的条件不成立时，for循环就停止迭代。最后一部分定义了迭代的过程，在每次迭代之后，最后一部分占定义的表达式会被执行，在此案例中，每迭代一次，<code>i</code>变量就会增加1。</p>
<p>bash shell也支持一种for循环，与C语言的for循环类似，它的格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (( variable assignment ; condition ; iteration process ))</div></pre></td></tr></table></figure>
<p>在bash shell的C语言风格的for命令中，它有一些特殊的地方：第一，变量赋值可以有空格；第二，条件中的变量不以美元符号开头；第三，迭代过程中的算式并使用expr命令格式。看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the C-sytle for loop</div><div class="line"></div><div class="line">for (( i=1; i&lt;=10;i++))</div><div class="line">do</div><div class="line">    echo "The next number is $i"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test8.sh</div><div class="line">The next number is 1</div><div class="line">The next number is 2</div><div class="line">The next number is 3</div><div class="line">The next number is 4</div><div class="line">The next number is 5</div><div class="line">The next number is 6</div><div class="line">The next number is 7</div><div class="line">The next number is 8</div><div class="line">The next number is 9</div><div class="line">The next number is 10</div></pre></td></tr></table></figure>
<h3 id="使用多个变量">　使用多个变量</h3>
<p>C风格的for命令也可以迭代多个变量，循环会单独处理每个变量，用户可以为每个变量定义不同的迭代过程，虽然可以使用多个变量，但在for循环中只能定义一种条件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test9.sh</div><div class="line">1-10</div><div class="line">2-9</div><div class="line">3-8</div><div class="line">4-7</div><div class="line">5-6</div><div class="line">6-5</div><div class="line">7-4</div><div class="line">8-3</div><div class="line">9-2</div><div class="line">10-1</div></pre></td></tr></table></figure>
<p>代码及结果解释：变量a和b分别用不同的值来初始化并定义了不同的迭代过程，循环的每次迭代在增加变量a的同时，减小了变量b。</p>
<h2 id="while命令">while命令</h2>
<p>while命令在某种程度上是<code>if-then</code>和<code>for</code>循环的混合体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0。它会在每次迭代的一开始测试test命令。在test命令返回非零退出状态码时，while命令会停止执行那组命令。</p>
<h3 id="while命令的基本使用">while命令的基本使用</h3>
<p>while命令的基本格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">while test command</div><div class="line">do</div><div class="line">    other commands</div><div class="line">done</div></pre></td></tr></table></figure>
<p>while命令中定义的test command和if-then语句中的格式一样。可以使用任何普通bash shell命令，或者用test命令进行条件测试，比如测试变量值。while命令的关键在于所指定的test command的退出状态码必须随着循环中运行的命令而改变，如果退出状态码不发生变化，while循环就将一直不停地进行下去。常用的test command的用法是用方括号来检查循环命令中用到的shell变量的值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> while command test</div><div class="line"></div><div class="line">var1=10</div><div class="line">while [ $var1 -gt 0 ]</div><div class="line">do</div><div class="line">    echo $var1</div><div class="line">    var1=$[ $var1 -1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test10.sh</div><div class="line">10</div><div class="line">9</div><div class="line">8</div><div class="line">7</div><div class="line">6</div><div class="line">5</div><div class="line">4</div><div class="line">3</div><div class="line">2</div><div class="line">1</div></pre></td></tr></table></figure>
<p>在这个例子中，while命令定义了每次迭代时检查的测试条件，即<code>whle [ $var1 -gt 0 ]</code>，只要测试条件成立，<code>while</code>命令就会不停地循环执行定义好的命令，在这些命令中，测试条件中用到的变量必须修改，否则就会降入无限循环，在这个案例中，每次循环，变量值就会减一，即<code>var1=[ $var1 -1 ]</code>。while循环会在测试条件不再成立时停止。</p>
<h3 id="使用多个测试命令">使用多个测试命令</h3>
<p>while命令允许用户在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。如果在输入命令时不小心，会导致一些意外，如下面的案例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing a multicommand while loop</div><div class="line"></div><div class="line">var1=10</div><div class="line"></div><div class="line">while echo $var1</div><div class="line">    [ $var1 -ge 0 ]</div><div class="line">do</div><div class="line">    echo "This is inside the loop"</div><div class="line">    var1=$[ $var1 - 1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test11.sh</div><div class="line">10</div><div class="line">This is inside the loop</div><div class="line">9</div><div class="line">This is inside the loop</div><div class="line">8</div><div class="line">This is inside the loop</div><div class="line">7</div><div class="line">This is inside the loop</div><div class="line">6</div><div class="line">This is inside the loop</div><div class="line">5</div><div class="line">This is inside the loop</div><div class="line">4</div><div class="line">This is inside the loop</div><div class="line">3</div><div class="line">This is inside the loop</div><div class="line">2</div><div class="line">This is inside the loop</div><div class="line">1</div><div class="line">This is inside the loop</div><div class="line">0</div><div class="line">This is inside the loop</div><div class="line">-1</div></pre></td></tr></table></figure>
<p>代码及结果解释：第一个测试显示了var1变量的当前值，即<code>while echo $var1</code>，第二个测试用方括号来判断var1变量的值，即<code>[ $var1 -ge 0 ]</code>，在循环内部，echo语句会显示一条信息，说明循环被执行了，在最后，变量成为-1，这是因为while循环会在var1变量等于0时执行echo语句，然后将var1送去1，接下来再执行测试命令，用于下一次迭代，echo不测试命令被执行并显示了var变量的值，直到shell执行test测试命令，while循环才停止。这就说明在含有多个命令的while语句中，在每次迭代中所有的测试命令都会被执行，包括测试命令失败的最后一交迭代，需要注意这种用法。</p>
<h2 id="until命令">until命令</h2>
<p>until命令和while命令的工作方式完全相反，until命令要求你指定一个通常返回非零退出状态码的测试命令。只有油门工命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结果了，until命令的基本格式如下所示：</p>
<h3 id="until命令的基本格式">until命令的基本格式</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">until test commands</div><div class="line">do</div><div class="line">    other commands</div><div class="line">done</div></pre></td></tr></table></figure>
<p>与while命令类似，在until命令中也可以放入多个测试命令，只有最后个命令的退出状态码决定了bash shell是否执行已经定义的other commands，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the until command</div><div class="line"></div><div class="line">var1=100</div><div class="line"></div><div class="line">until [ $var1 -eq 0 ]</div><div class="line">do</div><div class="line">    echo $var1</div><div class="line">    var1=$[ $var1 - 25 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test12.sh</div><div class="line">100</div><div class="line">75</div><div class="line">50</div><div class="line">25</div></pre></td></tr></table></figure>
<p>代码及结果解释：由于变量var1来决定until循环什么时候停止，只要该变量的的值等于0，until命令就会停止循环。until与while类似，在使用多个测试命令时要注意，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the until command</div><div class="line"></div><div class="line">var1=100</div><div class="line"></div><div class="line">until echo $var1</div><div class="line">    [ $var1 -eq 0 ]</div><div class="line">do</div><div class="line">    echo Inside the loop: $var1</div><div class="line">    var1=$[ var1 - 25 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test13.sh</div><div class="line">100</div><div class="line">Inside the loop: 100</div><div class="line">75</div><div class="line">Inside the loop: 75</div><div class="line">50</div><div class="line">Inside the loop: 50</div><div class="line">25</div><div class="line">Inside the loop: 25</div><div class="line">0</div></pre></td></tr></table></figure>
<p>直到var1=0，程序运行结束。</p>
<h2 id="嵌套循环">嵌套循环</h2>
<p>循环语句可以在循环内使用任意类型的命令，包括其他循环命令。这种循环叫嵌套循环（nested loop）。需要注意的是，在使用嵌套循环时，是在迭代中使用迭代，与命令运行次数的关系是乘积的关系，在写代码时尤其要注意这一点，看下面的一个案例。</p>
<h3 id="for循环与for循环的嵌套">for循环与for循环的嵌套</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> nesting for loops</div><div class="line"></div><div class="line">for (( a=1;a&lt;=3;a++))</div><div class="line">do</div><div class="line">    echo "Starting loop $a: "</div><div class="line">    for ((b=1;b&lt;=3;b++))</div><div class="line">    do</div><div class="line">        echo "   Inside loop: $b"</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test14.sh</div><div class="line">Starting loop 1: </div><div class="line">   Inside loop: 1</div><div class="line">   Inside loop: 2</div><div class="line">   Inside loop: 3</div><div class="line">Starting loop 2: </div><div class="line">   Inside loop: 1</div><div class="line">   Inside loop: 2</div><div class="line">   Inside loop: 3</div><div class="line">Starting loop 3: </div><div class="line">   Inside loop: 1</div><div class="line">   Inside loop: 2</div><div class="line">   Inside loop: 3</div></pre></td></tr></table></figure>
<p>代码及结果解释：在嵌套循环中，在外部循环的每次迭代中遍历一次它所有的值，两个循环的do和done命令没有任何差别，bash shell知道当第一个node命令执行的是内部循环，而非外部循环。</p>
<h3 id="while循环与for循环的嵌套">while循环与for循环的嵌套</h3>
<p>在while循环内也可以放置一个for循环，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> palcing a for loop inside a while loop</div><div class="line"></div><div class="line">var1=5</div><div class="line"></div><div class="line">while [ $var1 -ge 0 ]</div><div class="line">do</div><div class="line">    echo "Outer loop: $var1"</div><div class="line">    for ((var2=1;$var2&lt;3;var2++))</div><div class="line">    do</div><div class="line">        var3=$[ $var1*$var2 ]</div><div class="line">        echo " Inner loop: $var1*$var2=$var3"</div><div class="line">    done</div><div class="line">    var1=$[ $var1 - 1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Outer loop: 5</div><div class="line"> Inner loop: 5*1=5</div><div class="line"> Inner loop: 5*2=10</div><div class="line">Outer loop: 4</div><div class="line"> Inner loop: 4*1=4</div><div class="line"> Inner loop: 4*2=8</div><div class="line">Outer loop: 3</div><div class="line"> Inner loop: 3*1=3</div><div class="line"> Inner loop: 3*2=6</div><div class="line">Outer loop: 2</div><div class="line"> Inner loop: 2*1=2</div><div class="line"> Inner loop: 2*2=4</div><div class="line">Outer loop: 1</div><div class="line"> Inner loop: 1*1=1</div><div class="line"> Inner loop: 1*2=2</div><div class="line">Outer loop: 0</div><div class="line"> Inner loop: 0*1=0</div><div class="line"> Inner loop: 0*2=0</div></pre></td></tr></table></figure>
<h3 id="until循环与for循环的嵌套">until循环与for循环的嵌套</h3>
<p>案例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using until and while loops</div><div class="line"></div><div class="line">var1=3</div><div class="line"><span class="meta">#</span> 变量以3开始</div><div class="line">until [ $var1 -eq 0 ] # 除非var1等于0，否则继续运行do...done之间的语句</div><div class="line">do</div><div class="line">    echo "Outer loop: $vaar1"</div><div class="line">    var2=1</div><div class="line">    while [ $var2 -lt 5 ] # 当var2小于5时，一直运行</div><div class="line">    do</div><div class="line">        var3=$(echo "scale=4;$var1/$var2" |bc)</div><div class="line">        echo "   Inner loop: $var1/$var2=$var3"</div><div class="line">        var2=$[ $var2+1 ]</div><div class="line">    done</div><div class="line">    var1=$[ $var1-1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test16.sh</div><div class="line">Outer loop: </div><div class="line">   Inner loop: 3/1=3.0000</div><div class="line">   Inner loop: 3/2=1.5000</div><div class="line">   Inner loop: 3/3=1.0000</div><div class="line">   Inner loop: 3/4=.7500</div><div class="line">Outer loop: </div><div class="line">   Inner loop: 2/1=2.0000</div><div class="line">   Inner loop: 2/2=1.0000</div><div class="line">   Inner loop: 2/3=.6666</div><div class="line">   Inner loop: 2/4=.5000</div><div class="line">Outer loop: </div><div class="line">   Inner loop: 1/1=1.0000</div><div class="line">   Inner loop: 1/2=.5000</div><div class="line">   Inner loop: 1/3=.3333</div><div class="line">   Inner loop: 1/4=.2500</div></pre></td></tr></table></figure>
<h2 id="循环处理文件数据">循环处理文件数据</h2>
<p>当我们遇到一种情况，即必须要遍历储存在文件中的数据时，需要两种技术。第一，使用嵌套循环；第二，修改IFS环境变量。通过修改IFS环境变量，就能强制for命令将文件中的每行都当成单独的一个条目来处理，即使数据中有空格也是如此，一旦从文件中提取出了单独的行，可能需要再次利用循环来提取行中的数据，典型的案例就是处理<code>/etc/passwd</code>文件中的数据，这要求你逐行遍历<code>/etc/passwd</code>文件，并将IFS变量的值改为冒号，这样就能分隔开每行中的各个数据段了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> changing the IFS value</div><div class="line"></div><div class="line">IFS=$'\n'</div><div class="line">for entry in $(cat /etc/passwd)</div><div class="line">do</div><div class="line">    echo "Values in $entry -"</div><div class="line">    IFS=:</div><div class="line">    for value in $entry</div><div class="line">    do</div><div class="line">        echo "    $value"</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test17.sh|head</div><div class="line">Values in root:x:0:0:root:/root:/bin/bash -</div><div class="line">    root</div><div class="line">    x</div><div class="line">    0</div><div class="line">    0</div><div class="line">    root</div><div class="line">    /root</div><div class="line">    /bin/bash</div><div class="line">Values in daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin -</div><div class="line">    daemon</div></pre></td></tr></table></figure>
<p>这个脚本使用了两个不同的FIS值来解析数据，第一个IFS值解析出<code>/etc/passwd</code>文件中的单独的行，内部for循环接着将FIS的值修改为冒号，然后从单独的行中解析出单独的值，因此在第一次运行时，会提取出一行数据，例如<code>root​:x:​0:0:root:/root:/bin/bash</code> ，接头使用for循环，提取出这一行中以冒号为分割符的元素，即<code>root x  0 0 root /root /bin/bash</code>信息。</p>
<h2 id="控制循环">控制循环</h2>
<p>如果遇到这样的情况：一旦开启了循环，必须要等到所有的循环完成迭代时才结束，如果我想提前想结束循环的话，此时就要用到<code>break</code>命令和<code>continue</code>命令。</p>
<h3 id="break命令">break命令</h3>
<p><code>break</code>命令可以退出任意类型的循环，包括<code>until</code>和<code>while</code>循环。</p>
<h4 id="break跳出单个循环">break跳出单个循环</h4>
<p>在shell中执行break命令，它会深度跳出当前正在执行的循环，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> breaking out of a for loop</div><div class="line"></div><div class="line">for var1 in 1 2 3 4 5 6 7 8 9 10</div><div class="line">do</div><div class="line">    if [ $var1 -eq 5 ]</div><div class="line">    then</div><div class="line">       break</div><div class="line">    fi</div><div class="line">    echo "Iteration number: $var1"</div><div class="line">done</div><div class="line">echo "The for loop is completed"</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test18.sh</div><div class="line">Iteration number: 1</div><div class="line">Iteration number: 2</div><div class="line">Iteration number: 3</div><div class="line">Iteration number: 4</div><div class="line">The for loop is completed</div></pre></td></tr></table></figure>
<p>for循环通常都会遍历列表中指定的所有值。但当满足if-then的条件时，shell会执行break命令，停止for循环。同样的方法也适用于while和until循环，如下所示：：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> breaking oiut of a while loop</div><div class="line"></div><div class="line">var1=1</div><div class="line"></div><div class="line">while [ $var1 -lt 10 ]</div><div class="line">do</div><div class="line">    if [ $var1 -eq 5 ]</div><div class="line">    then</div><div class="line">        break</div><div class="line">    fi</div><div class="line">    echo "Iteration: $var1"</div><div class="line">    var1=$[ $var1+1 ]</div><div class="line">done</div><div class="line">echo "The while is loop is completed"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test19.sh</div><div class="line">Iteration: 1</div><div class="line">Iteration: 2</div><div class="line">Iteration: 3</div><div class="line">Iteration: 4</div><div class="line">The while is loop is completed</div></pre></td></tr></table></figure>
<h3 id="section"></h3>
<h4 id="跳出内部循环">跳出内部循环</h4>
<p>在处理多个循环时，break命令会自动终止你所在的最内层的循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> breaking out of an inner loop</div><div class="line"></div><div class="line">for ((a=1;a&lt;4;a++))</div><div class="line">do</div><div class="line">    echo "Outer loop: $a"</div><div class="line">    for ((b=1;b&lt;100;b++)) # 内部循环指定当变量b等于100时停止迭代；</div><div class="line">    do</div><div class="line">        if [ $b -eq 5 ] # 但是当内部循环的if-then语句指明当变量b的值等于5时就执行break命令，跳出循环</div><div class="line">        then</div><div class="line">            break</div><div class="line">        fi</div><div class="line">        echo "   Inner loop:  $b" # 但是外部的循环仍然继续执行</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test20.sh</div><div class="line">Outer loop: 1</div><div class="line">   Inner loop:  1</div><div class="line">   Inner loop:  2</div><div class="line">   Inner loop:  3</div><div class="line">   Inner loop:  4</div><div class="line">Outer loop: 2</div><div class="line">   Inner loop:  1</div><div class="line">   Inner loop:  2</div><div class="line">   Inner loop:  3</div><div class="line">   Inner loop:  4</div><div class="line">Outer loop: 3</div><div class="line">   Inner loop:  1</div><div class="line">   Inner loop:  2</div><div class="line">   Inner loop:  3</div><div class="line">   Inner loop:  4</div></pre></td></tr></table></figure>
<h4 id="跳出外部循环">跳出外部循环</h4>
<p>有时候需要在内部循环，但外部循环停止，break命令可以接受单个命令行参数值，<code>break -n</code>，其中n指定了要跳出的循环层级，默认情况下，n为1，表明跳出的是当前的循环，即最内层的是第1层循环，如果设为2，break命令就会停止下一级的外部循环，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> breaking out of an outer loop</div><div class="line"></div><div class="line">for ((a=1;a&lt;4;a++))</div><div class="line">do</div><div class="line">    echo "Outer loop: $a"</div><div class="line">    for ((b=1;b&lt;100;b++))</div><div class="line">    do</div><div class="line">        if [ $b -gt 4 ]</div><div class="line">        then</div><div class="line">            break 2</div><div class="line">        fi</div><div class="line">        echo "   Inner loop: $b"</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test21.sh</div><div class="line">Outer loop: 1</div><div class="line">   Inner loop: 1</div><div class="line">   Inner loop: 2</div><div class="line">   Inner loop: 3</div><div class="line">   Inner loop: 4</div></pre></td></tr></table></figure>
<p>当shell执行了break命令后，外部循环就停止了。</p>
<h3 id="continue命令">continue命令</h3>
<p>continue命令可以提前中止某次循环中的命令，但并不会完全终止整个循环，可以在循环内部设置shell不执行命令的条件，这里有个for循环中使用continue命令的简单例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing continue command</div><div class="line"></div><div class="line">for ((var1=1;var1&lt;15;var1++))</div><div class="line">do</div><div class="line">    if [ $var1 -gt 5 ] &amp;&amp; [ $var1 -lt 10 ] </div><div class="line">    then</div><div class="line">         continue</div><div class="line">    fi</div><div class="line">    echo "Iteration number: $var1"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ vim continue_test.sh</div><div class="line">biotest@ubuntu:~/loop$ bash continue_test.sh </div><div class="line">Iteration number: 1</div><div class="line">Iteration number: 2</div><div class="line">Iteration number: 3</div><div class="line">Iteration number: 4</div><div class="line">Iteration number: 5</div><div class="line">Iteration number: 10</div><div class="line">Iteration number: 11</div><div class="line">Iteration number: 12</div><div class="line">Iteration number: 13</div><div class="line">Iteration number: 14</div></pre></td></tr></table></figure>
<p>代码解释:当if-then语句的条件满足时，即值大于5小于10，shell会 执行continue命令，跳过此次循环中的剩余命令，但整个循环还会继续，当if-then的条件不再满足后，又继续循环。在while和until循环中也可以使用continue命令，但要谨慎，因为当shell执行continue命令时，它会跳过剩余的部分，如果在其中的条件具条件里对测试条件变量进行增值，问题就会出现，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> improperly using the continue command in a while loop</div><div class="line"></div><div class="line">var1=0</div><div class="line"></div><div class="line">while echo "while iteration; $var1"</div><div class="line">    [ $var1 -lt 15 ]</div><div class="line">do</div><div class="line">    if [ $var1 -gt 5 ] &amp;&amp; [ $var1 -lt 10 ]</div><div class="line">    then</div><div class="line">        continue</div><div class="line">    fi</div><div class="line">    echo "   Inside iteration number: $var1"</div><div class="line">    var1=$[ $var1+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash badtest3.sh|head -20</div><div class="line">while iteration; 0</div><div class="line">   Inside iteration number: 0</div><div class="line">while iteration; 1</div><div class="line">   Inside iteration number: 1</div><div class="line">while iteration; 2</div><div class="line">   Inside iteration number: 2</div><div class="line">while iteration; 3</div><div class="line">   Inside iteration number: 3</div><div class="line">while iteration; 4</div><div class="line">   Inside iteration number: 4</div><div class="line">while iteration; 5</div><div class="line">   Inside iteration number: 5</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div></pre></td></tr></table></figure>
<p>从结果可以看了同，在if-then的条件成立之后，一切都正常，但是当执行了continue命令后，它就跳过了while循环中的剩余部分，则跳过的部分正好是$var1计数变量增值的部分，而这个变量又被用于个渭测试命令中，因此这个值就不再变化，从而连续输出。</p>
<p>continue也可以与break一样，使用n来指定要继续执行哪一级循环，格式为<code>continue n</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> continuing an outer loop</div><div class="line"></div><div class="line">for ((a=1;a&lt;=5;a++))</div><div class="line">do</div><div class="line">    echo "Iteration $a: "</div><div class="line">    for((b=1;b&lt;3;b++))</div><div class="line">    do</div><div class="line">        if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ]</div><div class="line">        then</div><div class="line">            continue 2</div><div class="line">        fi</div><div class="line">        var3=$[ $a*$b ]</div><div class="line">        echo "   The result of $a*$b is $var3"</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test22.sh</div><div class="line">Iteration 1: </div><div class="line">   The result of 1*1 is 1</div><div class="line">   The result of 1*2 is 2</div><div class="line">Iteration 2: </div><div class="line">   The result of 2*1 is 2</div><div class="line">   The result of 2*2 is 4</div><div class="line">Iteration 3: </div><div class="line">Iteration 4: </div><div class="line">   The result of 4*1 is 4</div><div class="line">   The result of 4*2 is 8</div><div class="line">Iteration 5: </div><div class="line">   The result of 5*1 is 5</div><div class="line">   The result of 5*2 is 10</div></pre></td></tr></table></figure></p>
<p>代码解释，其中的if-then部分为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ]</div><div class="line">        then</div><div class="line">            continue 2</div><div class="line">        fi</div></pre></td></tr></table></figure>
<p>在此处用continue命令来停止处理循环内的命令，但会继续处理外部循环，值为3的那次迭代并没有处理任何内部循环语句，因为尽管continue命令命令会停止了处理过程，但外部循环会继续。（有关<code>break n</code>与<code>continue n</code>的这个原理，再写一篇笔记，我是没弄清楚原理）。</p>
<h2 id="处理循环输出">处理循环输出</h2>
<p>在shell脚本中，可以对循环的输出使用管道或重定向，这可以通过在done命令之后添加一个处理命令来实现。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">for file in /home/biotest/*</div><div class="line"></div><div class="line">do   </div><div class="line">   if [ -d "$file" ]</div><div class="line">   then</div><div class="line">       echo "$file is a directory"</div><div class="line">   elif [ -f "$file" ]</div><div class="line">   then</div><div class="line">       echo "$file is a file"</div><div class="line">   fi</div><div class="line">done &gt; output.tx</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ cat output.txt|head</div><div class="line">/home/biotest/Desktop is a directory</div><div class="line">/home/biotest/Documents is a directory</div><div class="line">/home/biotest/Downloads is a directory</div><div class="line">/home/biotest/examples.desktop is a file</div><div class="line">/home/biotest/filename is a file</div><div class="line">/home/biotest/log. is a file</div><div class="line">/home/biotest/log.180427 is a file</div><div class="line">/home/biotest/loop is a directory</div><div class="line">/home/biotest/miniconda2 is a directory</div><div class="line">/home/biotest/Miniconda2-latest-Linux-x86_64.sh is a file</div></pre></td></tr></table></figure>
<p>第2个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting the for output to a file</div><div class="line"></div><div class="line">for ((a=1;a&lt;10;a++))</div><div class="line">do</div><div class="line">    echo "The number is $a"</div><div class="line">done &gt; test23.txt</div><div class="line">echo "The commmand is finished."</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ cat test23.txt</div><div class="line">The number is 1</div><div class="line">The number is 2</div><div class="line">The number is 3</div><div class="line">The number is 4</div><div class="line">The number is 5</div><div class="line">The number is 6</div><div class="line">The number is 7</div><div class="line">The number is 8</div><div class="line">The number is 9</div></pre></td></tr></table></figure>
<p>代码及结果解释：shell创建了文件test23.txt并将for命令的输出重定向到这个文件，shell在for命令之后正常显示了echo语句。这种方法也同样适用于将循环的结果用通道导入另一个命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> piping a loop to another command</div><div class="line"></div><div class="line">for province in "Chine HK" Henan Guangdong </div><div class="line">do</div><div class="line">    echo "$province is the next place to go"</div><div class="line">done | sort</div><div class="line">echo "This completes out travels"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test24.sh</div><div class="line">Chine HK is the next place to go</div><div class="line">Guangdong is the next place to go</div><div class="line">Henan is the next place to go</div><div class="line">This completes out travels</div></pre></td></tr></table></figure>
<p>代码及结果解释：province的值并没有在for命令列表中以特定次序列出，for命令的输出结果导入到了sort命令中，该命令会改变for命令输出结果的顺序。运行这个脚本实际上说明了结果已经在脚本内部排好序了。</p>
<h2 id="最终案例">最终案例</h2>
<h3 id="第1案例查找可执行文件">第1案例：查找可执行文件</h3>
<p>如果要找出系统中有哪些可执行文件，只需要扫描PATH环境变量中的所有目录即可，下面是这样的一个脚本，如下所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> finding files in the PATH</div><div class="line"></div><div class="line">IFS=:</div><div class="line">for folder in $PATH</div><div class="line">do </div><div class="line">    echo "$folder:"</div><div class="line">    for file in $folder/*</div><div class="line">    do</div><div class="line">        if [ -x $file ]</div><div class="line">        then</div><div class="line">            echo "   $file"</div><div class="line">        fi</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test25.sh|head -5</div><div class="line">/home/biotest/miniconda2/bin:</div><div class="line">   /home/biotest/miniconda2/bin/2to3</div><div class="line">   /home/biotest/miniconda2/bin/activate</div><div class="line">   /home/biotest/miniconda2/bin/appletviewer</div><div class="line">   /home/biotest/miniconda2/bin/c2ph</div><div class="line">biotest@ubuntu:~/loop$ cat test25.sh</div></pre></td></tr></table></figure>
<h3 id="第2案例创建多个用户账户">第2案例：创建多个用户账户</h3>
<p>如果要创建大量的用户，可以使用while循环来实现，将需要添加的新用户账户放在一个文本文件中，然后创建一个简单的脚本处理，文件文件的格式是这样的<code>userid, user name</code>，第一个条目是新用户的ID，第二个条目是用户的全名。两个值之间使用逗号分隔，这样就形成卫 种名为逗号分隔值的文本文件（或是csv格式文件）。如果要读取这里面的数据，需要将<code>IFS</code>分隔符设置为逗号，并将其放入while语句的条件测试部分。然后使用read命令读取文件中的各行，这一部分 的代码就是<code>while IFS=',',read -r userid name</code>，read命令会自动读取<code>.csv</code>文件的下一行内容，因此不需要创建一个循环，当read命令返回FALSE时（也就是读取完整个文件时），while命令就会退出，完整的脚本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> process new user accounts</div><div class="line"></div><div class="line">input="user.csv"</div><div class="line">while IFS=',' read -r userid name # -r这个参数表示允许输入的值中包含反斜杠“\”,反斜杠也作为值输出</div><div class="line">do</div><div class="line">    echo "adding $userid"</div><div class="line">    useradd -c "$name" -m $userid #-c表示：加上备注文字。备注文字会保存在passwd的备注栏位中；</div><div class="line">                                  # -m表示自动建立用户的登入目录</div><div class="line">done &lt; "$input" #将input变量中的csv文件输导入到while循环中</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ cat user.csv </div><div class="line">userid,user name</div><div class="line">501,test01</div><div class="line">502,test02</div><div class="line">503,test03</div><div class="line"></div><div class="line">biotest@ubuntu:~/loop$ sudo bash test26.sh</div><div class="line">[sudo] password for biotest: </div><div class="line">adding userid</div><div class="line">adding 501</div><div class="line">adding 502</div><div class="line">adding 503</div><div class="line"></div><div class="line">biotest@ubuntu:~/loop$ tail /etc/passwd</div><div class="line">kernoops:x:116:65534:Kernel Oops Tracking Daemon,,,:/:/bin/false</div><div class="line">pulse:x:117:124:PulseAudio daemon,,,:/var/run/pulse:/bin/false</div><div class="line">rtkit:x:118:126:RealtimeKit,,,:/proc:/bin/false</div><div class="line">saned:x:119:127::/var/lib/saned:/bin/false</div><div class="line">usbmux:x:120:46:usbmux daemon,,,:/var/lib/usbmux:/bin/false</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div><div class="line">:/home/userid:1002:user name</div><div class="line">:/home/501:1003:test01</div><div class="line">:/home/502:1004:test02</div><div class="line">:/home/503:1005:test03</div></pre></td></tr></table></figure>
<p>从结果可以看出，这3个账户已经生成。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/30/Linux-shell02-if-then和case语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/Linux-shell02-if-then和case语句/" itemprop="url">Shell学习笔记（2）——if-then和case语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-30T12:10:54+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,786
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记的参考资料是（<a href="https://item.jd.com/12010266.html" target="_blank" rel="external">《Linux命令行与shell脚本编程大全》</a>（第3版），外加百度辅助，本篇笔记的主要内容是if-then和case语句。</p>
<p>许多程序要求对shell脚本中的命令添加一些逻辑流控制。有一类命令会根据条件使脚本跳过某些命令，这样的命令叫做结构化命令（structured command）。</p>
<h2 id="if-then语句">if-then语句</h2>
<p>if-then语句是最基本的结构化命令，if-then的结构如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if commandA</div><div class="line">then commandB</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>解释：if后面跟一个shell命令commandA，如果commandA命令的退出状态码是0（表示此命令成功运行），位于then后面的commandB命令就会被执行，如果commandA命令的退出状态码是其他值，then后面的commandB就不会被执行，而是继续执行脚本中的下一具命令，fi语句用来表示if-theny语句到此结构。</p>
<h3 id="第1案例简单的if-then">第1案例：简单的if-then</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the if statement</div><div class="line">if pwd</div><div class="line">then</div><div class="line">  echo "It worked"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[20161111.DESKTOP-IVG4HR1] ➤ bash test1.sh</div><div class="line">/home/mobaxterm</div><div class="line">It worked</div></pre></td></tr></table></figure>
<p>代码解释：if部分用了pwd命令，这个命令运行成功后，echo就会显示后面的字符串。</p>
<h3 id="第2案例出错的if-then">第2案例：出错的if-then</h3>
<p>看一段代码，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing a bad command</div><div class="line">if IamNotaCommand;then</div><div class="line">  echo "It worked"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[2018-04-28 10:41.15]  ~</div><div class="line">[20161111.DESKTOP-IVG4HR1] ➤ bash test2.sh</div><div class="line">test2.sh: line 3: IamNotaCommand: command not found</div></pre></td></tr></table></figure>
<p>代码解释：if后面跟的是一个无法工作的命令，它会产生一个非零的退出状态码，bash shell会跳过then部分。</p>
<h3 id="第3案例then部分的多条命令">第3案例：then部分的多条命令</h3>
<p>在if-then语句中，then部分可以输入多条命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing multiple commands in the then seciton</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=biotest</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then </div><div class="line">  echo "This is my first command"</div><div class="line">  echo "This is my second command"</div><div class="line">  echo "I can even put in other commands besides echo: "</div><div class="line">  ls -a /home/$testuser/.b*</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test3.sh</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div><div class="line">This is my first command</div><div class="line">This is my second command</div><div class="line">I can even put in other commands besides echo: </div><div class="line">/home/biotest/.bash_history  /home/biotest/.bash_logout  /home/biotest/.bashrc</div></pre></td></tr></table></figure>
<p>代码解释：<code>if grep $testuser /etc/passwd</code>这条代码用于查找某个用户名当前是否在系统上使用，如果有用户使用了这个登录名，脚本会显示出一些文本信息，并列出该用户HOME目录中的bash文件。如果没有这个用户，就什么都不显示，现在将<code>testuser=biotest</code>改为<code>testuser=biotest0</code>，运行，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test3.sh</div><div class="line">biotest@ubuntu:~/test$</div></pre></td></tr></table></figure>
<h2 id="if-then-else语句">if-then-else语句</h2>
<p>if-then使用的场景是：如果if后面的命令成功执行，就输出then后面的内容，如果无法成功执行，什么都不输出。只有一这一种情况。而if-then-else语句则是能够执行其他的命令，它的格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if commandA</div><div class="line">then </div><div class="line">  commandB</div><div class="line">else </div><div class="line">  commandC</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>命令解释：当if语句中的commandA命令返回退出状态状码0时，then部分中的命令commandB会执行，到此if-then-else语句与if-then语句是相同的。如果if语句中的commandA命令返回非零状态码时，bash shell会执行else部分中的命令。看一个案例。</p>
<h3 id="第1案例常规if-then-else语句">第1案例：常规if-then-else语句</h3>
<p>看下面的代码:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing  the else section</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=biotest0</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then </div><div class="line">  echo "The bash files for user $testuser are:   "</div><div class="line">  ls -a /home/$testuser/.b*</div><div class="line">  echo</div><div class="line">else</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  echo</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test4.sh</div><div class="line">The user biotest0 does not exist on this system.</div></pre></td></tr></table></figure>
<p>从代码与结果可以看出，<code>if grep $testuser /etc/passwd</code>命令出错，返回状态码是非0，<code>then</code>后面的命令不会执行，路过，执行<code>else</code>后面的命令。</p>
<h2 id="嵌套if">嵌套if</h2>
<h3 id="第1个案例常规if-then-else语句">第1个案例：常规if-then-else语句</h3>
<p>案例：要检验<code>/etc/passwd</code>文件中是否存在某个用户名以及该用户的目录是否存在，可以使用嵌套的<code>if-then</code>语法，嵌套的<code>if-then</code>语句位于主<code>if-then-else</code>语句的<code>else</code>代码块中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing nested ifs</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=NoSuchUser</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then</div><div class="line">  echo "The user $testuser exists on this system."</div><div class="line">else</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  if ls -d /home/$testuser/</div><div class="line">  then </div><div class="line">    echo "However, $testuser has a directory."</div><div class="line">    fi</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The user NoSuchUser does not exist on this system.</div><div class="line">ls: cannot access &apos;/home/NoSuchUser/&apos;: No such file or directory</div></pre></td></tr></table></figure>
<p>程序解释：<code>if grep $testuser /etc/passwd</code>这个命令无法运行，状态返回码是非0，跳过了<code>echo &quot;The user $testuser exists on this system.&quot;</code>这个语句，执行后面的语句，即<code>&quot;The user $testuser does not exist on this system.&quot;</code>，接头是个嵌套语句，其中<code>ls -d /home/$testuser/</code>无法执行（因为不存在这个目录），then后面的` `也无法执行。</p>
<p>从结果可以看出，NoSuchUser这个账户不存在，他的目录也不存在。<code>if-then-else</code>还有一个延伸，即<code>elif</code>，它的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if commandA</div><div class="line">then </div><div class="line">  commandB</div><div class="line">elif commandC</div><div class="line">then</div><div class="line">  more commands</div><div class="line">fi</div></pre></td></tr></table></figure>
<p><code>elif</code>语句提供了一个要测序的命令，这类似于原始的if语句，如果elif后命令的退出状态码是0，bash就执行第二个<code>then</code>语句部分的命令，即more commands这一部分，看一个案例（提前在<code>/home/</code>目录下建立一个<code>NoSuchUser</code>目录）：</p>
<h3 id="第2个案例elif语句">第2个案例：elif语句</h3>
<p>这是对第1个案例的修改，所实现的目的是一样的，只是这里用到了elif语句，这种语句在逻辑上更加清晰。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing nested ifs=user elif</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=NoSuchUser</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then</div><div class="line">  echo "The user $testuser exists on this system."</div><div class="line"><span class="meta">#</span></div><div class="line">elif ls -d /home/$testuser</div><div class="line">then</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  echo "Howerve, $testuser has a directory."</div><div class="line"><span class="meta">#</span></div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test6.sh</div><div class="line">/home/NoSuchUser</div><div class="line">The user NoSuchUser does not exist on this system.</div><div class="line">Howerve, NoSuchUser has a directory.</div></pre></td></tr></table></figure>
<p>程序解释：<code>if grep $testuser /etc/passwd</code>这条语句无法执行，执行<code>elif</code>后面的语句，即<code>ls -d /home/$testuser</code>,这条语句可以执行（因为我们提前建立了/home/NoSuchUser这个目录），随后执行then后面的语句。</p>
<h3 id="第3个案例elif扩展">第3个案例：elif扩展</h3>
<p>针对上面的案例，对脚本进行更改，让这个脚本的功能变成：一、检查拥有目录的不存在用户；二、检验没有目录的不存在用户，这是通过在嵌套elif中添加了一个else语句来实现的，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing nested ifs - user elif &amp; else</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=NoSuchUser</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then</div><div class="line">  echo "The user $testuser exists on this system."</div><div class="line"><span class="meta">#</span></div><div class="line">elif ls -d /home/$testuser</div><div class="line">then</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  echo "Howerve, $testuser has a directory."</div><div class="line"><span class="meta">#</span></div><div class="line">else</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  echo "And,$testuser does not have a directory."</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>第1次运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test7.sh</div><div class="line">/home/NoSuchUser</div><div class="line">The user NoSuchUser does not exist on this system.</div><div class="line">Howerve, NoSuchUser has a directory.</div></pre></td></tr></table></figure>
<p>第2次运行结果，现在删除掉<code>/home/NoSuchUser</code>目录，运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ sudo rm -rf /home/NoSuchUser</div><div class="line">biotest@ubuntu:~/test$ bash test7.sh </div><div class="line">ls: cannot access &apos;/home/NoSuchUser&apos;: No such file or directory</div><div class="line">The user NoSuchUser does not exist on this system.</div><div class="line">And,NoSuchUser does not have a directory.</div></pre></td></tr></table></figure>
<p>从两次的运行结果可以看出，在删除/home/NoSuchUser目录之前，即第1次运行，脚本执行的是<code>elif</code>后面的语句，返回状态码是0，删除了目录之后，elif语句返回的是非零状态码，elif块中的else就开始执行。需要注意的是，在elif语句中，紧跟其后的else语句属于elif代码块，它们并不属于if-then代码块。</p>
<h2 id="test命令">Test命令</h2>
<p>test命令是shell环境中测试条件表达式的工具。在前面的案例中，if后面的语句都是普通的shell语句，无法测序命令退出状态码之外的条件。在test命令中，如果test后面列出的条件成立，test命令就会退出并返回退出状态码0，如果条件不成立，test命令就会退出并返回非零的退出状态码，这就会使if-then语句不会被再执行，test的语句格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test condition</div></pre></td></tr></table></figure>
<p>其中，condition是test命令要测试的一系列参数和值，如果test与if-then配合使用的话，格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if test condition</div><div class="line">then</div><div class="line">  commands</div><div class="line">  if</div></pre></td></tr></table></figure>
<p>如果不写test命令的condition部分，它会以非零状态码退出，并执行else语句块，看一个案例。</p>
<h3 id="第1案例常规testtest不添加condition">第1案例：常规test：test不添加condition</h3>
<p>测试一下常规的test功能，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing the test command</div><div class="line"><span class="meta">#</span></div><div class="line">if test</div><div class="line">then</div><div class="line">  echo "No expression returns a True"</div><div class="line">else</div><div class="line">  echo "No expression returns a False"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test8.sh</div><div class="line">No expression returns a False</div></pre></td></tr></table></figure>
<p>程序解释：test后面没有condition，因此它以非零状态码退出，执行else后面的语句，即<code>echo &quot;No expression returns a False&quot;</code>，如果添加上condition，则是下面的案例：</p>
<h3 id="第2案例常规testtest添加condition">第2案例：常规test：test添加condition</h3>
<p>代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the test command</div><div class="line"><span class="meta">#</span></div><div class="line">my_variable="Full"</div><div class="line"><span class="meta">#</span></div><div class="line">if test $my_variable</div><div class="line">then </div><div class="line">  echo "The $my_variable expression returns a True"</div><div class="line">else</div><div class="line">  echo "The $my_variable expressoion returns a False"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test9.sh</div><div class="line">The Full expression returns a True</div></pre></td></tr></table></figure>
<p>代码解释：test后面有内容（Full），因此当test命令测试条件时，返回的状态为0，执行then后面的语句。如果<code>$my_variable=&quot;&quot;</code>时，没有内容，就会执行else后面的语句，就跟第1个案例一样了。</p>
<h2 id="shell另外一种条件测试方法">shell另外一种条件测试方法</h2>
<p>shell还有另外一种条件测序方法，无需要在if-then语句中使用test命令，其格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if [ condition ]</div><div class="line">then </div><div class="line">  commands</div><div class="line">fi</div></pre></td></tr></table></figure>
<p><code>[ condition ]</code>中定义了测试条件，需要注意提方括号中，condition前后要加上空格，否则就会报错，test命令可以判断三类条件，分别为①数值比较；②字符串比较；③文件比较。</p>
<h3 id="数值比较">数值比较</h3>
<p>test命令常见的情形是对两个数值进行比较，下表就列出了测试两个值可用的条件参数：</p>
<table>
<thead>
<tr class="header">
<th align="center">比较</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">n1 -eq n2</td>
<td align="center">检查n1是否与n2相等</td>
</tr>
<tr class="even">
<td align="center">n1 -ge n2</td>
<td align="center">检查n1是否大于或等于n2</td>
</tr>
<tr class="odd">
<td align="center">n1 -gt n2</td>
<td align="center">检查n1是否大于n2</td>
</tr>
<tr class="even">
<td align="center">n1 -le n2</td>
<td align="center">检查n1是否小于或等于n2</td>
</tr>
<tr class="odd">
<td align="center">n1 -lt n2</td>
<td align="center">检查n1是否小于n2</td>
</tr>
<tr class="even">
<td align="center">n1 -ne n2</td>
<td align="center">检查n1是否不等于n2</td>
</tr>
</tbody>
</table>
<h4 id="第1案例数值比较">第1案例：数值比较</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> Using numeric test evaluations</div><div class="line"><span class="meta">#</span></div><div class="line">value1=10</div><div class="line">value2=11</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $value1 -gt 5 ] # test value1 is great 5 or not</div><div class="line">then </div><div class="line">  echo "The test value $value1 is greater than 5"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $value1 -eq $value2 ] # test value1 and value2 is equal or not</div><div class="line">then </div><div class="line">  echo "The values are equal"</div><div class="line">else</div><div class="line">  echo "The values are different"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test10.sh</div><div class="line">The test value 10 is greater than 5</div><div class="line">The values are different</div></pre></td></tr></table></figure>
<h4 id="第2案例浮点数的比较">第2案例：浮点数的比较</h4>
<p>如果涉及浮点比较时，数值条件测试会有一个限制，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> Using floating point numbers in test evaluations</div><div class="line"><span class="meta">#</span></div><div class="line">value1=5.555</div><div class="line"><span class="meta">#</span></div><div class="line">echo "The test value is $value1"</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $value1 -gt 5 ]</div><div class="line">then </div><div class="line">  echo "The test value $value1 is greater than 5"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test11.sh</div><div class="line">The test value is 5.555</div><div class="line">test11.sh: line 8: [: 5.555: integer expression expected</div></pre></td></tr></table></figure>
<p>结果中提示有问题，因为变量value1中储存提浮点值，脚本对这个值进行了测试，因为bash shell只能处理整数，如果只是要通过echo语句来显示这个结果，没问题，但是如果是基于数字的函数，就会出现了问题，因此需要注意。</p>
<h3 id="字符串比较">字符串比较</h3>
<p>字符串的比较方法如下所示：</p>
<table>
<thead>
<tr class="header">
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>str1 = str2</td>
<td>检查str1是否和str2相同</td>
</tr>
<tr class="even">
<td>str1 != str2</td>
<td>检查str1是否和str3不相同</td>
</tr>
<tr class="odd">
<td>str1 &lt; str2</td>
<td>检查str1是否比str2小</td>
</tr>
<tr class="even">
<td>str1 &gt; str2</td>
<td>检查str1是否比str2大</td>
</tr>
<tr class="odd">
<td>-n str1</td>
<td>检查str1的长度是否非0</td>
</tr>
<tr class="even">
<td>-z str1</td>
<td>检查str1的长度是否为0</td>
</tr>
</tbody>
</table>
<h4 id="字符串比较第1案例">字符串比较第1案例</h4>
<p>代码如下；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> testing string equality</div><div class="line">testuser=biotest</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $USER = $testuser ]</div><div class="line">then</div><div class="line">  echo "Welcom $testuser"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test12.sh</div><div class="line">Welcom biotest</div></pre></td></tr></table></figure>
<h4 id="字符串比较第2案例判断字符串不等的条件">字符串比较第2案例：判断字符串不等的条件</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing string equality</div><div class="line">testuser=baduser</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $USER != $testuser ]</div><div class="line">then </div><div class="line">  echo "This is not $testuser"</div><div class="line">else</div><div class="line">  echo "Welcome $testuser"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test13.sh</div><div class="line">This is not baduser</div></pre></td></tr></table></figure>
<h3 id="字符串的大小">字符串的大小</h3>
<p>在比较字符串方面，有一些事情比较麻烦，主要有两个方面，①大于号和小于号必须要转义，否则shell会将它们当成重定向符号，把字符串值当作文件名；②大于和小于顺序和sort命令所采用的不同，看一个案例。</p>
<h4 id="第1案例大于或小于号的重定向问题">第1案例：大于或小于号的重定向问题</h4>
<p>看下面的案例，注意大于号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> mis-using string comparisons</div><div class="line"><span class="meta">#</span></div><div class="line">val1=baseball</div><div class="line">val2=hockey</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $val1 &gt; $val2 ]</div><div class="line">then</div><div class="line">  echo "$val1 is greater than $val2"</div><div class="line">else</div><div class="line">  echo "$val1 is less than $val2"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash badtest.sh </div><div class="line">val1 is less than val2</div><div class="line">biotest@ubuntu:~/test$ ll</div><div class="line">total 72</div><div class="line">-rw-rw-r--  1 biotest biotest     0 Apr 27 23:21 hockey</div></pre></td></tr></table></figure>
<p>运行结果时，shell没有报错，但是给出的结果却是错的，因为脚本把大于事情解释成了输出重定向，它在当前目录下创建了一个名为hockey的文件，由于重定向的完成，test命令（就是if语句）返回了退出状态码0。</p>
<h4 id="第2案例解决字符串比较时大于号的问题">第2案例：解决字符串比较时，大于号的问题</h4>
<p>如果要解决上述问题，需要对大于号进行转义，前面加上<code>\</code>符号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> mis-using string comparisons</div><div class="line"><span class="meta">#</span></div><div class="line">val1=baseball</div><div class="line">val2=hockey</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $val1 \&gt; $val2 ]</div><div class="line">then</div><div class="line">  echo "$val1 is greater than $val2"</div><div class="line">else</div><div class="line">  echo "$val1 is less than $val2"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash badtest2.sh </div><div class="line">baseball is less than hockey</div></pre></td></tr></table></figure>
<h4 id="sort命令对字符串的排序问题">sort命令对字符串的排序问题</h4>
<p>在处理字符串方面，sort和test的方法正好相反， 看一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing astring osrt order</div><div class="line">val1=Testing</div><div class="line">val2=testing</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $val1 \&gt; $val2 ]</div><div class="line">then</div><div class="line">  echo "$val1 is greater than $val2"</div><div class="line">else</div><div class="line">  echo "$val1 is less than $val2"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test14.sh</div><div class="line">Testing is less than testing</div></pre></td></tr></table></figure>
<p>结查要显示，Testing比testing小，如果是sort，则是下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ cat testfile </div><div class="line">Testing</div><div class="line">testing</div><div class="line">biotest@ubuntu:~/test$ sort testfile </div><div class="line">testing</div><div class="line">Testing</div></pre></td></tr></table></figure>
<p>testing要比Testing大。</p>
<p>在比较测试上，大写字符被认为是小于小写字母的，但是在sort命令中，小写字母会先出现。这是因为比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII为当会来决定排序结果，而sort命令使用的也是ASCII顺序排序，只是默认情况下，sort会按照ASCII从小到大进行排序，如果加上了-r参数，则是按照默认排序的相反顺序进行排序，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ sort -r testfile </div><div class="line">Testing</div><div class="line">testing</div></pre></td></tr></table></figure>
<h4 id="判断字符串是否为0">判断字符串是否为0</h4>
<p><code>-n</code>和<code>-z</code>可以检查一个变量是否含有数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing string length</div><div class="line">val1=testing  </div><div class="line">val2='' </div><div class="line"><span class="meta">#</span></div><div class="line">if [ -n $val1 ]</div><div class="line">then</div><div class="line">  echo "The string '$val1' is not empty"</div><div class="line">else</div><div class="line">  echo "The string '$val1' is empty"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line"></div><div class="line">if [ -z $val2 ]</div><div class="line">then</div><div class="line">  echo "The string '$val2' is empty"</div><div class="line">else</div><div class="line">  echo "The string '$val2' is not empty"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line"></div><div class="line">if [ -z $val3 ]</div><div class="line">then</div><div class="line">  echo "The string '$val3' is empty"</div><div class="line">else</div><div class="line">  echo "The string '$val3' is not empty"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test15.sh</div><div class="line">The string &apos;testing&apos; is not empty</div><div class="line">The string &apos;&apos; is empty</div><div class="line">The string &apos;&apos; is empty</div></pre></td></tr></table></figure>
<p>程序解释：①先创建了2个字符串变量，val1包含一个字符串，val2包含的是一个空字符串；②<code>if [ -n $val1 ]</code>表示：判断val1的变量是否长度非0，因为val1并不是一个空字符串，它不是0，因此执行后面的then部分；③<code>if [ -z $val2 ]</code>：判断val2的变量是否长度为0，而val2是一个空字符串，它的长度为0，因此执行then部分；④<code>if [ -z $val3 ]</code>：判断val3的变量是否长度为0，由于这个变量并未在shell脚本中定义过，所以它的字符串长度仍然为0。</p>
<h3 id="文件比较">文件比较</h3>
<p>文件比较是shell编程中使用比较多的形式，它允许用户测试Linux文件系统上的文件和目录的状态，下表列出了这些比较方式，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-d file</td>
<td>检查file是否存在并是一个目录</td>
</tr>
<tr class="even">
<td>-e file</td>
<td>检查file是否存在</td>
</tr>
<tr class="odd">
<td>-f file</td>
<td>检查file是否存在并 一个文件</td>
</tr>
<tr class="even">
<td>-r file</td>
<td>检查file是否存在并可读</td>
</tr>
<tr class="odd">
<td>-s file</td>
<td>检查file是否存在并非空</td>
</tr>
<tr class="even">
<td>-w file</td>
<td>检查file是否存在并可写</td>
</tr>
<tr class="odd">
<td>-x file</td>
<td>检查file是否存在并可执行</td>
</tr>
<tr class="even">
<td>-O file</td>
<td>检查file是否存在并属当前用户所有</td>
</tr>
<tr class="odd">
<td>-G file</td>
<td>检查file是否存在并默认组与当前用户相同</td>
</tr>
<tr class="even">
<td>file1 -nt file2</td>
<td>检查file是否比file2新</td>
</tr>
<tr class="odd">
<td>file1 -ot file2</td>
<td>检查file是否比file2旧</td>
</tr>
</tbody>
</table>
<h4 id="检查目录">检查目录</h4>
<p><code>-d</code>测试会检查指定的目录是否存在于系统中如果打算将文件写入目录或是准备切换到某个目录，先进行测试是一种好习惯，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Look before you leap</div><div class="line"><span class="meta">#</span></div><div class="line">jump_directory=/home/arthur</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -d $jump_directory ]</div><div class="line">then</div><div class="line">  echo "The $jump_directory directory exists"</div><div class="line">  cd $jump_directory</div><div class="line">  ls</div><div class="line">else</div><div class="line">  echo "The $jump_directory directory does not exist"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash directest.sh </div><div class="line">The /home/arthur directory does not exist</div></pre></td></tr></table></figure>
<p>代码解释：<code>-d</code>测试用于检测jump_directory变量是中目录是否存在，如果存在就使用cd命令进入该目录，如果不存在脚本就输出一条信息，然后退出。</p>
<h4 id="检查对象是否存在">检查对象是否存在</h4>
<p><code>-e</code>参数可以使脚本代码在使用文件或上当前检查它们是否存在，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> check if either a directory or file exists</div><div class="line"><span class="meta">#</span></div><div class="line">location=$HOME</div><div class="line">file_name="sentinel"</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -e $location ]</div><div class="line">then # Directory does exist</div><div class="line">  echo "OK on the $location directory."</div><div class="line">  echo "Now checking on the file, $file_name."</div><div class="line"><span class="meta">#</span></div><div class="line">  if [ -e $location/$file_name ]</div><div class="line">  then # file does exist</div><div class="line">    echo "OK on the filename"</div><div class="line">    echo "Updating Current Date..."</div><div class="line">    date &gt;&gt; $location/$file_name</div><div class="line"><span class="meta">#</span></div><div class="line">  else # file does no exist</div><div class="line">    echo "File does not exist"</div><div class="line">    echo "Nothing to update"</div><div class="line">  fi</div><div class="line"><span class="meta">#</span></div><div class="line">else #Directory does exist</div><div class="line">  echo "The $location directory does not exist."</div><div class="line">  echo "Nothing to update"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>第一次运行，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash object_exist.sh </div><div class="line">OK on the /home/biotest directory.</div><div class="line">Now checking on the file, sentinel.</div><div class="line">File does not exist</div><div class="line">Nothing to update</div></pre></td></tr></table></figure>
<p>第二次运行，如果创建了<code>sentinel</code>文件，则如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash object_exist.sh </div><div class="line">OK on the /home/biotest directory.</div><div class="line">Now checking on the file, sentinel.</div><div class="line">OK on the filename</div><div class="line">Updating Current Date...</div><div class="line">biotest@ubuntu:~/test$ cat ~/sentinel </div><div class="line">Sat Apr 28 00:37:31 PDT 2018</div></pre></td></tr></table></figure>
<p>代码解释：第一次检查用了<code>-e</code>比较来判断用户是否有<code>$HOME</code>目录，如果有接下来的<code>-e</code>会检测sentinel文件是否存在于<code>$HOME</code>目录中，如果不存在，shell脚本就会提示该文件不存在，不需要更新。第二次运行时，在<code>$HOME</code>目录下创建了一个<code>sentinel</code>文件，然后重新运行脚本，由于<code>$HOME</code>和<code>sentinel</code>文件都存在，当前的上期和时间就都追加到了这个文本中。</p>
<h4 id="检查文件">检查文件</h4>
<p>如果检查的对象是文件，需要用<code>-f</code>参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Check if either a directory or file exists.</div><div class="line"><span class="meta">#</span></div><div class="line">item_name=$HOME</div><div class="line">echo</div><div class="line">echo "The item being checked: $item_name"</div><div class="line">echo</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -e $item_name ]</div><div class="line">then # Item does exist</div><div class="line">  echo "The item, $item_name, does exist."</div><div class="line">  echo "But is it a file?"</div><div class="line">  echo</div><div class="line"><span class="meta">  #</span></div><div class="line">  if [ -f $item_name ]</div><div class="line">  then # Item is a file</div><div class="line">     echo "Yes, $item_name is a file."</div><div class="line"><span class="meta">  #</span></div><div class="line">  else # Item does not exist</div><div class="line">    echo "No, $item_name is not a file"</div><div class="line">  fi</div><div class="line"></div><div class="line">else #Item doese not exist</div><div class="line">    echo "The item , $item_name, does not exist."</div><div class="line">    echo "Nothing to update"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_file.sh </div><div class="line"></div><div class="line">The item being checked: /home/biotest</div><div class="line"></div><div class="line">The item, /home/biotest, does exist.</div><div class="line">But is it a file?</div><div class="line"></div><div class="line">No, /home/biotest is not a file</div></pre></td></tr></table></figure>
<p>代码解释：首先使用了<code>-e</code>比较测序<code>$HOME</code>是否存在，如果存在，继续使用<code>-f</code>来测试它是不是一个文件，如果它不是文件（肯定不是文件），就会显示一条消息，它不是一个文件，如果更改一下代码，把<code>item_name</code>设置为<code>$HOME/sentinel</code>，即如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Check if either a directory or file exists.</div><div class="line"><span class="meta">#</span></div><div class="line">item_name=$HOME/sentinel</div><div class="line">echo</div><div class="line">echo "The item being checked: $item_name"</div><div class="line">echo</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -e $item_name ]</div><div class="line">then # Item does exist</div><div class="line">  echo "The item, $item_name, does exist."</div><div class="line">  echo "But is it a file?"</div><div class="line">  echo</div><div class="line"><span class="meta">  #</span></div><div class="line">  if [ -f $item_name ]</div><div class="line">  then # Item is a file</div><div class="line">     echo "Yes, $item_name is a file."</div><div class="line"><span class="meta">  #</span></div><div class="line">  else # Item does not exist</div><div class="line">    echo "No, $item_name is not a file"</div><div class="line">  fi</div><div class="line"></div><div class="line">else #Item doese not exist</div><div class="line">    echo "The item , $item_name, does not exist."</div><div class="line">    echo "Nothing to update"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_file2.sh </div><div class="line"></div><div class="line">The item being checked: /home/biotest/sentinel</div><div class="line"></div><div class="line">The item, /home/biotest/sentinel, does exist.</div><div class="line">But is it a file?</div><div class="line"></div><div class="line">Yes, /home/biotest/sentinel is a file.</div></pre></td></tr></table></figure>
<h4 id="检查文件是否可读">检查文件是否可读</h4>
<p>在试图从某个文件中读取数据之前，可以测试一下文件是否可读，参数是<code>-r</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing a file is readable or not</div><div class="line">pwfile=/etc/shadow</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> first, test if the file exists, and is a file</div><div class="line">if [ -f $pwfile ]</div><div class="line">then </div><div class="line">    # Now test if you can read it</div><div class="line">    if [ -r $pwfile ]</div><div class="line">    then </div><div class="line">        tail $pwfile</div><div class="line">    else</div><div class="line">        echo "Sorry, I am unable to read the $pwfile file"</div><div class="line">    fi</div><div class="line">else</div><div class="line">    echo "Sorry, the file $pwfile does not exist"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_read.sh </div><div class="line">Sorry, I am unable to read the /etc/shadow file</div></pre></td></tr></table></figure>
<h4 id="检查空文档">检查空文档</h4>
<p>检查空文档的参数是<code>-s</code>，如果<code>-s</code>比较正确，说明文件中有数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing if a file is empty</div><div class="line"><span class="meta">#</span></div><div class="line">file_name=$HOME/sentinel</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -f $file_name ]</div><div class="line">then</div><div class="line">    if [ -s $file_name ]</div><div class="line">    then</div><div class="line">        echo "The $file_name file exists and has data in it."</div><div class="line">        echo "Will not remove this file."</div><div class="line"><span class="meta">#</span></div><div class="line">    else</div><div class="line">        echo "The $file_name file exists, but is empty."</div><div class="line">        echo "Deleting empty file..."</div><div class="line">        rm $file_name</div><div class="line">    fi</div><div class="line">else</div><div class="line">    echo "File, $file_name, does not exist."</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ ls -l $HOME/sentinel</div><div class="line">-rw-rw-r-- 1 biotest biotest 29 Apr 28 00:37 /home/biotest/sentinel</div><div class="line">biotest@ubuntu:~/test$ bash test_empty.sh </div><div class="line">The /home/biotest/sentinel file exists and has data in it.</div><div class="line">Will not remove this file.</div></pre></td></tr></table></figure>
<p>代码解释：首先使用<code>-f</code>测试文件是否存在，如果存在，用<code>-s</code>比较来判断该文件是否为空，空文件会被删除，在运行脚本前，使用<code>ls -l</code>命令检查了<code>$HOME/ssentinel</code>文件，发现不是空的，因此脚本并不会删除它。</p>
<h4 id="检查是否可写">检查是否可写</h4>
<p><code>-w</code>比较会判断当前用户对文件是否有可写权限，下面的一段代码应时检测item_name是否存在、是否为文件，是否可写，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing if a file is writable</div><div class="line"><span class="meta">#</span></div><div class="line">file_name=$HOME/sentinel</div><div class="line">echo</div><div class="line">echo "The item being checked: $file_name"</div><div class="line">echo</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -e $file_name ]</div><div class="line">then </div><div class="line">    echo "The item, $file_name, does exist."</div><div class="line">    echo "But is it a file?"</div><div class="line">    echo</div><div class="line">    #</div><div class="line">    if [ -f $file_name ]</div><div class="line">    then</div><div class="line">        echo "Yes, $file_name is a file."</div><div class="line">        echo "But is it writable ?"</div><div class="line">        echo</div><div class="line"></div><div class="line">    #</div><div class="line">        if [ -w $file_name ]</div><div class="line">        then</div><div class="line">            echo "Yes, it is writable."</div><div class="line">            echo "Writing current time to $file_name"</div><div class="line">            date +%H%M &gt;&gt; $file_name</div><div class="line">            echo</div><div class="line">        #</div><div class="line">        else</div><div class="line">            echo "The item, $file_name,is not a writable file"</div><div class="line">            echo "Unable to write to $file_name"</div><div class="line">        fi</div><div class="line"></div><div class="line">    else</div><div class="line">        echo "No, $file_name is not a file."</div><div class="line">    fi</div><div class="line">else</div><div class="line">    echo "The item  $file_name does not exist"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_write.sh </div><div class="line"></div><div class="line">The item being checked: /home/biotest/sentinel</div><div class="line"></div><div class="line">The item, /home/biotest/sentinel, does exit.</div><div class="line">But is it a file?</div><div class="line"></div><div class="line">Yes, /home/biotest/sentinel is a file.</div><div class="line">But is it writable ?</div><div class="line"></div><div class="line">Yes, it is writable.</div><div class="line">Writing current time to /home/biotest/sentinel</div><div class="line">biotest@ubuntu:~/test$ cat /home/biotest/sentinel </div><div class="line">Sat Apr 28 00:37:31 PDT 2018</div><div class="line">0137</div><div class="line">0138</div><div class="line">0141</div></pre></td></tr></table></figure>
<p>现在使用<code>chmod</code>命令关闭文件sentinel的用户写入权限，再测试一下这个脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">chmod u-w $HOME/sentinel</div><div class="line">biotest@ubuntu:~/test$ bash test_write.sh </div><div class="line"></div><div class="line">The item being checked: /home/biotest/sentinel</div><div class="line"></div><div class="line">The item, /home/biotest/sentinel, does exist.</div><div class="line">But is it a file?</div><div class="line"></div><div class="line">Yes, /home/biotest/sentinel is a file.</div><div class="line">But is it writable ?</div><div class="line"></div><div class="line">The item, /home/biotest/sentinel,is not a writable file</div><div class="line">Unable to write to /home/biotest/sentinel</div></pre></td></tr></table></figure>
<h4 id="检查文件是否可以执行">检查文件是否可以执行</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing file execution</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -x test11.sh ]</div><div class="line">then </div><div class="line">    echo "You can run the script: "</div><div class="line">    ./test11.sh</div><div class="line">else</div><div class="line">    echo "Sorry, you are unable to execute the script"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_ex.sh</div><div class="line">Sorry, you are unable to execute the script</div><div class="line"></div><div class="line">biotest@ubuntu:~/test$ ll test11.sh</div><div class="line">-rw-rw-r-- 1 biotest biotest 195 Apr 27 23:06 test11.sh</div><div class="line">biotest@ubuntu:~/test$ chmod u+x test11.sh</div><div class="line">biotest@ubuntu:~/test$ ll test11.sh</div><div class="line">-rwxrw-r-- 1 biotest biotest 195 Apr 27 23:06 test11.sh*</div><div class="line">biotest@ubuntu:~/test$ bash test_ex.sh </div><div class="line">You can run the script: </div><div class="line">The test value is 5.555</div><div class="line">./test11.sh: line 8: [: 5.555: integer expression expected</div></pre></td></tr></table></figure>
<p>代码及结果解释：代码开头使用了-x参数来判断是滞有权限执行test11.sh脚本，如果有权限就运行这个脚本。在首次运行时，没有权限，随后使用<code>chmod u+x test11.sh</code>命令赋予权限，再次执行，结果显示有权限运行test11.sh这个脚本。</p>
<h4 id="检查所属关系">检查所属关系</h4>
<p><code>-O</code>（大写），测试出某个文件的属主，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> check file ownership</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -O /etc/passwd ]</div><div class="line">then</div><div class="line">    echo "You are the owner of the /etc/passwd file"</div><div class="line">else</div><div class="line">    echo "Sorry, you are not the owner of the /etc/passwd file"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash owner.sh </div><div class="line">Sorry, you are not the owner of the /etc/passwd file</div></pre></td></tr></table></figure>
<p>代码解释：<code>-O</code>田头来测试运行该脚本的用户是否是<code>/etc/passwd</code>文件的属主，这个脚本是运行在普通有入眠账户下的，所以测试失败。</p>
<h4 id="检查默认属组关系">检查默认属组关系</h4>
<p><code>-G</code>比较会检查文件的默认组，如果它匹配了用户的默认组，则测试成功。由于-G比较只会检查默认组而非用户所属的所有组，因此会有一定的局限性，如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> check file group test</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -G $HOME/testing ]</div><div class="line">then </div><div class="line">    echo "Your are in the same group as the file"</div><div class="line">else</div><div class="line">    echo "The file is not owned by your gruop"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ll testing/  #查看HOME目录下的testing目录详细信息</div><div class="line">drwxr-xr-x 24 biotest biotest 4096 Apr 29 02:55 ../ # testing属于biotest组</div><div class="line">biotest@ubuntu:~$ cd test</div><div class="line">biotest@ubuntu:~/test$ bash group.sh # 运行脚本</div><div class="line">You are in the same group as the file  # testing属于当前biotest组</div><div class="line">biotest@ubuntu:~$ cd</div><div class="line">biotest@ubuntu:~$ sudo chgrp sharing $HOME/testing # 将testing所属的biotest组更改为sharing组</div><div class="line">[sudo] password for biotest: </div><div class="line">biotest@ubuntu:~$ ll testing/</div><div class="line">drwxrwxr-x  2 biotest sharing 4096 Apr 29 00:03 ./</div><div class="line">biotest@ubuntu:~$ cd test</div><div class="line">biotest@ubuntu:~/test$ bash group.sh </div><div class="line">The file is not owned by your gruop # testing就不属于了biotest组</div><div class="line">biotest@ubuntu:~/test$ cd ..</div></pre></td></tr></table></figure>
<h4 id="检查文件日期">检查文件日期</h4>
<p>有时候需要比较两个文件的创建日期，<code>-nt</code>比较会判断文件A是否比另外一个文件B新，如果文件A较新，那意味着它的文件创建日期更近。<code>-ot</code>比较会判断一个文件A是否比另外一个文件B旧，如果文件A较旧，则是意味着它的创建日期更早。</p>
<p>先来查看地一下test12.sh文件与test13.sh文件，以及test11.sh和test12.sh文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ ll test11.sh test12.sh test13.sh</div><div class="line">-rwxrw-r-- 1 biotest biotest 196 Apr 28 20:42 test11.sh*</div><div class="line">-rw-rw-r-- 1 biotest biotest 116 Apr 27 23:14 test12.sh</div><div class="line">-rw-rw-r-- 1 biotest biotest 156 Apr 27 23:17 test13.sh</div></pre></td></tr></table></figure>
<p>由上述结果可以发现，test11.sh文件创建于4.28，20:42；test12.sh文件创建于4.27，23:14，test13.sh文件创建于4.27 ，23:17，现在运行下面的脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing file dates</div><div class="line"><span class="meta">#</span></div><div class="line">if [ test12.sh -nt test13.sh ]</div><div class="line">then</div><div class="line">    echo "The test12 file is newer than test13"</div><div class="line">else</div><div class="line">    echo "The test13 file is newer than test12"</div><div class="line">fi</div><div class="line"></div><div class="line">if [ test11.sh -ot test12.sh ]</div><div class="line">then </div><div class="line">    echo "The test11 file is older than the test12 file"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash contrast_file.sh </div><div class="line">The test13 file is newer than test12</div></pre></td></tr></table></figure>
<p>代码及结果解释：<code>test12.sh -nt test13.sh</code>这一句用于判断test12是否比test13更新，结果是否，执行<code>then</code>后面的语句，即<code>echo &quot;The test13 file is newer than test12&quot;。</code>结果也显示，test13文件比test12文件更新，因为test13.sh文件创建的时间（2018-4-27-23:17)比test12.sh文件（2018-4-27-23:14)要晚。在第二个<code>if-then</code>语句中，<code>test11.sh -ot test12.sh</code>语句用于判断，test11文件是否比test12文件更老，由于test11.sh文件创建于2018-4-28-20:42；而test12.sh文件创建于2018-4-27-23:14，test11文件比test12文件创建的时候更晚，因此<code>test11.sh -ot test12.sh</code>这个语句不执行。</p>
<p>再补充一个案例，如果要比较的两个文件不存在，如果仅用<code>-nt</code>来判断，那么还会返回结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing file dates</div><div class="line"><span class="meta">#</span></div><div class="line">if [ badfile1 -nt badfile2 ]</div><div class="line">then</div><div class="line">    echo "The badfile1 file is newer than badfile2"</div><div class="line">else</div><div class="line">    echo "The badfile2 file is newer than badfile1"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test21.sh</div><div class="line">The badfile2 file is newer than badfile1</div></pre></td></tr></table></figure>
<p>代码运行后，仍然有结果，这就是有问题了，因此在使用<code>-nt</code>时，首先需要判断文件是否存在。</p>
<h2 id="复合条件测试">复合条件测试</h2>
<p>在<code>if-then</code>语句中，还可以使用布尔逻辑来组合测试，有两种布尔运算符可以使用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ condition1 ] &amp;&amp; [ condition2 ] </div><div class="line"># 使用的是AND布尔运行算来组合两个条件，若要执行then后面的语句，两个条件必须都满足</div><div class="line"></div><div class="line">[ condition1 ] || [ condition2 ]</div><div class="line"># 使用OR布尔运算符来组合两个条件，如果任意条件为TRUE，then后面的语句执行</div></pre></td></tr></table></figure>
<h3 id="and运算符">AND运算符</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing compound comparisons</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ]</div><div class="line">then</div><div class="line">    echo "The file exists and you can write to it"</div><div class="line">else</div><div class="line">    echo "I cannot write to the file"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test22.sh</div><div class="line">The file exists and you can write to it</div></pre></td></tr></table></figure>
<h2 id="if-then的高级特性">if-then的高级特性</h2>
<p>bash sehll提供了2项可在if-then语句中使用的高级特性，第一：用于数学表达式的双括号；第二：用于高级字符串处理的双方括号。</p>
<h3 id="使用双括号">使用双括号</h3>
<p>双括号命令可以使用户在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的自述操作，而双括号命令提供了更多的数学符号，双括号的命令格式为<code>(( expressiton ))</code>。其中<code>expresstion</code>可以是任意的数学赋值或比较表达式，除了test命令使用的标准数学运算答外，下表列出了双括号命令中会用到的其他运算符，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>val++</td>
<td>后增</td>
</tr>
<tr class="even">
<td>val–</td>
<td>后减</td>
</tr>
<tr class="odd">
<td>++val</td>
<td>先增</td>
</tr>
<tr class="even">
<td>–val</td>
<td>先减</td>
</tr>
<tr class="odd">
<td>!</td>
<td>逻辑求反</td>
</tr>
<tr class="even">
<td>~</td>
<td>位求反</td>
</tr>
<tr class="odd">
<td>**</td>
<td>幂运算</td>
</tr>
<tr class="even">
<td>&lt;&lt;</td>
<td>左位移</td>
</tr>
<tr class="odd">
<td>&gt;&gt;</td>
<td>右位移</td>
</tr>
<tr class="even">
<td>&amp;</td>
<td>位布尔和</td>
</tr>
<tr class="odd">
<td>|</td>
<td>位布尔或</td>
</tr>
<tr class="even">
<td>&amp;&amp;</td>
<td>逻辑和</td>
</tr>
<tr class="odd">
<td>||</td>
<td>逻辑或</td>
</tr>
</tbody>
</table>
<h4 id="案例在if语句中使用双括号">案例：在if语句中使用双括号</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using double parenthesis</div><div class="line"><span class="meta">#</span></div><div class="line">val1=10</div><div class="line"><span class="meta">#</span></div><div class="line">if (( $val1 **2 &gt; 90))</div><div class="line">then</div><div class="line">    (( val2=$val1**2 ))</div><div class="line">    echo "The square of $val1 is $val2"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test23.sh</div><div class="line">The square of 10 is 100</div></pre></td></tr></table></figure>
<h3 id="使用双方括号">使用双方括号</h3>
<p>双方括号命令提供了针对字符串比较的高级特性，双方括号命令的格式为<code>[[ expression ]]</code>，双方括号里的<code>expression</code>使用了test命令中采用的标准字符串比较，但它还有另外的一个特性，即模式匹配（pattern matching）。（注：bash shel对中双方括号的支持很好，但其他的shell未必如此）。</p>
<p>在模式匹配中，用户可以定义一个正则表达式来匹配字符串，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using pattern matching</div><div class="line"><span class="meta">#</span></div><div class="line">if [[ $USER == r* ]]</div><div class="line">then</div><div class="line">    echo "Hello $USER"</div><div class="line">else</div><div class="line">    echo "Sorry, I do not know you"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test24.sh</div><div class="line">Sorry, I do not know you</div></pre></td></tr></table></figure></p>
<p>如果将其中<code>$USER == r*</code>改为<code>$USER == b*</code>（当前Linux系统中biotest用户，<code>b*</code>这种格式可以查换所有以b开头的用户，运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test24.sh</div><div class="line">Hello biotest</div></pre></td></tr></table></figure>
<h2 id="case命令">case命令</h2>
<p>如果有一种情况：用户在尝试计算一个变量的值，可以在一组可能的值中寻找特定值。在这种情况下，可以写一段长的<code>if-then-else</code>代码，如下所示：</p>
<h3 id="常规if-then-else代码">常规<code>if-then-else</code>代码</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Looking for a possible value</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $USER = "rich" ]</div><div class="line">then</div><div class="line">    echo "Welcome $USER"</div><div class="line">    echo "Please enjoy your visit"</div><div class="line">elif [ $USER = "barbara" ]</div><div class="line">then</div><div class="line">    echo "Welcome $USER"</div><div class="line">    echo "Please enjoy your visit"</div><div class="line">elif [ $USER = "testing" ]</div><div class="line">then</div><div class="line">    echo "Special testing account"</div><div class="line">elif [ $USER = "jessica" ]</div><div class="line">then</div><div class="line">    echo "Do not forget to logout when you're done"</div><div class="line">elif [ $USER = "biotest" ]</div><div class="line">then</div><div class="line">    echo "You are currnet user"</div><div class="line">else</div><div class="line">    echo "Sorry, your are not allowed here"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test25.sh</div><div class="line">You are currnet user</div></pre></td></tr></table></figure>
<p>如果有了<code>case</code>命令，则不需要写出所有的<code>elif</code>语句来不停地检查同一个变量的值，<code>case</code>命令会采用列表格式来检查单个变量的多个值。</p>
<h3 id="case语句"><code>case</code>语句</h3>
<p><code>case</code>语句的格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">case variable in </div><div class="line">pattern1 | pattern2)  command1;;</div><div class="line">pattern3) commands2;;</div><div class="line">*) default commands;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>case命令会将指定的变量与不同械进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令，可以通过竖线操作符在一行中分隔出多个模式。星号会捕获所有与已知模式不匹配的值，现在将前面的<code>if-then-else</code>代码转换为<code>case</code>形式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the case command</div><div class="line"><span class="meta">#</span></div><div class="line">case $USER in </div><div class="line">rich | barbara)</div><div class="line">    echo "Welcome, $USER"</div><div class="line">    echo "Please enjoy your visit";;</div><div class="line">testing)</div><div class="line">    echo "Special testing account";;</div><div class="line">jessica)</div><div class="line">    echo "Do not forget to log off when you're done";;</div><div class="line">biotest)</div><div class="line">    echo "You are current user";;</div><div class="line">*)</div><div class="line">    echo "Sorry, you are not allowed here";;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test26.sh</div><div class="line">You are current user</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/29/Linux-shell01-基础笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/Linux-shell01-基础笔记/" itemprop="url">Shell学习笔记（1）——shell脚本基础笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T12:10:54+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,088
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记的参考资料是（<a href="https://item.jd.com/12010266.html" target="_blank" rel="external">《Linux命令行与shell脚本编程大全》</a>（第3版），外加百度辅助，本篇笔记主要内容是Shell脚本的一些基本知识。</p>
<p>使用命令行的一大特点就是能够写脚本，可以将一些命令写到一个脚本中，自动运行。而在Linux的命令行中，一次基本上只能运行一个或几个命令，就像下面的这样，它可以运行两个命令，只是要用分号隔开。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ date;who</div><div class="line">Fri Apr 27 15:56:32 CST 2018</div><div class="line">biotest  tty7         2018-04-27 11:24 (:0)</div></pre></td></tr></table></figure>
<p>这两个命令其实也可以视为一个非常简单的脚本，虽然它只有两个命令，作用就是显示今天的日期以及当前登录到系统中的用户。</p>
<h2 id="创建shell脚本文件">创建shell脚本文件</h2>
<p>如果要将shell命令放到文本文件中，就需要一个文本编辑器，Linux中常用的是vim，写好的脚本文件如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">date;who</div><div class="line"><span class="meta">#</span> this is comments</div></pre></td></tr></table></figure>
<p>将脚本文件保存，命令为test.sh。</p>
<p>现在解释一下这个脚本：</p>
<p>第1行：写入的是<code>#!/bin/bash</code>，#号是用于注释的，shell并不会处理注释，注释只是起到说明的作用，但第1行是个例外，#!的意思是要告诉shell要到哪个shell来运行，这里指定的是bash。</p>
<p>第2行：在第1行中指定了运行脚本的shell后，就可以输入命令了，输入一个命令后，回车，再输入另外一个命令，或者是用分号隔开两个命令。</p>
<p>命令结束后，输入脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ test.sh</div><div class="line">test.sh: command not found</div></pre></td></tr></table></figure>
<p>这是因为，shell是通过PATH环境变量来查找命令的，现在test.sh这个脚本文件并不在环境变量PATH中，因此如果要运行这个脚本，只有2种方法：</p>
<p>第一，将shell脚本文件所在的目录添加到PATH环境中；</p>
<p>第二，使用绝对或相对路径引用shell脚本文件。</p>
<p>现在使用第二种方法，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$</div></pre></td></tr></table></figure>
<p>发现没有反应，此时输入<code>bash test</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ bash test</div><div class="line">Fri Apr 27 16:19:14 CST 2018</div><div class="line">biotest  tty7         2018-04-27 11:24 (:0)</div></pre></td></tr></table></figure>
<p>test是一个脚本文件，通过<code>ls -lF</code>命令查看发现，test不是一个可执行程序，因此运行这个脚本，需要使用bash test，如果要将它设为可执行文件，则如下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls -lF test</div><div class="line">-rw-rw-r-- 1 biotest biotest 42 Apr 27 01:28 test</div><div class="line">biotest@ubuntu:~$ chmod u+x test</div><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$ ./test</div><div class="line">Fri Apr 27 01:29:38 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure>
<p>此时输入的是相对路径<code>./test</code>，如果要直接运行，则需要将test添加到环境变量中去，如下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ./test</div><div class="line">Fri Apr 27 01:36:50 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">biotest@ubuntu:~$ pwd</div><div class="line">/home/biotest</div><div class="line">biotest@ubuntu:~$ echo 'export PATH=$PATH:/home/biotest/'&gt;&gt;~/.bashrc</div><div class="line">biotest@ubuntu:~$ source ~/.bashrc</div><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$ mv test test.sh</div><div class="line">biotest@ubuntu:~$ test.sh</div><div class="line">Fri Apr 27 01:37:57 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure>
<p>添加到环境变量用到了<code>echo 'export PATH=$PATH:/home/biotest/'&gt;&gt;~/.bashrc</code>命令，此外，还有一点，test是用shell写的，原来没有后缀名，输入后无法运行，当添加上上了<code>.sh</code>后，可以正常运行，原理现在还不清楚，懂了再写。</p>
<h2 id="显示消息">显示消息</h2>
<p>多数shell都会产生自己的输出，这些输出会显示脚本所运行的控制台显示器上。很多时候，在自己写脚本时，要添加自己的文本消息来告诉脚本用户正在做什么，需要echo命令，如果在echo命令后面加上一个字符串，就会显示出这个文本字符串，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo This is a test</div><div class="line">This is a test</div><div class="line">biotest@ubuntu:~$ echo "This is a test to see if you're paying attention"</div><div class="line">This is a test to see if you're paying attention</div><div class="line">biotest@ubuntu:~$ ^C</div><div class="line">biotest@ubuntu:~$ echo 'Rich says "scripting is easy".'</div><div class="line">Rich says "scripting is easy".</div></pre></td></tr></table></figure>
<p>从中可以发现：第一，常规情况下字符串并不需要使用引号；第二，如果要使用引号，字符串中间的引号不能与字符串两端的引号重复（即字符串中使用单引号，整个字符串就使用双引号，反之亦然）。</p>
<p>再看一案例，新建一个文件，命名为test1，输入以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> This script displays the date and who's logged on </div><div class="line">echo The time and date are:</div><div class="line">date</div><div class="line">echo "Let's see who's logged into the system:"</div><div class="line">who</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test1</div><div class="line">The time and date are:</div><div class="line">Fri Apr 27 03:01:29 PDT 2018</div><div class="line">Let&apos;s see who&apos;s logged into the system:</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure></p>
<h2 id="使用变量">使用变量</h2>
<p>环境变量是常见的变量之一，在shell脚本中，也能使用环境变量，只需要在环境㸄前加上美元符号（$）即可，下面的脚本中就使用了一些环境变量，如下所示： <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> display user information from the system.</div><div class="line">echo "User info for userid: $USER"</div><div class="line">echo UID:$UID</div><div class="line">echo HOME: $HOME</div></pre></td></tr></table></figure></p>
<p>运行后结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test2</div><div class="line">User info for userid: biotest</div><div class="line">UID:1000</div><div class="line">HOME: /home/biotest</div></pre></td></tr></table></figure>
<p>如果在字符串中使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo "The cost of the item is $15"</div><div class="line">The cost of the item is 5</div></pre></td></tr></table></figure>
<p>这里面的美元符号就不会显示，如果要显示的话，需要添加转义字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo "The cost of the item is \$15"</div><div class="line">The cost of the item is $15</div></pre></td></tr></table></figure>
<h2 id="用户变量">用户变量</h2>
<p>用户变量是用户自己定义的一些变量，这些常见的编程语言中的变量大同小异，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing vairbales</div><div class="line">days=10</div><div class="line">guest="Test"</div><div class="line">echo "$guest checked in $days days ago"</div><div class="line">days=5</div><div class="line">guest="Test01"</div><div class="line">echo "$guest checked in $days days ago"</div></pre></td></tr></table></figure>
<p>运行后结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test3</div><div class="line">Test checked in 10 days ago</div><div class="line">Test01 checked in 5 days ago</div></pre></td></tr></table></figure>
<h3 id="有关美元符号与赋值的另一案例">有关美元符号与赋值的另一案例</h3>
<p>如果引用变量不使用美元符号，会将引用的某个变量名称识别为字符串，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> assigning a variable value to another variable</div><div class="line"></div><div class="line">value1=10</div><div class="line">value2=$value1</div><div class="line">echo The resulting value is $value2</div><div class="line">value3=value1</div><div class="line">echo The resulting value is $value3</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test4</div><div class="line">The resulting value is 10</div><div class="line">The resulting value is value1</div></pre></td></tr></table></figure></p>
<p>从结果可以看出来，当value2=$value1时，就把变量value1的值10赋值给了value2，当使用value3=value1时，由于没加美元符号，就把value1这个字符串赋值给了value3。</p>
<h2 id="命令替换">命令替换</h2>
<p>shell脚本有一个重要的功能就是从命令输出中提取信息，并将值赋给某个变量。有2种方法可以将命令输出赋值给某个变量：</p>
<p>第一：使用反引号（`）； 第二：使用<code>$()</code>格式。 使用这两种方法可以使shell命令的输出赋值给变量，具体用法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">testing=`date`</div><div class="line"># 或者是</div><div class="line">testing=$(date)</div></pre></td></tr></table></figure>
<p>具体的案例如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">testing=$(date)</div><div class="line">echo &quot;The date and time are: &quot; $testing</div></pre></td></tr></table></figure></p>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test5</div><div class="line">The date and time are:  Fri Apr 27 07:10:16 PDT 2018</div></pre></td></tr></table></figure>
<p>第二案例： 以下的案例就是就是通过命令替换获得当前日期，并用它来生成唯一文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># copy the /usr/bin directory listing to a log file</div><div class="line">today=$(date +%y%m%d) </div><div class="line"># there is a blank between +%y%m%d</div><div class="line">ls /usr/bin -al &gt; log.$today</div></pre></td></tr></table></figure>
<p>运行后没有输出信息，但是它会在当前目录下生成一个log文件，名称就是log加上今天的日期（今天是2018年4月27日），则这个文件名称就是log.180427。代码的运行原理是，date命令得到当前日期，经格式化后，赋值给today。关于日期的格式化，可以看下面的案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date</div><div class="line">Fri Apr 27 07:21:17 PDT 2018</div><div class="line">biotest@ubuntu:~$ date +%y%m%d</div><div class="line">180427</div></pre></td></tr></table></figure>
<h2 id="重定向输入和输出">重定向输入和输出</h2>
<p>有时候我们会遇到这样的场景，我想把某个命令的输出结果保存到某个文件中，这个文件我可以用于查看，或者是经后来的命令处理。这就用到了重定向，重定向可以用于输入，也可以用于输出。</p>
<h3 id="输出重定向">输出重定向</h3>
<p>最基本的重定向就是将命令的输出发送到一个文件中，bash shell中使用大于号（&gt;）来完成，格式为<code>command &gt; outputfile</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date &gt; test7</div><div class="line">biotest@ubuntu:~$ ls -l test7</div><div class="line">-rw-rw-r-- 1 biotest biotest 29 Apr 27 07:25 test7</div><div class="line">biotest@ubuntu:~$ less test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">Fri Apr 27 07:25:44 PDT 2018</div><div class="line">biotest@ubuntu:~$ who &gt; test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">biotest@ubuntu:~$ date &gt;&gt; test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">Fri Apr 27 07:28:58 PDT 2018</div></pre></td></tr></table></figure>
<p>使用重定向文件创建了一个文件test7，将date命令的输出结果重定向了到了test7中，如果这个文件存在，则重定向的数据会覆盖原来的数据，如果不想覆盖，只是追加，可以使用双大于号。</p>
<h3 id="输入重定向">输入重定向</h3>
<h4 id="常规的输入重定向">常规的输入重定向</h4>
<p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令。 输入重定向符号是小于号（&lt;），格式为<code>command &lt; inputfile</code>。 如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">Fri Apr 27 07:28:58 PDT 2018</div><div class="line">biotest@ubuntu:~$ wc &lt; test7</div><div class="line"> 2 11 73</div></pre></td></tr></table></figure></p>
<p>在这个案例中，将test7的内容输入到wc命令中，wc命令可以对数据中的文本进行计数（wc的全称为words count），wc的默认输出有3个值，从左到右分别为： ①文本的行数；②文本的词数；③文本的字节数，在前面的案例中，结果就是2行，11个单词，73个字节。</p>
<h4 id="内联输入重定向">内联输入重定向</h4>
<p>内联输入重定向的英文是inline input redirection，这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致，格式为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">command &lt;&lt; marker </div><div class="line">data </div><div class="line">marker</div></pre></td></tr></table></figure></p>
<p>maker是数据的开始，也是结果，data是位于maker之间的文本文件，看一个案例： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ wc &lt;&lt; EOF</div><div class="line">&gt; test string 1</div><div class="line">&gt; test string 2</div><div class="line">&gt; test string 3</div><div class="line">&gt; EOF</div><div class="line"> 3  9 42</div></pre></td></tr></table></figure></p>
<p>当输入wc &lt;&lt; EOF时，命令行会自动变成大于号，接着输入内容，输入完毕后，再输入EOF表示结束，此时命令开始运行，结果为3，9， 42.</p>
<h2 id="管道">管道</h2>
<p>管道的使用场景为，将命令A的输出结果导入到命令B，使A的结果成为B的输入。其实这样可以通过重定向实现，但是太麻烦，管道就是出于此目的而设计的。</p>
<p>举个例子：统计当前的文件数有多少个。</p>
<p>先看一下重定向是如何实现的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls &gt; filename</div><div class="line">biotest@ubuntu:~$ cat filename</div><div class="line">Desktop</div><div class="line">Documents</div><div class="line">Downloads</div><div class="line">examples.desktop</div><div class="line">filename</div><div class="line">log.</div><div class="line">log.180427</div><div class="line">miniconda2</div><div class="line">Miniconda2-latest-Linux-x86_64.sh</div><div class="line">Music</div><div class="line">Pictures</div><div class="line">Public</div><div class="line">Templates</div><div class="line">test1</div><div class="line">test2</div><div class="line">test3</div><div class="line">test4</div><div class="line">test5</div><div class="line">test6</div><div class="line">test7</div><div class="line">test8</div><div class="line">test.sh</div><div class="line">Videos</div><div class="line">biotest@ubuntu:~$ wc filename</div><div class="line"> 23  23 210 filename</div></pre></td></tr></table></figure></p>
<p>使用重定向就是，先用ls列出当前的文件名，重定向到filename文件，然后使用wc命令来统计。</p>
<p>再看一下管道命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls|wc</div><div class="line">     23      23     210</div><div class="line">biotest@ubuntu:~$</div></pre></td></tr></table></figure></p>
<p>管道命令通过一条竖线，将ls的结果导入到wc中。</p>
<h2 id="退出脚本">退出脚本</h2>
<p>shell中运行的每个命令都是使用退出状态码（exit status）告诉shell它已经运行完毕，退出状态码是一个0~255的号数值，在命令结束运行时，由命令传给shell。</p>
<h3 id="查看退出状态码">查看退出状态码</h3>
<p>Linux提供了一个专门的变量<code>$?</code> 来保存上个已执行命令的退出状态码。对于需要进行检查的 命令，必须在其运行完毕后立刻查看或使用 $? 变量。它的值会变成由shell所执行的最后一条命令的退出状态码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date</div><div class="line">Fri Apr 27 07:52:45 PDT 2018</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">0</div></pre></td></tr></table></figure>
<p>通常一个成功结束的命令的退出状态码是0，如果命令结束时有错误，这个代码就是一个正整数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ asd</div><div class="line">No command &apos;asd&apos; found, but there are 22 similar ones</div><div class="line">asd: command not found</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">127</div></pre></td></tr></table></figure>
<h3 id="exit命令">exit命令</h3>
<p>exit 命令允许你在脚本结束时指定一个退出状态码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># testing the exit status</div><div class="line">var1=10</div><div class="line">var2=30</div><div class="line">var3=$[$var1 + $var2]</div><div class="line">echo The answer is $var3</div><div class="line">exit 5</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test9</div><div class="line">The answer is 40</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">5</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/28/Linux环境变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/Linux环境变量/" itemprop="url">Linux环境变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-28T12:10:54+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,588
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是shell">1. 什么是shell？</h3>
<p>答：在计算机科学中，Shell俗称壳（用来区别于核，核是指“内核”），Shell是指“提供使用者使用界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。</p>
<p>在很多并不正式的场合，这两个名词表达的意思相同，即命令解释器。但从严格的意义上讲，命令行是指供用户输入命令的界面，其本身只是接受输入，然后把命令传递给命令解释器，后者就是Shell，从本质上讲，Shell是一个程序，它在用户和操作系统之间提供了一个面向行的可交互接口，用户在命令行中输入命令，运行在后台的Shell把命令转换成指令代码发送给操作系统。Shell并非只有命令行这一种形式，例如GNOME、KDE等图形界面也是Shell，不过它们是GUI Shell，都是为了解决人机交互的问题。</p>
<p>目前在Linux环境下有几种不同类型的Shell，常用的有Bourne Again Shell（BASH）、TCSH Shell、Z-Shell。不同的Shell提供不同的语法和特性。</p>
<p>例如在Ubuntu中，可以在<code>etc/passwd</code>文件中查看到自己的默认shell程序，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ cat /etc/passwd |grep biotest</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div></pre></td></tr></table></figure>
<p>由上述结果可知，biotest用户所用到shell是bash。bash shell程序位于/bin目录内，从长列表中可以看出<code>/bin/bash</code>是一个可执行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls -lF /bin/bash</div><div class="line">-rwxr-xr-x 1 root root 1037528 May 16  2017 /bin/bash*</div></pre></td></tr></table></figure>
<p>注：在Linux系统中，当使用ls，添加了-F参数时，会在每个输出项后追加文件的类型标识符，具体含义为：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；</p>
<h3 id="什么是bash">2. 什么是bash？</h3>
<p>答：bash相当于shell中的某个，shell的范围更广。bash的全称是Bourne again / born again。</p>
<h3 id="什么是环境变量">3. 什么是环境变量？</h3>
<p>答：shell 在 shell 会话中保存着大量信息。这些信息被称为 (shell 的) 环境。 程序获取环境中的数据（即环境变量）来了解本机的配置。虽然大多数程序用配置文件来存储程序设置， 一些程序会根据环境变量来调整他们的行为。Linux是一个多用户的操作系统。每个用户登录系统后，都会有一个专用的运行环境。 通常每个用户默认的环境都是相同的，这个默认环境实际上就是一组环境变量的定义。 环境变量是全局的，设置好的环境变量可以被所有当前用户所运行的程序所使用。 用户可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。在bash shell中，环境变量分为两类，分别为全局变量，局部变量。</p>
<p>shell 在环境中存储了两种基本类型的数据，虽然 bash 几乎无法分辨这些数据的类型。 它们是环境变量和 shell 变量。Shell 变量是 bash 存放的少量数据。剩下的都是 环境变量。除了变量，shell 也存储了一些可编程的数据，即别名和 shell 函数。</p>
<h3 id="如何查看环境变量">4. 如何查看环境变量？</h3>
<p>答：<code>printenv</code>可以显示全局变量，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/f429H66haH.png?imageslim" alt="mark"> 上述的内容是环境变量及其数值列表，环境变量通常是大写字母，这主要是为了与用户的变量进行区分，例如我们可以看到USER=biotest这行代码，就表示当前的用户是biotest，用<code>printenv</code>命令也可以查看当前用户，如下所示：</p>
<blockquote>
<p>biotest@ubuntu:~$ printenv USER biotest</p>
</blockquote>
<h4 id="通过echo来查看变量的值如下所示">通过echo来查看变量的值，如下所示：</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo $HOME</div><div class="line">/home/biotest</div><div class="line">biotest@ubuntu:~/miniconda2/opt$ echo $PWD # PWD是显示当前目录</div><div class="line">/home/biotest/miniconda2/opt</div></pre></td></tr></table></figure>
<h4 id="的作用">$的作用</h4>
<p>在echo命令中，在变量名前加上<code>$</code>就能显示当前变量的值，它也能让变量作为命令行参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/miniconda2/opt$ ls $HOME</div><div class="line">biosoft    Downloads         Miniconda2-latest-Linux-x86_64.sh  Public     Videos</div><div class="line">Desktop    examples.desktop  Music                              Templates</div><div class="line">Documents  miniconda2        Pictures                           test</div></pre></td></tr></table></figure>
<h4 id="设置局部用户定义变量">设置局部用户定义变量</h4>
<p>一旦启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变量了。可以通过等号给环境变量赋值，值可以是数值或字符串，需要注意的是，在shell中，变量名，等号和值之间没有空格，否则会出错，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/miniconda2/opt$ echo $mywords</div><div class="line"></div><div class="line">biotest@ubuntu:~/miniconda2/opt$ mywords=hello</div><div class="line">biotest@ubuntu:~/miniconda2/opt$ echo $mywords</div><div class="line">hello</div></pre></td></tr></table></figure>
<p>如果要给变量赋值一个含有空格的字符串，必须要加上单绰号来界定字符串的首和尾，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/miniconda2/opt$ mywords=Hello linux</div><div class="line">linux: command not found</div><div class="line">biotest@ubuntu:~/miniconda2/opt$ mywords="Hello linux"</div><div class="line">biotest@ubuntu:~/miniconda2/opt$ echo $mywords</div><div class="line">Hello linux</div></pre></td></tr></table></figure>
<p>设置了局部变量后，就能在shell进程的任何地方使用它了，但是，如果生成了另外一个shell，在它的子shell中就无法使用。类似地，如果在子进程中设置了一个局部变量，一旦退出了子进程，那个局部环境变量就无法使用。</p>
<h4 id="设置全局环境变量">设置全局环境变量</h4>
<p>在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。，这个过程是通过<code>export</code>命令实现的，变量名前面不加<code>$</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ my_words="I love Linux"</div><div class="line">biotest@ubuntu:~$ export my_words</div><div class="line">biotest@ubuntu:~$ echo $mywords</div><div class="line">Hello linux</div><div class="line">biotest@ubuntu:~$ bash</div><div class="line">bbiotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div></pre></td></tr></table></figure>
<p>在定义了my_words变量后，用bash命令启动了一个子shell，在空上子shell中能够显示变量my_words的值，这是因为export命令将其设为了全局变量。</p>
<p>修改子shell中全局环境变量的值并不会影响你shell中该变量的值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div><div class="line">biotest@ubuntu:~$ bash</div><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div><div class="line">biotest@ubuntu:~$ my_words="I love Ubuntu"</div><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Ubuntu</div><div class="line">biotest@ubuntu:~$ exit</div><div class="line">exit</div><div class="line">biotest@ubuntu:~$ exit</div><div class="line">exit</div><div class="line">biotest@ubuntu:~$ ps</div><div class="line">   PID TTY          TIME CMD</div><div class="line"> 20142 pts/4    00:00:00 bash</div><div class="line"> 20318 pts/4    00:00:00 ps</div><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div></pre></td></tr></table></figure>
<p>子shell也无法通export命令改变父shell中全局变量的值。</p>
<h4 id="删除环境变量">删除环境变量</h4>
<p>删除环境变量使用<code>unset</code>命令，前面不加<code>$</code>符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div><div class="line">biotest@ubuntu:~$ unset my_words</div><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line"></div><div class="line">biotest@ubuntu:~$</div></pre></td></tr></table></figure>
<p>在涉及变量名时，什么时候使用<code>$</code>，什么时候不使用<code>$</code>，只需要这样记忆：要具体地查看变量的值时，就需要<code>$</code>符号，如果不需要查看变量的值，只针对变量本身操作，就不使用<code>$</code>符号。</p>
<h3 id="setprintenv都可以查看系统变量它们有什么区别">5. setprintenv都可以查看系统变量，它们有什么区别？</h3>
<p>答：（1）通过<code>set</code>可以设置shell选项，如果只输入set而不加任何参数，它就会显示shell 变量，环境变量，和定义的 shell 函数，此时与printenv命令类似，与 printenv 命令不同的是，set 命令的输出很友好地按照首字母顺序排列，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/Hc4BKfI9eL.png?imageslim" alt="mark"> 如上图所示，当使用没有带选项和参数的 set 命令时，shell 变量，环境变量，和定义的 shell 函数都会被显示。不同于 printenv 命令，set 命令的输出很友好地按照首字母顺序排列。 （2）set命令显示当前shell的变量，包括当前用户的变量；printenv（输入env也可以）命令只显示当前用户的变量。每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，但shell自己的变量不同shell是不同的，比如BASH_ARGC， BASH等，这些变量只有set才会显示，是bash特有的。</p>
<h3 id="环境变量存放在哪个地方">6. 环境变量存放在哪个地方？</h3>
<p>答：当你进入系统的时候，linux 就会为你读入系统的环境变量，这些环境变量存放在什么地方，那就是环境变量的文件中。Linux 中有很多记载环境变量的文件，它们被系统读入是按照一定的顺序的，这些文件包括以下部分：</p>
<h4 id="etcprofile">6.1 <code>/etc/profile</code>：</h4>
<p>此文件是bash shell默认的主启动文件，只要登录了Linux，bash就会执行/etc/profile启动文件中的命令，该文件存储的是整个系统的环境变量，它为每个用户设置环境信息，这个文件只有root才能修改。当用户第一次登录时，该文件被执行。并从/etc/profile.d目录的配置文件中搜集shell 的设置。这个文件，是任何用户登陆操作系统以后都会读取的文件（如果用户的shell 是csh 、tcsh 、zsh ，则不会读取此文件），用于获取系统的环境变量，只在登陆的时候读取一次。</p>
<h4 id="etcbashrc">6.2<code>/etc/bashrc</code>：</h4>
<p>在执行完/etc/profile 内容之后，如果用户的Shell运行的是bash ，那么接着就会执行此文件。另外，当每次一个新的bash shell 被打开时, 该文件被读取。每个使用bash的用户在登陆以后执行完/etc/profile 中内容以后都会执行此文件，在新开一个bash 的时候也会执行此文件。因此，如果你想让每个使用bash 的用户每新开一个bash 和每次登陆都执行某些操作，或者给他们定义一些新的环境变量，就可以在这个里面设置。 注：<code>/etc/profile</code>，<code>/etc/bashrc</code> 是系统全局环境变量设定</p>
<h4 id="home.bashrc">6.3<code>$HOME/.bashrc</code>：</h4>
<p>该文件包含专用于单个人的bash shell 的bash 信息，当登录时以及每次打开一个新的shell 时, 该该文件被读取。 单个用户此文件的修改会影响到他以后的每一次登陆系统和每一次新开一个bash 。因此，可以在这里设置单个用户的特殊的环境变量或者特殊的操作，那么每次它新登陆系统或者新开一个bash ，都会去获取相应的特殊的环境变量和特殊操作。</p>
<h4 id="home.bash_profile">6.4<code>$HOME/.bash_profile</code>：</h4>
<p>每个用户都可使用该文件输入专用于自己使用的shell 信息。当用户登录时，该文件仅仅执行一次，默认情况下，它设置一些环境变量，执行用户的.bashrc 文件。单个用户此文件的修改只会影响到他以后的每一次登陆系统。因此，可以在这里设置单个用户的特殊的环境变量或者特殊的操作，那么它在每次登陆的时候都会去获取这些新的环境变量或者做某些特殊的操作，但是仅仅在登陆时。 <code>~/.bashrc</code>和<code>~/.bash_profile</code>都只对当前的用户永久生效，也就是说假如用户A设置了些类环境变量，这个环境变量只有A才能使用，而对于其他的B，C，D等用户来说，这个变量是不存在的。在根目录下，通过<code>ls -a</code>可以查看这两个文件，正常情况下，这两个文件是隐藏的。</p>
<h4 id="home.bash_logout">6.5<code>$HOME/.bash_logout</code>：</h4>
<p>当每次退出系统( 退出bash shell) 时, 执行该文件。</p>
<h3 id="bashrc和.bash_profile的区别是什么">7. <code>~/.bashrc</code>和<code>~/.bash_profile</code>的区别是什么？</h3>
<p>答：原则上来说，设置自己的环境变量时，在这两个文件中任意选一个即可，它们的区别在于：<code>~/.bash_profile</code>是交互式login方式进入bash shell运行而<code>~/ .bashrc</code>是交互式non-login方式进入bash shell运行。二者设置大致相同。通俗点说，就是<code>.bash_profile</code>文件只会在用户登录的时候读取一次，而<code>.bashrc</code>在每次打开终端进行一次新的会话时都会读取。</p>
<h4 id="登录-shell-会读取一个或多个启动文件的总结">登录 shell 会读取一个或多个启动文件的总结:</h4>
<table style="width:85%;">
<colgroup>
<col width="27%">
<col width="56%">
</colgroup>
<thead>
<tr class="header">
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/etc/profile</td>
<td>应用于所有用户的全局配置脚本。</td>
</tr>
<tr class="even">
<td>$HOME/.bash_profile</td>
<td>用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td>
</tr>
<tr class="odd">
<td>$HOME/.bash_login</td>
<td>如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。</td>
</tr>
<tr class="even">
<td>$HOME/.profile</td>
<td>如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。</td>
</tr>
</tbody>
</table>
<p>非登录 shell 会话会读取以下启动文件：</p>
<table>
<thead>
<tr class="header">
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/etc/bash.bashrc</td>
<td>应用于所有用户的全局配置文件。</td>
</tr>
<tr class="even">
<td>~/.bashrc</td>
<td>用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td>
</tr>
</tbody>
</table>
<p>在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。</p>
<h3 id="如何查看某个变量的内容">8. 如何查看某个变量的内容？</h3>
<p>答：如果只查看某个变量的内容，用echo，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/EEDi017BBh.png?imageslim" alt="mark"></p>
<h3 id="什么是临时有效的环境变量">9. 什么是临时有效的环境变量？</h3>
<p>答：临时有效的环境变量就是只对当前的shell有效，当我们退出登录或者关闭终端再打开时，这个环境变量就会消失，它是临时的，设置方法是直接使用<code>export</code>命令来添加，如下所示：</p>
<blockquote>
<p>biotest@ubuntu:~$ export Words=“Hello, world!” biotest@ubuntu:~$ echo $Words Hello, world! biotest@ubuntu:~</p>
</blockquote>
<h3 id="如何查看地自定义的别名">10. 如何查看地自定义的别名？</h3>
<p>答：通过set或printenv无法查看通过alias命名的别名，此时需要通过alias来查看，如下所示：</p>
<blockquote>
<p>alias egrep=‘egrep –color=auto’ alias fgrep=‘fgrep –color=auto’ alias grep=‘grep –color=auto’ alias l=‘ls -CF’ alias la=‘ls -A’ alias ll=‘ls -alF’ alias ls=‘ls –color=auto’</p>
</blockquote>
<h3 id="shell中的一些大写字母是什么意思">11. Shell中的一些大写字母是什么意思？</h3>
<p>答：这些大写字母表示一些特殊的环境变量，如下所示：</p>
<table style="width:68%;">
<colgroup>
<col width="11%">
<col width="56%">
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DISPLAY</td>
<td>如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 “:0”， 意思是由 X 产生的第一个显示器。</td>
</tr>
<tr class="even">
<td>EDITOR</td>
<td>文本编辑器的名字。</td>
</tr>
<tr class="odd">
<td>SHELL</td>
<td>shell 程序的名字。</td>
</tr>
<tr class="even">
<td>HOME</td>
<td>用户家目录。</td>
</tr>
<tr class="odd">
<td>LANG</td>
<td>定义了字符集以及语言编码方式。</td>
</tr>
<tr class="even">
<td>OLD_PWD</td>
<td>先前的工作目录。</td>
</tr>
<tr class="odd">
<td>PAGER</td>
<td>页输出程序的名字。这经常设置为/usr/bin/less。</td>
</tr>
<tr class="even">
<td>PATH</td>
<td>由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。</td>
</tr>
<tr class="odd">
<td>PS1</td>
<td>Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。</td>
</tr>
<tr class="even">
<td>PWD</td>
<td>当前工作目录。</td>
</tr>
<tr class="odd">
<td>TERM</td>
<td>终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。</td>
</tr>
<tr class="even">
<td>TZ</td>
<td>指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。</td>
</tr>
<tr class="odd">
<td>USER</td>
<td>你的用户名</td>
</tr>
</tbody>
</table>
<h3 id="设置环境变量常用的指令有哪些">12. 设置环境变量常用的指令有哪些?</h3>
<p>答:常用的命令有<code>echo</code>,<code>export</code>,<code>env</code>,<code>set</code>,<code>unset</code>，<code>readonly</code>等，如下所示：</p>
<h4 id="echo">(1)<code>echo</code></h4>
<p>查看某个环境变量．</p>
<h4 id="env">(２)<code>env</code></h4>
<p>查看所有环境变量</p>
<h4 id="set">(３)<code>set</code></h4>
<p>查看本地定义的所有shell变量．</p>
<h4 id="unset">(４)<code>unset</code></h4>
<p>删除一个环境变量，例如：</p>
<blockquote>
<p>biotest@ubuntu:~$ export Words=“Hello, world!” biotest@ubuntu:~$ echo $Words Hello, world! biotest@ubuntu:~$ unset Words biotest@ubuntu:~$ echo $Words biotest@ubuntu:~$</p>
</blockquote>
<h4 id="readonly">(5)<code>readonly</code></h4>
<p>设置只读环境变量．</p>
<h3 id="如何将某程序的目录添加到环境变量">13. 如何将某程序的目录添加到环境变量？</h3>
<p>答：当在shell中输入一个外部命令时,shell就会搜索系统来找到相应的程序,<code>PATH</code>这个环境变量就是定义用于命令和程序查找的目录,通过<code>echo $PATH</code>可以查看环境变量，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/H7kICbk6jf.png?imageslim" alt="mark"></p>
<p>在<code>PATH</code>变量中，可以看到许多由冒号（黄色方框标出的部分）分开的路径。每个冒号就是一个路径，这些搜索路径都是一些可以找到可执行程序的目录列表。当我们输入一个指令时，shell会先检查命令是否是内部命令，不是的话会再检查这个命令是否是一个应用程序。然后shell会试着从这些搜索路径，即PATH（上图中路径）中寻找这些应用程序。如果shell在这些路径目录里没有找到可执行文件。则会报错。若找到，shell内部命令或应用程序将被分解为系统调用并传给Linux内核。在某些时候,我们在Linux中安装了软件,如果没有把软件的可执行文件路径添加到PATH中去的话，要执行某个程序，就需要输入全路径，非常不方便，因此我们需要把软件的安装目录添加到PATH变量中。</p>
<h4 id="path环境变量的一个案例"><code>PATH</code>环境变量的一个案例</h4>
<ol style="list-style-type: decimal">
<li>创建一个可执行文件 在<code>/mnt/hgfs/biotest</code>这个目录下建立一个<code>test.py</code>文件，输入以下内容：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"></div><div class="line">print(<span class="string">"hello, world"</span>)</div></pre></td></tr></table></figure>
<p>保存，退出。 然后将这个文件权限修改为可执行，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x test.py</div></pre></td></tr></table></figure>
<ol start="2" style="list-style-type: decimal">
<li><p>测试相对路径与绝对路径调用 在当前目录下打开客户端，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:/mnt/hgfs/biotest$ ./test.py # 相对路径调用</div><div class="line">&gt;hello, world</div><div class="line">&gt;biotest@ubuntu:/mnt/hgfs/biotest$ </div><div class="line">&gt;biotest@ubuntu:/mnt/hgfs/biotest$ cd</div><div class="line">&gt;biotest@ubuntu:/mnt/hgfs/biotest/test.py # 绝对路径调用</div><div class="line">&gt;hello, world</div></pre></td></tr></table></figure></p></li>
<li><p>未添加到环境变量PATH时的情况 此时，<code>test.py</code>文件并没添加到<code>PATH</code>的环境变量中，因此直接输入<code>test.py</code>会出错，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:$ test.py</div><div class="line">&gt;test.py: command not found</div></pre></td></tr></table></figure></p></li>
<li><p>将文件的路径添加到环境变量PATH 通过设置PATH环境变量，直接用文件名调用：</p></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:$export PATH=$PATH:/mnt/hgfs/biotest</div><div class="line">&gt;biotest@ubuntu:$ test.py</div><div class="line">&gt;hello, world</div><div class="line">&gt;biotest@ubuntu:$</div></pre></td></tr></table></figure>
<p>注：在添加路径到环境变量时，用到了<code>export</code>，它的用法是<code>export PATH=$PATH:路径</code>，或<code>export $PATH=&quot;路径”</code></p>
<ol start="5" style="list-style-type: decimal">
<li>永久将文件路径添加到环境变量 此时，将这个客户端关闭，再打开，试着输入<code>test.py</code>，发现出错了，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:$ test.py</div><div class="line">&gt;test.py: command not found</div></pre></td></tr></table></figure></li>
</ol>
<p>因为在第4步中，<code>export PATH=$PATH:/mnt/hgfs/biotest</code>只是一种临时添加到环境变量的方法，如果要每次打开客户端时，都能直接执行<code>test.py</code>，则需要将目录添加到.bashrc文件中，步骤如下： 第一，输入<code>biotest@ubuntu:/$ vi ~/.bashrc</code>打开bashrc文件； 第二，移到bashrc文件的最末端，按<code>I</code>，切换到编辑模式，输入<code>export PATH=/mnt/hgfs/biotest:$PATH</code>，再按<code>Esc</code>键，输入<code>wq</code>，回车，退出； 第三，输入<code>source ~/.bashrc</code>，刷新文件，此时，再输入<code>test.py</code>，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:$ test.py</div><div class="line">&gt;hello, world</div></pre></td></tr></table></figure></p>
<p>把客户端关闭或者是重启电脑，再次输入<code>test.py</code>也能够执行，用<code>export</code>查看一下环境变量，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/lfJc52FL4H.png?imageslim" alt="mark"> 可以发现，test.py所在的目录在环境变量中。</p>
<p>如果觉得打开<code>~/.bashrc</code>文件，添加环境变量太麻烦了，可以直接在命令行模式下面进行添加，现在将原来的那个test.py文件拷到另外一个目录（<code>~/Downloads</code>）下面，并把文件名字进行修改，改为<code>test2.py</code>，此时输入以下命令即可： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &apos;export PATH=$PATH:~/Downloads&apos;&gt;&gt;~/.bashrc &amp;&amp; source ~/.bashrc</div></pre></td></tr></table></figure></p>
<p>运行过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/Downloads$ ./test2.py #相对路径运行</div><div class="line">hello, world</div><div class="line">biotest@ubuntu:~/Downloads$ echo &apos;export PATH=$PATH:~/Downloads&apos;&gt;&gt;~/.bashrc &amp;&amp; source ~/.bashrc #将路径添加到环境变量，直接运行；；</div><div class="line">biotest@ubuntu:~/Downloads$ test2.py</div><div class="line">hello, world</div></pre></td></tr></table></figure>
<p>通过echo还可以添加alias，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;alias lh=&apos;ls -lh&apos;&quot; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc</div></pre></td></tr></table></figure>
<p>运行过程如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/0fJGD9KkA1.png?imageslim" alt="mark"></p>
<h3 id="什么是非交互式shell">什么是非交互式shell？</h3>
<p>答：在命令行中输入bash命令，这就是交互式shell，系统执行shell脚本时则是非交互式shell，不同的地方就在于非交互式shell没有命令行提示答。bash shell有一个环境变量即，<code>BASH_ENV</code>环境变量，当shell启动一个非交互式shell进程时，它会检查这个环境变量来查提要执行的启动文件，如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。这个环境㸄在默认情况下并没有设置，输入<code>printenv BASH_ENV</code>不会返回任何信息。如果BASH_ENV没有设置，shell脚本获取环境变量的过程是这样的：shell脚本是通过启动一个子shell来执行的，子shell可以继承父shell导出过的变量，举例来说，如果父shell是登录shell，在<code>etc/profile</code>、<code>/etc/profile.d/*.sh</code>和<code>$HOME/.bashrc</code>文件中设置并导出了变量，用于执行脚本的子shell就能够继池在这些变量。需要注意的是，父shell设置但并未导出的变量都是局部变量，子shell无法继承局部变量。</p>
<h3 id="什么是数组变量">什么是数组变量？</h3>
<p>答：环境变量有一个很有用的特性就是它们可以作为数组使用，数组是能够储存多个值的变量，这些值可以单独引用，也可以作为整个数组来引物，要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ mytest=(one two three four five)</div><div class="line">biotest@ubuntu:~$ echo $mytest</div><div class="line">one</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[2]&#125;</div><div class="line">three</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[0]&#125;</div><div class="line">one</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[*]&#125;</div><div class="line">one two three four five</div><div class="line">biotest@ubuntu:~$ unset mytest[2]</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[*]&#125;</div><div class="line">one two four five</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[3]&#125;</div><div class="line">four</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[*]&#125;</div><div class="line">one two four five</div><div class="line">biotest@ubuntu:~$ unset mytest</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[*]&#125;</div></pre></td></tr></table></figure>
<p>从上面结果可以知道，数组变量有这样的特点：①如果只输入变量的名称，只返回第1个元素的值；②如果要显其余的变量的值，格式为<code>echo ${mytest[n]}</code>，其中n是元素的索引，它是从0开始的，如果要显示全部的内容，需要输入星号（*）；③如果要删除数组变量中间的某个元素，删除后，原变量的索引不变；④</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/24/生信-KEGG学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/24/生信-KEGG学习笔记/" itemprop="url">KEGG学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-24T12:00:00+08:00">
                2018-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物信息学/" itemprop="url" rel="index">
                    <span itemprop="name">生物信息学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,225
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1. 什么是通路分析？</strong> 答：一个生物学过程的实现会涉及到许多蛋白质，这些蛋白质合在一起就是一个通路。通路分析能够帮助我们更好地了解某个或某一些蛋白质在一个生物学过程中所扮演的角色。通路分析和GO都是对基因进行注释，那么为什么要对基因进行注释呢？因为基因说穿了其实是一串RNA，那么它的功能和结构虽然都是客观存在的，但是要如何描述这些客观的东西是基因注释所要解决的问题。 最常用的通路分析数据库是京都基因与基因组百科全书 (Kyoto Encyclopedia of Genes and Genomes, KEGG)。1995年，KEGG数据库项目由京都大学化学研究所教授Minoru Kanehisa领头启动。KEGG数据库是手工绘制的KEGG途径图的集合，每个途径图包含分子相互作用和反应的网络，将基因组中的基因与通路中的基因产物（主要是蛋白质）连接。KEGG pathway analysis即为将目的基因定位到KEGG途径图中的过程。下图为small cell lung cancer的KEGG途径图。</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/5e1AC87cD0.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<p><strong>2. 什么是KEGG？</strong> 答：KEGG，Kyoto Encyclopedia of Genes and Genomes，京都基因和基因组百科全书，是系统分析基因功能，联系基因组信息和功能信息的知识库。其中包含有大量的通路图，如下图所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/cDH8eG65Fi.png?imageslim" alt="mark"></p>
<p><strong>3. KEGG中的各种符号表示什么意思？</strong> 答：如下图所示，这种绿色方框里面的是酶； <img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/IhKbhEe588.png?imageslim" alt="mark"></p>
<p>圆圈代表代谢物，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/1e02LEaa7B.png?imageslim" alt="mark"> 点一个圆圈，如cAMP进去，有这个代谢物的各种信息，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/e1IG9ciEcK.png?imageslim" alt="mark"> 其中C00575的信息为，C代表人物，即compound，00575是这种化合物在KEGG中的编号。</p>
<p>此外，还有一些白框，它们的信息如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/FKc3Flfl3I.jpg?imageslim" alt="mark"></p>
<p><strong>4. KEGG中的不同颜色表示什么意思？</strong> 答：一般KEGG存在两种代谢图： ①reference pathway，这是根据已有的知识绘制的、概括的、详尽的具有一般参考意义的代谢图，为白色小框，在KEGG中名字以map开头，比如map00010，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/HHGK5jf20m.png?imageslim" alt="mark"></p>
<p>②species-specific pathway，绿色小框为该物种特有的基因或酶，只有这些绿色的框有更详细的信息。KEGG中名字为特定物种种属英文缩写，比如酵母的糖酵解通路图，sce00010，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/bJLf2ck2i8.png?imageslim" alt="mark"></p>
<p><strong>5. KEGG在生物信息学方面分析的原理是什么？ </strong> 答：人类的七千多个基因组都是有已知功能的，KEGG把这七千多个基因分成了300个类，就是我们通常说的kegg通路；比如，我现在做了个实验，发现某细胞系里面的两万个基因里面有300个基因变化了，那这300个基因会涉及到KEGG数据库的哪几个通路？这时候就需要用到我的工具啦~将这300个基因加入工具里面，得出结果：有30个Cell cycle通路。</p>
<p><strong>6. 富集分析怎么分析？</strong> 答：事实上，Cell Cycle KEGG 通路 hsa04110只有124个基因；而我处理了细胞系之后，在只有300个基因发生统计学显著变化的情况下，就有30个是Cell Cycle通路？高达10%的概率，那到底这个Cell Cycle通路是不是被显著改变了呢？ 首先，我会把用户的300个基因，都用KEGG数据库的300个通路注释，然后一个个通路循环做超几何分布检验，给出P值；比如刚才的Cell Cycle 通路就很显著，因为124/7000就2%的概率，结果我 30/300有10%的概率~太可怕了，所以我的这个处理显著的改变了细胞系的Cell Cycle 通路。</p>
<p><strong>7. KEGG分析后的结果是什么样子，怎么解读？</strong> 答：这是某个工具的KEGG分析后的结果如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180409/d5KH0eKjb8.jpg?imageslim" alt="mark"> 黄色是高表达（有的工具会是红色），绿色是低表达，灰色是表达不变。</p>
<p><strong>8. KEGG中的代码是什么意思？</strong> 答：1. K+num（基因ID号，表示在所有同源物种中具有相似结构或功能的一类同源蛋白），如K04456=&gt;丝氨酸/苏氨酸蛋白激酶（备注：K建议大写）。 2. ko + num（代谢通路名称，表示一个特定的生物路径），如：k04151=&gt;PIK-Akt信号通路（备注：ko小写）。 3. M+num（模块名称），M00676=&gt;PI3K-Akt信号模块。 4. C+num（代合物名），如C00533表示NO。 5. E-.-.-.-（酶名），例如EC2.7.1.11.1=&gt;丝氨酶/苏氨酸激酶（即K04456，AKT）。 6. R+num（反应名） 7. RC+num(反应类型）RP + RP+num（反应物质对）</p>
<p>参考资料 1. <a href="https://mp.weixin.qq.com/s?src=3&amp;timestamp=1523265048&amp;ver=1&amp;signature=SlU3Ctn3S1ucuf07HpdA5BO7jftw2xUN1IpV84vyrd2zq-RdrZhJihCJ1WKkxk0DkrPc--l-Gz-rqX4274h94eqWPiZ2Zsx6*tz0buy1Zxg54pZ-6D6smfhmLAUtCAbBE52Q8qgh5SrjjuJcVBZH91psMGXAb8oqFWTmlxB-EIg=" target="_blank" rel="external">手把手教你看KEGG通路图！</a> 2. <a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1523265396&amp;ver=806&amp;signature=5oh1CmbL0GLyXQ62PnvxR7ZafrvmFU-09TV0vuGJ4TNVw7vVVaEw**EjPiKXQBiYJG6LmwtjT2YRNiBOBYu3matCTy3cvVG9SICTWYkPAln7ivUte0n*KsIXY*yVauf-&amp;new=1" target="_blank" rel="external">KEGG富集分析从未如此简单</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/12/Python学习笔记（10）-输入输入与文件及目录操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/Python学习笔记（10）-输入输入与文件及目录操作/" itemprop="url">Python学习笔记（10）-文件、目录和输入输出操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T12:00:00+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,774
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="读取键盘的输入">读取键盘的输入</h2>
<p>Python提供了<code>input()</code>内置函数从标准输入读入一行文本，默认的标准输入是键盘。<code>input</code>可以接收一个Python表达式作为输入，并将运算结果返回，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat input.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">str=input(<span class="string">"Please input:  "</span>)</div><div class="line">print(<span class="string">"What you input is: "</span>,str)</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 input.py </div><div class="line">Please input:  Hello</div><div class="line">What you input <span class="keyword">is</span>:  Hello</div></pre></td></tr></table></figure>
<h2 id="文件的读取">文件的读取</h2>
<p><code>open()</code>将会返回一个file对象，基本语法格式为<code>open(filename,mode)</code>，其中<code>filename</code>：包含了你要访问的文件名称的字符串值。<code>mode</code>决定了打开文件的模式，打开文件的模式有：①只读；②写入；③追加。这个参数是非强制的，默认文件访问模式为只读<code>(r)</code>。不同模式打开文件的完全列表：</p>
<table style="width:92%;">
<colgroup>
<col width="6%">
<col width="84%">
</colgroup>
<thead>
<tr class="header">
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr class="even">
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td>
</tr>
<tr class="odd">
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr class="even">
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr class="odd">
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="even">
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="odd">
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="even">
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="odd">
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr class="even">
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr class="odd">
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr class="even">
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
<p>下图总结了这几种模式（出处：<a href="http://www.runoob.com/python3/python3-inputoutput.html" target="_blank" rel="external">菜鸟教程</a>）：</p>
<div class="figure">
<img src="http://ortxpw68f.bkt.clouddn.com/professional/180523/ilf5lkh0lA.png?imageslim" alt="mark">
<p class="caption">mark</p>
</div>
<table>
<thead>
<tr class="header">
<th>模式</th>
<th>r</th>
<th>r+</th>
<th>w</th>
<th>w+</th>
<th>a</th>
<th>a+</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
</tr>
<tr class="even">
<td>写</td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr class="odd">
<td>创建</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr class="even">
<td>覆盖</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>指针在开始</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>指针在结尾</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
<h3 id="文件读写案例">文件读写案例</h3>
<p>下面的代码会将一些字符串写入到文件<code>foo.txt</code>中，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat write.py</div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line"><span class="comment"># open a file</span></div><div class="line"><span class="comment"># If this file does not exist, python will create it</span></div><div class="line"><span class="comment"># You can use absolute path or current path;</span></div><div class="line">f = open(<span class="string">"foo.txt"</span>,<span class="string">"w"</span>)</div><div class="line">f.write(<span class="string">"Python is a good program language.\n Yes, it is very good!\n"</span>)</div><div class="line">f.close()</div><div class="line"></div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 write.py </div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ ls</div><div class="line">foo.txt  input.py  write.py</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div></pre></td></tr></table></figure>
<p>代码解释：<code>open()</code>括号中是文件路径，如果不指明绝对路径，则就会默认为当前目录；如果文件存在，就打开，如果不存在，代码会创建这个文件。</p>
<h2 id="文件对象的方法">文件对象的方法</h2>
<h3 id="file对象常用函数">file对象常用函数</h3>
<p>file对象使用open函数来创建，下表列出了file对象常用的函数：</p>
<table style="width:92%;">
<colgroup>
<col width="6%">
<col width="84%">
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>方法及描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>file.close()：关闭文件。关闭后文件不能再进行读写操作。</td>
</tr>
<tr class="even">
<td>2</td>
<td>file.flush()：刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>
</tr>
<tr class="odd">
<td>3</td>
<td>file.fileno()：返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>
</tr>
<tr class="even">
<td>4</td>
<td>file.isatty()：如果文件连接到一个终端设备返回 True，否则返回 False。</td>
</tr>
<tr class="odd">
<td>5</td>
<td>file.next()：返回文件下一行。</td>
</tr>
<tr class="even">
<td>6</td>
<td>file.read([size])：从文件读取指定的字节数，如果未给定或为负则读取所有。</td>
</tr>
<tr class="odd">
<td>7</td>
<td>file.readline([size])：读取整行，包括 “” 字符。</td>
</tr>
<tr class="even">
<td>8</td>
<td>file.readlines([sizeint])：读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td>
</tr>
<tr class="odd">
<td>9</td>
<td>file.seek(offset[, whence])：设置文件当前位置</td>
</tr>
<tr class="even">
<td>10</td>
<td>file.tell()：返回文件当前位置。</td>
</tr>
<tr class="odd">
<td>11</td>
<td>file.truncate([size])：从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。</td>
</tr>
<tr class="even">
<td>12</td>
<td>file.write(str)：将字符串写入文件，没有返回值。</td>
</tr>
<tr class="odd">
<td>13</td>
<td>file.writelines(sequence)：向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody>
</table>
<h3 id="f.read">f.read()</h3>
<p>为了读取一个文件的内容，调用<code>f.read(size)</code>,这将读取一定数目的数据,然后作为字符串或字节对象返回。<code>size</code>是一个可选的数字类型的参数。当<code>size</code>被忽略了或者为负,那么该文件的所有内容都将被读取并且返回，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt</div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat read.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line"><span class="comment"># open a file</span></div><div class="line">f = open(<span class="string">"foo.txt"</span>,<span class="string">"r"</span>)</div><div class="line"></div><div class="line">str=f.read()</div><div class="line">print(str)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 read.py </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div></pre></td></tr></table></figure>
<h3 id="f.readline">f.readline()</h3>
<p><code>f.readline()</code>会从文件中读取单独的一行，换行符为<code>\n</code>，<code>f.readline()</code>如果返回一个空字符串，说明已经读取到了最后一下，看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat readline.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">f=open(<span class="string">"foo.txt"</span>,<span class="string">"r"</span>)</div><div class="line"></div><div class="line">str=f.readline()</div><div class="line">print(str)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 readline.py </div><div class="line">Python <span class="keyword">is</span> a good program language.</div></pre></td></tr></table></figure>
<h3 id="f.readlines">f.readlines()</h3>
<p><code>f.readlines()</code>将返回该文件中包含的所有行。如果设置可选参数<code>sizehint</code>,则读取指定长度的字节,并且将这些字节按行分割，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat readlines.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">f = open(<span class="string">"foo.txt"</span>,<span class="string">"r"</span>)</div><div class="line">str=f.readlines()</div><div class="line">print(str)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 readlines.py </div><div class="line">[<span class="string">'Python is a good program language.\n'</span>, <span class="string">' Yes, it is very good!\n'</span>]</div></pre></td></tr></table></figure>
<p>另外一种读取文件内容的方式就是对文件中的行进行迭代，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat iteration.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line">f=open(<span class="string">"foo.txt"</span>,<span class="string">"r"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">    print(line,end=<span class="string">" "</span>)</div><div class="line"></div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 iteration.py </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line">  Yes, it <span class="keyword">is</span> very good!</div></pre></td></tr></table></figure>
<h3 id="f.write">f.write()</h3>
<p>f.write(string)会将string写入到文件中，然后返回写入的字符数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat f_write.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">f = open(<span class="string">"foo.txt"</span>,<span class="string">"w"</span>)</div><div class="line"></div><div class="line">num = f.write(<span class="string">"Python is a good tool.\n Yes, it is good!\n"</span>)</div><div class="line">print(num)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 f_write.py </div><div class="line"><span class="number">41</span></div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good tool.</div><div class="line"> Yes, it <span class="keyword">is</span> good!</div></pre></td></tr></table></figure>
<p>如果要写入一些非字符串的东西, 那么将需要先进行转换，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat string_trans.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">f = open(<span class="string">"foo1.txt"</span>,<span class="string">"w"</span>)</div><div class="line">value = (<span class="string">'www.runoob.com'</span>,<span class="number">14</span>)</div><div class="line">s = str(value)+<span class="string">"\n"</span></div><div class="line">f.write(s)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 string_trans.py </div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo1.txt </div><div class="line">(<span class="string">'www.runoob.com'</span>, <span class="number">14</span>)</div></pre></td></tr></table></figure>
<h3 id="f.tell">f.tell()</h3>
<p><code>f.tell()</code>返回文件对象当前所处的位置,它是从文件开头开始算起的字节数。</p>
<h3 id="f.seek">f.seek()</h3>
<p>如果要改变文件当前的位置,可以使用<code>f.seek(offset,from_what)</code>函数。 <code>from_what</code>的值,如果是0表示开头,如果是1表示当前位置,2表示文件的结尾，例如：</p>
<ol style="list-style-type: decimal">
<li>seek(x,0)：从起始位置即文件首行首字符开始移动x个字符</li>
<li>seek(x,1)：表示从当前位置往后移动x个字符</li>
<li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li>
<li>from_what值为默认为0，即文件开头。</li>
</ol>
<p>看下面的案例： <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f=open(<span class="string">'foo.txt'</span>,<span class="string">'rb+'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b'0123456789abcdef'</span>)</div><div class="line"><span class="number">16</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">5</span>)</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</div><div class="line"><span class="string">b'5'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">-3</span>,<span class="number">2</span>)</div><div class="line"><span class="number">38</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</div><div class="line"><span class="string">b'd'</span></div></pre></td></tr></table></figure></p>
<h3 id="f.close">f.close()</h3>
<p>在文本文件中(那些打开文件的模式下没有<code>b</code>的)，只会相对于文件起始位置进行定位。当你处理完一个文件后，调用<code>f.close()</code>来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: read of closed file</div></pre></td></tr></table></figure>
<p>当处理一个文件对象时,使用<code>with</code>关键字是非常好的方式。在结束后,它会帮你正确的关闭文件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'foo.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line"><span class="meta">... </span>    read_data = f.read()</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<h2 id="pickle模块">pickle模块</h2>
<p>python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。基本接口如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pickle.dump(obj, file, [,protocol])</div></pre></td></tr></table></figure>
<p>有了 pickle 这个对象, 就能对 file 以读取的形式打开，即<code>x = pickle.load(file0</code>)。file表示类文件对象，它有<code>read()</code>和<code>readline()</code>接口，看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat pickly.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> pickle</div><div class="line"></div><div class="line"><span class="comment"># using pickle module to save data object to a file</span></div><div class="line">data1 = &#123;<span class="string">'a'</span>:[<span class="number">1</span>,<span class="number">2.0</span>,<span class="number">3</span>,<span class="number">4</span>+<span class="number">6j</span>],</div><div class="line">        <span class="string">'b'</span>:(<span class="string">'string'</span>,<span class="string">u'Unicode string'</span>),</div><div class="line">        <span class="string">'c'</span>:<span class="keyword">None</span>&#125;</div><div class="line"></div><div class="line">selfref_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">selfref_list.append(selfref_list)</div><div class="line"></div><div class="line">output = open(<span class="string">'data.pkl'</span>,<span class="string">'wb'</span>)</div><div class="line"></div><div class="line"><span class="comment"># Pickle dictionary using protocol 0.</span></div><div class="line">pickle.dump(data1,output)</div><div class="line"></div><div class="line"><span class="comment"># Pickle th elist using the highest protocol available.</span></div><div class="line">pickle.dump(selfref_list,output,<span class="number">-1</span>)</div><div class="line"></div><div class="line">output.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 pickly.py </div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ ls</div><div class="line">data.pkl  foo.txt     input.py      pickly.py    readline.py   read.py  string_trans.py</div><div class="line">foo1.txt  f_write.py  iteration.py  __pycache__  readlines.py  seek.py  write.py</div></pre></td></tr></table></figure>
<p>在当前目录下生成了一个<code>data.pkl</code>文件，打开后是乱码，现在不清楚这个文件什么意思，接着还有一段代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat pickle2.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"><span class="keyword">import</span> pprint, pickle</div><div class="line"></div><div class="line">pkl_file = open(<span class="string">'data.pkl'</span>,<span class="string">'rb'</span>)</div><div class="line"></div><div class="line">data1 = pickle.load(pkl_file)</div><div class="line">pprint.pprint(data1)</div><div class="line"></div><div class="line">data2 = pickle.load(pkl_file)</div><div class="line">pprint.pprint(data2)</div><div class="line"></div><div class="line">pkl_file.close()</div><div class="line"></div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 pickle2.py</div><div class="line">&#123;<span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>, (<span class="number">4</span>+<span class="number">6j</span>)], <span class="string">'b'</span>: (<span class="string">'string'</span>, <span class="string">'Unicode string'</span>), <span class="string">'c'</span>: <span class="keyword">None</span>&#125;</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &lt;Recursion on list <span class="keyword">with</span> id=<span class="number">140696236160136</span>&gt;]</div></pre></td></tr></table></figure>
<p>上述代码解释：</p>
<h2 id="目录操作">目录操作</h2>
<p>Python中的目录操作有这些：</p>
<table style="width:92%;">
<colgroup>
<col width="6%">
<col width="84%">
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>方法及描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>os.access(path, mode)：检验权限模式</td>
</tr>
<tr class="even">
<td>2</td>
<td>os.chdir(path)：改变当前工作目录</td>
</tr>
<tr class="odd">
<td>3</td>
<td>os.chflags(path, flags)：设置路径的标记为数字标记。</td>
</tr>
<tr class="even">
<td>4</td>
<td>os.chmod(path, mode)：更改权限</td>
</tr>
<tr class="odd">
<td>5</td>
<td>os.chown(path, uid, gid)：更改文件所有者</td>
</tr>
<tr class="even">
<td>6</td>
<td>os.chroot(path)：改变当前进程的根目录</td>
</tr>
<tr class="odd">
<td>7</td>
<td>os.close(fd)：关闭文件描述符 fd</td>
</tr>
<tr class="even">
<td>8</td>
<td>os.closerange(fd_low, fd_high)：关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr class="odd">
<td>9</td>
<td>os.dup(fd)：复制文件描述符 fd</td>
</tr>
<tr class="even">
<td>10</td>
<td>os.dup2(fd, fd2)：将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr class="odd">
<td>11</td>
<td>os.fchdir(fd)：通过文件描述符改变当前工作目录</td>
</tr>
<tr class="even">
<td>12</td>
<td>os.fchmod(fd, mode)：改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr class="odd">
<td>13</td>
<td>os.fchown(fd, uid, gid)：修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr class="even">
<td>14</td>
<td>os.fdatasync(fd)：强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr class="odd">
<td>15</td>
<td>os.fdopen(fd[, mode[, bufsize]])：通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr class="even">
<td>16</td>
<td>os.fpathconf(fd, name)：返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr class="odd">
<td>17</td>
<td>os.fstat(fd)：返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr class="even">
<td>18</td>
<td>os.fstatvfs(fd)：返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td>
</tr>
<tr class="odd">
<td>19</td>
<td>os.fsync(fd)：强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr class="even">
<td>20</td>
<td>os.ftruncate(fd, length)：裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr class="odd">
<td>21</td>
<td>os.getcwd()：返回当前工作目录</td>
</tr>
<tr class="even">
<td>22</td>
<td>os.getcwdu()：返回一个当前工作目录的Unicode对象</td>
</tr>
<tr class="odd">
<td>23</td>
<td>os.isatty(fd)：如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr class="even">
<td>24</td>
<td>os.lchflags(path, flags)：设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr class="odd">
<td>25</td>
<td>os.lchmod(path, mode)：修改连接文件权限</td>
</tr>
<tr class="even">
<td>26</td>
<td>os.lchown(path, uid, gid)：更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr class="odd">
<td>27</td>
<td>os.link(src, dst)：创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr class="even">
<td>28</td>
<td>os.listdir(path)：返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr class="odd">
<td>29</td>
<td>os.lseek(fd, pos, how)：设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr class="even">
<td>30</td>
<td>os.lstat(path)：像stat(),但是没有软链接</td>
</tr>
<tr class="odd">
<td>31</td>
<td>os.major(device)：从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr class="even">
<td>32</td>
<td>os.makedev(major, minor)：以major和minor设备号组成一个原始设备号</td>
</tr>
<tr class="odd">
<td>33</td>
<td>os.makedirs(path[, mode])：递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr class="even">
<td>34</td>
<td>os.minor(device)：从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr class="odd">
<td>35</td>
<td>os.mkdir(path[, mode])：以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr class="even">
<td>36</td>
<td>os.mkfifo(path[, mode])：创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr class="odd">
<td>37</td>
<td>os.mknod(filename[, mode=0600, device])：创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr class="even">
<td>38</td>
<td>os.open(file, flags[, mode])：打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr class="odd">
<td>39</td>
<td>os.openpty()：打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr class="even">
<td>40</td>
<td>os.pathconf(path, name)：返回相关文件的系统配置信息。</td>
</tr>
<tr class="odd">
<td>41</td>
<td>os.pipe()：创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr class="even">
<td>42</td>
<td>os.popen(command[, mode[, bufsize]])：从一个 command 打开一个管道</td>
</tr>
<tr class="odd">
<td>43</td>
<td>os.read(fd, n)：从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr class="even">
<td>44</td>
<td>os.readlink(path)：返回软链接所指向的文件</td>
</tr>
<tr class="odd">
<td>45</td>
<td>os.remove(path)：删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr class="even">
<td>46</td>
<td>os.removedirs(path)：递归删除目录。</td>
</tr>
<tr class="odd">
<td>47</td>
<td>os.rename(src, dst)：重命名文件或目录，从 src 到 dst</td>
</tr>
<tr class="even">
<td>48</td>
<td>os.renames(old, new)：递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr class="odd">
<td>49</td>
<td>os.rmdir(path)：删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr class="even">
<td>50</td>
<td>os.stat(path)：获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr class="odd">
<td>51</td>
<td>os.stat_float_times([newvalue])：决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr class="even">
<td>52</td>
<td>os.statvfs(path)：获取指定路径的文件系统统计信息</td>
</tr>
<tr class="odd">
<td>53</td>
<td>os.symlink(src, dst)：创建一个软链接</td>
</tr>
<tr class="even">
<td>54</td>
<td>os.tcgetpgrp(fd)：返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr class="odd">
<td>55</td>
<td>os.tcsetpgrp(fd, pg)：设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr class="even">
<td>56</td>
<td>os.tempnam([dir[, prefix]])：Python3 中已删除。返回唯一的路径名用于创建临时文件。</td>
</tr>
<tr class="odd">
<td>57</td>
<td>os.tmpfile()：Python3 中已删除。返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
</tr>
<tr class="even">
<td>58</td>
<td>os.tmpnam()：Python3 中已删除。为创建一个临时文件返回一个唯一的路径</td>
</tr>
<tr class="odd">
<td>59</td>
<td>os.ttyname(fd)：返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr class="even">
<td>60</td>
<td>os.unlink(path)：删除文件路径</td>
</tr>
<tr class="odd">
<td>61</td>
<td>os.utime(path, times)：返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr class="even">
<td>62</td>
<td>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])：输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
</tr>
<tr class="odd">
<td>63</td>
<td>os.write(fd, str)：写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
</tbody>
</table>
<p>目录操作的函数太多，用到的时候再学习，下面只列出几个简单的案例：</p>
<h3 id="显示某文件夹下的所有文件名">显示某文件夹下的所有文件名</h3>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>&gt;type practice.py</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(<span class="string">'d:/Software'</span>):</div><div class="line">    print(filename)</div><div class="line">    </div><div class="line">C:\Users\<span class="number">20161111</span>&gt;python practice.py</div><div class="line">office_tools</div><div class="line">Professional_tools</div><div class="line">ProgramTool</div><div class="line">SnapGene <span class="number">3.2</span><span class="number">.1</span> Win</div><div class="line">system_enhance</div><div class="line">windows_iso</div><div class="line">谷歌批量翻译</div></pre></td></tr></table></figure>
<h3 id="创建某个目录">创建某个目录</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">"d:/Software/test"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</div><div class="line">C:\Users\<span class="number">20161111</span>&gt;d:</div><div class="line">D:\&gt;cd software</div><div class="line">D:\software&gt;dir</div><div class="line"> Volume <span class="keyword">in</span> drive D <span class="keyword">is</span> 新加卷</div><div class="line"> Volume Serial Number <span class="keyword">is</span> C0C6<span class="number">-2E4</span>F</div><div class="line"></div><div class="line"> Directory of D:\software</div><div class="line"></div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">24</span>  <span class="number">09</span>:<span class="number">33</span>    &lt;DIR&gt;          .</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">24</span>  <span class="number">09</span>:<span class="number">33</span>    &lt;DIR&gt;          ..</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span>  <span class="number">13</span>:<span class="number">46</span>    &lt;DIR&gt;          office_tools</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">21</span>  <span class="number">10</span>:<span class="number">30</span>    &lt;DIR&gt;          Professional_tools</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span>  <span class="number">13</span>:<span class="number">46</span>    &lt;DIR&gt;          ProgramTool</div><div class="line"><span class="number">2017</span>/<span class="number">11</span>/<span class="number">22</span>  <span class="number">20</span>:<span class="number">21</span>    &lt;DIR&gt;          SnapGene <span class="number">3.2</span><span class="number">.1</span> Win</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">13</span>  <span class="number">21</span>:<span class="number">38</span>    &lt;DIR&gt;          system_enhance</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">24</span>  <span class="number">09</span>:<span class="number">33</span>    &lt;DIR&gt;          test <span class="comment"># 刚刚创建的文件夹</span></div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">11</span>  <span class="number">00</span>:<span class="number">48</span>    &lt;DIR&gt;          windows_iso</div><div class="line"><span class="number">2017</span>/<span class="number">11</span>/<span class="number">02</span>  <span class="number">10</span>:<span class="number">52</span>    &lt;DIR&gt;          谷歌批量翻译</div><div class="line">               <span class="number">1</span> File(s)              <span class="number">0</span> bytes</div><div class="line">              <span class="number">10</span> Dir(s)  <span class="number">49</span>,<span class="number">307</span>,<span class="number">074</span>,<span class="number">560</span> bytes free</div></pre></td></tr></table></figure>
<h3 id="删除某个文件夹">删除某个文件夹</h3>
<p>命令<code>rmdir</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">'d:/Software/test'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</div><div class="line"></div><div class="line">D:\software&gt;dir</div><div class="line"> Volume <span class="keyword">in</span> drive D <span class="keyword">is</span> 新加卷</div><div class="line"> Volume Serial Number <span class="keyword">is</span> C0C6<span class="number">-2E4</span>F</div><div class="line"></div><div class="line"> Directory of D:\software</div><div class="line"></div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">25</span>  <span class="number">12</span>:<span class="number">40</span>    &lt;DIR&gt;          .</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">25</span>  <span class="number">12</span>:<span class="number">40</span>    &lt;DIR&gt;          ..</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span>  <span class="number">13</span>:<span class="number">46</span>    &lt;DIR&gt;          office_tools</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">21</span>  <span class="number">10</span>:<span class="number">30</span>    &lt;DIR&gt;          Professional_tools</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span>  <span class="number">13</span>:<span class="number">46</span>    &lt;DIR&gt;          ProgramTool</div><div class="line"><span class="number">2017</span>/<span class="number">11</span>/<span class="number">22</span>  <span class="number">20</span>:<span class="number">21</span>    &lt;DIR&gt;          SnapGene <span class="number">3.2</span><span class="number">.1</span> Win</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">13</span>  <span class="number">21</span>:<span class="number">38</span>    &lt;DIR&gt;          system_enhance</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">11</span>  <span class="number">00</span>:<span class="number">48</span>    &lt;DIR&gt;          windows_iso</div><div class="line"><span class="number">2017</span>/<span class="number">11</span>/<span class="number">02</span>  <span class="number">10</span>:<span class="number">52</span>    &lt;DIR&gt;          谷歌批量翻译</div><div class="line">               <span class="number">1</span> File(s)              <span class="number">0</span> bytes</div><div class="line">               <span class="number">9</span> Dir(s)  <span class="number">48</span>,<span class="number">131</span>,<span class="number">309</span>,<span class="number">568</span> bytes free</div></pre></td></tr></table></figure>
<p>把<code>D:\Software\test</code>这个文件夹删除了 。</p>
<h3 id="对待定文件的操作">对待定文件的操作</h3>
<p>如果要对特定类型的文件进行操作时，需要用fnmatch模块，这个模块的主要作用是文件名称的匹配，并且匹配的模式使用的unix shell风格。字面意思感觉就是filename match ，以下是显示<code>.txt</code>文件的内容和<code>.exe</code>文件的文件名，其中<code>*</code>表示任意字符，而<code>?</code>只表示一个字符，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">81</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共270.2k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
