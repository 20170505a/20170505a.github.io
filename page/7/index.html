<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/7/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/7/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/06/Linux/Linux-shell08-sed与gawk(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/Linux/Linux-shell08-sed与gawk(1)/" itemprop="url">Shell学习笔记（8）——sed与gawk基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T12:12:54+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/正则表达式/" itemprop="url" rel="index">
                    <span itemprop="name">正则表达式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,874
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  41
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="sed与gawk的基本用法">sed与gawk的基本用法</h2>
<p>Linux系统中有两个常用的命令行编辑器，分别为<code>sed</code>和<code>gawk</code>。</p>
<h3 id="sed编辑器">sed编辑器</h3>
<p>sed编辑器被称作流编辑器（streameditor），和普通的交互式文本编辑器有所不同。在交互式文本编辑器中（比如vim），用户可以用键盘命令来交互式地插入、删除或替换数据中的文本。而流编辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。sed编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。可以简单地理解为，流编辑器像一种滤器，数据进入后，会以一定标准的格式出来，sed编辑器会执行下列操作：</p>
<ol style="list-style-type: decimal">
<li>一次从输入中读取一行数据。</li>
<li>根据所提供的编辑器命令匹配数据。</li>
<li>按照命令修改流中的数据。</li>
<li>将新的数据输出到STDOUT。</li>
</ol>
<p>在流编辑器将所有命令与一行数据匹配完毕后，它会读取下一行数据并重复这个过程。在流编辑器处理完流中的所有数据行后，它就会终止。由于命令是按顺序逐行给出的，sed编辑器只需对数据流进行一遍处理就可以完成编辑操作。</p>
<p>sed命令的格式如下为<code>sed options script file</code>，其中sed的选项如下所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-e script</td>
<td>在处理输入时，将script中指定的命令添加到已有的命令中</td>
</tr>
<tr class="even">
<td>-f file</td>
<td>在处理输入时，将file中指定的命令添加到已有的命令中</td>
</tr>
<tr class="odd">
<td>-n</td>
<td>不产生命令输出，使用print命令来完成输出</td>
</tr>
</tbody>
</table>
<p>script参数指定了应用于流数据上的单个命令。如果需要用多个命令，要么使用-e选项在命令行中指定，要么使用-f选项在单独的文件中指定。</p>
<h4 id="在命令行定义编辑器命令">在命令行定义编辑器命令</h4>
<p>默认情况下，sed编辑器会将指定的命令应用到STDIN输入流上。这样你可以直接将数据通过管道输入sed编辑器处理，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This is a test"|sed 's/test/big test/'</div><div class="line">This is a big test</div></pre></td></tr></table></figure>
<p>在这个例子中，sed编辑器使用了s命令。s命令会用斜线间指定的第二个文本字符串（这里是big test）来替换第一个文本字符串（test）模式。在本例中是big test替换了test。在运行这个例子时，结果应该立即就会显示出来，再看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dogs.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed 's/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>sed命令几乎瞬间就执行完并返回数据。在处理每行数据的同时，结果也显示出来了。可以在sed编辑器处理完整个文件之前就开始观察结果。需要注意的是，sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT，也可以发送到某个文件。如果你查看原来的文本文件，它仍然保留着原始数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/dog/cat/' data1.txt &gt; data1b.txt</div><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">biotest@ubuntu:~/sed$ cat data1b.txt</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h4 id="在命令行使用多个编辑器命令">在命令行使用多个编辑器命令</h4>
<p>要在sed命令行上执行多个命令时，只要用-e选项就可以了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -e 's/brown/green/;s/dog/cat/' data1.txt</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>两个命令都作用到文件中的每行数据上。命令之间必须用分号隔开，并且在命令末尾和分号之间不能有空格。如果不想用分号，也可以用bash shell中的次提示符来分隔命令。只要输入第一个单引号标示出sed程序脚本的起始（sed编辑器命令列表），bash会继续提示你输入更多命令，直到输入了标示结束的单引号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -e '</div><div class="line"><span class="meta">&gt;</span> s/brown/green/</div><div class="line"><span class="meta">&gt;</span> s/fox/elephant/</div><div class="line"><span class="meta">&gt;</span> s/dog/cat/' data1.txt</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h4 id="从文件中读取编辑器命令">从文件中读取编辑器命令</h4>
<p>如果有大量要处理的sed命令，那么将它们放进一个单独的文件中，可以在sed命令中用-f选项来指定文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script1.sed</div><div class="line">s/brown/green/</div><div class="line">s/fox/elephant/</div><div class="line">s/dog/cat/</div><div class="line">biotest@ubuntu:~/sed$ sed -f script1.sed data1.txt</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div></pre></td></tr></table></figure>
<p>在这种情况下，不用在每条命令后面放一个分号。sed编辑器知道每行都是一条单独的命令。跟在命令行输入命令一样，sed编辑器会从指定文件中读取命令，并将它们应用到数据文件中的每一行上。</p>
<h3 id="gawk-程序">gawk 程序</h3>
<p>gawk程序是另外的一个处理文本文件的工具，它是Unix原始awk程序的GUN版本，它能提供一个类编程环境来修改和重新组织文件中的数据。 gawk的强大之处在于程序脚本，用户可以写脚本来读取文本行的数据，然后处理并显示数据，创 建任何类型的输出报告。 Ubuntu本身并没有带gawk工具，需要自己安装，即<code>get apt install gawk</code>。在gawk编程语言中，用户可以做下面的事情：</p>
<ol style="list-style-type: decimal">
<li>定义变量来保存数据；</li>
<li>使用算术和字符串操作符来处理数据；</li>
<li>使用结构化编程概念（比如 if-then 语句和循环）来为数据处理增加处理逻辑；</li>
<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。</li>
</ol>
<p>gawk程序通常用来从大文本文件中提取数据元素，并将它们格式化成可读的报告。其中最常用的就是格式化日志文件。在日志文件中找出错误行会很难，gawk程序可以让用户从日志文件中过滤出需要的数据元素，然后将其格式化，使得重要的数据更易于阅读。</p>
<h4 id="gawk的用法">gawk的用法</h4>
<p>gawk的使用格式为<code>gawk options program file</code>，可用选项如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-F fs</td>
<td>指定行中划分数据字段的字段分隔符</td>
</tr>
<tr class="even">
<td>-f file</td>
<td>从指定的文件中读取程序</td>
</tr>
<tr class="odd">
<td>-v var=value</td>
<td>定义gawk程序中的一个变量及其默认值</td>
</tr>
<tr class="even">
<td>-mf N</td>
<td>指定要处理的数据文件中的最大字段数</td>
</tr>
<tr class="odd">
<td>-mr N</td>
<td>指定数据文件中的最大数据行数</td>
</tr>
<tr class="even">
<td>-W keyword</td>
<td>指定gawk的兼容模式或警告等级</td>
</tr>
</tbody>
</table>
<h4 id="从命令行读取程序脚本">从命令行读取程序脚本</h4>
<p>gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号（{}）中。如果你错误地使用了圆括号来包含gawk脚本，就会得到一条类似于下面的错误提示，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '(print "Hello World!"&#125;'</div><div class="line">gawk: cmd. line:1: (print "Hello World!"&#125;</div><div class="line">gawk: cmd. line:1:                     ^ syntax error</div></pre></td></tr></table></figure>
<p>由于gawk命令行假定脚本是单个文本字符串，必须将脚本放到单引号中。下面的例子在命令行上指定了一个简单的gawk程序脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;print "Hello World!"&#125;'</div><div class="line">Hello World!</div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>这个程序脚本定义了一个命令：print命令。这个命令会将文本打印到STDOUT。如果尝试运行这个命令，什么都不会发生。原因在于没有在命令行上指定文件名，所以gawk程序会从STDIN接收数据。在运行这个程序时，它会一直等待从STDIN输入的文本。如果输入一行文本并按下回车键，gawk会对这行文本运行一遍程序脚本。跟sed编辑器一样，gawk程序会针对数据流中的每行文本执行程序脚本。由于程序脚本被设为显示一行固定的文本字符串，因此不管在数据流中输入什么文本，都会得到同样的文本输出。</p>
<p>要终止这个gawk程序，你必须表明数据流已经结束了。bash shell提供了一个组合键来生成EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk程序并返回到命令行界面提示符下。</p>
<h4 id="使用数据字段变量">使用数据字段变量</h4>
<p>gawk的主要特性之一是其处理文本文件中数据的能力。它会自动给一行中的每个数据元素分配一个变量。默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段：</p>
<ol style="list-style-type: decimal">
<li><code>$0</code> 代表整个文本行；</li>
<li><code>$1</code> 代表文本行中的第1个数据字段；</li>
<li><code>$2</code> 代表文本行中的第2个数据字段；</li>
<li><code>$n</code> 代表文本行中的第n个数据字段。</li>
</ol>
<p>在文本行中，每个数据字段都是通过字段分隔符划分的。gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符）。在下面的例子中，gawk程序读取文本文件，只显示第1个数据字段的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data2.txt</div><div class="line">One line of test text.</div><div class="line">Two lines of test text.</div><div class="line">Three lines of test text.</div><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;print $1&#125;' data2.txt</div><div class="line">One</div><div class="line">Two</div><div class="line">Three</div></pre></td></tr></table></figure>
<p>该程序用$1字段变量来仅显示每行文本的第1个数据字段。如果你要读取采用了其他字段分隔符的文件，可以用-F选项指定，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk -F: '&#123;print $1&#125;' /etc/passwd</div><div class="line">root</div><div class="line">daemon</div><div class="line">bin</div><div class="line">sys</div><div class="line">sync</div><div class="line">games</div><div class="line">man</div><div class="line">lp</div><div class="line">mail</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这个简短的程序显示了系统中密码文件的第1个数据字段。由于/<code>etc/passwd</code>文件用冒号来分隔数字字段，因而如果要划分开每个数据元素，则必须在gawk选项中将冒号指定为字段分隔符，其中<code>-F:</code>就是指定冒号为分隔符。</p>
<h4 id="在程序脚本中使用多个命令">在程序脚本中使用多个命令</h4>
<p>gawk编程语言允许多条命令组合成一个正常的程序。要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "My name is Zhang" |gawk '&#123;$4="Li";print $0&#125;'</div><div class="line">My name is Li</div></pre></td></tr></table></figure>
<p>第一条命令会给字段变量<code>$4</code>赋值。第二条命令会打印整个数据字段。注意，gawk程序在输出中已经将原文本中的第四个数据字段替换成了新值。也可以用次提示符一次一行地输入程序脚本命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk '&#123;</div><div class="line"><span class="meta">&gt;</span> $4="Li"</div><div class="line"><span class="meta">&gt;</span> print $0&#125;'</div><div class="line">My name is Zhang</div><div class="line">My name is Li</div></pre></td></tr></table></figure>
<p>在用了表示起始的单引号后，bashs hell会使用次提示符来提示你输入更多数据。可以每次在每行加一条命令，直到输入了结尾的单引号。因为没有在命令行中指定文件名，gawk程序会从STDIN中获得数据。当运行这个程序的时候，它会等着读取来自STDIN的文本。要退出程序，只需按下Ctrl+D组合键来表明数据结束。</p>
<h4 id="从文件中读取程序">从文件中读取程序</h4>
<p>gawk编辑器允许将程序存储到文件中，然后再在命令行中引用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script2.gawk</div><div class="line">&#123;print $1 "'s home directory is " $6&#125;</div><div class="line">biotest@ubuntu:~/sed$ gawk -F: -f script2.gawk /etc/passwd</div><div class="line">root's home directory is /root</div><div class="line">daemon's home directory is /usr/sbin</div><div class="line">bin's home directory is /bin</div><div class="line">sys's home directory is /dev</div><div class="line">sync's home directory is /bin</div><div class="line">......</div></pre></td></tr></table></figure>
<p>在这个案例中，script2.gawk程序脚本会再次使用print命令打印/etc/passwd文件的主目录数据字段（字段变量<code>$6），以及userid数据字段（字段变量</code>$1`）。可以在程序文件中指定多条命令。要这么做的话，只要一条命令放一行即可，不需要用分号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script3.gawk </div><div class="line">&#123;</div><div class="line">text = "'s home directory is " # 变量未使用美元符号，需要注意</div><div class="line">print $1 text $6</div><div class="line">&#125;</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ gawk -F: -f script3.gawk /etc/passwd</div><div class="line">root's home directory is /root</div><div class="line">daemon's home directory is /usr/sbin</div><div class="line">bin's home directory is /bin</div><div class="line">sys's home directory is /dev</div><div class="line">sync's home directory is /bin</div></pre></td></tr></table></figure>
<p>script3.gawk程序脚本定义了一个变量来保存print命令中用到的文本字符串。注意，gawk程序在引用变量值时并未像shell脚本一样使用美元符。</p>
<h4 id="在处理数据前运行脚本">在处理数据前运行脚本</h4>
<p>gawk可以指定程序脚本何时运行。默认情况下，gawk会从输入中读取一行文本，然后针对该行的数据执行程序脚本。有时可能需要在处理数据前运行脚本，比如为报告创建标题。BEGIN关键字就是用来做这个的。它会强制gawk在读取数据前执行BEGIN关键字后指定的程序脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;print "Hello World!"&#125;'</div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<p>这次print命令会在读取数据前显示文本。但在它显示了文本后，它会快速退出，不等待任何数据。如果想使用正常的程序脚本中处理数据，必须用另一个脚本区域来定义程序，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;pirnt "The data3 File Contents:"&#125;</div><div class="line"><span class="meta">&gt;</span> &#123;print $0&#125;' data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div></pre></td></tr></table></figure>
<p>在gawk执行了BEGIN脚本后，它会用第二段脚本来处理文件数据。这么做时要小心，两段脚本仍然被认为是gawk命令行中的一个文本字符串。你需要相应地加上单引号。</p>
<h4 id="在处理数据后运行脚本">在处理数据后运行脚本</h4>
<p>与BEGIN关键字类似，END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ gawk 'BEGIN &#123;pirnt "The data3 File Contents:"&#125;</div><div class="line"><span class="meta">&gt;</span> &#123;print $0&#125;</div><div class="line"><span class="meta">&gt;</span> END &#123;print "End of FIle"&#125;' data3.txt</div><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div><div class="line">End of FIle</div></pre></td></tr></table></figure>
<p>当gawk程序打印完文件内容后，它会执行END脚本中的命令。这是在处理完所有正常数据后给报告添加页脚的最佳方法。可以将所有这些内容放到一起组成一个脚本文件，用它从一个简单的数据文件中创建一份完整的报告，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat script4.gawk </div><div class="line">BEGIN &#123;</div><div class="line">print "The latest list of users and shells"</div><div class="line">print " UserID \t Shell"</div><div class="line">print "-------- \t --------"</div><div class="line">FS=":"</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">print $1 "        \t " $7</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">print "This concludes the listing"</div><div class="line">&#125;</div><div class="line">biotest@ubuntu:~/sed$ gawk -f script4.gawk /etc/passwd</div><div class="line">The latest list of users and shells</div><div class="line"> UserID 	 Shell</div><div class="line">-------- 	 --------</div><div class="line">root        	 /bin/bash</div><div class="line">daemon        	 /usr/sbin/nologin</div><div class="line">bin        	 /usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>这个脚本用BEGIN脚本来为报告创建标题。它还定义了一个叫作FS的特殊变量。这是定义字段分隔符的另一种方法。这样就不用依靠脚本用户在命令行选项中定义字段分隔符了。BEGIN脚本创建了标题，程序脚本处理特定数据文件（<code>/etc/passwd）</code>中的信息，END脚本生成页脚。</p>
<h2 id="sed-编辑器基础">sed 编辑器基础</h2>
<h3 id="更多的替换选项">更多的替换选项</h3>
<p>s命令（substitute）用来在行中替换文本。这个命令还有另外一些选项。</p>
<h4 id="替换标记">替换标记</h4>
<p>先看一个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data4.txt </div><div class="line">This is a test of the test script.</div><div class="line">This is the second test of the test script.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/' data4.txt </div><div class="line">This is a trial of the test script.</div><div class="line">This is the second trial of the test script.</div></pre></td></tr></table></figure>
<p>替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记（substitution flag）。替换标记会在替换命令字符串之后设置，格式为<code>s/pattern/replacement/flags</code>，有4种可用的替换标记：</p>
<ol style="list-style-type: decimal">
<li>数字，表明新文本将替换第几处模式匹配的地方；</li>
<li>g ，表明新文本将会替换所有匹配的文本；</li>
<li>p ，表明原先行的内容要打印出来；</li>
<li>w file ，将替换的结果写到文件中。</li>
</ol>
<h5 id="数字替换标记">数字替换标记</h5>
<p>在第一类替换中，可以指定sed编辑器用新文本替换第几处模式匹配的地方，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/2' data4.txt </div><div class="line">This is a test of the trial script.</div><div class="line">This is the second test of the trial script.</div></pre></td></tr></table></figure>
<p>这个脚本运行的结果是：sed编辑器只替换每行中第2次出现的匹配模式。</p>
<h5 id="g替换标记">g替换标记</h5>
<p>g替换标记使你能替换文本中匹配模式所匹配的每处地方，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/g' data4.txt</div><div class="line">This is a trial of the trial script.</div><div class="line">This is the second trial of the trial script.</div></pre></td></tr></table></figure>
<p>如结果所示，使用了g替换标记后，文本中所有的地方都被替换了。</p>
<h5 id="p替换标记">p替换标记</h5>
<p>p替换标记会打印与替换命令中指定的模式匹配的行。这通常会和sed的-n选项一起使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test5.txt</div><div class="line">This is a test line.</div><div class="line">This is a different line.</div><div class="line">biotest@ubuntu:~/sed$ sed -n 's/test/trial/p' test5.txt</div><div class="line">This is a trial line.</div></pre></td></tr></table></figure>
<p>-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是只输出被替换命令修改过的行，第二行并没有被替换，也就不输出了。</p>
<h5 id="w替换标记">w替换标记</h5>
<p>w 替换标记会产生同样的输出，不过会将输出保存到指定文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/test/trial/w test.txt' test5.txt </div><div class="line">This is a trial line.</div><div class="line">This is a different line.</div><div class="line">biotest@ubuntu:~/sed$ cat test.txt</div><div class="line">This is a trial line.</div></pre></td></tr></table></figure>
<p>sed编辑器的正常输出是在STDOUT中，而只有那些包含匹配模式的行才会保存在指定的输出文件中。</p>
<h4 id="替换字符">替换字符</h4>
<p>有时会在文本字符串中遇到一些不太方便在替换模式中使用的字符。Linux中一个常见的例子就是正斜线（/）。替换文件中的路径名会比较麻烦。比如想用C shell替换/etc/passwd文件中的bash shell，必须这么做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/csh</div><div class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</div><div class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</div><div class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>由于正斜线通常用作字符串分隔符，因而如果它出现在了模式文本中的话，必须用反斜线来转义。这通常会带来一些困惑和错误。 要解决这个问题，sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed 's!/bin/bash!/bin/csh!' /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/csh</div><div class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</div><div class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</div></pre></td></tr></table></figure>
<p>在这个例子中，感叹号被用作字符串分隔符，这样路径名就更容易阅读和理解了。</p>
<h4 id="使用地址">使用地址</h4>
<p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（lineaddressing）。在sed编辑器中有两种形式的行寻址：第一，以数字形式表示区间；第二，用文本模式来过滤出行。两种形式都使用相同的格式来指定地址：</p>
<p><code>[address] command</code>或者是将特定地址的多个命令分组，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">address &#123;</div><div class="line">    command1</div><div class="line">    command2</div><div class="line">    command3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sed编辑器会将指定的每条命令作用到匹配指定地址的行上。本节将会演示如何在sed编辑器脚本中使用两种寻址方法。</p>
<h5 id="第一数字方式的行寻址">第一，数字方式的行寻址。</h5>
<p>当使用数字方式的行寻址时，可以用行在文本流中的行位置来引用。sed编辑器会将文本流中的第一行编号为1，然后继续按顺序为接下来的行分配行号。在命令中指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围内的行。这里有个sed命令作用到指定行号的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>sed编辑器只修改地址指定的第二行的文本。这里有另一个例子，这次使用了行地址区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,3s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>如果需要将命令作用到文本从某行开始的所有行，可以使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,$s/dog/cat/' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div></pre></td></tr></table></figure>
<h5 id="第二使用文本模式过滤器">第二，使用文本模式过滤器</h5>
<p>另一种限制命令作用到哪些行上的方法会稍稍复杂一些。sed编辑器允许指定文本模式来过滤出命令要作用的行。格式为<code>/pattern/command，</code>必须用正斜线将要指定的pattern封起来。sed编辑器会将该命令作用到包含指定文本模式的行上。举个例子，如果你想只修改用户test001的默认shell，可以使用sed命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ grep biotest /etc/passwd</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/csh</div></pre></td></tr></table></figure>
<p>该命令只作用到匹配文本模式的行上。虽然使用固定文本模式能帮你过滤出特定的值，就跟上面这个用户名的例子一样，但其作用难免有限。sed编辑器在文本模式中支持正则表达式（regular expression）。</p>
<h5 id="第三命令组合">第三，命令组合</h5>
<p>如果需要在单行上执行多条命令，可以用花括号将多条命令组合在一起，sed编辑器会处理地址行处列出的每条命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed '2&#123;</div><div class="line"><span class="meta">&gt;</span> s/fox/elephant/</div><div class="line"><span class="meta">&gt;</span> s/dog/cat/</div><div class="line"><span class="meta">&gt;</span> &#125;' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown elephant jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>两条命令都会作用到该地址上，也可以在一组命令前指定一个地址区间，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '3,$&#123;</div><div class="line"><span class="meta">&gt;</span> s/brown/green/</div><div class="line"><span class="meta">&gt;</span> s/lazy/active/</div><div class="line"><span class="meta">&gt;</span> &#125;' data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick green fox jumps over the active dog.</div><div class="line">The quick green fox jumps over the active dog.</div></pre></td></tr></table></figure>
<h3 id="删除行">删除行</h3>
<p>在sed中，删除使用的是<code>d</code>参数，使用此命令需要谨慎，如果用户忘记加入寻址模式的话，流中所有的文都会被删除，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt # 原始文本</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '3d' test6.txt # 删除第3行</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '2,3d' test6.txt # 删除第2，3行</div><div class="line">This is line number 1.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '3,$d' test6.txt # 删除第3行及3行以下</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">biotest@ubuntu:~/sed$ sed '/number 1/d' test6.txt # 删除第1行</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/3/d' test6.txt # 删除1到3行</div><div class="line">This is line number 4.</div><div class="line"><span class="meta">#</span> 指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed编辑器会删除两个指定行之间的所有行</div></pre></td></tr></table></figure>
<p>只要sed编辑器在数据流中匹配到了开始模式，删除功能就会打开。这可能会导致意外的结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test7.txt </div><div class="line">This is line number 1.</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is line number 1 again.</div><div class="line">THis is text you want to keep.</div><div class="line">This is the last line in the file.</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/3/d' test7.txt</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>在这段代码中，第二个出现数字“1”的行再次触发了删除命令，因为没有找到停止模式，所以就将数据流中的剩余行全部删除了。如果你指定了一个从未在文本中出现的停止模式，显然会出现另外一个问题，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/1/,/5/d' test7.txt</div><div class="line">biotest@ubuntu:~/sed$</div></pre></td></tr></table></figure>
<p>在这段代码中，因为删除功能在匹配到第一个模式的时候打开了，但一直没匹配到结束模式，所以整个数据流都被删掉了。</p>
<h3 id="插入和附加文本">插入和附加文本</h3>
<p>sed编辑器可以向数据流插入和附加文本行。它有两种操作：第一，插入（insert）：命令（i）会在指定行前增加一个新行；第二，追加（append）命令（a）会在指定行后增加一个新行。这两条命令在使用格式上有些特殊，它们不能在单个命令行上使用。用户必须指定是要将行插入还是附加到另一行。格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed '[address] command\</div><div class="line">new line'</div></pre></td></tr></table></figure>
<p>其中，<code>new line</code>中的文本将会出现在sed编辑器输出中指定的位置。记住，当使用插入命令时，文本会出现在数据流文本的前面，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "Test Line2"|sed 'i\Test Line 1' # 在第2行之前插入文本</div><div class="line">Test Line 1</div><div class="line">Test Line2</div><div class="line"></div><div class="line">biotest@ubuntu:~/sed$ echo "Test Line2"|sed 'a\Test Line 1' # 在第2行之后插入文本 </div><div class="line">Test Line2</div><div class="line">Test Line 1</div></pre></td></tr></table></figure>
<p>在命令行界面提示符上使用sed编辑器时，用户会看到次提示符来提醒输入新的行数据。用户必须在该行完成sed编辑器命令。一旦你输入了结尾的单引号，bash shell就会执行该命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "Test Line 2"|sed 'i\</div><div class="line"><span class="meta">&gt;</span> Test Line 1'</div><div class="line">Test Line 1</div><div class="line">Test Line 2</div></pre></td></tr></table></figure>
<p>前面所述的方法只能给数据流中的文本前面或后面添加文本，但有时候还需要向一行的前后添加文本，要向数据流行内部插入或附加数据，必须用寻址来告诉sed编辑器想让数据出现在什么位置。可以在用这些命令时只指定一个行地址。可以匹配一个数字行号或文本模式，但不能用地址区间（因为用户只能将文本插入或附加到单个行的前面或后面，而不是行区间的前面或后面），在下面的例子中，用户将一个新行插入到数据流第三行前。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt </div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line"></div><div class="line"><span class="meta">#</span> 将一个新行插入到数据流第三行前</div><div class="line">biotest@ubuntu:~/sed$ sed '3i\ </div><div class="line"><span class="meta">&gt;</span> This is an inserted line.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is an inserted line.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line"></div><div class="line"><span class="meta">#</span>将一个新行附加到数据流中第三行后</div><div class="line">biotest@ubuntu:~/sed$ sed '3a\ </div><div class="line"><span class="meta">&gt;</span> This is an appended line.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is an appended line.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>如果有一个多行数据流，需要将新行追加到数据流的末决，只要用代表数据最后一行的美元符号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '$a\</div><div class="line"><span class="meta">&gt;</span> This is a new line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is a new line of text.</div></pre></td></tr></table></figure>
<p>同样的方法也适用于要在数据流起始位置增加一个新行。只要在第一行之前插入新行即可。要插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后一行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '1i\</div><div class="line"><span class="meta">&gt;</span> This ia one line of new text.\</div><div class="line"><span class="meta">&gt;</span> This is another line of new text.' test6.txt</div><div class="line">This ia one line of new text.</div><div class="line">This is another line of new text.</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<h3 id="修改行">修改行</h3>
<p>sed可以对文本进行修改，使用的参数是<code>c</code>，意思为修改（change）。这个参数允许修改数据流中整行文本的内容。它跟插入和附加命令的工作机制一样，必须在sed命令中单独指定新行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '3c\</div><div class="line"><span class="meta">&gt;</span> This is a change line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is a change line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>在这个例子中，sed编辑器会修改第三行中的文本。也可以用文本模式来寻址，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/number 3/c\</div><div class="line"><span class="meta">&gt;</span> This is a changed line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is a changed line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>文本模式修改命令会修改它匹配的数据流中的任意文本行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test8.txt</div><div class="line">This is line number 1. </div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is line number 1 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file. </div><div class="line">biotest@ubuntu:~/sed$ sed '/number 1/c\</div><div class="line"><span class="meta">&gt;</span> This is a changed line of text.' test8.txt</div><div class="line">This is a changed line of text.</div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is a changed line of text.</div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file.</div></pre></td></tr></table></figure>
<p>在修改命令中使用地址区间，结果就会出问题，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '2,3c\</div><div class="line"><span class="meta">&gt;</span> This is a new line of text.' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is a new line of text.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>sed编辑器会用这一行文本来替换数据流中的两行文本，而不是逐一修改这两行文本。</p>
<h3 id="转换命令">转换命令</h3>
<p>sed中还有一个转换命令，参数是<code>y</code>，转换（ transform ）可以处理单个字符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address]y/inchars/outchars/</div></pre></td></tr></table></figure>
<p>转换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转换为outchars中的第一个字符，第二个字符会被转换成outchars中的第二个字符。这个映射过程会一直持续到处理完指定字符。如果inchars和outchars的长度不同，则sed编辑器会产生一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test8.txt</div><div class="line">This is line number 1. </div><div class="line">This is line number 2. </div><div class="line">This is line number 3. </div><div class="line">This is line number 4. </div><div class="line">This is line number 1 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file. </div><div class="line">biotest@ubuntu:~/sed$ sed 'y/123/789/' test8.txt</div><div class="line">This is line number 7. </div><div class="line">This is line number 8. </div><div class="line">This is line number 9. </div><div class="line">This is line number 4. </div><div class="line">This is line number 7 again. </div><div class="line">This is yet another line. </div><div class="line">This is the last line in the file.</div></pre></td></tr></table></figure>
<p>在这个案例中，<code>inchars</code>械中指定的字符的每个实例都会被替换成<code>outchars</code>模式中相同位置的那个字符，转换命令是一个全局命令，它会在文本行中找到所有指定字符自动进行转换，而不会考虑它们出现的位置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This 1 is a test of 1 try."|sed 'y/123/456/'</div><div class="line">This 4 is a test of 4 try.</div></pre></td></tr></table></figure>
<p>sed编辑器转换了在文本行中匹配到的字符1的两个实例。你无法限定只转换在特定地方出现的字符。</p>
<h3 id="回顾打印">回顾打印</h3>
<p>有3个命令可以打印文本行，分别为：</p>
<ol style="list-style-type: decimal">
<li>p命令用来打印文本行；</li>
<li>等号（=）用于打印行号；</li>
<li>l（小写的L）用于列出行。</li>
</ol>
<h4 id="打印行">打印行</h4>
<p>这里的<code>p</code>参业与替换中的<code>p</code>参数类似，它可以打印sed编译器输出中的一行，如果只使用这个命令，就是显示这一行命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ echo "This is a test"|sed 'p'</div><div class="line">This is a test</div><div class="line">This is a test</div></pre></td></tr></table></figure>
<p><code>p</code>参数就是打印已有的数据文本，打印命令常用的用法就是打印包含匹配文本模式的行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ sed -n '/number 3/p' test6.txt</div><div class="line">This is line number 3.</div></pre></td></tr></table></figure>
<p>在命令行上用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。也可以用它来快速打印数据流中的某些行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '2,3p' test6.txt</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div></pre></td></tr></table></figure>
<p>如果需要在修改之前查看行，也可以使用打印命令，比如与替换或修改命令一起使用。可以创建一个脚本在修改行之前显示该行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '/3/&#123;</div><div class="line"><span class="meta">&gt;</span> p</div><div class="line"><span class="meta">&gt;</span> s/line/test/p</div><div class="line"><span class="meta">&gt;</span> &#125;' test6.txt</div><div class="line">This is line number 3.</div><div class="line">This is test number 3.</div></pre></td></tr></table></figure>
<p>sed编辑器命令会查找包含数字3的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。</p>
<h4 id="打印行号">打印行号</h4>
<p>等号命令会打印行在数据流中的当前行号。行号由数据流中的换行符决定。每次数据流中出现一个换行符，sed编辑器会认为一行文本结束了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">biotest@ubuntu:~/sed$ sed '=' data1.txt</div><div class="line">1</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">2</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">3</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">4</div><div class="line">The quick brown fox jumps over the lazy dog.</div></pre></td></tr></table></figure>
<p>sed编辑器在实际的文本行出现前打印了行号。如果你要在数据流中查找特定文本模式的话，等号命令用起来非常方便，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed -n '/number 4/&#123;</div><div class="line"><span class="meta">&gt;</span> =</div><div class="line"><span class="meta">&gt;</span> p</div><div class="line"><span class="meta">&gt;</span> &#125;' test6.txt</div><div class="line">4</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>利用 -n 选项，你就能让sed编辑器只显示包含匹配文本模式的行的行号和文本。</p>
<h4 id="列出行">列出行</h4>
<p>列出（list）命令（l）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如，来代表制表符。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data9.txt </div><div class="line">This	line	contains	tabs.</div><div class="line">biotest@ubuntu:~/sed$ sed -n 'l' data9.txt</div><div class="line">This\tline\tcontains\ttabs.$</div></pre></td></tr></table></figure>
<p>制表符的位置使用。行尾的美元符表示换行符。</p>
<h3 id="使用sed处理文件">使用sed处理文件</h3>
<h4 id="写入文件">写入文件</h4>
<p><code>w</code>选项用于向文件写入行，该选项的命令格式为<code>[address] w filename</code>，其中<code>filename</code>可以使用相对路径或绝对路径，并且用户要有文件的写权限，地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</p>
<p>下面的例子是将数据流中的前两行打印到一个文本文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '1,2w test.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ cat test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">biotest@ubuntu:~/sed$ cat test.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div></pre></td></tr></table></figure>
<p>如果不想让行显示到STDOUT上，可以用sed命令的-n选项。如果要根据一些公用的文本值从主文件中创建一份数据文件，比如下面的邮件列表中的，那么w命令会非常好用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data11.txt</div><div class="line">Zhang San</div><div class="line">Li Si</div><div class="line">Wang Er</div><div class="line">Liu Qi</div><div class="line">biotest@ubuntu:~/sed$ sed -n '/Zhang/w Zhang.txt' data11.txt</div><div class="line">biotest@ubuntu:~/sed$ cat Zhang.txt </div><div class="line">Zhang San</div></pre></td></tr></table></figure>
<p>sed编辑器会只将包含文本模式的数据写入目标文件。</p>
<h4 id="从文件读取数据">从文件读取数据</h4>
<p>取（read）命令（r）允许用户将一个独立文件中的数据插入到数据流中。读取命令的格式为<code>[address]r filename</code>，其中filename参数指定了数据文件的绝对路径或相对路径，在读取命令中使用地址区间，只能指定单独一个行号或文本模式地址。sed编辑器会将文件中的文本插入到指定地址后，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat data12.txt</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">biotest@ubuntu:~/sed$ sed '3r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>使用文本模式进行读取，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/number 2/r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div></pre></td></tr></table></figure>
<p>如果需要在数据流的末尾添加文件，需要使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '$r data12.txt' test6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is an added line.</div><div class="line">This is the second added line.</div></pre></td></tr></table></figure>
<p>读取命令的另一个很有用的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。举例来说，假定你有一份套用信件保存在文本文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ cat notice.std </div><div class="line">Would the following people:</div><div class="line">LIST</div><div class="line">please report to the ship's captain.</div></pre></td></tr></table></figure>
<p>套用信件将通用占位文本 LIST 放在人物名单的位置。要在占位文本后插入名单，只需读取 命令就行了。但这样的话，占位文本仍然会留在输出中。要删除占位文本的话，你可以用删除命 令。结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/sed$ sed '/LIST/&#123;</div><div class="line"><span class="meta">&gt;</span> r data11.txt</div><div class="line"><span class="meta">&gt;</span> d</div><div class="line"><span class="meta">&gt;</span> &#125;' notice.std</div><div class="line">Would the following people:</div><div class="line">Zhang San</div><div class="line">Li Si</div><div class="line">Wang Er</div><div class="line">Liu Qi</div><div class="line">please report to the ship's captain.</div></pre></td></tr></table></figure>
<p>现在占位文本已经被替换成了数据文件中的名单。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/06/Experiment/病毒包装笔记(7)-第三代慢病毒包装笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/Experiment/病毒包装笔记(7)-第三代慢病毒包装笔记/" itemprop="url">病毒包装笔记(7)-第三代慢病毒</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T12:02:00+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物实验笔记/" itemprop="url" rel="index">
                    <span itemprop="name">生物实验笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,283
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>最近在国内某公司买了一个慢病毒质粒，公司的人说可以用来包慢病毒，也可以用来瞬转。但是我发现这个质粒上没有<code>3'UTR</code>和<code>5' UTR</code>，我怀疑不能用来包慢病毒，公司说可以，但要用他们的试剂盒。我问了一下师兄，师兄说，这种质粒可能是第三代慢病毒包装质粒，试剂盒里的主要试剂就是包含三种包装质粒的混合液。我们实验室用的是第二代病毒包装系统，两个包装质粒，一个目的质粒，因此我对这种质粒包装系统并不清楚。现在查了一些三代包装系统的资料，现在总结如下。</p>
<h2 id="慢病毒的成分">慢病毒的成分</h2>
<p>现在的慢病毒包装系统通常包括几个质粒，这几个质粒上分别含有慢病毒复制的成分，这样做的目的就是为了增加安全性，毕竟如果只用一个成分的话，危险系数很高，人一旦接触这种病毒就有可能遇到危险。而把这几个成分分散在几个质粒中，很难在体外形成危险的病毒颗粒。第二代慢病毒包装系统含有3个质粒，第3代慢病毒包装系统含有4个质粒。这两代病毒包装系统都含有以下相同的成分：</p>
<p>第一，编码目的蛋白或转录目的基因的转移质粒。其实就是你自己的目的质粒，也就是通常需要自己做载体的质粒。目的基因的两侧都含有长末端重复序列（LTR，long terminal repeat），LTR的作用就是辅助目的基因插入到宿主细胞的基因组。许多慢病毒质粒都是基于HIV-1病毒改造的。为了安全目的，这些目的质粒的复能能力并不完全，它们的<code>3'LTR</code>有所删减，这样病毒插入到基因组后会自我失活（self-inactivating）（SIN）。</p>
<p>第二，包装质粒，毒包装的结构蛋白编码质粒。</p>
<p>第三，包膜质粒，编码蛋白质外壳。</p>
<p>第二代慢病毒利用病毒的LTR启动子用于基因的表达，第三代慢病毒利用一个杂合的LTR启动子进行基因表达。</p>
<h2 id="第二代慢病毒">第二代慢病毒</h2>
<p>下图是第二代慢病毒系统：</p>
<div class="figure">
<img src="https://media.addgene.org/data/easy-thumbnails/filer_public/cms/filer_public/56/36/563610a3-a100-4f87-9d10-309cf106dfe7/geneticorganizationoflentiviruses_1.jpg__450x255_q85_subsampling-2_upscale.png">

</div>
<p>这个系统含有3个质粒，第1个质粒：包装质粒，它编码Gag，PoI，Rev与Tat基因。第2个质粒：包膜质粒，含有VSV-G，编码蛋白Env。第3个质粒：目的质粒，含有病毒的LTRs和psi包装信号（图片未画出），除非有内部启动子，否则这个目的质粒的目的基因是由<code>5'LTR</code>驱动的，它是一个弱启动子，需要Tat元件 的来激活它。所有的第2代慢病毒目的质粒必须要用第2代慢病毒包装系统，因此它的LTR是Tat依赖性的。</p>
<h2 id="第三代慢病毒">第三代慢病毒</h2>
<p>第3代慢病毒如下所示：</p>
<div class="figure">
<img src="https://media.addgene.org/data/easy-thumbnails/filer_public/cms/filer_public/7f/54/7f549fd8-1c37-4448-a2d3-227e5c24c550/3rdgenerationplasmids.png__350x194_q85_subsampling-2_upscale.png">

</div>
<p>设计第3代病毒的目的主要还是提高安全性。在第3代病毒中，将第2代病毒的包装质粒分成了2个质粒，一个编码Rev，另外一个编码Gag和PoI。虽然第3代病毒更加安全了，但是它的效率却降低了。除此之外，第3代病毒删除了Tat元件，并且在目的质粒中引入了一个嵌合了<code>5'LTR</code>的异源启动子。这种目的质粒基因的启动子并不依赖于Tat元件。第3代病毒的目的质粒可以使用第2代或第3代的包装质粒，也就是说第3代慢病毒的目的质粒兼容第2代的包装系统。</p>
<h2 id="第二代慢病毒与第第三代病毒的区别">第二代慢病毒与第第三代病毒的区别</h2>
<table>
<colgroup>
<col width="10%">
<col width="41%">
<col width="47%">
</colgroup>
<thead>
<tr class="header">
<th>特点</th>
<th>第2代慢病毒</th>
<th>第3代慢病毒</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目的质粒</td>
<td>只能被含有TAT的2代病毒包装</td>
<td>可以被第2代和第3代病毒包装系统包装</td>
</tr>
<tr class="even">
<td>包装质粒</td>
<td>一个质粒上含有Gag，PoI，Rev，Tat（也就是psPAX2）</td>
<td>2个质粒，一个编码Gag和PoI；另外一个质粒编码Rev（也就是pMDLg/pRRE和pRSV-Rev）</td>
</tr>
<tr class="odd">
<td>包膜质粒</td>
<td>可替换，通常用于编码VSV-G（pMD2G）</td>
<td>可替换，通常用于编码VSV-G（pMD2G）</td>
</tr>
<tr class="even">
<td>案例性</td>
<td>安全。复能能力不完全，使用编码各种HIV基因的3个质粒。</td>
<td>更安全，复制能力不完全，有自身失活性（SIN）。使用4个质粒来替换2代慢病毒的3个质粒，删除了Tat元件。</td>
</tr>
<tr class="odd">
<td>LTR病毒启动子</td>
<td>广泛型</td>
<td>杂合：删除了部分的5’LTR，与另外一个异源增强子/启动子融合，例如CMV或RSV。</td>
</tr>
</tbody>
</table>
<h2 id="第三代病毒包装系统的过程">第三代病毒包装系统的过程</h2>
<p>其实买的目的质粒虽然是三代病毒包装系统的，但是完全可以用二代慢病毒包装系统来替代，用PMD2G和psPAX2，外加目的质粒进行转染。</p>
<h2 id="参考资料">参考资料</h2>
<p>https://www.addgene.org/viral-vectors/lentivirus/lenti-guide/</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/05/Linux/Linux-shell07-构建函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/Linux/Linux-shell07-构建函数/" itemprop="url">Shell学习笔记（7）——构建函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-05T12:12:54+08:00">
                2018-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,347
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本的脚本函数">基本的脚本函数</h2>
<p>函数是一个脚本代码块，用户可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。</p>
<h3 id="创建函数">创建函数</h3>
<p>创建函数有2种方式：第一种，使用关键字<code>function</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function name&#123;</div><div class="line">    commands</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。</p>
<p>第二种构建函数的格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name() &#123; </div><div class="line">    commands </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数名后的空括号表明正在定义的是一个函数。这种格式的命名规则和之前定义shell脚本函数的格式一样。</p>
<h3 id="使用函数">使用函数</h3>
<p>要在脚本中使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a function in a script</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">     echo "This is an example of a function"</div><div class="line">&#125;</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    func1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">echo "This is the end of the loop"</div><div class="line">func1</div><div class="line">echo "Now this is the end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test1.sh</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is the end of the loop</div><div class="line">This is an example of a function</div><div class="line">Now this is the end of the script</div></pre></td></tr></table></figure>
<p>每次引用函数名func1时，bash shell会找到func1函数的定义并执行你在那里定义的命令。如果在函数被定义前使用函数，会收到一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a function located in the middle of a script</div><div class="line"></div><div class="line">count=1</div><div class="line">echo "This line comes before the function definition"</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is an example of a function"</div><div class="line">&#125;</div><div class="line"></div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    func1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "This is the end of the loop"</div><div class="line">func2</div><div class="line">echo "Now this is the end of the scripts"</div><div class="line"></div><div class="line">function func2 &#123;</div><div class="line">   echo "This is an example of a function"</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test2.sh</div><div class="line">This line comes before the function definition</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is an example of a function</div><div class="line">This is the end of the loop</div><div class="line">test2.sh: line 17: func2: command not found</div><div class="line">Now this is the end of the scripts</div></pre></td></tr></table></figure>
<p>第一个函数func1的定义出现在脚本中的几条语句之后，运行起来没问题。当func1函数 在脚本中被使用时，shell知道去哪里找它。 脚本试图在func2函数被定义之前使用它。由于func2函数还没有定义，脚本运行函数调用处时，产生了一条错误消息。 此外，还需要注意函数名，函数名必须是唯一的，否则也会有问题。如果你重定义了函数，新定义会覆盖原来函数的定义，这一切不会产生任何错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing using a duplicate function name</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is the first definition of the function name"</div><div class="line">&#125;</div><div class="line"></div><div class="line">func1</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    echo "This is a repeat of the same function name"</div><div class="line">&#125;</div><div class="line">func1</div><div class="line">echo "This is end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test3.sh</div><div class="line">This is the first definition of the function name</div><div class="line">This is a repeat of the same function name</div><div class="line">This is end of the script</div></pre></td></tr></table></figure>
<p>func1函数最初的定义工作正常，但重新定义该函数后，后续的函数调用都会使用第二个定义。</p>
<h2 id="返回值">返回值</h2>
<p>bash shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成退出状态码。</p>
<h3 id="默认退出状态码">默认退出状态码</h3>
<p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the exit status of a function</div><div class="line"></div><div class="line">func1() &#123;</div><div class="line">   echo "Trying to display a non-existent file"</div><div class="line">   ls -l badfile</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo "testing the function:  "</div><div class="line">func1</div><div class="line">echo "The exit status is : $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test4.sh</div><div class="line">testing the function:  </div><div class="line">Trying to display a non-existent file</div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">The exit status is : 2</div></pre></td></tr></table></figure>
<p>函数的退出状态码是2，这是因为函数中的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行。看下面的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the exit status of a fucntion </div><div class="line"></div><div class="line">func1() &#123;</div><div class="line">    ls -l badfile</div><div class="line">    echo "This was a test of a bad command"</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo "Testing the function: "</div><div class="line">func1</div><div class="line">echo "The exit status is:  $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test4b.sh</div><div class="line">Testing the function: </div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">This was a test of a bad command</div><div class="line">The exit status is:  0</div></pre></td></tr></table></figure>
<p>在这个案例中，由于函数最后一条语句echo运行成功，该函数的退出状态码就是0，尽管其中有一条 命令并没有正常运行。使用函数的默认退出状态码是很危险的。在bash shell中，有几种办法可以解决这个问题。</p>
<h3 id="使用return命令">使用return命令</h3>
<p>bash shell使用return命令来退出函数并返回特定的退出状态码。return命令允许指定一个 整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the return command in a function</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    read -p "Enter a value:" value</div><div class="line">    echo "doubling the value"</div><div class="line">    return $[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">dbl</div><div class="line">echo "The new value is $?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5.sh</div><div class="line">Enter a value:5</div><div class="line">doubling the value</div><div class="line">The new value is 10</div></pre></td></tr></table></figure>
<p>dbl函数会将<code>$value</code>变量中用户输入的值翻倍，然后用return命令返回结果。脚本用<code>$?</code>变量显示了该值。但当用这种方法从函数中返回值时，需要注意两点：第一，函数一结束就取返回值；第二，退出状态码必须是0~255。如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。<code>$?</code>变量会返回执行的最后一条命令的退出状态码。第二个问题界定了返回值的取值范围。由于退出状态码必须小于256，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5.sh</div><div class="line">Enter a value:200</div><div class="line">doubling the value</div><div class="line">The new value is 144</div></pre></td></tr></table></figure>
<h3 id="使用函数的输出">使用函数的输出</h3>
<p>将函数的份输出保存到shell变量中，就能获取任何类型的函数输出，例如<code>result='dbl</code>就是将dbl函数的输出赋值给<code>$result</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the return command in a function</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    read -p "Enter a value:" value</div><div class="line">    echo $[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">result=$(dbl)</div><div class="line"></div><div class="line">echo "The new value is $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test5b.sh</div><div class="line">Enter a value:200</div><div class="line">The new value is 400</div></pre></td></tr></table></figure>
<p>新函数会用echo语句来显示计算的结果。该脚本会获取dbl函数的输出，而不是查看退出状态码。在这个例子中，dbl函数实际上输出了两条消息。read命令输出了一条简短的消息来向用户询问输入值。bash shell脚本并不将其作为STDOUT输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中。通过这种技术，还可以返回浮点值和字符串值。</p>
<h2 id="在函数中使用变量">在函数中使用变量</h2>
<p>在test5例子的脚本里，在函数里用了一个叫作$value的变量来保存处理后的值。在函数中使用变量时，用户需要注意它们的定义方式以及处理方式。这是shell脚本中常见错误的根源。</p>
<h3 id="向函数传递参数">向函数传递参数</h3>
<p>函数使用两种类型的变量，分别为全局变量和局部变量。</p>
<h4 id="全局变量">全局变量</h4>
<p>全局变量是在shell脚本中任何地方都有效的变量。如果在脚本的主体部分定义了一个全局 变量，那么可以在函数内读取它的值。同样的，如果你在函数内定义了一个全局变量，可以在脚本的主体部分读取它的值。 默认情况下，在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a global variable to pass a value</div><div class="line"></div><div class="line">function dbl &#123;</div><div class="line">    value=$[ $value*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">read -p "Enter a vluae: " value</div><div class="line">dbl</div><div class="line">echo "The new value is :  $value"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test8.sh</div><div class="line">Enter a vluae: 300</div><div class="line">The new value is :  600</div></pre></td></tr></table></figure>
<p><code>$value</code>变量在函数外定义并被赋值。当dbl函数被调用时，该变量及其值在函数中都依然有效。如果变量在函数内被赋予了新值，那么在脚本中引用该变量时，新值也依然有效。但这操作其实很危险，因为如果是不同的脚本都使用该函数，有可能造成冲突，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating a bad use of variable</div><div class="line"></div><div class="line">function func1 &#123;</div><div class="line">    temp=$[ $value+5 ]</div><div class="line">    result=$[ $temp*2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">temp=4</div><div class="line">value=6</div><div class="line"></div><div class="line">func1</div><div class="line">echo "The result is $result"</div><div class="line">if [ $temp -gt $value ]</div><div class="line">then</div><div class="line">    echo "temp is larger"</div><div class="line">else</div><div class="line">    echo "temp is smaller"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest2.sh </div><div class="line">The result is 22</div><div class="line">temp is larger</div></pre></td></tr></table></figure>
<p>由于函数中用到了<code>$temp</code>变量，它的值在脚本中使用时受到了影响，产生了意想不到的后果。</p>
<h4 id="局部变量">局部变量</h4>
<p>在函数内部，通常无需使用全局变量，使用局部变量即可，要实现这一点，只要在变量声明的前面加上 local 关键字就可以了，例如<code>local temp</code>，local关键字保证了变量只局限在该函数中。如果脚本中在该函数之外有同样名字的变量， 那么shell将会保持这两个变量的值是分离的。现在你就能很轻松地将函数变量和脚本变量隔离开了，只共享需要共享的变量。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test9.sh</div><div class="line">The result is 22</div><div class="line">temp is smaller</div></pre></td></tr></table></figure>
<p>在 func1 函数中使用<code>$temp</code>变量时，并不会影响在脚本主体中赋给 <code>$temp</code>变量的值。</p>
<h2 id="数组变量和函数">数组变量和函数</h2>
<h3 id="向函数传数组参数">向函数传数组参数</h3>
<p>如果你试图将该数组变量作为函数参数，函数只会取数组变量的第一个值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Trying to pass an arraya variable</div><div class="line"></div><div class="line">function testit &#123;</div><div class="line">    echo "The parameters are: $@"</div><div class="line">    thisarray=$1</div><div class="line">    echo "The received array is $&#123;thisarray[*]&#125;"</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5)</div><div class="line">echo "The original array is: $&#123;myarray[*]&#125;"</div><div class="line">testit $myarray</div></pre></td></tr></table></figure>
<p>结果运行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest3b.sh</div><div class="line">The original array is: 1 2 3 4 5</div><div class="line">The parameters are: 1</div><div class="line">The received array is 1</div></pre></td></tr></table></figure>
<p>要解决上述问题，用户必须将该数组变量的值分解成单个的值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ cat test10.sh</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> array variable to function test</div><div class="line">function testit &#123; </div><div class="line">   local newarray </div><div class="line">   newarray=($(echo "$@")) </div><div class="line">   echo "The new array value is: $&#123;newarray[*]&#125;" </div><div class="line">&#125; </div><div class="line"> </div><div class="line">myarray=(1 2 3 4 5) </div><div class="line">echo "The original array is $&#123;myarray[*]&#125;" </div><div class="line">testit $&#123;myarray[*]&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test10.sh</div><div class="line">The original array is 1 2 3 4 5</div><div class="line">The new array value is: 1 2 3 4 5</div></pre></td></tr></table></figure>
<p>该脚本用<code>$myarray</code>变量来保存所有的数组元素，然后将它们都放在函数的命令行上。该函数随后从命令行参数中重建数组变量。在函数内部，数组仍然可以像其他数组一样使用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> adding values in an array</div><div class="line"></div><div class="line">function addarray &#123;</div><div class="line">    local sum=0</div><div class="line">    local newarray</div><div class="line">    newarray=($(echo "$@"))</div><div class="line">    for value in $&#123;newarray[*]&#125;</div><div class="line">    do</div><div class="line">        sum=$[ $sum+$value ]</div><div class="line">    done</div><div class="line">    echo $sum</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5)</div><div class="line">echo "The original array is : $&#123;myarray[*]&#125;"</div><div class="line">arg1=$(echo $&#123;myarray[*]&#125;)</div><div class="line">result=$(addarray $arg1)</div><div class="line">echo "The result is $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test11.sh</div><div class="line">The original array is : 1 2 3 4 5</div><div class="line">The result is 15</div></pre></td></tr></table></figure>
<p>addarray函数会遍历所有的数组元素，将它们累加在一起。你可以在myarray数组变量中放置任意多的值，addarry函数会将它们都加起来。</p>
<h3 id="从函数返回数组">从函数返回数组</h3>
<p>从函数里向shell脚本传回数组变量也用类似的方法。函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span>returning an array value</div><div class="line"></div><div class="line">function arraydblr &#123;</div><div class="line">    local origarray</div><div class="line">    local newarray</div><div class="line">    local elements</div><div class="line">    local i</div><div class="line">    origarray=($(echo "$@"))</div><div class="line">    newarray=($(echo "$@"))</div><div class="line">    elements=$[ $# -1 ]</div><div class="line">    for (( i=0;i&lt;=$elements;i++))</div><div class="line">    &#123;</div><div class="line">        newarray[$i]=$[ $&#123;origarray[$i]&#125;*2 ]</div><div class="line">    &#125;</div><div class="line">    echo $&#123;newarray[*]&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">myarray=(1 2 3 4 5 )</div><div class="line">echo "The original array is: $&#123;myarray[*]&#125;"</div><div class="line">arg1=$(echo $&#123;myarray[*]&#125;)</div><div class="line">result=($(arraydblr $arg1))</div><div class="line">echo "The new array is: $&#123;result[*]&#125;"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test12.sh</div><div class="line">The original array is: 1 2 3 4 5</div><div class="line">The new array is: 2 4 6 8 10</div></pre></td></tr></table></figure>
<p>该脚本用<code>$arg1</code>变量将数组值传给arraydblr函数。arraydblr函数将该数组重组到新的数 组变量中，生成该输出数组变量的一个副本。然后对数据元素进行遍历，将每个元素值翻倍，并 将结果存入函数中该数组变量的副本。 arraydblr函数使用echo语句来输出每个数组元素的值。脚本用arraydblr函数的输出来 重新生成一个新的数组变量。</p>
<h2 id="函数递归">函数递归</h2>
<p>函数可以调用函数自身，这个过程就称为函数的递归。下面看一个函数，这个函数就是通过递归来计算阶乘，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using recursion</div><div class="line"></div><div class="line">function factorial &#123;</div><div class="line">    if [ $1 -eq 1 ]</div><div class="line">    then</div><div class="line">        echo 1</div><div class="line">    else</div><div class="line">        local temp=$[ $1 -1 ]</div><div class="line">        local result=$(factorial $temp)</div><div class="line">        echo $[ $result*$1 ]</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"></div><div class="line">read -p "Enter value: " value</div><div class="line">result=$(factorial $value)</div><div class="line">echo "The factorial of $value is: $result"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test13.sh</div><div class="line">Enter value: 5</div><div class="line">The factorial of 5 is: 120</div></pre></td></tr></table></figure>
<p>在创建了函数后，可以在其他的脚本中调用。</p>
<h2 id="创建库">创建库</h2>
<p>如果用户要在多个脚本中使用同一段代码的话，这就需要创建函数库文件，然后在多个脚本中引用该库文件。这个过程的第一步是创建一个包含脚本中所需函数的公用库文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> my script functions </div><div class="line"></div><div class="line">function addem &#123;</div><div class="line">    echo $[ $1+$2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">function multem &#123;</div><div class="line">    echo $[ $1*$2 ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">function divem &#123;</div><div class="line">    if [ $2 -ne 0 ]</div><div class="line">    then</div><div class="line">        echo $[ $1/$2 ]</div><div class="line">    else</div><div class="line">        echo -1</div><div class="line">    fi</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下一步是在用到这些函数的脚本文件中包含myfuncs库文件。从这里开始，事情就变复杂了。问题出在shell函数的作用域上。和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。这同样适用于脚本。如果你尝试像普通脚本文件那样运行库文件，函数并不会出现在脚本中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a library file the wrong way</div><div class="line">bash myfuncs.sh</div><div class="line"></div><div class="line">result=$(addem 10 15)</div><div class="line">echo "The result is $result"</div></pre></td></tr></table></figure>
<p>运行后如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash badtest4.sh </div><div class="line">badtest4.sh: line 5: addem: command not found</div><div class="line">The result is</div></pre></td></tr></table></figure>
<p>使用函数库的需要用到<code>source</code>命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。source命令有个快捷的别名，称作<code>点操作符（dotoperator）</code>。要在shell脚本中运行myfuncs库文件，只需添加这一行，即<code>. ./myfuncs</code>(两个点之间有空格），这个例子是假定myfuncs库文件与shell脚本位于同一目录，如果不是，则需要输入全路径。使用source命令的脚本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a library file the wrong way</div><div class="line">. ./myfuncs.sh</div><div class="line"></div><div class="line">value1=10</div><div class="line">value2=5</div><div class="line">result1=$(addem $value1 $value2)</div><div class="line">result2=$(multem $value1 $value2)</div><div class="line">result3=$(divem $value1 $value2)</div><div class="line">echo "The result of adding them is: $result1"</div><div class="line">echo "The result of multiplying them is: $result2"</div><div class="line">echo "The result of dividing them is: $result3"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test14.sh</div><div class="line">The result of adding them is: 15</div><div class="line">The result of multiplying them is: 50</div><div class="line">The result of dividing them is: 2</div></pre></td></tr></table></figure>
<h2 id="在命令行上使用函数">在命令行上使用函数</h2>
<p>在命令行界面中也可以使用函数，一旦在shell中定义了函数，用户就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。</p>
<p>### 在命令行上创建函数</p>
<h4 id="第1种方法直接定义函数">第1种方法：直接定义函数</h4>
<p>这一种方法使用的是单行试，需要函数主体部分的每个命令后面加上分号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function divem &#123; echo $[ $1/$2 ]; &#125;</div><div class="line">biotest@ubuntu:~/funciton$ divem 100 5</div><div class="line">20</div></pre></td></tr></table></figure>
<p>再看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function doubleit &#123; read -p "Enter value: " value; echo $[ $value*2 ]; &#125;</div><div class="line">biotest@ubuntu:~/funciton$ doubleit</div><div class="line">Enter value: 12</div><div class="line">24</div></pre></td></tr></table></figure>
<h4 id="第2种方法多行形式">第2种方法：多行形式</h4>
<p>还可以采用多行方式定义函数，此种情况下，bash shell会用提示符提示输入更多的命令，此种方法不需要在命令后面加分号，直接回车就行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ function multem &#123;</div><div class="line"><span class="meta">&gt;</span> echo $[ $1*$2 ]</div><div class="line"><span class="meta">&gt;</span> &#125;</div><div class="line">biotest@ubuntu:~/funciton$ multem 2 5</div><div class="line">10</div></pre></td></tr></table></figure>
<h3 id="在.bashrc文件中定义函数">在<code>.bashrc</code>文件中定义函数</h3>
<p>在命令行上直接定义shell函数的明显缺点是退出shell时，函数就消失了。对于复杂的函数来说，这种形式并不常用。解决这个问题的方式就是将函数定义在一个特定的位置，这个位置在每次启动一个新shell的时候，都会由shell重新载入。最佳地点就是.bashrc文件。bash shell在每次启动时都会在主目录下查找这个文件，不管是交互式shell还是从现有shell中启动的新shell。</p>
<h4 id="直接定义函数">直接定义函数</h4>
<p>打开<code>.bashrc</code>文件，下拉在文件的末尾处写入函数即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if [ -r /etc/bashrc ];then</div><div class="line">        . /etc/bashrc</div><div class="line">fi</div><div class="line"></div><div class="line">function addem &#123;</div><div class="line">    echo $[ $1 + $2 ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ addem 10 2</div><div class="line">12</div></pre></td></tr></table></figure>
<p>也可以将库文件写入到<code>.bashrc</code>文件中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if [ -r /etc/bashrc ];then</div><div class="line">        . /etc/bashrc</div><div class="line">fi</div><div class="line"></div><div class="line">. /home/biotest/funciton/myfuncs.sh</div></pre></td></tr></table></figure>
<p>然后<code>source ~/.bashrc，</code>这样在shell中就可以使用myfuncs.sh中的函数了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ addem 10 5</div><div class="line">15</div><div class="line">biotest@ubuntu:~/funciton$ multem 10 5</div><div class="line">50</div><div class="line">biotest@ubuntu:~/funciton$ divem 10 5</div><div class="line">2</div></pre></td></tr></table></figure>
<h2 id="案例">案例</h2>
<p>shtool库提供了一些简单的shell脚本函数，可以用来完成日常的shell功能，例如处理临时文件和目录或者格式化输出显示。</p>
<h3 id="下载及安装">下载及安装</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget ftp://ftp.gnu.org/gnu/shtool/shtool-2.0.8.tar.gz</div><div class="line">tar -zxvf shtool-2.0.8.tar.gz</div></pre></td></tr></table></figure>
<h3 id="构建库">构建库</h3>
<p>shtool文件必须针对特定的Linux环境进行配置。配置工作必须使用标准的configure和make命令，这两个命令常用于C编程环境。要构建库文件，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ ./configure</div><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ make</div></pre></td></tr></table></figure>
<p>configure命令会检查构建shtool库文件所必需的软件。一旦发现了所需的工具，它会使用工具路径修改配置文件。make命令负责构建shtool库文件。最终的结果（shtool）是一个完整的库软件包。也可以使用make命令测试这个库文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make test</div></pre></td></tr></table></figure>
<p>测试模式会测试shtool库中所有的函数。如果全部通过测试，就可以将库安装到Linux系统中的公用位置，这样所有的脚本就都能够使用这个库了。要完成安装，需要使用make命令的install选项。不过需要以root用户的身份运行该命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/Downloads/shtool-2.0.8$ sudo make install</div></pre></td></tr></table></figure>
<p>现在就能在自己的shell脚本中使用这些函数了。</p>
<h3 id="shtool-库函数">shtool 库函数</h3>
<p>shtool库提供了大量方便的、可用于shell脚本的函数。如下所示：</p>
<table>
<thead>
<tr class="header">
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arx</td>
<td>创建归档文件（包含一些扩展功能）</td>
</tr>
<tr class="even">
<td>Echo</td>
<td>显示字符串，并提供了一些扩展构件</td>
</tr>
<tr class="odd">
<td>fixperm</td>
<td>改变目录树中的文件权限</td>
</tr>
<tr class="even">
<td>install</td>
<td>安装脚本或文件</td>
</tr>
<tr class="odd">
<td>mdate</td>
<td>显示文件或目录的修改时间</td>
</tr>
<tr class="even">
<td>mkdir</td>
<td>创建一个或更多目录</td>
</tr>
<tr class="odd">
<td>Mkln</td>
<td>使用相对路径创建链接</td>
</tr>
<tr class="even">
<td>mkshadow</td>
<td>创建一棵阴影树</td>
</tr>
<tr class="odd">
<td>move</td>
<td>带有替换功能的文件移动</td>
</tr>
<tr class="even">
<td>Path</td>
<td>处理程序路径</td>
</tr>
<tr class="odd">
<td>platform</td>
<td>显示平台标识</td>
</tr>
<tr class="even">
<td>Prop</td>
<td>显示一个带有动画效果的进度条</td>
</tr>
<tr class="odd">
<td>rotate</td>
<td>转置日志文件</td>
</tr>
<tr class="even">
<td>Scpp</td>
<td>共享的C预处理器</td>
</tr>
<tr class="odd">
<td>Slo</td>
<td>根据库的类别，分离链接器选项</td>
</tr>
<tr class="even">
<td>Subst</td>
<td>使用sed的替换操作</td>
</tr>
<tr class="odd">
<td>Table</td>
<td>以表格的形式显示由字段分隔（field</td>
</tr>
<tr class="even">
<td>tarball</td>
<td>从文件和目录中创建tar文件</td>
</tr>
<tr class="odd">
<td>version</td>
<td>创建版本信息文件</td>
</tr>
</tbody>
</table>
<p>shtool函数的使用格式为<code>shtool [options] [function [options] [args]]</code>。</p>
<h3 id="使用库">使用库</h3>
<p>下面是一个在shell脚本中使用platform函数的例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">shtool platform</div></pre></td></tr></table></figure>
<p>运行后如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ bash test16.sh</div><div class="line">Ubuntu 16.04 (AMD64)</div></pre></td></tr></table></figure>
<p>platform函数会返回Linux发行版以及系统所使用的CPU硬件的相关信息。还有一个函数是prop函数。它可以使用、|、/和-字符创建一个旋转的进度条。可以告诉shell脚本用户目前正在进行一些后台处理工作。要使用prop函数，只需要将希望监看的输出管接到shtool脚本就行了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/funciton$ ls -al /usr/bin | shtool prop -p "waiting..."</div><div class="line">waiting...</div></pre></td></tr></table></figure>
<p>prop函数会在处理过程中不停地变换进度条字符。在本例中，输出信息来自于ls命令。你能看到多少进度条取决于CPU能以多快的速度列出/usr/bin中的文件，-p选项允许你定制输出文本，这段文本会出现在进度条字符之前。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/04/Linux/Linux-shell06-控制脚本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/Linux/Linux-shell06-控制脚本/" itemprop="url">Shell学习笔记（6）——控制脚本</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T12:12:54+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,083
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="控制信号">控制信号</h2>
<p>Linux利用信号与运行在系统中的进程进行通信。通过对脚本进行编程，使其在收到特定信号时执行某些命令，从而控制shell脚本的操作。Linux系统和应用程序可以生成超过30个信息，下表是常见的Linux系统信号：</p>
<h3 id="常见的信号">常见的信号</h3>
<table>
<thead>
<tr class="header">
<th>信号</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>SIGHUP</td>
<td>挂起进程</td>
</tr>
<tr class="even">
<td>2</td>
<td>SIGINF</td>
<td>终止进程</td>
</tr>
<tr class="odd">
<td>3</td>
<td>SIGQUIT</td>
<td>停止进程</td>
</tr>
<tr class="even">
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程</td>
</tr>
<tr class="odd">
<td>15</td>
<td>SIGTERM</td>
<td>尽可能终止进程</td>
</tr>
<tr class="even">
<td>17</td>
<td>SIGSTOP</td>
<td>无条件停止进程，但不是终止进程</td>
</tr>
<tr class="odd">
<td>18</td>
<td>SIGTSTP</td>
<td>停止或暂停进程，但不终止进程</td>
</tr>
<tr class="even">
<td>19</td>
<td>SIGCONT</td>
<td>继续运行停止的进程</td>
</tr>
</tbody>
</table>
<p>默认情况下，bash shell会忽略收到的任何 SIGQUIT (3) 和 SIGTERM (5) 信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的 SIGHUP (1) 和 SIGINT (2) 信号。如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退出之前，它会将SIGHUP信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。通过SIGINT信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这种情况发生时，shell会将SIGINT信号传给所有由它所启动的进程，以此告知出现的状况。你可能也注意到了，shell会将这些信号传给shell脚本程序来处理。而shell脚本的默认行为是忽略这些信号。它们可能会不利于脚本的运行。要避免这种情况，你可以脚本中加入识别信号的代码，并执行命令来处理信号。</p>
<h3 id="生成信号">生成信号</h3>
<p>使用键盘上的组合键可以生成2种基本的Linux信号。</p>
<h4 id="中断进程">中断进程</h4>
<p>Ctrl<code>+</code>C<code>会生成</code>SIGINT`信号，将其发送给当前在shell运行中的所有进程，停止shell当前运行的进程，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 500</div><div class="line">^C</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$</div></pre></td></tr></table></figure>
<h4 id="暂停进程">暂停进程</h4>
<p><code>Ctrl</code>+<code>Z</code>可以生成一个SIGTSTP信号，停止shell运行的任何进程，停止进程（stopping）与终止（terminating）进程不同，停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 100</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 sleep 100</div></pre></td></tr></table></figure>
<p>结果中的方括号里的数字是shell分配的作业号（job number），shell将运行中的每个进程称为作为，并为每个作业分配有唯一的作业号，第一个作业分配的是作业号1，第二个是2。如果shell会话中有一个已经停止的作业，在退出shell时，bash会提醒用户，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ sleep 100</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 sleep 100</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ^C</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ exit</div><div class="line">exit</div><div class="line">There are stopped jobs.</div></pre></td></tr></table></figure>
<p>通过ps命令可以查看已经停止的作业，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ps -l</div><div class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</div><div class="line">0 S  1000  10009  10002  0  80   0 -  5700 wait   pts/4    00:00:01 bash</div><div class="line">0 T  1000  28664  10009  0  80   0 -  1822 signal pts/4    00:00:00 sleep</div><div class="line">0 R  1000  28674  10009  0  80   0 -  7229 -      pts/4    00:00:00 ps</div></pre></td></tr></table></figure>
<p>在S列（进程状态），ps命令将已经停止作业的状态显示为T，这说明命令要么被跟踪，要么被停止了。如果在有已停止作业存在的情况下，你仍旧想退出shell，只要再输入一遍 exit 命令就行了。shell会退出，终止已停止作业。或者，既然你已经知道了已停止作业的PID，就可以用 kill 命令来发送一个 SIGKILL 信号来终止它(-9表示强迫终止）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ kill -9 28664</div><div class="line">[1]+  Killed                  sleep 100</div></pre></td></tr></table></figure>
<h3 id="捕获信号">捕获信号</h3>
<p>在信号出现时捕获它们并执行其他命令时用<code>trap</code>，此命令可以指定shell脚本要监视并从shell中拦截的Linux信号，如果脚本收到了trap命令中列出的信号，此信号不再由shell处理，则是交给本地处理，trap的用法为<code>trap commands signals</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing signla trapping</div><div class="line"></div><div class="line">trap "echo ' Sorry! I have trapped Ctrl-C'" SIGINT</div><div class="line"></div><div class="line">echo This is a test script</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">echo "This is the end of the test script"</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test1.sh </div><div class="line">This is a test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #6</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #7</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #8</div><div class="line">^C Sorry! I have trapped Ctrl-C</div><div class="line">Loop #9</div><div class="line">Loop #10</div><div class="line">This is the end of the test script</div></pre></td></tr></table></figure>
<p>在这个案例中，使用了trap命令，在检测到SIGINT信号时，就会显示一行简单的文本消息，捕获这些信号会阻止用户使用bash shell组合键<code>Ctrl</code>+<code>C</code>来停止程序。也就是说每次使用组合键<code>Ctrl</code>+<code>C</code>时，脚本就都会执行<code>trap</code>命令中指定的<code>echo</code>语句，而不是处理该信号并允许shell停止该脚本。</p>
<h3 id="捕获脚本退出">捕获脚本退出</h3>
<p>shell脚本在退出时也能进行捕获，这是在shell完成任务时执行命令的一种简便方法，用法是在trap命令后加上EXIT信号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Trapping the script exit</div><div class="line"><span class="meta">#</span></div><div class="line">trap "echo Goodbye..." EXIT</div><div class="line"><span class="meta">#</span></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test2.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Goodbye...</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ bash test2.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">^CGoodbye...</div></pre></td></tr></table></figure>
<p>当脚本运行到正常的退出位置时，捕获就被触发了，shell会执行在trap命令行指定的命令。如果提前退出脚本，同样能够捕获到EXIT。这是因为SIGINT信号并没有出现在trap命令的捕获列表中，当按下Ctrl+C组合键发送SIGINT信号时，脚本就退出了。但在脚本退出前捕获到了EXIT，于是shell执行了trap命令。</p>
<h3 id="修改或移除捕获">修改或移除捕获</h3>
<p>要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Modifying a set trap</div><div class="line"></div><div class="line">trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">trap "echo 'I modified the trap!'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Second Loop #$count"</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test3.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">^C Sorry...Ctrl-C is trapped.</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Second Loop #1</div><div class="line">^CI modified the trap!</div><div class="line">Second Loop #2</div><div class="line">Second Loop #3</div><div class="line">Second Loop #4</div><div class="line">Second Loop #5</div></pre></td></tr></table></figure>
<p>修改了信号捕获之后，脚本处理信号的方式就会发生变化。但如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的 trap 命令进行处理。 也可以删除已设置好的捕获。只需要在 trap 命令与希望恢复默认行为的信号列表之间加上两个破折号就行了。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> removing a set trap</div><div class="line"></div><div class="line">trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">   echo "Loop #$count"</div><div class="line">   sleep 1</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span> Remove the trap</div><div class="line">trap -- SIGINT</div><div class="line">echo "I just removed the trap"</div><div class="line"></div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">   echo "Second Loop #$count"</div><div class="line">   sleep 1</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test3b.sh</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">^C Sorry...Ctrl-C is trapped.</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">I just removed the trap</div><div class="line">Second Loop #1</div><div class="line">Second Loop #2</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>移除信号捕获后，脚本按照默认行为来处理 SIGINT 信号，也就是终止脚本运行。但如果信号是在捕获被移除前接收到的，那么脚本会按照原先 trap 命令中的设置进行处理。 在本例中，第一个Ctrl+C组合键用于提前终止脚本。因为信号在捕获被移除前已经接收到了，脚本会照旧执行 trap 中指定的命令。捕获随后被移除，再按Ctrl+C就能够提前终止脚本了。</p>
<h2 id="后台模式运行脚本">后台模式运行脚本</h2>
<p>有些脚本不会在终端的显示器上显示，而是在后台（background）运行，在后台模式中，进行运行不会与STDIN、STDOUT以及STDERR发生关联。</p>
<h3 id="后台运行脚本">后台运行脚本</h3>
<p>打开后台模式运行脚本霜肆在脚本后面添加上<code>&amp;</code>符号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> test running in the background</div><div class="line"><span class="meta">#</span></div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    sleep 1</div><div class="line">    count=$[ $count + 1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test4.sh &amp;</div><div class="line">[1] 28920</div><div class="line">biotest@ubuntu:~/signal$ ps </div><div class="line">   PID TTY          TIME CMD</div><div class="line"> 10009 pts/4    00:00:01 bash</div><div class="line"> 28920 pts/4    00:00:00 bash</div><div class="line"> 28923 pts/4    00:00:00 sleep</div><div class="line"> 28924 pts/4    00:00:00 ps</div><div class="line"> </div><div class="line"> # 按回车键</div><div class="line"> biotest@ubuntu:~/signal$ </div><div class="line">[1]+  Done                    bash test4.sh</div></pre></td></tr></table></figure>
<p>从结果可以看出，当 &amp; 符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后 台进程运行。显示的第一行是[1] 28920，其中[1]是shell分配给后台进程的作业号。28920是进程号。在运行结束后，按回车键，脚本会在终端显示消息（<code>[1]+ Done...</code>），就是结果的最后一部分，这表明了作业的作业号以及作业状态（Done）。当脚本在后台运行时，它仍然会使用终端显示器来显示STDOUT和STDERR，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Test running in the background with output</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span></div><div class="line">echo "Start the test script"</div><div class="line">count=1</div><div class="line">while [ $count -le 5 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 5</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"><span class="meta">#</span></div><div class="line">echo "Test script is complete"</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test5.sh &amp;</div><div class="line">[1] 28986</div><div class="line">biotest@ubuntu:~/signal$ Start the test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Test script is complete</div><div class="line"></div><div class="line">[1]+  Done                    bash test5.sh</div></pre></td></tr></table></figure>
<p>在这个案例中，脚本test5.sh的输出与shell提示符混杂在一歧异，这也是为什么Start the test script会出现在提示符普边的原因。在显示输出的同时，仍然可以运行命令，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ Start the test script</div><div class="line">Loop #1</div><div class="line">ls</div><div class="line">test1.sh  test2.sh  test3b.sh  test3.sh  test4.sh  test5.sh</div></pre></td></tr></table></figure>
<p>当脚本test5.sh运行在后台模式时，输入了命令ls。脚本输出、输入的命令以及命令输出全都混在了一起。针对这种情况，最好是将后台运行的脚本的STDOUT和STDERR进行重定向，避免这种杂乱的输出。</p>
<h3 id="运行多个后台作业">运行多个后台作业</h3>
<p>可以在命令行提示符下同时启动多个后台作业，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test6.sh &amp;</div><div class="line">[2] 29019</div><div class="line">[1]   Done                    bash test5.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test6.sh: No such file or directory</div><div class="line">bash test7.sh &amp;</div><div class="line">[3] 29020</div><div class="line">[2]   Exit 127                bash test6.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test7.sh: No such file or directory</div><div class="line">bash test8.sh &amp;</div><div class="line">[4] 29021</div><div class="line">[3]   Exit 127                bash test7.sh</div><div class="line">biotest@ubuntu:~/signal$ bash: test8.sh: No such file or directory</div><div class="line">ps</div><div class="line">   PID TTY          TIME CMD</div><div class="line"> 10009 pts/4    00:00:01 bash</div><div class="line"> 29022 pts/4    00:00:00 ps</div><div class="line">[4]+  Exit 127                bash test8.sh</div></pre></td></tr></table></figure>
<p>每次启动新作业时，Linux系统都会为其分配一个新的作业号和PID。通过 ps 命令，可以看到所有脚本处于运行状态。 在终端会话中使用后台进程时一定要小心。注意，在ps命令的输出中，每一个后台进程都和终端会话（pts/0）终端联系在一起。如果终端会话退出，那么后台进程也会随之退出。</p>
<h2 id="nohup命令">nohup命令</h2>
<p>在有些情况下，用户会终端会话中启动shell脚本，即使退出了终端会话，脚本也会一直在后台模式运行，直到结束。这可以用nohup命令来实现。nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会话时阻止进程退出。nohup命令的格式为<code>nohup commands &amp;</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nohup bash test1.sh &amp;</div><div class="line">[1] 29325</div><div class="line">biotest@ubuntu:~/signal$ nohup: ignoring input and appending output to 'nohup.out'</div></pre></td></tr></table></figure>
<p>shell会给命令分配一个作业号，Linux系统会为其分配一个PID号。与shell中的普通进程相比，区 别在于，当使用nohup命令时，如果关闭该会话，脚本会忽略终端会话发过来的SIGHUP信号。 由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。 为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为 nohup.out的文件中。如果使用nohup运行了另一个命令，该命令的输出会被追加到已有的nohup.out文件中。因此，当运行位于同一个目录中的多个命令时一定要小心，因为所有的输出都会被发送到同一个nohup.out文件中，结果会让人摸不清头脑。</p>
<p>nohup.out文件包含了通常会发送到终端显示器上的所有输出。在进程完成运行后，你可以查 看nohup.out文件中的输出结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ ls</div><div class="line">nohup.out  test1.sh  test2.sh  test3b.sh  test3.sh  test4.sh  test5.sh</div><div class="line">biotest@ubuntu:~/signal$ cat nohup.out </div><div class="line">This is a test script</div><div class="line">Loop #1</div><div class="line">Loop #2</div><div class="line">Loop #3</div><div class="line">Loop #4</div><div class="line">Loop #5</div><div class="line">Loop #6</div><div class="line">Loop #7</div><div class="line">Loop #8</div><div class="line">Loop #9</div><div class="line">Loop #10</div><div class="line">This is the end of the test script</div></pre></td></tr></table></figure>
<h2 id="作业控制">作业控制</h2>
<p>在作业停止后，Linux系统会让用户选择是终止还是重启。用户可以用kill命令终止该进程。要重启停止的进程需要向其发送一个SIGCONT信号。启动、停止、终止以及恢复作业的这些功能统称为<strong>作业控制</strong>。通过作业控制，就能完全控制shell环境中所有进程的运行方式。</p>
<h3 id="查看作业">查看作业</h3>
<p>查看作业的命令是<code>jobs</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> test job control</div><div class="line"></div><div class="line">echo "Script process ID: $$"</div><div class="line">count=1</div><div class="line">while [ $count -le 10 ]</div><div class="line">do</div><div class="line">    echo "Loop #$count"</div><div class="line">    sleep 10</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "End of script ..."</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh</div><div class="line">Script process ID: 29360</div><div class="line">Loop #1</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10.out &amp;</div><div class="line">[2] 29364</div><div class="line">biotest@ubuntu:~/signal$ jobs</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line">[2]-  Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[1]+ 29360 Stopped                 bash test10.sh</div><div class="line">[2]- 29364 Running                 bash test10.sh &gt; test10.out &amp;</div></pre></td></tr></table></figure>
<p>代码及结果解释：脚本使用<code>$$</code>变量业显示Linux系统分配给此脚本的PID，然后进入循环，每次迭代都休眠10秒，可以从命令行中启动脚本，然后使用<code>Ctrl</code>+<code>Z</code>停止脚本。随后又使用了<code>&amp;</code>操作将另外一个作用设为后台进程启动，出于简化目的，在这个案例中，脚本的输出被重定向到文件中，避免出现在屏幕上。<code>jobs</code>命令可以查看分配给Shell的作用，jobs命令显示了2个已经停止/运行中的作用，以及它们的作业号和作业中使用的命令。如果使用<code>job -l</code>则会业显示作用的PID，有关jobs命令的一些参数，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-l</td>
<td>列出进程的PID以及作业号</td>
</tr>
<tr class="even">
<td>-n</td>
<td>只列出上次shell发出的通知后改变了状态的作业</td>
</tr>
<tr class="odd">
<td>-p</td>
<td>只列出作业的PID</td>
</tr>
<tr class="even">
<td>-r</td>
<td>只列出运行中的作业</td>
</tr>
<tr class="odd">
<td>-s</td>
<td>只列出已停止的作业</td>
</tr>
</tbody>
</table>
<p>jobs命令输出中有加号和减号。带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候，不管shell中有多少个正在运行的作业，shell中都只有一个带加号的作业和一个带减号的作业。</p>
<p>下面例子说明了队列中的下一个作业在默认作业移除时是如何成为默认作业的。有3个独立的进程在后台被启动。jobs命令显示出了这些进程、进程的PID及其状态。注意，默认进程（带有加号的那个）是最后启动的那个进程，也就是3号作业。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10a.out &amp;</div><div class="line">[2] 29402</div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10.out &amp;</div><div class="line">[3] 29404</div><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &gt; test10c.out &amp;</div><div class="line">[4] 29409</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[2]+ 29402 Running                 bash test10.sh &gt; test10a.out &amp;</div><div class="line">[3]  29404 Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">[4]- 29409 Running                 bash test10.sh &gt; test10c.out &amp;</div><div class="line">biotest@ubuntu:~/signal$ kill 29402</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[3]+ 29404 Running                 bash test10.sh &gt; test10.out &amp;</div><div class="line">[4]- 29409 Terminated              bash test10.sh &gt; test10c.out</div><div class="line">biotest@ubuntu:~/signal$ kill 29404</div><div class="line"><span class="meta">#</span> 调用了 kill 命令向默认进程发送了一个 SIGHUP 信号，终止了该作业。在接下来的 jobs</div><div class="line"><span class="meta">#</span> 命令输出中，先前带有减号的作业成了现在的默认作业，减号也变成了加号。</div><div class="line">biotest@ubuntu:~/signal$ jobs -l</div><div class="line">[3]+ 29409 Terminated              bash test10.sh &gt; test10.out</div></pre></td></tr></table></figure>
<h3 id="重启停止的作业">重启停止的作业</h3>
<p>在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你当前工作的终端，所以在使用该功能时要小心，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh</div><div class="line">Script process ID: 29612</div><div class="line">Loop #1</div><div class="line">^Z</div><div class="line">[1]+  Stopped                 bash test10.sh</div><div class="line">biotest@ubuntu:~/signal$ bg</div><div class="line">[1]+ bash test10.sh &amp;</div><div class="line">biotest@ubuntu:~/signal$ jobs</div><div class="line">[1]+  Running                 bash test10.sh &amp;</div></pre></td></tr></table></figure>
<p>因为该作业是默认作业（从加号可以看出），只需要使用bg命令就可以将其以后台模式重启。 注意，当作业被转入后台模式时，并不会列出其PID。如果有多个作业，需要在<code>bg</code>命令后加上作业号，如果要以前台模式恢复运行，则用<code>fg</code>加上作业号。</p>
<h2 id="调整优先级">　调整优先级</h2>
<p>在多任务操作系统中（Linux就是），内核负责将CPU时间分配给系统上运行的每个进程。调度优先级（scheduling priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。调度优先级是个整数值，从20（最高优先级）到+19（最低优先级）。默认情况下，bashshell以优先级0来启动所有进程。</p>
<p>有时用户要改变一个shell脚本的优先级。不管是降低它的优先级（这样它就不会从占用其他 进程过多的处理能力），还是给予它更高的优先级（这样它就能获得更多的处理时间），都可以通过<code>nice</code>这个命令达到目的。</p>
<h3 id="nice命令">nice命令</h3>
<p>nice命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用nice的-n命令行来指定新的优先级级别。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -n 10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[2] 29646</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29646 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line">[2]-  Done                    nice -n 10 bash test4.sh &gt; test4.out</div></pre></td></tr></table></figure>
<p>注意，必须将nice命令和要启动的命令放在同一行中。ps命令的输出验证了谦让度值（NI列）已经被调整到了10。</p>
<p>nice命令会让脚本以更低的优先级运行。但如果想提高某个命令的优先级，普通用户则无法实现,如下所示:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -n -10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[2] 29677</div><div class="line">biotest@ubuntu:~/signal$ nice: cannot set niceness: Permission denied</div></pre></td></tr></table></figure>
<p>nice命令阻止普通系统用户来提高命令的优先级。注意，指定的作业的确运行了，但是试图使用nice命令提高其优先级的操作却失败了,这很好,理解计算机的资源是有限有，用户可以将自己的作业推后，但是你不能提前。nice命令的-n选项并不是必须的，只需要在破折号后面跟上优先级就行了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ nice -10 bash test4.sh &gt; test4.out &amp;</div><div class="line">[3] 29691</div><div class="line">[2]   Done                    nice -n -10 bash test4.sh &gt; test4.out</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29691 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line">[3]-  Done                    nice -10 bash test4.sh &gt; test4.out</div></pre></td></tr></table></figure>
<h3 id="renice命令">renice命令</h3>
<p><code>renice</code>命令可以改变系统上已经运行命令的优先级，它允许用户指定运行进程的PID来改变它的优先级，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ bash test10.sh &amp;</div><div class="line">[2] 29718</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29718 -o pid,Loop #3</div><div class="line">ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line"> 29718  10009   0 bash test10.sh</div><div class="line">biotest@ubuntu:~/signal$ renice -n 10 -p 29718</div><div class="line">29718 (process ID) old priority 0, new priority 10</div><div class="line">biotest@ubuntu:~/signal$ ps -p 29718 -o pid,ppid,ni,cmd</div><div class="line">   PID   PPID  NI CMD</div><div class="line"> 29718  10009  10 bash test10.sh</div></pre></td></tr></table></figure>
<p>renice命令会自动更新当前运行进程的调度优先级。和nice命令一样，renice命令也有一些限制：第一，只能对属于用户自身的进程执行renice；只能通过renice降低进程的优先级；root用户可以通过renice来任意调整进程的优先级。如果想完全控制运行进程，必须以root账户身份登录或使用sudo命令。</p>
<h2 id="定时运行作业">定时运行作业</h2>
<p><code>at</code>命令和<code>cron</code>表可以指定用户在某个时间运行脚本。</p>
<h3 id="at命令"><code>at</code>命令</h3>
<p>at命令允许指定Linux系统何时运行脚本。at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程atd会以后台模式运行，检查作业队列来运行作业。atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下，atd守护进程会每60秒检查一下这个目录。有作业时，atd守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配，atd守护进程就会运行此作业。</p>
<h4 id="at命令的格式">at命令的格式</h4>
<p>at命令的格式at命令的基本格式为：<code>at [-f filename ] time</code></p>
<p>默认情况下，at命令会将STDIN的输入放到队列中。用户可以用-f参数来指定用于读取命令（脚本文件）的文件名。time参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过，at命令会在第二天的那个时间运行指定的作业。at命令能识别多种不同的时间格式。</p>
<ol style="list-style-type: decimal">
<li>标准的小时和分钟格式，比如10:15。</li>
<li>AM/PM指示符，比如10:15 PM。</li>
<li>特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。 除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。</li>
<li>标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。</li>
<li>文本日期，比如Jul 4或Dec 25，加不加年份均可。</li>
<li>可以指定时间增量（例如当前时间+25min；明天10:15 PM；10:15 + 7days）。</li>
</ol>
<p>在使用at命令时，该作业会被提交到作业队列（jobqueue）。作业队列会保存通过at命令提交的待处理的作业。针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a<sub>z和大写字母A</sub>Z来指代。作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。默认情况下，at的作业会被提交到a作业队列。如果想以更高优先级运行作业，可以用-q参数指定不同的队列字母。</p>
<h4 id="获取作业的输出">获取作业的输出</h4>
<p>当作业在Linux系统上运行时，显示器并不会关联到该作业。取而代之的是，Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给该用户。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>注：Ubuntu上可能没有安装<code>at</code>，需要自己手动安装。at命令会显示分配给作业的作业号以及为作业安排的运行时间。-f选项指明使用哪个脚本 文件，now指示at命令立刻执行该脚本。</p>
<p>使用e-mail作为at命令的输出极其不便。at命令利用sendmail应用程序来发送邮件。如果你的系统中没有安装sendmail，那就无法获得任何输出，因此在使用at命令时，最好在脚本中对STDOUT和STDERR进行重定向，如下例所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Test using at command</div><div class="line"></div><div class="line">echo "This script ran at $(date +%B%d,%T)" &gt; test13b.out</div><div class="line">echo &gt;&gt; test13b.out</div><div class="line">sleep 5</div><div class="line">echo "This is the script's end ..." &gt;&gt; test13b.out</div><div class="line"></div><div class="line">biotest@ubuntu:~/signal$ chmod u+x test13b.sh</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh now</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 3 at Sun May  6 05:10:00 2018</div><div class="line">biotest@ubuntu:~/signal$ cat test13b.out</div><div class="line">This script ran at May06,05:10:51</div><div class="line"></div><div class="line">This is the script's end ...</div></pre></td></tr></table></figure>
<p>如果不想在at命令中使用邮件或重定向，最好加上-M选项来屏蔽作业产生的输出信息。</p>
<h4 id="列出等待的作业">列出等待的作业</h4>
<p>atq命令可以查看系统中有哪些作业在等待，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh teatime</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 4 at Sun May  6 16:00:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh tomorrow</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 5 at Mon May  7 05:16:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh 13:30</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 6 at Sun May  6 13:30:00 2018</div><div class="line">biotest@ubuntu:~/signal$ at -M -f test13b.sh now</div><div class="line">warning: commands will be executed using /bin/sh</div><div class="line">job 7 at Sun May  6 05:16:00 2018</div><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">2	Sun May  6 05:06:00 2018 = biotest</div><div class="line">7	Sun May  6 05:16:00 2018 = biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div></pre></td></tr></table></figure>
<p>作业列表中显示了作业号、系统运行该作业的日期和时间及其所在的作业队列。</p>
<h4 id="删除作业">删除作业</h4>
<p>一旦知道了哪些作业在作业队列中等待，就能用 atrm 命令来删除等待中的作业。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">2	Sun May  6 05:06:00 2018 = biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div><div class="line">biotest@ubuntu:~/signal$ atrm 2</div><div class="line">Warning: deleting running job</div><div class="line">biotest@ubuntu:~/signal$ atq</div><div class="line">4	Sun May  6 16:00:00 2018 a biotest</div><div class="line">1	Sun May  6 05:06:00 2018 = biotest</div><div class="line">5	Mon May  7 05:16:00 2018 a biotest</div><div class="line">6	Sun May  6 13:30:00 2018 a biotest</div></pre></td></tr></table></figure>
<h3 id="cron时间表">cron时间表</h3>
<p>如果用户需要脚本在每天的同一时间运行或是每周一次、每月一次运行，就要使用cron程序来安排要定期执行的作业。cron程序会在后台运行并检查一个特殊的表（被称作cron时间表），以获知已安排执行的作业。</p>
<h4 id="cron时间表-1">cron时间表</h4>
<ol style="list-style-type: decimal">
<li>cron时间表采用一种特别的格式来指定作业何时运行。其格式为<code>min hour dayofmonth month dayofweek command</code>，cron时间表允许你用特定值、取值范围（比如1~5）或者是通配符（星号）来指定条目。</li>
<li>例如，如果想在每天的10:15运行一个命令，可以用cron时间表条目：<code>15 10 * * * command</code>，在<code>dayofmonth</code>、<code>month</code>以及<code>dayofweek</code>字段中使用了通配符，表明cron会在每个月每天的10:15执行该命令。要指定在每周一4:15PM运行的命令，可以用这样的命令，即<code>15 16 * * 1 command</code>。</li>
<li>可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）来指定dayofweek表项。 再看一个例子，如果要在每个月的第一天中午12点执行命令。可以用这样的命令，即<code>00 12 1 * * command</code>，dayofmonth表项指定月份中的日期值（1~31）。</li>
<li>如何设置一个在每个月的最后一天执行的命令，因为无法设置dayofmonth的值来涵盖所有的月份。常用的方法是加一条使用date 命令的 if-then 语句来检查明天的日期是不是01，如下所示：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 12 * * * if [ ` date +%d -d tomorrow `  = 01 ] ; then ; command</div></pre></td></tr></table></figure>
<p>上述这段代码会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令。</p>
<ol start="5" style="list-style-type: decimal">
<li>命令列表必须指定要运行的命令或脚本的全路径名。你可以像在普通的命令行中那样，添加任何想要的命令行参数和重定向符号。 <code>15 10 * * * /home/biotest/test4.sh &gt; test4out</code>，cron程序会用提交作业的用户账户运行该脚本。因此，用户必须有访问该命令和命令中指定的输出文件的权限。</li>
</ol>
<h4 id="构建cron时间表">构建cron时间表</h4>
<p>每个系统用户（包括root用户）都可以用自己的cron时间表来运行安排好的任务。Linux提供了crontab命令来处理cron时间表。要列出已有的cron时间表，可以用-l选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ crontab -l</div><div class="line">no crontab for biotest</div></pre></td></tr></table></figure>
<p>默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用-e选项。 在添加条目时，crontab命令会启用一个文本编辑器，使用已有的cron时间表作为文件内容，如果时间表不存在的话，它会新建一个空文件。</p>
<h4 id="浏览cron目录">浏览cron目录</h4>
<p>如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个基本目录：hourly、daily、monthly和weekly。 Ubuntu无此目录，略过。</p>
<h4 id="anacron程序">anacron程序</h4>
<p>cron程序的唯一问题是它假定Linux系统是7×24小时运行的。如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。要解决这个问题，许多Linux发行版还包含了anacron程序。如果anacron知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果Linux系统关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行。这个功能常用于进行常规日志维护的脚本。如果系统在脚本应该运行的时间刚好关机，日志文件就不会被整理，可能会变很大。通过anacron，至少可以保证系统每次启动时整理日志文件。anacron程序只会处理位于cron目录的程序，比如/etc/cron.monthly。它用时间戳来决定作业是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/anacron，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ sudo cat /var/spool/anacron/cron.monthly</div><div class="line">[sudo] password for biotest: </div><div class="line">20180427</div></pre></td></tr></table></figure>
<p>anacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/signal$ sudo cat /etc/anacrontab </div><div class="line"><span class="meta">#</span> /etc/anacrontab: configuration file for anacron</div><div class="line"></div><div class="line"><span class="meta">#</span> See anacron(8) and anacrontab(5) for details.</div><div class="line"></div><div class="line">SHELL=/bin/sh</div><div class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">HOME=/root</div><div class="line">LOGNAME=root</div><div class="line"></div><div class="line"><span class="meta">#</span> These replace cron's entries</div><div class="line">1	5	cron.daily	run-parts --report /etc/cron.daily</div><div class="line">7	10	cron.weekly	run-parts --report /etc/cron.weekly</div><div class="line">@monthly	15	cron.monthly	run-parts --report /etc/cron.monthly</div></pre></td></tr></table></figure>
<p>anacron时间表的基本格式和cron时间表略有不同，前者的格式为<code>period delay identifier command。</code></p>
<p>period条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。command条目包含了run-parts程序和一个cron脚本目录名。run-parts程序负责运行目录中传给它的任何脚本。注意，anacron不会运行位于/etc/cron.hourly的脚本。这是因为anacron程序不会处理执行时间需求小于一天的脚本。identifier条目是一种特别的非空字符串，如cron-weekly。它用于唯一标识日志消息和错误邮件中的作业。</p>
<h2 id="使用新-shell-启动脚本">使用新 shell 启动脚本</h2>
<p>如果每次运行脚本的时候都能够启动一个新的bashshell（即便只是某个用户启动了一个bashshell），将会非常的方便。有时候，用户希望为shell会话设置某些shell功能，或者只是为了确保已经设置了某个文件。用户登入bashshell时需要运行的启动文件基本上依照下列顺序所找到的第一个文件会被运行，其余的文件会被忽略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$HOME/.bash_profile </div><div class="line">$HOME/.bash_login </div><div class="line">$HOME/.profile</div></pre></td></tr></table></figure>
<p>因此，应该将需要在登录时运行的脚本放在上面第一个文件中。每次启动一个新shell时，bash shell都会运行.bashrc文件。可以这样来验证：在主目录下的.bashrc文件中加入一条简单的echo语句，然后启动一个新shell。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> source global definitions</div><div class="line">if [ -f /etc/bashrc ]; then</div><div class="line">          . /etc/bashrc</div><div class="line">fi</div><div class="line"><span class="meta">#</span> User specific aliases and functions</div><div class="line">echo "I'm in a new shell!"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash</div><div class="line">I&apos;m in a new shell!</div><div class="line">biotest@ubuntu:~$ exit</div><div class="line">exit</div></pre></td></tr></table></figure>
<p>.bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是当你登入bashshell时，另一次是当你启动一个bashshell时。如果你需要一个脚本在两个时刻都得以运行，可以把这个脚本放进该文件中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/03/Linux/Linux-shell05-理解shell的重定向/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/Linux/Linux-shell05-理解shell的重定向/" itemprop="url">Shell学习笔记（5）——理解Shell的重定向</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T00:00:01+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,079
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解输入与输出">理解输入与输出</h2>
<p>脚本的两种显示方法就是：第一，在显示器屏幕上显示输出；第二，将输出重定向到文件。这篇笔记主要是理解Linux如何处理输入与输出的。</p>
<h3 id="标准文件描述符">标准文件描述符</h3>
<p>Linux系统将每个对象当作文件处理，这就包括了输入和输出过程，Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，每个进程最多可以有9个文件描述符，而bash shell保留了前3个文件描述符，即0、1和2。</p>
<table>
<thead>
<tr class="header">
<th>文件描述符</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr class="even">
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr class="odd">
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
<p>这三个特殊文件描述符会处理脚本中的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</p>
<h3 id="stdin">STDIN</h3>
<p>STDIN文件描述符代表了shell的标准输入，对于终端来说，标准输入就是键盘，shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上的键输入的。许多bash命令能接受STDIN的输入，尤其是在命令行上指定文件的话。下面看一下<code>cat</code>这个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat</div><div class="line">test cat command</div><div class="line">test cat command</div><div class="line">cat command can input from keyboard</div><div class="line">cat command can input from keyboard</div></pre></td></tr></table></figure>
<p>当在命令行上只输入<code>cat</code>时，它会从<code>STDIN</code>接受僌，输入一行，<code>cat</code>命令就会显示出一行。但也可以通过<code>STDIN</code>重定向符号强制<code>cat</code>命令接受来自另一个非<code>STDIN</code>文件的输入，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat testfile </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div><div class="line">biotest@ubuntu:~/input$ cat &lt; testfile </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div></pre></td></tr></table></figure>
<p>这个结果显示，cat命令会用testfile文件中的行作为输入。</p>
<h3 id="stdout">STDOUT</h3>
<p><code>STDOUT</code>文件描述符代表shell的标准输出。在终端界面上，标准输出应时终显示器。Shell的所有输出（包括shell文中运行的程序和脚本）会被定向到标准输出中，也就是显示器。默认情况下，大多数bash命令会将输出导向STDOUT文件描述符，也可以使用输出重定向来改变，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -l &gt; test2</div><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div></pre></td></tr></table></figure>
<p>使用<code>&gt;&gt;</code>符号可以向一个文件中追加数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div><div class="line">biotest@ubuntu:~/input$ who</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">biotest@ubuntu:~/input$ who &gt;&gt; test2</div><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div></pre></td></tr></table></figure>
<p>当某个主文件不存在时，无产进行重定向，但会生成要重定向的文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al badfile &gt; test3</div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">biotest@ubuntu:~/input$ cat test3</div></pre></td></tr></table></figure>
<p>由于不存在badfile文件，因此bash无法获取里面的信息，也无法将其信息重定向到test3，但是test3这个文件会被创建，只是里面是空的。</p>
<h3 id="stderr">STDERR</h3>
<p><code>STDERR</code>文件描述符被设成2，可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al badfile 2&gt; test3</div><div class="line">biotest@ubuntu:~/input$ cat test3</div><div class="line">ls: cannot access 'badfile': No such file or directory</div></pre></td></tr></table></figure>
<p>此时，错误消息不会出现在屏幕上，该命令生怕任何错误消息都会保存在输出文件中，用这种方法，shell只重定向错误消息，而非普通数据。下面的一个案例是将<code>STDOUT</code>和<code>STDERR</code>消息混杂在同一个输出中的例子，如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test badtest test2 2&gt; test5</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">biotest@ubuntu:~/input$ cat test5</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div></pre></td></tr></table></figure>
<p>ls命令的正常<code>STDOUT</code>输出仍然公改善到默认的<code>STDOUT</code>文件描述符，也就是显示器，由于该命令将文件描述符2的输出（<code>STDERR</code>）重定向到了一个输出文件，shell将生成的所有错误消息直接改善到指定的重定向文件中。</p>
<h4 id="重定向错误和数据">重定向错误和数据</h4>
<p>如果想重定向错误和正常输出，需要用2个重定向符号，需要在符号前放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</div><div class="line">biotest@ubuntu:~/input$ cat test6</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div><div class="line">biotest@ubuntu:~/input$ cat test7</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest  55 May  5 19:48 test3</div></pre></td></tr></table></figure>
<p>在这个案例中，shell利用<code>1&gt;</code>符号将ls命令的正常输出重定向到了<code>test7</code>文件，而这些输出本该是进入<code>STDOUT</code>的。所有本该输出到<code>STDERR</code>的错误消息通过<code>2&gt;</code>符号被重定向到了<code>test6</code>文件。 这种方法哦可以将脚本的正常输出和脚本的错误消息分离开来。</p>
<p>除此之外，还可以将<code>STDERR</code>和<code>STDOUT</code>的输出重定向到同一个输出文件，可以使用特殊的重定向符号<code>$&gt;</code>，如下所示：：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test test2 test3 badtest &amp;&gt; test7</div><div class="line">biotest@ubuntu:~/input$ cat test7</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest  55 May  5 19:48 test3</div></pre></td></tr></table></figure>
<p>当使用<code>&amp;&gt;</code>符号哩主，命令生成的所有输出都会改善到同一位置，包括数据和错误。bash shell会自动赋予错误消息更高的优先级，在输出文件的最开头部分显示错误消息。</p>
<h2 id="在脚本中重定向输出">在脚本中重定向输出</h2>
<p>有2种方法在脚本中重定向输出，第一，临时重定向行输出；第二，永久重定向脚本中的所有命令。</p>
<h3 id="临时重定向">临时重定向</h3>
<p>如果脚本中意外生成错误消息，可以将单独的一行输出重定向到<code>STDERR</code>，在重定向到文件描述符时，需要在文件描述符前面添加一具<code>&amp;</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing STDERR messages</div><div class="line"></div><div class="line">echo "This is an error" &gt;&amp;2</div><div class="line">echo "This is normal output"</div></pre></td></tr></table></figure>
<p>运行过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test8.sh</div><div class="line">biotest@ubuntu:~/input$ ./test8.sh</div><div class="line">This is an error</div><div class="line">This is normal output</div><div class="line">biotest@ubuntu:~/input$ ./test8.sh 2&gt;test9</div><div class="line">This is normal output</div><div class="line">biotest@ubuntu:~/input$ cat test9</div><div class="line">This is an error</div></pre></td></tr></table></figure>
<p>从结果可以看出，STDOUT显示的文件会出现在屏幕上，而发送给STDERR的echo语句的文本则被重定向到了输出文件。这个方便适合在脚本中生成错误的消息。</p>
<h3 id="永久重定向">永久重定向</h3>
<p>如果脚本中有大量数据需要重定向，则可以使用<code>exec</code>命令告诉shell脚本执行期间重定向某个特定文件的描述符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting all output to a file</div><div class="line">exec 1&gt; testout</div><div class="line"></div><div class="line">echo "This is a test of redirecting all output"</div><div class="line">echo "from a script to another file."</div><div class="line">echo "without having to redirect every individual line"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test10.sh</div><div class="line">biotest@ubuntu:~/input$ ./test10.sh</div><div class="line">biotest@ubuntu:~/input$ cat testout</div><div class="line">This is a test of redirecting all output</div><div class="line">from a script to another file.</div></pre></td></tr></table></figure>
<p><code>exec</code>命令会启动一个新的shell，并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。可以在脚本执行过程中重定向STDOUT，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting output to different locatons</div><div class="line"></div><div class="line">exec 2&gt; testerror</div><div class="line"></div><div class="line">echo "This is the start of the script"</div><div class="line">echo "now redirecting all output to another location"</div><div class="line"></div><div class="line">exec 1&gt; testout</div><div class="line"></div><div class="line">echo "THis output should go to the testout file"</div><div class="line">echo "but this should go to the testerror file" &gt;&amp;2</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test11.sh</div><div class="line">biotest@ubuntu:~/input$ ./test11.sh</div><div class="line">This is the start of the script</div><div class="line">now redirecting all output to another location</div><div class="line">biotest@ubuntu:~/input$ cat testerror</div><div class="line">but this should go to the testerror file</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将发给STDERR的输出重定向到了文件testerror，接下来，脚本用echo语句向STDOUT显示了几行文本，随后再次使用exec命令来将STDOUT重定向到了testout文件，虽然STDOUT被重定向了，但仍然可以将echo语句的输出发给STDERR，在此案例中，重定向到了testerror文件。</p>
<h2 id="在脚本中重定向输入">在脚本中重定向输入</h2>
<p>在脚本中可以使用与重向STDOUT和STDERR同样的方法来将STDIN从键盘重定向到其他位置。exec命令可以将STDIN重定向到linux系统上的文件中，用法是<code>exec 0&lt; testfile</code>，这个命令会告诉shell应该从文件testfile中获得输入，而不是<code>STDIN</code>，这个重定向只要在脚本需要输入时就会作用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting fiel input</div><div class="line"></div><div class="line">exec 0&lt; testfile</div><div class="line">count=1</div><div class="line"></div><div class="line">while read line</div><div class="line">do</div><div class="line">    echo "Line #$count: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test12.sh</div><div class="line">biotest@ubuntu:~/input$ ./test12.sh</div><div class="line">Line #1: This is the first line.</div><div class="line">Line #2: This is the second line.</div><div class="line">Line #3: This is the third line.</div></pre></td></tr></table></figure>
<p>将<code>STDIN</code>重定向到文件后，当read命令试图从STDIN读入数据时，它会到文件中去读取数据，而不是键盘。</p>
<h2 id="创建自己的重定向">创建自己的重定向</h2>
<p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符（即0，1和2）。shell中最多可以有9个打开的文件描述符。其他6个从 3 ~ 8 的文件描述符均可用作输入或输出重定向。用户可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>
<h3 id="创建输出文件描述符">创建输出文件描述符</h3>
<p>exec 命令可以给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using an alternative file descriptor</div><div class="line"></div><div class="line">exec 3&gt;test13out</div><div class="line"></div><div class="line">echo "This should display on the monitor"</div><div class="line">echo "and this should be stored in the file" &gt;&amp;3</div><div class="line">echo "Then this shold be back on the monitor"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test13.sh</div><div class="line">biotest@ubuntu:~/input$ ./test13.sh</div><div class="line"></div><div class="line">This should display on the monitor</div><div class="line">Then this shold be back on the monitor</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat test13out</div><div class="line">and this should be stored in the file</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内容会像预想中那样显示在STDOUT 上。但你重定向到文件描述符3 的那行echo语句的输出却进入了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如日志文件）。 也可以不用创建文件，使用exec命令来将输出追加到现有文件早，例如<code>exec 3&gt;&gt; test13out</code>。</p>
<h3 id="重定向文件描述符">重定向文件描述符</h3>
<p>看一个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> storing STDOUT, then coming back to it</div><div class="line"></div><div class="line">exec 3&gt;&amp;1 # 将文件描述符3重定向到文件描述符1的位置，也就是STDOUT，这意味着任何发送给文件描述符3的输出都将会出现在显示器上</div><div class="line"></div><div class="line">exec 1&gt; test14out # 将STDOUT重定向到文件，shell现在会将改善给STDOUT的输出直接重定向到输出文件上，但文件描述符3仍然指向STDOUT原来的位置，也就是显示器，如果此时将输出数据改善给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了</div><div class="line"></div><div class="line">echo "This should store in the output file"</div><div class="line">echo "along with this line."</div><div class="line"></div><div class="line">exec 1&gt;&amp;3</div><div class="line"><span class="meta">#</span> 在向STDOUT发送一些输出后，脚本将STDOUT重定向到文件描述符3的当前位置（显示器），这意味着现在STDOUT又指向了原来的位置，即显示器</div><div class="line"></div><div class="line">echo "Now things should be back to normal"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test14.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test14.sh </div><div class="line">Now things should be back to normal</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat test14out </div><div class="line">This should store in the output file</div><div class="line">along with this line.</div></pre></td></tr></table></figure>
<h3 id="创建输入文件描述符">创建输入文件描述符</h3>
<p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将 STDIN 文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将 STDIN 恢复到它原来的位置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting input file descriptors</div><div class="line"></div><div class="line">exec 6&lt;&amp;0</div><div class="line"></div><div class="line">exec 0&lt; testfile</div><div class="line"></div><div class="line">count=1</div><div class="line">while read line </div><div class="line">do</div><div class="line">    echo "Line #$cont: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">exec 0&lt;&amp;6</div><div class="line">read -p "Are you done now " answer</div><div class="line">case $answer in </div><div class="line">Y|y) echo "Goodbye";;</div><div class="line">N|n) echo "Sorry, this is the end.";;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test15.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test15.sh</div><div class="line">Line #: This is the first line.</div><div class="line">Line #: This is the second line.</div><div class="line">Line #: This is the third line.</div><div class="line">Are you done now Y</div><div class="line">Goodbye</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test15.sh</div><div class="line">Line #: This is the first line.</div><div class="line">Line #: This is the second line.</div><div class="line">Line #: This is the third line.</div><div class="line">Are you done now n</div><div class="line">Sorry, this is the end.</div></pre></td></tr></table></figure>
<p>在这个案例中，文件描述符6用来保存STDIN的位置，然后脚本将STDIN重定向到一个文件，read命令的所有输入都来自重定向后的STDIN（也就是输入文件），在读取了所有行之后，脚本将STDIN重定向到文件描述符6，从而将STDIN恢复到原来的位置，该脚本用了另外一个read命令来测试STDIN是否恢复正常，这将它等待键盘的输入。</p>
<h3 id="创建读写文件描述符">创建读写文件描述符</h3>
<p>在bash shell中，可以打开单个文件描述符来作为输入和输出，可以用一个文件描述符对同一个文件进行读写，不过使用这种方法需要谨慎，由于用户是对一个文件进行数据读写，shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始，如果不够小心，会生成严重的后果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing input/output file descriptor</div><div class="line"></div><div class="line">exec 3&lt;&gt; testfile</div><div class="line">read line &lt;&amp;3</div><div class="line">echo "Read: $line"</div><div class="line">echo "This is a test line" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test16.sh </div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test16.sh</div><div class="line">Read: This is the first line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is a test line</div><div class="line">ine.</div><div class="line">This is the third line.</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将文件描述符分配文件testfile以进行文件读写，接下来，通过使用分配好的文件描述符，使read命令读取文件中的第一行，然后将这一行显示在STDOUT上，最后使用echo语句将一行数据写入由同一个文件描述符打开的文件中。在运行结果中，开始运行正常，输出内容表明脚本读取了testfile文件中的第一行，如果脚本运行完毕，查看testfile文件时发现，写入文件中的数据覆盖了已有的数据。原因是，当脚本向中文件中写入数据时，它会从文件指针所处的位置开始，read命令读取了第一行数据，所以它使得文件指针指向了第二行数据的第一个字符，在echo语句将数据输出到文件时，它会将数据放在文件指针的当前位置，覆盖了该位置的已有数据。</p>
<h3 id="关闭文件描述符">关闭文件描述符</h3>
<p>如果用户创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们，有些情况下需要在脚本关闭之前手动关闭文件描述符，要关闭文件描述符，将它重定向到特殊符号<code>&amp;-</code>，在脚本中是这样的<code>exec 3&gt;&amp;-</code>，这条语句会关闭文件描述符3，不再脚本中使用它，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing closing file descriptors</div><div class="line"></div><div class="line">exec 3&gt; tets17file</div><div class="line"></div><div class="line">echo "This is a test line of data " &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">echo "This won't work" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash badtest2.sh </div><div class="line">badtest2.sh: line 9: 3: Bad file descriptor</div></pre></td></tr></table></figure>
<p>一旦关闭了文件描述符，就无法在脚本中写入任何数据，否则shell会生成错误消息。在关闭文件描述符时还需要注意，如果在随后的脚本中打开了同一个输出文件，shell会用一个新文件来替换已有的文件，这就意味着，如果输出数据，它就会覆盖已有鹰爪，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing closing file descriptors</div><div class="line"></div><div class="line">exec 3&gt; test17file</div><div class="line">echo "This is a test line of test" &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">cat test17file</div><div class="line"></div><div class="line">exec 3&gt;test17file</div><div class="line">echo "This will be bad" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test17.sh</div><div class="line">This is a test line of test</div><div class="line">biotest@ubuntu:~/input$ cat test17file</div><div class="line">This will be bad</div></pre></td></tr></table></figure>
<p>在向test17file文件发送一个数据字符串并关闭该文件描述符之后，脚本用了 cat 命令来显示文件的内容。下一步，脚本重新打开了该输出文件并向它发送了另一个数据字符串。当显示该输出文件的内容时，你所能看到的只有第二个数据字符串。shell覆盖了原来的输出文件。</p>
<h2 id="列出打开的文件描述符">列出打开的文件描述符</h2>
<p>bash shell中有一个<code>lsof</code>命令，这个命令会列出整个Linux系统打开的所有文件描述符，<code>lsof</code>命令位于<code>/usr/sbin</code>目录中，这个命令会产生大量的输出，它会显示Linux系统中打开的每个文件的有产信息，这包括后台运行的所有进程，以及登录到系统的任何用户。<code>lsof</code>有各种命令选项和参数可以使用，最常用的是<code>-p</code>和<code>-d</code>，前者用于指定进程ID（即PID），后者用于指定显示的文件描述符编号，如果要知道进程的当前PID，可以使用特殊的环境变量<code>$$</code>（shell会将它设为当前PID），<code>-a</code>选项用来对其他两个选项的结果执行布尔<code>AND</code>运算，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ lsof -a -p $$ -d 0,1,2</div><div class="line">COMMAND   PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</div><div class="line">bash    10009 biotest    0u   CHR  136,4      0t0    7 /dev/pts/4</div><div class="line">bash    10009 biotest    1u   CHR  136,4      0t0    7 /dev/pts/4</div><div class="line">bash    10009 biotest    2u   CHR  136,4      0t0    7 /dev/pts/4</div></pre></td></tr></table></figure>
<p>结果显示了当前进程的国俯文件描述符（0、1和2），lsof的默认输出有7列信息，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COMMAND</td>
<td>正在运行的命令名的前9个字符</td>
</tr>
<tr class="even">
<td>PID</td>
<td>进程的PID</td>
</tr>
<tr class="odd">
<td>USER</td>
<td>进程属主的登录名</td>
</tr>
<tr class="even">
<td>FD</td>
<td>文件描述符号以及访问类型（r代表读，w代表写，u代表读写）</td>
</tr>
<tr class="odd">
<td>TYPE</td>
<td>文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）</td>
</tr>
<tr class="even">
<td>DEVICE</td>
<td>设备的设备号（主设备号和从设备号）</td>
</tr>
<tr class="odd">
<td>SIZE</td>
<td>如果有的话，表示文件的大小</td>
</tr>
<tr class="even">
<td>NODE</td>
<td>本地文件的节点号</td>
</tr>
<tr class="odd">
<td>NAME</td>
<td>文件名</td>
</tr>
</tbody>
</table>
<p>与 STDIN 、 STDOUT 和 STDERR 关联的文件类型是字符型。因为 STDIN 、 STDOUT 和 STDERR 文 件描述符都指向终端，所以输出文件的名称就是终端的设备名。现在看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing lsof with file descriptors</div><div class="line"></div><div class="line">exec 3&gt; test18file1</div><div class="line">exec 6&gt; test18file2</div><div class="line">exec 7&lt; testfile</div><div class="line"></div><div class="line">lsof -a -p $$ -d0,1,2,3,6,7</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test18.sh</div><div class="line">COMMAND   PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</div><div class="line">bash    28264 biotest    0u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    1u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    2u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    3w   REG    8,1        0 928519 /home/biotest/input/test18file1</div><div class="line">bash    28264 biotest    6w   REG    8,1        0 928521 /home/biotest/input/test18file2</div><div class="line">bash    28264 biotest    7r   REG    8,1       73 928491 /home/biotest/input/testfile</div></pre></td></tr></table></figure>
<p>这个脚本创建了3个替代性文件描述符，两个是输出（3和6），一个是输入（7），在脚本运行了<code>lsof</code>命令时，可以在输出中看到新的文件描述符，如果去掉输出中的第一部分，就会看到文件名的结果，文件名显示了文件描述符所使用的文件的完整路径名，它将每个文件都显示成了REG类型，这就说明它们是文件系统中的常规文件。</p>
<h2 id="阻止命令输出">阻止命令输出</h2>
<p>有些情况下，用户不想显示脚本的输出。这在将脚本作为后台进程运行时很常见，如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al &gt; /dev/null</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null</div><div class="line">biotest@ubuntu:~/input$ ls -al badfile2 test16.sh 2&gt; /dev/null</div><div class="line">-rwxrw-r-- 1 biotest biotest 135 May  5 23:28 test16.sh</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null</div><div class="line">biotest@ubuntu:~/input$</div></pre></td></tr></table></figure>
<p>也可以在输入重定向中将<code>dev/null</code>作为输入文件，由于<code>dev/null</code>文件不含有任何内容，用户通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is a test line</div><div class="line">ine.</div><div class="line">This is the third line.</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null &gt; testfile</div><div class="line">biotest@ubuntu:~/input$ cat testfile</div></pre></td></tr></table></figure>
<p>文件testfile仍然存在于系统上，但现在是空文件，这是清除日志文件的一个常用的方法。</p>
<h2 id="创建临时文件">创建临时文件</h2>
<p>Linux系统有特殊的目录，专供临时文件使用。Linux使用/tmp目录来存放不需要永久保留的文件。系统上的任何用户账户都有权限在读写/tmp目录中的文件。这个特性为用户提供了一种创建临时文件的简单方法，而且还不用操心清理工作。有个特殊命令可以用来创建临时文件。mktemp命令可以在/tmp目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的umask值（参见第7章）。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。一旦创建了文件，你就在脚本中有了完整的读写权限，但其他人没法访问它（当然，root用户除外）。</p>
<h3 id="创建本地临时文件">创建本地临时文件</h3>
<p>默认情况下，<code>mktemp</code>会在本地目录中创建一个文件，要用<code>mktemp</code>在本地目录中创建一个临时文件，只要指定一个文件名模板就行了，模板可以包含任意文本文件名，在文件名末尾加上6个x就行了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.ATlZBX</div><div class="line">biotest@ubuntu:~/input$ ls -al testing*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:32 testing.ATlZBX</div></pre></td></tr></table></figure>
<p><code>mktemp</code>命令会用6个字符码替换这6个x，从而保证文件名在目录中是唯一的。用户可以创建多个临床文件，这种用法可以使每个文件名都是唯一的。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.EWLscI</div><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.Y6pjo8</div><div class="line">biotest@ubuntu:~/input$ ls -al testing*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:32 testing.ATlZBX</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:37 testing.EWLscI</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:37 testing.Y6pjo8</div></pre></td></tr></table></figure>
<p>在脚本中使用<code>mktemp</code>命令可以将文件名保存到变量中，这样就可以在后面的脚本中引用了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> creating and using a temp file</div><div class="line"></div><div class="line">tempfile=$(mktemp test19.XXXXXX)</div><div class="line"></div><div class="line">exec 3&gt;$tempfile</div><div class="line">echo "This script writes to temp file $tempfile"</div><div class="line"></div><div class="line">echo "This is the first line" &gt;&amp;3</div><div class="line">echo "This is the second line" &gt;&amp;3</div><div class="line">echo "This is the last line" &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">echo "Done creating temp file. The contents are: "</div><div class="line">cat $tempfile</div><div class="line">rm -f $tempfile 2&gt; /dev/null</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test19.sh</div><div class="line">This script writes to temp file test19.RyVPfD</div><div class="line">Done creating temp file. The contents are: </div><div class="line">This is the first line</div><div class="line">This is the second line</div><div class="line">This is the last line</div><div class="line">biotest@ubuntu:~/input$ ls -al test19*</div><div class="line">-rw-rw-r-- 1 biotest biotest 354 May  6 00:40 test19.sh</div></pre></td></tr></table></figure>
<p>在这个脚本中，使用mktemp命令创建临时文件，并将文件名赋给<code>$tempfile</code>变量，接着将这个临时文件作为文件描述3的输出重定向文件，在将临时文件名显示在STDOUT之后，向中临时文件中写入了几行文本，然后关闭了文件描述符，最后显示出临时文件的内容，并用<code>rm</code>命令将其删除。</p>
<h3 id="在tmp目录创建临时文件">在<code>/tmp</code>目录创建临时文件</h3>
<p><code>-t</code>选项会强制mktemp命令在系统的临时目录来创建文件，在使用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不是仅有文件名，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp -t test.XXXXXX</div><div class="line">/tmp/test.oL5jbT</div><div class="line">biotest@ubuntu:~/input$ ls -al /tmp/test*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:45 /tmp/test.oL5jbT</div></pre></td></tr></table></figure>
<p>由于mktemp返回了全路径，因此用户可以在Linux系统的任意目录下引用该临时文件，不管目录在哪里，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> creating a temp file in /tmp</div><div class="line"></div><div class="line">tempfile=$(mktemp -t tmp.XXXXXX)</div><div class="line"></div><div class="line">echo "This is a test file." &gt; $tempfile</div><div class="line">echo "This is the second line of the test." &gt;&gt; $tempfile</div><div class="line"></div><div class="line">echo "The temp file is located at: $tempfile"</div><div class="line">cat $tempfile</div><div class="line">rm -f $tempfile</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test20.sh</div><div class="line">The temp file is located at: /tmp/tmp.4hLOyR</div><div class="line">This is a test file.</div><div class="line">This is the second line of the test.</div></pre></td></tr></table></figure>
<p>mktemp创建了临时文件时，它会返回全路径给变量，这样就可以在任何命令中使用该值来引用临时变量了。</p>
<h3 id="创建临时目录">创建临时目录</h3>
<p><code>-d</code>选项告诉mktemp命令来创建一个临时目录，而不是临时文件，这样就能用此目录进行任何需要的操作，体积如创建其他的临时文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a temporary directory</div><div class="line"></div><div class="line">tempdir=$(mktemp -d dir.XXXXXX)</div><div class="line">cd $tempdir</div><div class="line">tempfile1=$(mktemp temp.XXXXXX)</div><div class="line">tempfile2=$(mktemp temp.XXXXXX)</div><div class="line">exec 7&gt; $tempfile1</div><div class="line">exec 8&gt; $tempfile2</div><div class="line"></div><div class="line">echo "Sending data to directory $tempdir"</div><div class="line">echo "This is a test line of data for $tempfile1" &gt;&amp;7</div><div class="line">echo "This is a test line of data for $tempfile2" &gt;&amp;8</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test21.sh</div><div class="line">Sending data to directory dir.4ZeP0T</div><div class="line">biotest@ubuntu:~/input$ ls -al</div><div class="line">drwx------  2 biotest biotest 4096 May  6 01:02 dir.4ZeP0T</div><div class="line">... ...</div><div class="line">-rw-rw-r--  1 biotest biotest   29 May  5 23:41 tets17file</div><div class="line">biotest@ubuntu:~/input$ cd dir.4ZeP0T</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ls</div><div class="line">temp.7KoQoD  temp.jj2vb1</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat temp.7KoQoD </div><div class="line">This is a test line of data for temp.7KoQoD</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat temp.jj2vb1 </div><div class="line">This is a test line of data for temp.jj2vb1</div></pre></td></tr></table></figure>
<p>这段脚本在当前目录创建了一个目录，然后它用cd命令进入该目录，并创建了两个临时文件。之后这两个临时文件被分配给文件描述符，用来存储脚本的输出。</p>
<h2 id="记录消息">记录消息</h2>
<p>有时候需要将输出同时发送到显示器和日志文件，此时需要<code>tee</code>命令。tee在英文就是T的意思，在Linux中，这个命令相当于管道一个T接头，它将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是tee命令所指定的文件名<code>tee filename</code>，由于tee会重定向来自STDIN的数据，可以用它配合管道命令来重定向命令输出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ date | tee testfile2</div><div class="line">Sun May  6 01:12:57 PDT 2018</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">Sun May  6 01:12:57 PDT 2018</div></pre></td></tr></table></figure>
<p>输出出现在了STDOUT中，同时也写入了指定的文件中，默认情况下，tee命令会在每次使用时覆盖输出文件的内容，如下挂满：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ who | tee testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div></pre></td></tr></table></figure>
<p>如果需要追加数据，则要使用<code>-a</code>参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ date | tee -a testfile2</div><div class="line">Sun May  6 01:14:55 PDT 2018</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">Sun May  6 01:14:55 PDT 2018</div></pre></td></tr></table></figure>
<p>看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the tee command for logging </div><div class="line"></div><div class="line">tempfile=test22file</div><div class="line"></div><div class="line">echo "This is the start of the test" |tee $tempfile</div><div class="line">echo "This is the second line of the test" | tee -a $tempfile</div><div class="line">echo "This is the end of the test" | tee -a $tempfile</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ bash test22.sh</div><div class="line">This is the start of the test</div><div class="line">This is the second line of the test</div><div class="line">This is the end of the test</div><div class="line"></div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat test22file</div><div class="line">This is the start of the test</div><div class="line">This is the second line of the test</div><div class="line">This is the end of the test</div></pre></td></tr></table></figure>
<p>从结果可以看出，用户显示输出的同时，还能保存一份输出内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/02/Linux/Linux-shell03-break几层循环的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Linux/Linux-shell03-break几层循环的理解/" itemprop="url">break n层循环的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T12:13:54+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生物信息学/" itemprop="url" rel="index">
                    <span itemprop="name">生物信息学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  590
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Shell脚本的break与continue语句时，有一些困惑，就是<code>break n</code>可以跳出几层循环的问题，continue也是如此。不过弄懂了<code>break n</code>的问题，<code>continue n</code>的问题应该也清楚了。</p>
<p>第一步：<code>break 1</code>。</p>
<p>新建一个<code>loop.sh</code>脚本，输入以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 1</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 1 the out cycle is 2,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 2,and inner cycle is 2</div><div class="line">The m cycle is 1 the out cycle is 3,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 3,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 2,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 2,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 3,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 3,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>第二步：<code>break 2</code>。</p>
<p>现在将<code>break 1</code>改为<code>break 2</code>，运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 2</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 2 the out cycle is 1,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>第三步，<code>break 3</code>。</p>
<p>现在将<code>break 2</code>改为<code>break 3</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line">for ((m=1;m&lt;=2;m++))</div><div class="line">do</div><div class="line">   for((j=1;j&lt;=3;j++))</div><div class="line">        do</div><div class="line">            for ((i=1;i&lt;=4;i++))</div><div class="line">                do</div><div class="line">                    if [ $i -eq 3 ]</div><div class="line">                    then</div><div class="line">                       break 3</div><div class="line">                    fi</div><div class="line">                    echo "The m cycle is $m the out cycle is $j,and inner cycle is $i"</div><div class="line">                done</div><div class="line">         done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash loop.sh </div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 1</div><div class="line">The m cycle is 1 the out cycle is 1,and inner cycle is 2</div></pre></td></tr></table></figure>
<p>从上面的结果可以看出来：①最内层的是第1层循环，再次是第2层循环，最外层就是第3层循环。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/02/Linux/Linux-shell04-处理用户输入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Linux/Linux-shell04-处理用户输入/" itemprop="url">Shell学习笔记（4）——处理用户输入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T12:12:54+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,003
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="命令行参数">命令行参数</h2>
<p>脚本还可以接受一些参数。向shell脚本传递数据的最基本方法是使用命令行参数，命令行参数就像是一些常规的Linux命令一样，例如<code>head -20 file001.sh</code>，在一条命令上，head命令就能接收一个<code>-20</code>的参数，用户自己定义的脚本，也可以接收一定的参数。</p>
<h3 id="读取参数">读取参数</h3>
<h4 id="第1个案例读取1个参数">第1个案例：读取1个参数</h4>
<p>bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数，这也包括shell所执行的脚本名称，位于参数变量是标准的数据，其中，<code>$0</code>是程序名，<code>$1</code>是第1个参数，<code>$2</code>是第2个参数，直到第9个参数，即<code>$9</code>。下面的案例是shell脚本中使用单个命令行参数的例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using one command line parameter</div><div class="line"><span class="meta">#</span> </div><div class="line"></div><div class="line">factorial=1</div><div class="line"></div><div class="line">for (( number=1; number &lt;= $1;number++ )) </div><div class="line"><span class="meta">#</span> 这里的$1指的是脚本运行过程中输入的参数，在后面的运行过程中，输入5</div><div class="line"> do</div><div class="line">    factorial=$[ $factorial*$number ]</div><div class="line"> done</div><div class="line"> echo The factorial of $1 is $factorial</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test1.sh 5</div><div class="line">The factorial of 5 is 120</div></pre></td></tr></table></figure>
<p>运行过程：第1次：factorial=1，number=1；第2次：n=2，f=2；第3次：n=3，f=6；第4次：n=4,f=24；第5次：n=5；f=120。</p>
<h4 id="第2个案例读取2个及以上参数">第2个案例：读取2个及以上参数</h4>
<p>如果要读取更多的参数，需要将每个参数用空格分开，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing two command line parameters</div><div class="line"><span class="meta">#</span></div><div class="line">total=$[ $1*$2 ]</div><div class="line">echo The first parameter is $1.</div><div class="line">echo The second parameter is $2.</div><div class="line">echo The total value is $total.</div></pre></td></tr></table></figure>
<p>运行结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The first parameter is 2.</div><div class="line">The second parameter is 5.</div><div class="line">The total value is 10.</div></pre></td></tr></table></figure></p>
<h4 id="第3个案例使用字符串作为变量">第3个案例，使用字符串作为变量</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> testing string parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo Hello $1, glad to meet you.</div></pre></td></tr></table></figure>
<p>运行结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh Zhang</div><div class="line">Hello Zhang, glad to meet you.</div></pre></td></tr></table></figure></p>
<p>在这个案例中，使用了字符串作为脚本的参数，但是，如果参数中含有空格，则会出现问题，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh Zhang San</div><div class="line">Hello Zhang, glad to meet you.</div></pre></td></tr></table></figure></p>
<p>脚本只识别了Zhang，没有识别出完整的Zhang San，因为shell脚本会把空格分隔开的字符串当成两个参数，如果要使含有空格的字符串当成一个，需要添加引号，如下所示；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test3.sh &apos;Zhang San&apos;</div><div class="line">Hello Zhang San, glad to meet you.</div></pre></td></tr></table></figure>
<h4 id="第4个案例参数大于9个">第4个案例：参数大于9个</h4>
<p>如果脚本需要的命令行参数大于9个，此时需要在变量数字周围加上花括号，例如<code>${``10``}</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> handling lots of paramerters</div><div class="line"><span class="meta">#</span></div><div class="line">total=$[ $&#123;10&#125;*$&#123;11&#125; ]</div><div class="line">echo The tenth parameter is $&#123;10&#125;</div><div class="line">echo The eleventh parameter is $&#123;11&#125;</div><div class="line">echo The total is $total</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test4.sh 1 2 3 4 5 6 7 8 9 10 11 12</div><div class="line">The tenth parameter is 10</div><div class="line">The eleventh parameter is 11</div><div class="line">The total is 110</div></pre></td></tr></table></figure></p>
<h4 id="第5个案例读取脚本名">第5个案例：读取脚本名</h4>
<h5 id="参数的意义"><code>$0</code>参数的意义。</h5>
<p><code>$0</code>参数用于获取shell在命令行启动的脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing the $0 parameter</div><div class="line"><span class="meta">#</span></div><div class="line">echo The zero parameter is set to:$0</div></pre></td></tr></table></figure>
<p>需要注意的是，如果使用完整路径运行脚本，则<code>$0</code>就是完整脚本，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash /home/biotest/userdata/test5.sh</div><div class="line">The zero parameter is set to:/home/biotest/userdata/test5.sh</div></pre></td></tr></table></figure>
<h5 id="basename命令可以补充0参数的局限"><code>basename</code>命令可以补充<code>$0</code>参数的局限</h5>
<p>如果要写一个根据脚本名来执行不同功能的脚本，则就需要注意把脚本的运行路径给剥离掉，shell中有一个命令可以考虑，即<code>basename</code>命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Using basename with the $0 parameter</div><div class="line"><span class="meta">#</span></div><div class="line">name=$(basename $0)</div><div class="line">echo</div><div class="line">echo The script name is: $name</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test5b.sh</div><div class="line">The script name is: test5b.sh</div><div class="line">biotest@ubuntu:~/userdata$ bash /home/biotest/userdata/test5b.sh</div><div class="line">The script name is: test5b.sh</div></pre></td></tr></table></figure>
<p>从结果可以看出来，使用了<code>basename</code>命令后，即使运行脚本时输入全路径，<code>$0</code>也只是脚本的名称。</p>
<h5 id="相对路径与绝对路径的案例">相对路径与绝对路径的案例</h5>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing a Multi-function script</div><div class="line"><span class="meta">#</span></div><div class="line">name=$(basename $0)</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $name = "addem" ]</div><div class="line">then</div><div class="line">    total=$[ $1 + $2 ]</div><div class="line"><span class="meta">#</span></div><div class="line">elif [ $name = "multem" ]</div><div class="line">then</div><div class="line">    total=$[ $1*$2 ]</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">echo The calculated value is $total</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cp test6.sh addem</div><div class="line">biotest@ubuntu:~/userdata$ chmod u+x addem</div><div class="line">biotest@ubuntu:~/userdata$ ln -s test6.sh multem</div><div class="line">biotest@ubuntu:~/userdata$ ls -l *em</div><div class="line">-rwxrw-r-- 1 biotest biotest 224 May  1 10:48 addem</div><div class="line">lrwxrwxrwx 1 biotest biotest   8 May  1 10:48 multem -&gt; test6.sh</div><div class="line">biotest@ubuntu:~/userdata$ bash addem 2 5</div><div class="line">The calculated value is 7</div><div class="line">biotest@ubuntu:~/userdata$ sudo bash ./multem 2 5</div><div class="line">The calculated value is 10</div></pre></td></tr></table></figure>
<p>结果解释：第一，<code>cp test6.sh addem</code>复制<code>test6.sh</code>脚本，新生成的文件命令为<code>addem</code>；第二，<code>chmod u+x addem</code>，将<code>addem</code>文件权限更改为可执行；第三，<code>ln -s test6.sh multem</code>，其中<code>ln</code>是为文件创建链接，<code>-s</code>表示软连接，可以理解为Linux的快捷方式；第四，当执行<code>addem 2 5</code>时，执行<code>total=$[ $1 + $2 ]</code>语句，如果是<code>bash ./multem 2 5</code>，则执行<code>total=$[ 41*$2 ]</code>语句。</p>
<h4 id="测试参数">测试参数</h4>
<p>当脚本认为参数变量中会有数据，而实际上没有时，脚本就有可能会产生错误消息。通常要避免这种脚本的写法，在使用参数前一定要检查其中是否存在为数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat test7.sh</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing parameters befoire user</div><div class="line"><span class="meta">#</span></div><div class="line"> if [ -n "$1" ]</div><div class="line">then</div><div class="line">    echo Hello $1, gload to meet you.</div><div class="line">else</div><div class="line">    echo "Sorry you did not identify yourself."</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test7.sh Zhang</div><div class="line">Hello Zhang, gload to meet you.</div><div class="line">biotest@ubuntu:~/userdata$ bash test7.sh</div><div class="line">Sorry you did not identify yourself.</div></pre></td></tr></table></figure>
<p>代码解释：在<code>if</code>语句中使用了<code>if [ -n &quot;$1&quot; ]</code>语句，这里的<code>-n</code>是用于判断<code>$1</code>中是否有数据。</p>
<h2 id="特殊参数变量">特殊参数变量</h2>
<p>在bash shell中有一些变量，它们会记录命令行参数。</p>
<h3 id="参数统计基本用法">参数统计基本用法</h3>
<p>bash shell有一个特殊的变量，可以记录命令行中输入了多少个参数，其中这个特殊变量就是<code>$#</code>，哦可以肝脚本中任何地方使用这个特殊的变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> getting the number of parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo There were $# parameters supplied.</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh</div><div class="line">There were 0 parameters supplied.</div><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh 1 2 3 4 5 6 7</div><div class="line">There were 7 parameters supplied.</div><div class="line">biotest@ubuntu:~/userdata$ bash test8.sh &quot;Zhang San&quot;</div><div class="line">There were 1 parameters supplied.</div></pre></td></tr></table></figure>
<h3 id="参数统计案例">参数统计案例</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>/bin/bash</div><div class="line"><span class="meta">#</span> Testing parameters</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $# -ne 2 ] # -ne测试命令行参数的数量，-ne是检查$#是否不等于2，ne相当于non-equal</div><div class="line">then</div><div class="line">    echo</div><div class="line">    echo Usage: test9..sh a b</div><div class="line">    echo</div><div class="line">else</div><div class="line">    total=$[ $1 + $2 ]</div><div class="line">    echo</div><div class="line">    echo The total is $total</div><div class="line">    echo</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh </div><div class="line">Usage: test9..sh a b</div><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh 10</div><div class="line">Usage: test9..sh a b</div><div class="line">biotest@ubuntu:~/userdata$ bash test9.sh 10 10 15</div><div class="line">Usage: test9..sh a b</div></pre></td></tr></table></figure>
<p>需要注意的是，如果认为<code>$#</code>变量含有参数的总数，而变量<code>$\{$#\}</code>代表了最后一个命令行参数变量，那就会出错，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing grabbing last parameter</div><div class="line"><span class="meta">#</span></div><div class="line">echo The last parameter was $&#123;$#&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash badtest1.sh 10</div><div class="line">The last parameter was 19343</div></pre></td></tr></table></figure>
<p>结果是19343，这说明，在花括号内不能使用美元符号，除非按照下面的方式进行修改，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Grabbing the last parameter</div><div class="line"><span class="meta">#</span></div><div class="line">params=$#</div><div class="line">echo</div><div class="line">echo The last parameter is $params</div><div class="line">echo The last parameter is $&#123;!#&#125;</div><div class="line">echo</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test10.sh 1 2 3 4 5 6</div><div class="line">The last parameter is 6</div><div class="line">The last parameter is 6</div><div class="line"></div><div class="line">biotest@ubuntu:~/userdata$ bash test10.sh</div><div class="line">The last parameter is 0</div><div class="line">The last parameter is test10.sh</div></pre></td></tr></table></figure>
<p>从结果来看，如果将<code>$#</code>变量的值赋给了变量<code>params</code>，然后也按特殊命令行参数变量的格式（即使用<code>$/{!#/}</code>）使用了该变量，结果就能正常显示。但是，当脚本没有参数时，<code>$#</code>的值为0，params变量的值也一样，但<code>$\{!#\}</code>变量的返回值则是脚本名本身。</p>
<h3 id="抓取所有的数据">抓取所有的数据</h3>
<p>有时候需要抓取命令行上提供的所有参数，这时候不需要先用<code>$#</code>变量来判断命令行上有多少参数，然后再进行遍历，可以使用其他的特殊变量来解决这个问题，其中<code>$*</code>和<code>$@</code>变量可以访问所有的参数，这两个变量都能够在单个变量中存储所有的命令行参数。</p>
<p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存，这个单词包含了命令行中出现的每一个参数，基本上<code>$*</code>变量会将这些参数视为一个整体，而不是单独的个体。而<code>$@</code>变量会将命令行上提供的所有参数当作同一字符串中多个独立的单词，这样可以遍历所有的参数值，得到每个参数，这通常使用for命令完成。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing $* and $@</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">echo "Using the \$* method: $*"</div><div class="line">echo</div><div class="line">echo "Using the \$@ mehtods: $@"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biostudy@ubuntu18:~/script$ bash test11.sh Zhang Li Wang</div><div class="line">Using the $* method: Zhang Li Wang</div><div class="line">Using the $@ mehtods: Zhang Li Wang</div></pre></td></tr></table></figure>
<p>从结果来看，<code>$*</code>和<code>$@</code>在形式上并没有区别。但是下面的例子则能看出区别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing $* and $@</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">count=1</div><div class="line"></div><div class="line">for param in "$*"</div><div class="line">do</div><div class="line">    echo "\$ Parameter # $count=$param"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line"></div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">    echo "\$@ Parameter # $count=$param"</div><div class="line">    ecount=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test12.sh Zhang Li Wang</div><div class="line"></div><div class="line">$ Parameter # 1=Zhang Li Wang</div><div class="line">$@ Parameter # 1=Zhang</div><div class="line">$@ Parameter # 1=Li</div><div class="line">$@ Parameter # 1=Wang</div></pre></td></tr></table></figure>
<p>从结果可以看出来，使用for遍历这两个特殊的变量时，<code>$*</code>会将所有参数当成单个参数，而<code>$@</code>变量会单独处理所有的参数。</p>
<h2 id="移动变量">移动变量</h2>
<p>bash shell中的<code>shift</code>命令可以操作命令行参数，<code>shift</code>可以根据它们的相对位置来移动命令行参数。当使用该命令时，它会将每个参数变量向左移动一个位置。因此，变量<code>$3</code>的值会移到<code>$2</code>，变量<code>$2</code>的值会移到<code>$1</code>，而变量<code>$1</code>的值则会被删除（因为<code>$0</code>的值是程序名，不会改变）。这是遍历命令行参数的一个方法，当用户不矢科有多少个参数时，可以只操作第1个参数，移动参数，然后继续操作下一个参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating the shift command</div><div class="line"></div><div class="line">echo</div><div class="line">count=1</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    echo "Parameter #$count=$1"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">    shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[000.DESKTOP-FS88S5S] &gt; bash test13.sh Zhang Li Wang Tian</div><div class="line"></div><div class="line">Parameter #1=Zhang</div><div class="line">Parameter #2=Li</div><div class="line">Parameter #3=Wang</div><div class="line">Parameter #4=Tian</div></pre></td></tr></table></figure>
<p>代码及结果解释： -n 测试来检查命令行参数<code>$1</code>中是否有数据。如果不是0，就执行，一直执行到<code>$1</code>参数为0为止。也可以为shift提供一个参数，指明要移动的位置数即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> demonstrating a multi-positon shift</div><div class="line"><span class="meta">#</span></div><div class="line">echo "The original parameters: $*"</div><div class="line">shift 2</div><div class="line">echo "Here's the new first parameter: $1"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[000.DESKTOP-FS88S5S] &gt; bash test14.sh 1 2 3 4 5</div><div class="line">The original parameters: 1 2 3 4 5</div><div class="line">Here&apos;s the new first parameter: 3</div></pre></td></tr></table></figure>
<p>从上述案例可知，通过使用shfit的参数可以跳过不想要的参数。</p>
<h2 id="处理选项">处理选项</h2>
<p>选项指的是这样的一种情况，在命令后面的短横线的单个字母 ，例如 <code>ls -a</code>，其中<code>-a</code>就是选项。</p>
<h3 id="查找选项">查找选项</h3>
<p>在提取每个单独参数时用<code>case</code>语句来判断某个参数是否为选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting command line options as parameters</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in </div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) echo "Found the -b option";;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">    esac</div><div class="line">    shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test15.sh -a -b -c -d</div><div class="line">Found the -a option</div><div class="line">Found the -b option</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>case语句会检查每个参数是不是有效选项。如果是的话，就运行对应case语句中的命令，无论选项按什么顺序出现在命令行上，这种方法都适用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test15.sh -d -c -a</div><div class="line">-d is not an option</div><div class="line">Found the -c option</div><div class="line">Found the -a option</div></pre></td></tr></table></figure>
<p>case语句在命令行参数中找到一个选项，就处理一个选项，如果命令行上的还提供了其他参数，就可以在case语句的通用情况处理部分中处理。</p>
<h3 id="分离参数和选项">分离参数和选项</h3>
<p>在shell脚本中同时使用选项有参数时，Linux处理这种问题的标准方式是用特殊字符，也就是双破折号（<code>--</code>）将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。在双破折线之后，脚本可以将剩下的命令行参数当作参数，而不是选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting options and parameters</div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in</div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) echo "Found the -b option";;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">        --) shift</div><div class="line">            break;;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">    esac</div><div class="line">    shift</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line">for param in $@</div><div class="line">do</div><div class="line">   echo "Parameter #$count: $param"</div><div class="line">   count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test16.sh -c -a -b test1 test2 test3</div><div class="line">Found the -c option</div><div class="line">Found the -a option</div><div class="line">Found the -b option</div><div class="line">test1 is not an option</div><div class="line">test2 is not an option</div><div class="line">test3 is not an option</div></pre></td></tr></table></figure>
<p>当脚本遇到双破折号时，它会停止处理选项，并将剩下的参数都当作命令行参数。</p>
<h3 id="处理带值的选项">处理带值的选项</h3>
<p>有些选项会带上额外的参数值，例如像这样的<code>bash testing.sh -a test1 -b -c -d test2</code>，如果例行选项中带有额外的参数，脚本必须要能检测到，并且进行处理，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> extracting command line options and values</div><div class="line">echo</div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in </div><div class="line">        -a) echo "Found the -a option";;</div><div class="line">        -b) param="$2"</div><div class="line">            echo "Found the -b option, with parameter value $param"</div><div class="line">           shift;;</div><div class="line">        -c) echo "Found the -c option";;</div><div class="line">        --) shift</div><div class="line">            break;;</div><div class="line">         *) echo "$1 is not an option";;</div><div class="line">     esac</div><div class="line">     shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -a -b test1 -d</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with parameter value test1</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>代码及结果解释：在这案例中，<code>case</code>语句定义了3个安要处理的选项，其中<code>-b</code>选项还需要一个额外的参数值，由于要处理的参数是<code>$1</code>，额外的参数值就应该位于<code>$2</code>位置上（因为所有的参数在处理完后就会被移出），只要将参数值从<code>$2</code>变量中提取出来就行，因为这个选项占了2个参数位，因此还需要<code>shift</code>命令多移动一个位置。只用这些基本的特性，整个过程就能正常工作，不管按什么顺序放置选项（但要记住包含每个选项相应的选项参数）。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -b test1 -a -d</div><div class="line">Found the -b option, with parameter value test1</div><div class="line">Found the -a option</div><div class="line">-d is not an option</div></pre></td></tr></table></figure>
<p>此时，shell脚本就有了处理例行选项的基本能力，但还一些限制，例如，想要多个选项放一个参数时，就像<code>ls -lh</code>这个命令这样，脚本就无法正常工作，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test17.sh -ac</div><div class="line">-ac is not an option</div></pre></td></tr></table></figure>
<p>此时需要<code>getopt</code>命令。</p>
<h3 id="使用getopt命令">使用getopt命令</h3>
<h4 id="getopt命令基本用法">getopt命令基本用法</h4>
<p><code>getopt</code>命令是一个在处理命令行选项和参数时非常方便的工具，它能够识别命令行参数，从而在脚本中解析它们时更方便。<code>getopt</code>命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换为适当的格式，它的使用方法为<code>getopt optstring parameters</code>，其中，<code>optstring</code>定义了命令行有效的选项字符，不这它义了哪些选项字母需要参数值。首先在<code>optstring</code>中列出要在脚本中用到的每个命令行选项字母，然后在每个需要参数值的选项字母后面加一个冒号，<code>getopt</code>命令会基于定义的<code>optstring</code>解析提供的参数。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt ab:cd -a -b test1 -cd test2 test3</div><div class="line"> -a -b test1 -c -d -- test2 test3</div></pre></td></tr></table></figure>
<p>optstring定义了4个有效选项字母，a、b、c和d。冒号（<code>：</code>）被放到了字母b的后面，因为b选项需要一个参数值，当<code>getopt</code>命令运行时，它会检查提供的参数列表（-a -b test1 -cd test2 test3），并基于提供的<code>optstring</code>进行解析。此时，它会自动将<code>-cd</code>选项分成两个单独的选项，并插入双破折线来分隔行中的额外参数，如果指定了一个不在<code>optstring</code>中的选项，默认情况下，<code>getopt</code>会产生一条错误消息，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt ab:cd -a -b test1 -cde test2 test3</div><div class="line">getopt: invalid option -- 'e'</div><div class="line"> -a -b test1 -c -d -- test2 test3</div></pre></td></tr></table></figure>
<p>如果需要忽略这条错误消息，可以在命令后加<code>-q</code>选项，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ getopt -q ab:cd -a -b test1 -cde test2 test3</div><div class="line"> -a -b 'test1' -c -d -- 'test2' 'test3'</div></pre></td></tr></table></figure>
<p>注意：getopt命令选项必须出现在optstring之间。</p>
<h4 id="在脚本中使用getopt">在脚本中使用getopt</h4>
<p>在脚本中使用<code>getopt</code>来格式化脚本所携带的任何选项或参数时，方法就是使用<code>getopt</code>命令生成的格式化后的版本替换已有的命令行选项的参数。这其中要用到<code>set</code>命令。<code>set</code>命令的选项之一就是双破折线（<code>--</code>），它会将命令行参数值的成set命令的命令行值。该方法会将原始脚本的命令行参数传给<code>getopt</code>命令，之后再将<code>getopt</code>命令的输出传给<code>set</code>命令，用<code>getopt</code>格式化后的命令行参数来替换原始的命令行参数，看起来就像这样的<code>set --$(getopt -q ab:cd &quot;$@&quot;)</code>,此时，原始命令行参数变量的值会被<code>getopt</code>命令的输出替换，而<code>getopt</code>已经格式化好了命令行参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Extract command line options and values with getop</div><div class="line"><span class="meta">#</span> </div><div class="line">set --$(getopt -q ab:cd "$@")</div><div class="line"><span class="meta">#</span></div><div class="line">echo </div><div class="line">while [ -n "$1" ]</div><div class="line">do</div><div class="line">    case "$1" in</div><div class="line">    -a) echo "Found the -a option";;</div><div class="line">    -b) param="$2"</div><div class="line">        echo "Found the -b option, with paraeter value $param"</div><div class="line">        shift;;</div><div class="line">    -c) echo "Found the -c option";;</div><div class="line">    --) shift</div><div class="line">        break;;</div><div class="line">     *) echo "$1 is not an option";;</div><div class="line">     esac</div><div class="line">  shift</div><div class="line">done</div><div class="line"></div><div class="line">count=1</div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">    echo "Parameter $count: $param"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -ac</div><div class="line">Found the -a option</div><div class="line">Found the -c option</div><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -a -b test1 -cd test2 test3 test4</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with paraeter value &apos;test1&apos;</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div><div class="line">Parameter 1: &apos;test2&apos;</div><div class="line">Parameter 2: &apos;test3&apos;</div><div class="line">Parameter 3: &apos;test4&apos;</div><div class="line"></div><div class="line">biotest@ubuntu:~/userdata$ bash test18.sh -a -b test1 -cd &quot;test2 test3&quot; test4</div><div class="line">Found the -a option</div><div class="line">Found the -b option, with paraeter value &apos;test1&apos;</div><div class="line">Found the -c option</div><div class="line">-d is not an option</div><div class="line">Parameter 1: &apos;test2</div><div class="line">Parameter 2: test3&apos;</div><div class="line">Parameter 3: &apos;test4</div></pre></td></tr></table></figure>
<p>从运行结果来看，第一个与第二个没有问题，第三个出现了问题，在第三个运行过程中，参数选项其中人有<code>&quot;test2 test3&quot;</code>，用了双引号，由于<code>getopt</code>命令不擅长处理带空格和引号的参数值，它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。此时就需要另外一个命令，即<code>getopts</code>，这个命令是在<code>getopt</code>后面加了一个<code>s</code>。</p>
<h3 id="使用getopts命令注意后面加了s">使用getopts命令（注意后面加了s）</h3>
<p><code>getopts</code>命令能够与已有的shell参数变量进行配合。每调用它时，它一次只处理命令行上检测到的一个参数，处理完所有的参数后，它会退回一个大于0的退出状态码，因此这个命令很适合解析命令行所有参数的循环。它的用法为<code>getopts optstring variable</code>。<code>optstring</code>中储存的是有效的选项字母，如果选项字母要求有个参数值，就要加一个冒号，要去年错误消息的话，可以在<code>optstring</code>之前加一个冒号，<code>getopts</code>命令将当前参数保存在命令行中定义的<code>variable</code>中。<code>getopts</code>命令会用到两个环境变量，如果选项需要跟一个参数值，<code>OPTARG</code>环境变量会保存这个值，<code>OPTIND</code>环境变量保存了参数列表中<code>getopts</code>正在处理的参数位置。这样能够在处理完选项之后继续处理其他命令行参数。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> simple demonstration of the getopts command</div><div class="line"><span class="meta">#</span></div><div class="line">echo</div><div class="line">while getopts :ab:c opt</div><div class="line">do</div><div class="line">    case "$opt" in </div><div class="line">        a) echo "Found the -a option";;</div><div class="line">        b) echo "Found the -b option, with value $OPTARG";;</div><div class="line">        c) echo "Found the -c option";;</div><div class="line">        *) echoi "Unknown options:$opt";;</div><div class="line">    esac</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -ab test1 -c</div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div><div class="line">Found the -c option</div></pre></td></tr></table></figure>
<p>while语句定义了<code>getopts</code>命令，指明了要查找哪些命令选项，以及每次迭代中储存它们的变量名（<code>opt</code>）。此时<code>case</code>语句的用法有些不同，getopts命令解析命令行选项时会移除开头的单破拆线，所以在case定义中不用单破折线。getopts命令的参数值中可以包含空格，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Found the -b option, with value test1 test2</div><div class="line">Found the -a option</div></pre></td></tr></table></figure>
<p>还可以将选项字母和参数值放在一起使用，而不用加空格，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -abtest1</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div></pre></td></tr></table></figure>
<p><code>getopts</code>命令能够从<code>-b</code>选项中正确解析出<code>test1</code>值。除此之外，<code>getopts</code>还能够将命令行上找到的所有未定义的选项统一输出成问号，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -d</div><div class="line"></div><div class="line">Unknown options:?</div><div class="line">biotest@ubuntu:~/userdata$ bash test19.sh -acde</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -c option</div><div class="line">Unknown options:?</div><div class="line">Unknown options:?</div></pre></td></tr></table></figure>
<p><code>optstring</code>中未定义的选项字母会以问号形式发给代码。<code>getopts</code>命令知道何时停止处理选项，并将参数留给用户处理，在使用<code>getopts</code>处理每个选项时，它会将<code>OPTIND</code>环境变量值增一。在<code>getopts</code>完成处理时，用户可以使用<code>shift</code>命令和<code>OPTIND</code>值来移动参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Processing options and parameters with getopts</div><div class="line"></div><div class="line">echo </div><div class="line">while getopts :ab:cd opt</div><div class="line">do</div><div class="line">    case "$opt" in </div><div class="line">    a) echo "Found the -a option";;</div><div class="line">    b) echo "Found the -b option, with value $OPTARG";;</div><div class="line">    c) echo "Found the -c option";;</div><div class="line">    c) echo "Found the 0d option";;</div><div class="line">    *) echo "Unknown option: $opt";;</div><div class="line">    esac</div><div class="line">done</div><div class="line"></div><div class="line">shift $[ $OPTIND - 1 ]</div><div class="line"></div><div class="line">echo</div><div class="line">count=1</div><div class="line">for param in "$@"</div><div class="line">do</div><div class="line">   echo "Parameter $count: $param"</div><div class="line">   coiunt=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test20.sh -a -b test1 -d test2 test3 test4</div><div class="line"></div><div class="line">Found the -a option</div><div class="line">Found the -b option, with value test1</div><div class="line">Unknown option: d</div><div class="line"></div><div class="line">Parameter 1: test2</div><div class="line">Parameter 1: test3</div><div class="line">Parameter 1: test4</div></pre></td></tr></table></figure>
<h2 id="选项标准化">选项标准化</h2>
<p>在Linux系统中，一些字母选项已经拥有了某种程度的标准含义，因此在写bash shell脚本时，用户自己脚本中如果要使用一些选项参数的话，最好与Linux系统中的保持一致，一些常用的linux命令选项如下所示：</p>
<table>
<thead>
<tr class="header">
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-a</td>
<td>显示所有对象</td>
</tr>
<tr class="even">
<td>-c</td>
<td>生成一个计数</td>
</tr>
<tr class="odd">
<td>-d</td>
<td>指定一个目录</td>
</tr>
<tr class="even">
<td>-e</td>
<td>扩展一个对象</td>
</tr>
<tr class="odd">
<td>-f</td>
<td>指定读入数据的文件</td>
</tr>
<tr class="even">
<td>-h</td>
<td>显示命令的帮助信息</td>
</tr>
<tr class="odd">
<td>-i</td>
<td>忽略文本大小写</td>
</tr>
<tr class="even">
<td>-l</td>
<td>产生输出的长格式版本</td>
</tr>
<tr class="odd">
<td>-n</td>
<td>使用非交互模式（批处理）</td>
</tr>
<tr class="even">
<td>-o</td>
<td>将所有输出重定向到的</td>
</tr>
<tr class="odd">
<td>-q</td>
<td>以安静模式运行</td>
</tr>
<tr class="even">
<td>-r</td>
<td>递归地处理目录和文件</td>
</tr>
<tr class="odd">
<td>-s</td>
<td>以安静模式运行</td>
</tr>
<tr class="even">
<td>-v</td>
<td>生成详细输出</td>
</tr>
<tr class="odd">
<td>-x</td>
<td>排除某个对象</td>
</tr>
<tr class="even">
<td>-y</td>
<td>对所有问题回答yes</td>
</tr>
</tbody>
</table>
<h3 id="获得用户输入">获得用户输入</h3>
<p>虽然命令行选项和参数可以从脚本用户处获得输入，但还有一种情况下，需要读取用户的一些信息，例如在运行某个脚本时，需要用户输入自己的用户名。bash shell为此提供了<code>read</code>命令。</p>
<h3 id="read的基本用法"><code>read</code>的基本用法</h3>
<p><code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入，在收入输入后，<code>read</code>命令会将数据放进一个变量，下面是<code>read</code>命令的一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the read command</div><div class="line"><span class="meta">#</span></div><div class="line">echo -n "Enter your name: "</div><div class="line">read name</div><div class="line">echo "Hello, $name, welcome to my program."</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行后结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test21.sh</div><div class="line">Enter your name: Zhang San</div><div class="line">Hello, Zhang San, welcome to my program.</div></pre></td></tr></table></figure>
<p>代码及结果解释：生成提示的echo使用了<code>-n</code>选项，该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。<code>read</code>命令还包含了<code>-p</code>选项，可以直接在<code>read</code>命令行指定指示符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the read -p option</div><div class="line"><span class="meta">#</span></div><div class="line">read -p "Please enter your age: " age</div><div class="line">days=$[ $age*365 ]</div><div class="line">echo "That makes your over $days days old!"</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test22.sh</div><div class="line">Please enter your age: 20</div><div class="line">That makes your over 7300 days old!</div></pre></td></tr></table></figure>
<p>代码及结果解释，在第一个例子中当有名字输入时，<code>read</code>命令会将姓和名保存在同一个变量中，<code>read</code>命令会将提示符后输入的所有数据分配给单个变量，要么用户指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量，如果变量数量不够，剩下的数据就全部分配给最后一个变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"></div><div class="line"><span class="meta">#</span> entering multiple varibales</div><div class="line">read -p "Enter your name:    " first last</div><div class="line">echo "Checking data for $last, $first..."</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test23.sh</div><div class="line">Enter your name:    Zhang San</div><div class="line">Checking data for San, Zhang...</div></pre></td></tr></table></figure>
<p>如果<code>read</code>命令行中不指定变量，<code>read</code>命令会将它收到的任何数据都放到特殊环境变量<code>REPLY</code>中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing the REPLY Environemnt variable</div><div class="line"><span class="meta">#</span></div><div class="line">read -p "Enter uyuour name: "</div><div class="line">echo</div><div class="line">echo Hello $REPLY, welcome to my program.</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test24.sh</div><div class="line">Enter uyuour name: Zhang</div><div class="line"></div><div class="line">Hello Zhang, welcome to my program.</div></pre></td></tr></table></figure>
<p><code>REPLY</code>环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用。</p>
<h3 id="超时">超时</h3>
<p>在使用<code>read</code>命令时需要注意，脚本很有可能会一直等着用户的输入，如果不管是否有数据输入，脚本都必须继续执行，可以使用<code>-t</code>选项来指定个计时器，<code>-t</code>选项指定了<code>read</code>命令等待输入的秒数，当计时器过期后，<code>read</code>命令会返回一个非零退出状态码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> timing the data entry</div><div class="line"><span class="meta">#</span> </div><div class="line">if read -t 5 -p "Please enter your name:  " name</div><div class="line">then</div><div class="line">    echo "Hello $name, welcome to my script"</div><div class="line">else</div><div class="line">    echo</div><div class="line">    echo "Sorry, too slow!"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test25.sh</div><div class="line">Please enter your name:  Zhang</div><div class="line">Hello Zhang, welcome to my script</div><div class="line">biotest@ubuntu:~/userdata$ bash test25.sh</div><div class="line">Please enter your name:  </div><div class="line">Sorry, too slow!</div></pre></td></tr></table></figure>
<p>代码及结果解释：如果计时器过期，<code>read</code>命令会以非零退出状态码退出，可以使用如<code>if-then</code>语句或<code>while</code>循环这种标准的结构化语句所发生的具体情况，在这个例子中，<code>if</code>语句不成立，shell会执行else部分的命令。也可以不进行诸，让<code>read</code>命令来统计输入的字符数，当输入的字符数达到预设的字符数时，就自动退出，将输入的数据赋给变量，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> getting just one character of input</div><div class="line"><span class="meta">#</span></div><div class="line">read -n1 -p "Do you want to continue [Y/N]? " answer</div><div class="line">case $answer in </div><div class="line">Y|y) echo</div><div class="line">     echo "fine, continue on...";;</div><div class="line">N|n) echo</div><div class="line">     echo OK, goodbye</div><div class="line">     exit;;</div><div class="line">esac</div><div class="line">echo "This is the end of the script"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test26.sh</div><div class="line">Do you want to continue [Y/N]? Y</div><div class="line">fine, continue on...</div><div class="line">This is the end of the script</div><div class="line">biotest@ubuntu:~/userdata$ bash test26.sh</div><div class="line">Do you want to continue [Y/N]? n</div><div class="line">OK, goodbye</div></pre></td></tr></table></figure>
<p>在这个案例中，将<code>-n选项</code>和值<code>1</code>一起使用，告诉<code>read</code>命令在接受单个字符后退出，只要按下单个字符回答后，<code>read</code>命令就会接受输入并将它传给变量，无需按回车键。</p>
<h3 id="隐藏方式读取">隐藏方式读取</h3>
<p>有时候需要从脚本用户处得到输入，在屏幕上显示输入信息。但有种例外，就是输入密码，需要隐藏输入的信息。在<code>read</code>命令使用时，使用<code>-s</code>选项可以避免在<code>read</code>命令中输入的数据出现在显示器上（其实数据是会显示的，只是<code>read</code>命令将文本的颜色设成了跟背景色一样），下面是一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> hiding input data from the monitor</div><div class="line"><span class="meta">#</span></div><div class="line">read -s -p "Enter your passwd:  " pass</div><div class="line">echo</div><div class="line">echo "Is your password really $pass?"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ bash test27.sh</div><div class="line">Enter your passwd:  </div><div class="line">Is your password really dsfdf?</div></pre></td></tr></table></figure>
<p>输入提示符输入的数据不会出现在屏幕上，但会赋值给变量，以便在脚本中使用。</p>
<h3 id="从文件中读取数据">从文件中读取数据</h3>
<p><code>read</code>可以用于读取文件中的数据，每次调用<code>read</code>命令时，它就会从文件中读取一行文本。当文件中再没有内容时，<code>read</code>命令就会退出，并返回非零退出状态码。通常使用<code>cat</code>命令将数据中的文件传给含有<code>read</code>命令的<code>while</code>命令，看一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> reading data from a file</div><div class="line"></div><div class="line">count=1</div><div class="line">cat test|while read line</div><div class="line">do</div><div class="line">    echo "Line $count: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">echo "Finished processing the file"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat test</div><div class="line">The quick brown dog jumps over the lazy fox.</div><div class="line">This is a test, this is only a test.</div><div class="line">O Romeo, Romeo! Wherefore art thou Romeo?</div></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/01/Linux/Linux-shell03-for、while和until语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/Linux/Linux-shell03-for、while和until语句/" itemprop="url">Shell学习笔记（3）——for、while和until语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-01T12:10:54+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,875
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记的参考资料是（<a href="https://item.jd.com/12010266.html" target="_blank" rel="external">《Linux命令行与shell脚本编程大全》</a>（第3版），外加百度辅助，本篇笔记的主要内容是循环语句，即for、while和until语句。</p>
<h2 id="for命令">for命令</h2>
<p>如果遇到这样的场景：重复一组命令直到某个特定条件，例如处理某个目录下的所有文件、系统上所有用户或是某个文本文件中的所有行。此时就会用到<code>for</code>命令，for命令可以创建一个遍历一系列值的的循环，每次迭代就会使用其中一个值来执行已定义好的一组命令，for命令的格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for var in list</div><div class="line">do </div><div class="line">    commands</div><div class="line">done</div></pre></td></tr></table></figure>
<p>格式解释：</p>
<p>第一，在list参数中，用户需要提供推荐中要用到的一系列值；</p>
<p>第二，在每次迭代时，变量var会包含列表中的当前值，第一次迭代使用列表中的第1个值，第2次使用第2个值，以此类推；</p>
<p>第三，在<code>do</code>和<code>done</code>语句之间输入的命令可以是一条或多条标准的bash sehll命令，在这些命令中，<code>$var</code>变量包含着这次迭代对应的当前列表项的中值。</p>
<h3 id="第1案例读取列表中的值">第1案例：读取列表中的值</h3>
<p>for命令最基本的用法就是遍历for命令自身所定义的一系列值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> basic for command</div><div class="line">for test in Apple Pear Banana Orange Onion</div><div class="line">do</div><div class="line">    echo The next fruit is $test</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The next fruit is Apple</div><div class="line">The next fruit is Pear</div><div class="line">The next fruit is Banana</div><div class="line">The next fruit is Orange</div><div class="line">The next fruit is Onion</div></pre></td></tr></table></figure>
<p>每次for命令遍历值列表，它都会将列表中的下个值赋给<code>$test</code>变量，<code>$test</code>变量可以像for命令语句中的其他脚本变量一样使用，在最后一次迭代后，<code>$test</code>变量的值会在shell脚本的剩余部分一直保持有效，它会一直保持最后一次迭代的值，除非再次为变量赋值，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the for variable after the looping</div><div class="line"></div><div class="line">for test in Apple Pear Banana Orange Onion</div><div class="line">do</div><div class="line">    echo The next fruit is $test</div><div class="line">done</div><div class="line"></div><div class="line">echo "The last fruit we visited was $test"</div><div class="line">test=Watermelon</div><div class="line">echo "Wait, now we're visiting $test"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test1b.sh</div><div class="line">The next fruit is Apple</div><div class="line">The next fruit is Pear</div><div class="line">The next fruit is Banana</div><div class="line">The next fruit is Orange</div><div class="line">The next fruit is Onion</div><div class="line">The last fruit we visited was Onion</div><div class="line">Wait, now we&apos;re visiting Watermelon</div></pre></td></tr></table></figure>
<h3 id="转义字符的使用">转义字符的使用</h3>
<p>for中有可能会遇到比较复杂的值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> another example of how not to use the for command</div><div class="line"></div><div class="line">for test in I don't know if this'll work</div><div class="line">do</div><div class="line">    echo "word:$test"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果运行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test1c.sh</div><div class="line">word:I</div><div class="line">word:dont know if thisll</div><div class="line">word:work</div></pre></td></tr></table></figure>
<p>从结果中可以看出，如果for的列表中存在单引号，则在迭代中会出错误，它会把单引号去掉，并把单引号中间的字符串当作是一个值，如果要解决这个问题，可以使用两种方法：第一，使用转义字符来将单引号转义；第二，使用双引号来定义用到的单引号的值。</p>
<p>现在用这两种方法来解决这个问题，第一个引用用第一种方法，第二个引号用第二种方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># another example of how not to use the for command</div><div class="line"></div><div class="line">for test in I don\&apos;t know if this\&apos;ll work</div><div class="line">do</div><div class="line">    echo &quot;word:$test&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test1c1.sh</div><div class="line">word:I</div><div class="line">word:don&apos;t</div><div class="line">word:know</div><div class="line">word:if</div><div class="line">word:this&apos;ll</div><div class="line">word:work</div></pre></td></tr></table></figure>
<p>从结果可以看出两个单引号都能正常工作了。</p>
<h3 id="多个词的分割">多个词的分割</h3>
<p>在for循环中，每个值都是用空格进行分割的，如果某个值包含空格，就会比较麻烦，如下面的案例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> another example of how not to user the for command</div><div class="line">for test in Nevada New Hampshire New Mexico New York North Carolina</div><div class="line">do</div><div class="line">    echo "Now going to $test"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash bedtest2 </div><div class="line">Now going to Nevada</div><div class="line">Now going to New</div><div class="line">Now going to Hampshire</div><div class="line">Now going to New</div><div class="line">Now going to Mexico</div><div class="line">Now going to New</div><div class="line">Now going to York</div><div class="line">Now going to North</div><div class="line">Now going to Carolina</div></pre></td></tr></table></figure>
<p>从结果来看有问题，如果想要把含有空格的数值正确地迭代出来，必须使用双引号将这些值给圈起来，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> another example of how not to user the for command</div><div class="line">for test in Nevada "New Hampshire" " New Mexico" "New York" "North Carolina"</div><div class="line">do</div><div class="line">    echo "Now going to $test"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash bedtest2 </div><div class="line">Now going to Nevada</div><div class="line">Now going to New Hampshire</div><div class="line">Now going to  New Mexico</div><div class="line">Now going to New York</div><div class="line">Now going to North Carolina</div></pre></td></tr></table></figure>
<h3 id="从变量读取列表">从变量读取列表</h3>
<p>在shell脚本中会遇到这样的情况：将一系列的值都储存在了一个变量中，然后需要遍历变量中的整个列表。这种情况下，可以使用for命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a variable to hold the list</div><div class="line"><span class="meta">#</span></div><div class="line">list="Henan Chongqing Hebei Jiangsu"</div><div class="line">list=$list" Heilongjiang"</div><div class="line">for province in $list</div><div class="line">do</div><div class="line">    echo "Have you ever visited $province?"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test4.sh</div><div class="line">Have you ever visited Henan?</div><div class="line">Have you ever visited Chongqing?</div><div class="line">Have you ever visited Hebei?</div><div class="line">Have you ever visited Jiangsu?</div><div class="line">Have you ever visited Heilongjiang?</div></pre></td></tr></table></figure>
<p>代码解释，在代码中有一行这样的代码，即<code>list=$list&quot; Heilongjiang&quot;</code>，它表示在原来的列表中添加一个元素。</p>
<h3 id="从命令读取值">从命令读取值</h3>
<p>生成列表中所需要值的另外一个途径就是使用命令的输出，可以用命令替换来执行任何能产生输出的 命令，然后在for命令中使用该命令的输出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> reading values from a file</div><div class="line"></div><div class="line">file="province"</div><div class="line"></div><div class="line">for province in $(cat $file)</div><div class="line">do</div><div class="line">    echo "Visit beautifull $province"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ cat province</div><div class="line">Henan</div><div class="line">Chongqing</div><div class="line">Hubei</div><div class="line">Jiansu</div><div class="line">Guangdong</div><div class="line">Guangxi</div><div class="line">biotest@ubuntu:~/loop$ bash test5.sh</div><div class="line">Visit beautifull Henan</div><div class="line">Visit beautifull Chongqing</div><div class="line">Visit beautifull Hubei</div><div class="line">Visit beautifull Jiansu</div><div class="line">Visit beautifull Guangdong</div><div class="line">Visit beautifull Guangxi</div></pre></td></tr></table></figure>
<p>在这个案例中，使用了cat命令来输出文件province的内容，在province文件中，每一行有一个省，其中最后一行是China HongKong，中间有一个空格。然后在输出时，for命令把China HongKong分开了。这是因为，在bash shell中，空格，换行符，制表符都是分割符，因此会被分开。</p>
<h3 id="更改字段分割符">更改字段分割符</h3>
<p>for在迭代变量时，使用空格作为分割符，这是因为存在一个特殊的环境就是IFS，它的全称是internal field separator，中文名是内部字段分割符。IFS环境变量定义了bash shell用作字段分割符的一系列字符。默认情况下，bash shell会将以下字符当作是字段分割符，其中包括①空格；②制表符；③换行符。bash shell会将数据中的这些字符都当成分割符，因此在处理含有空格的数据（例如某些文件名）时非常麻烦。如果要解决这个问题，需要修改IFS的值，例如，想让bash shell只识别换行符，就当IFS更改为<code>IFS=$'/n'</code>。将这个语句加入到脚本中，就会告诉bash shell在数据中忽略空格和制表符，还以上面的案例为基础，看一下这段代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> reading values from a file</div><div class="line"></div><div class="line">file="province"</div><div class="line"></div><div class="line">IFS=$'\n'</div><div class="line">for province in $(cat $file)</div><div class="line">do</div><div class="line">    echo "Visit beautifull $province"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test5a.sh </div><div class="line">Visit beautifull Henan</div><div class="line">Visit beautifull Chongqing</div><div class="line">Visit beautifull Hubei</div><div class="line">Visit beautifull Jiansu</div><div class="line">Visit beautifull Guangdong</div><div class="line">Visit beautifull Guangxi</div><div class="line">Visit beautifull China HongKong</div></pre></td></tr></table></figure>
<p>现在结果一切正常。如果处理的代码量比较大时，可能在一个地方需要修改IFS的值，然后忽略这次悠，在脚本的其他地方继续没用IFS的默认值，这个时候需要在改变IFS之前保存原来的IFS值，之后再恢复它，这种做法习惯是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IFS.OLD=$IFS</div><div class="line">IFS=$'\n'</div><div class="line">&lt;在代码中使用新的IFS值&gt;</div><div class="line">IFS=$IFS.OLD</div></pre></td></tr></table></figure>
<p>此外，还有一种情况，如果某个文件中的分割隔都是冒号（:），例如<code>etc/passwd</code>文件中就是这样，此时也可以将IFS的值更改炒冒号，就像这样<code>IFS=:</code>，如果需要指定多个IFS字符，只要将它们在赋值行中一并输入就行，例如<code>IFS=$'\n':;&quot;</code>，这个赋值就是将换行符、冒号、分号和双引号作为字段分隔符。</p>
<h3 id="使用通配符读取目录">使用通配符读取目录</h3>
<p>使用for命令可以自动遍历目录中的文件，进行操作时，必须要在文件名或路径名中使用通配符，它会强制shell使用文件扩展匹配，文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程，如果不清楚所有的文件名，这个特性在处理上当中的文件时很好用，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> iterate throught all the files in a directory</div><div class="line"></div><div class="line">for file in /home/biotest/test/*</div><div class="line">do</div><div class="line"></div><div class="line">    if [ -d "$file" ]</div><div class="line">    then</div><div class="line">        echo "$file is a directory"</div><div class="line">    elif [ -f "$file" ]</div><div class="line">    then</div><div class="line">        echo "$file is a file"</div><div class="line">    fi</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行后结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test6.sh|head</div><div class="line">/home/biotest/test/badtest2.sh is a file</div><div class="line">/home/biotest/test/badtest.sh is a file</div><div class="line">/home/biotest/test/cheat is a directory</div><div class="line">/home/biotest/test/contrast_file.sh is a file</div><div class="line">/home/biotest/test/directest.sh is a file</div><div class="line">/home/biotest/test/group.sh is a file</div><div class="line">/home/biotest/test/hockey is a file</div><div class="line">/home/biotest/test/object_exist.sh is a file</div><div class="line">/home/biotest/test/owner.sh is a file</div><div class="line">/home/biotest/test/sentinel is a file</div></pre></td></tr></table></figure>
<p>代码及结果解释：for命令遍历<code>/home/biotest/test/*</code>输出的结果，此代码使用了test命令测试了每个目录，以查看它是目录（-d参数）还是文件（-f参数）。在上面的代码中，<code>if [ -d &quot;$file&quot; ]</code>这里比较特殊，因此它加了引号，因为目录名和文件中包含空格非常常见，因此为了适应这种情况，需要将<code>$file</code>变量用双引号圈起来，如果不圈起来，就会输出错误，如下所示：</p>
<p>现在在<code>/home/biotest/test</code>目录中添加一个目录，命令为<code>a b</code>（中间有空格），再把上面的代码中的<code>if [ -d &quot;$file&quot; ]</code>的引号去掉，运行，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test6a.sh</div><div class="line">test6a.sh: line 7: [: /home/biotest/test/a: binary operator expected</div></pre></td></tr></table></figure>
<p>这里就显示出错。因为在test命令方面，bash shell会将额外的单词当作参数，从而造成错误。</p>
<p>在for命令中可以列出多个目录通配符，将目录查找和列表合并到同一个for语句中，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> iterating through multiple directories</div><div class="line"></div><div class="line">for file in /home/biotest/.b*  /home/biotest/testing</div><div class="line">do</div><div class="line">    if [ -d "$file" ]</div><div class="line">    then</div><div class="line">        echo "$file is a directory"</div><div class="line">    elif [ -f "$file" ]</div><div class="line">    then</div><div class="line">        echo "$file is a file"</div><div class="line">    else</div><div class="line">        echo "$file doesn't exist"</div><div class="line">    fi</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test7.sh</div><div class="line">/home/biotest/.bash_history is a file</div><div class="line">/home/biotest/.bash_logout is a file</div><div class="line">/home/biotest/.bashrc is a file</div><div class="line">/home/biotest/testing is a directory</div></pre></td></tr></table></figure>
<p>for语句使用了文件扩展匹配来遍历通配符生成的文件列表，然后它会遍历列表中的下一个文件。</p>
<h2 id="c语言风格的for命令">C语言风格的for命令</h2>
<h3 id="简单的c风格for命令">简单的C风格for命令</h3>
<p>在C语言中，它的for命令有一个用来指明变量的特定方法，一个必须保持成立才能继续迭代的条件。以及另一个在每个迭代中改变变量的方法，当指定的条件不成立时，for循环就会停止，条件等式通过标准的数学符号定义，例如下面的C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"The next number is %d\n"</span>,i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码会产生一个简单的迭代循环，其中变量<code>i</code>作为计数器，第一部分将一个默认值赋给该变量，中间的部分定义了循环重复的条件。当定义的条件不成立时，for循环就停止迭代。最后一部分定义了迭代的过程，在每次迭代之后，最后一部分占定义的表达式会被执行，在此案例中，每迭代一次，<code>i</code>变量就会增加1。</p>
<p>bash shell也支持一种for循环，与C语言的for循环类似，它的格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (( variable assignment ; condition ; iteration process ))</div></pre></td></tr></table></figure>
<p>在bash shell的C语言风格的for命令中，它有一些特殊的地方：第一，变量赋值可以有空格；第二，条件中的变量不以美元符号开头；第三，迭代过程中的算式并使用expr命令格式。看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the C-sytle for loop</div><div class="line"></div><div class="line">for (( i=1; i&lt;=10;i++))</div><div class="line">do</div><div class="line">    echo "The next number is $i"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test8.sh</div><div class="line">The next number is 1</div><div class="line">The next number is 2</div><div class="line">The next number is 3</div><div class="line">The next number is 4</div><div class="line">The next number is 5</div><div class="line">The next number is 6</div><div class="line">The next number is 7</div><div class="line">The next number is 8</div><div class="line">The next number is 9</div><div class="line">The next number is 10</div></pre></td></tr></table></figure>
<h3 id="使用多个变量">　使用多个变量</h3>
<p>C风格的for命令也可以迭代多个变量，循环会单独处理每个变量，用户可以为每个变量定义不同的迭代过程，虽然可以使用多个变量，但在for循环中只能定义一种条件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test9.sh</div><div class="line">1-10</div><div class="line">2-9</div><div class="line">3-8</div><div class="line">4-7</div><div class="line">5-6</div><div class="line">6-5</div><div class="line">7-4</div><div class="line">8-3</div><div class="line">9-2</div><div class="line">10-1</div></pre></td></tr></table></figure>
<p>代码及结果解释：变量a和b分别用不同的值来初始化并定义了不同的迭代过程，循环的每次迭代在增加变量a的同时，减小了变量b。</p>
<h2 id="while命令">while命令</h2>
<p>while命令在某种程度上是<code>if-then</code>和<code>for</code>循环的混合体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0。它会在每次迭代的一开始测试test命令。在test命令返回非零退出状态码时，while命令会停止执行那组命令。</p>
<h3 id="while命令的基本使用">while命令的基本使用</h3>
<p>while命令的基本格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">while test command</div><div class="line">do</div><div class="line">    other commands</div><div class="line">done</div></pre></td></tr></table></figure>
<p>while命令中定义的test command和if-then语句中的格式一样。可以使用任何普通bash shell命令，或者用test命令进行条件测试，比如测试变量值。while命令的关键在于所指定的test command的退出状态码必须随着循环中运行的命令而改变，如果退出状态码不发生变化，while循环就将一直不停地进行下去。常用的test command的用法是用方括号来检查循环命令中用到的shell变量的值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> while command test</div><div class="line"></div><div class="line">var1=10</div><div class="line">while [ $var1 -gt 0 ]</div><div class="line">do</div><div class="line">    echo $var1</div><div class="line">    var1=$[ $var1 -1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test10.sh</div><div class="line">10</div><div class="line">9</div><div class="line">8</div><div class="line">7</div><div class="line">6</div><div class="line">5</div><div class="line">4</div><div class="line">3</div><div class="line">2</div><div class="line">1</div></pre></td></tr></table></figure>
<p>在这个例子中，while命令定义了每次迭代时检查的测试条件，即<code>whle [ $var1 -gt 0 ]</code>，只要测试条件成立，<code>while</code>命令就会不停地循环执行定义好的命令，在这些命令中，测试条件中用到的变量必须修改，否则就会降入无限循环，在这个案例中，每次循环，变量值就会减一，即<code>var1=[ $var1 -1 ]</code>。while循环会在测试条件不再成立时停止。</p>
<h3 id="使用多个测试命令">使用多个测试命令</h3>
<p>while命令允许用户在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。如果在输入命令时不小心，会导致一些意外，如下面的案例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing a multicommand while loop</div><div class="line"></div><div class="line">var1=10</div><div class="line"></div><div class="line">while echo $var1</div><div class="line">    [ $var1 -ge 0 ]</div><div class="line">do</div><div class="line">    echo "This is inside the loop"</div><div class="line">    var1=$[ $var1 - 1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test11.sh</div><div class="line">10</div><div class="line">This is inside the loop</div><div class="line">9</div><div class="line">This is inside the loop</div><div class="line">8</div><div class="line">This is inside the loop</div><div class="line">7</div><div class="line">This is inside the loop</div><div class="line">6</div><div class="line">This is inside the loop</div><div class="line">5</div><div class="line">This is inside the loop</div><div class="line">4</div><div class="line">This is inside the loop</div><div class="line">3</div><div class="line">This is inside the loop</div><div class="line">2</div><div class="line">This is inside the loop</div><div class="line">1</div><div class="line">This is inside the loop</div><div class="line">0</div><div class="line">This is inside the loop</div><div class="line">-1</div></pre></td></tr></table></figure>
<p>代码及结果解释：第一个测试显示了var1变量的当前值，即<code>while echo $var1</code>，第二个测试用方括号来判断var1变量的值，即<code>[ $var1 -ge 0 ]</code>，在循环内部，echo语句会显示一条信息，说明循环被执行了，在最后，变量成为-1，这是因为while循环会在var1变量等于0时执行echo语句，然后将var1送去1，接下来再执行测试命令，用于下一次迭代，echo不测试命令被执行并显示了var变量的值，直到shell执行test测试命令，while循环才停止。这就说明在含有多个命令的while语句中，在每次迭代中所有的测试命令都会被执行，包括测试命令失败的最后一交迭代，需要注意这种用法。</p>
<h2 id="until命令">until命令</h2>
<p>until命令和while命令的工作方式完全相反，until命令要求你指定一个通常返回非零退出状态码的测试命令。只有油门工命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结果了，until命令的基本格式如下所示：</p>
<h3 id="until命令的基本格式">until命令的基本格式</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">until test commands</div><div class="line">do</div><div class="line">    other commands</div><div class="line">done</div></pre></td></tr></table></figure>
<p>与while命令类似，在until命令中也可以放入多个测试命令，只有最后个命令的退出状态码决定了bash shell是否执行已经定义的other commands，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the until command</div><div class="line"></div><div class="line">var1=100</div><div class="line"></div><div class="line">until [ $var1 -eq 0 ]</div><div class="line">do</div><div class="line">    echo $var1</div><div class="line">    var1=$[ $var1 - 25 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test12.sh</div><div class="line">100</div><div class="line">75</div><div class="line">50</div><div class="line">25</div></pre></td></tr></table></figure>
<p>代码及结果解释：由于变量var1来决定until循环什么时候停止，只要该变量的的值等于0，until命令就会停止循环。until与while类似，在使用多个测试命令时要注意，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the until command</div><div class="line"></div><div class="line">var1=100</div><div class="line"></div><div class="line">until echo $var1</div><div class="line">    [ $var1 -eq 0 ]</div><div class="line">do</div><div class="line">    echo Inside the loop: $var1</div><div class="line">    var1=$[ var1 - 25 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test13.sh</div><div class="line">100</div><div class="line">Inside the loop: 100</div><div class="line">75</div><div class="line">Inside the loop: 75</div><div class="line">50</div><div class="line">Inside the loop: 50</div><div class="line">25</div><div class="line">Inside the loop: 25</div><div class="line">0</div></pre></td></tr></table></figure>
<p>直到var1=0，程序运行结束。</p>
<h2 id="嵌套循环">嵌套循环</h2>
<p>循环语句可以在循环内使用任意类型的命令，包括其他循环命令。这种循环叫嵌套循环（nested loop）。需要注意的是，在使用嵌套循环时，是在迭代中使用迭代，与命令运行次数的关系是乘积的关系，在写代码时尤其要注意这一点，看下面的一个案例。</p>
<h3 id="for循环与for循环的嵌套">for循环与for循环的嵌套</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> nesting for loops</div><div class="line"></div><div class="line">for (( a=1;a&lt;=3;a++))</div><div class="line">do</div><div class="line">    echo "Starting loop $a: "</div><div class="line">    for ((b=1;b&lt;=3;b++))</div><div class="line">    do</div><div class="line">        echo "   Inside loop: $b"</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test14.sh</div><div class="line">Starting loop 1: </div><div class="line">   Inside loop: 1</div><div class="line">   Inside loop: 2</div><div class="line">   Inside loop: 3</div><div class="line">Starting loop 2: </div><div class="line">   Inside loop: 1</div><div class="line">   Inside loop: 2</div><div class="line">   Inside loop: 3</div><div class="line">Starting loop 3: </div><div class="line">   Inside loop: 1</div><div class="line">   Inside loop: 2</div><div class="line">   Inside loop: 3</div></pre></td></tr></table></figure>
<p>代码及结果解释：在嵌套循环中，在外部循环的每次迭代中遍历一次它所有的值，两个循环的do和done命令没有任何差别，bash shell知道当第一个node命令执行的是内部循环，而非外部循环。</p>
<h3 id="while循环与for循环的嵌套">while循环与for循环的嵌套</h3>
<p>在while循环内也可以放置一个for循环，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> palcing a for loop inside a while loop</div><div class="line"></div><div class="line">var1=5</div><div class="line"></div><div class="line">while [ $var1 -ge 0 ]</div><div class="line">do</div><div class="line">    echo "Outer loop: $var1"</div><div class="line">    for ((var2=1;$var2&lt;3;var2++))</div><div class="line">    do</div><div class="line">        var3=$[ $var1*$var2 ]</div><div class="line">        echo " Inner loop: $var1*$var2=$var3"</div><div class="line">    done</div><div class="line">    var1=$[ $var1 - 1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Outer loop: 5</div><div class="line"> Inner loop: 5*1=5</div><div class="line"> Inner loop: 5*2=10</div><div class="line">Outer loop: 4</div><div class="line"> Inner loop: 4*1=4</div><div class="line"> Inner loop: 4*2=8</div><div class="line">Outer loop: 3</div><div class="line"> Inner loop: 3*1=3</div><div class="line"> Inner loop: 3*2=6</div><div class="line">Outer loop: 2</div><div class="line"> Inner loop: 2*1=2</div><div class="line"> Inner loop: 2*2=4</div><div class="line">Outer loop: 1</div><div class="line"> Inner loop: 1*1=1</div><div class="line"> Inner loop: 1*2=2</div><div class="line">Outer loop: 0</div><div class="line"> Inner loop: 0*1=0</div><div class="line"> Inner loop: 0*2=0</div></pre></td></tr></table></figure>
<h3 id="until循环与for循环的嵌套">until循环与for循环的嵌套</h3>
<p>案例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using until and while loops</div><div class="line"></div><div class="line">var1=3</div><div class="line"><span class="meta">#</span> 变量以3开始</div><div class="line">until [ $var1 -eq 0 ] # 除非var1等于0，否则继续运行do...done之间的语句</div><div class="line">do</div><div class="line">    echo "Outer loop: $vaar1"</div><div class="line">    var2=1</div><div class="line">    while [ $var2 -lt 5 ] # 当var2小于5时，一直运行</div><div class="line">    do</div><div class="line">        var3=$(echo "scale=4;$var1/$var2" |bc)</div><div class="line">        echo "   Inner loop: $var1/$var2=$var3"</div><div class="line">        var2=$[ $var2+1 ]</div><div class="line">    done</div><div class="line">    var1=$[ $var1-1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test16.sh</div><div class="line">Outer loop: </div><div class="line">   Inner loop: 3/1=3.0000</div><div class="line">   Inner loop: 3/2=1.5000</div><div class="line">   Inner loop: 3/3=1.0000</div><div class="line">   Inner loop: 3/4=.7500</div><div class="line">Outer loop: </div><div class="line">   Inner loop: 2/1=2.0000</div><div class="line">   Inner loop: 2/2=1.0000</div><div class="line">   Inner loop: 2/3=.6666</div><div class="line">   Inner loop: 2/4=.5000</div><div class="line">Outer loop: </div><div class="line">   Inner loop: 1/1=1.0000</div><div class="line">   Inner loop: 1/2=.5000</div><div class="line">   Inner loop: 1/3=.3333</div><div class="line">   Inner loop: 1/4=.2500</div></pre></td></tr></table></figure>
<h2 id="循环处理文件数据">循环处理文件数据</h2>
<p>当我们遇到一种情况，即必须要遍历储存在文件中的数据时，需要两种技术。第一，使用嵌套循环；第二，修改IFS环境变量。通过修改IFS环境变量，就能强制for命令将文件中的每行都当成单独的一个条目来处理，即使数据中有空格也是如此，一旦从文件中提取出了单独的行，可能需要再次利用循环来提取行中的数据，典型的案例就是处理<code>/etc/passwd</code>文件中的数据，这要求你逐行遍历<code>/etc/passwd</code>文件，并将IFS变量的值改为冒号，这样就能分隔开每行中的各个数据段了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> changing the IFS value</div><div class="line"></div><div class="line">IFS=$'\n'</div><div class="line">for entry in $(cat /etc/passwd)</div><div class="line">do</div><div class="line">    echo "Values in $entry -"</div><div class="line">    IFS=:</div><div class="line">    for value in $entry</div><div class="line">    do</div><div class="line">        echo "    $value"</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test17.sh|head</div><div class="line">Values in root:x:0:0:root:/root:/bin/bash -</div><div class="line">    root</div><div class="line">    x</div><div class="line">    0</div><div class="line">    0</div><div class="line">    root</div><div class="line">    /root</div><div class="line">    /bin/bash</div><div class="line">Values in daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin -</div><div class="line">    daemon</div></pre></td></tr></table></figure>
<p>这个脚本使用了两个不同的FIS值来解析数据，第一个IFS值解析出<code>/etc/passwd</code>文件中的单独的行，内部for循环接着将FIS的值修改为冒号，然后从单独的行中解析出单独的值，因此在第一次运行时，会提取出一行数据，例如<code>root​:x:​0:0:root:/root:/bin/bash</code> ，接头使用for循环，提取出这一行中以冒号为分割符的元素，即<code>root x  0 0 root /root /bin/bash</code>信息。</p>
<h2 id="控制循环">控制循环</h2>
<p>如果遇到这样的情况：一旦开启了循环，必须要等到所有的循环完成迭代时才结束，如果我想提前想结束循环的话，此时就要用到<code>break</code>命令和<code>continue</code>命令。</p>
<h3 id="break命令">break命令</h3>
<p><code>break</code>命令可以退出任意类型的循环，包括<code>until</code>和<code>while</code>循环。</p>
<h4 id="break跳出单个循环">break跳出单个循环</h4>
<p>在shell中执行break命令，它会深度跳出当前正在执行的循环，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> breaking out of a for loop</div><div class="line"></div><div class="line">for var1 in 1 2 3 4 5 6 7 8 9 10</div><div class="line">do</div><div class="line">    if [ $var1 -eq 5 ]</div><div class="line">    then</div><div class="line">       break</div><div class="line">    fi</div><div class="line">    echo "Iteration number: $var1"</div><div class="line">done</div><div class="line">echo "The for loop is completed"</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test18.sh</div><div class="line">Iteration number: 1</div><div class="line">Iteration number: 2</div><div class="line">Iteration number: 3</div><div class="line">Iteration number: 4</div><div class="line">The for loop is completed</div></pre></td></tr></table></figure>
<p>for循环通常都会遍历列表中指定的所有值。但当满足if-then的条件时，shell会执行break命令，停止for循环。同样的方法也适用于while和until循环，如下所示：：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> breaking oiut of a while loop</div><div class="line"></div><div class="line">var1=1</div><div class="line"></div><div class="line">while [ $var1 -lt 10 ]</div><div class="line">do</div><div class="line">    if [ $var1 -eq 5 ]</div><div class="line">    then</div><div class="line">        break</div><div class="line">    fi</div><div class="line">    echo "Iteration: $var1"</div><div class="line">    var1=$[ $var1+1 ]</div><div class="line">done</div><div class="line">echo "The while is loop is completed"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test19.sh</div><div class="line">Iteration: 1</div><div class="line">Iteration: 2</div><div class="line">Iteration: 3</div><div class="line">Iteration: 4</div><div class="line">The while is loop is completed</div></pre></td></tr></table></figure>
<h3 id="section"></h3>
<h4 id="跳出内部循环">跳出内部循环</h4>
<p>在处理多个循环时，break命令会自动终止你所在的最内层的循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> breaking out of an inner loop</div><div class="line"></div><div class="line">for ((a=1;a&lt;4;a++))</div><div class="line">do</div><div class="line">    echo "Outer loop: $a"</div><div class="line">    for ((b=1;b&lt;100;b++)) # 内部循环指定当变量b等于100时停止迭代；</div><div class="line">    do</div><div class="line">        if [ $b -eq 5 ] # 但是当内部循环的if-then语句指明当变量b的值等于5时就执行break命令，跳出循环</div><div class="line">        then</div><div class="line">            break</div><div class="line">        fi</div><div class="line">        echo "   Inner loop:  $b" # 但是外部的循环仍然继续执行</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test20.sh</div><div class="line">Outer loop: 1</div><div class="line">   Inner loop:  1</div><div class="line">   Inner loop:  2</div><div class="line">   Inner loop:  3</div><div class="line">   Inner loop:  4</div><div class="line">Outer loop: 2</div><div class="line">   Inner loop:  1</div><div class="line">   Inner loop:  2</div><div class="line">   Inner loop:  3</div><div class="line">   Inner loop:  4</div><div class="line">Outer loop: 3</div><div class="line">   Inner loop:  1</div><div class="line">   Inner loop:  2</div><div class="line">   Inner loop:  3</div><div class="line">   Inner loop:  4</div></pre></td></tr></table></figure>
<h4 id="跳出外部循环">跳出外部循环</h4>
<p>有时候需要在内部循环，但外部循环停止，break命令可以接受单个命令行参数值，<code>break -n</code>，其中n指定了要跳出的循环层级，默认情况下，n为1，表明跳出的是当前的循环，即最内层的是第1层循环，如果设为2，break命令就会停止下一级的外部循环，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> breaking out of an outer loop</div><div class="line"></div><div class="line">for ((a=1;a&lt;4;a++))</div><div class="line">do</div><div class="line">    echo "Outer loop: $a"</div><div class="line">    for ((b=1;b&lt;100;b++))</div><div class="line">    do</div><div class="line">        if [ $b -gt 4 ]</div><div class="line">        then</div><div class="line">            break 2</div><div class="line">        fi</div><div class="line">        echo "   Inner loop: $b"</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test21.sh</div><div class="line">Outer loop: 1</div><div class="line">   Inner loop: 1</div><div class="line">   Inner loop: 2</div><div class="line">   Inner loop: 3</div><div class="line">   Inner loop: 4</div></pre></td></tr></table></figure>
<p>当shell执行了break命令后，外部循环就停止了。</p>
<h3 id="continue命令">continue命令</h3>
<p>continue命令可以提前中止某次循环中的命令，但并不会完全终止整个循环，可以在循环内部设置shell不执行命令的条件，这里有个for循环中使用continue命令的简单例子，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing continue command</div><div class="line"></div><div class="line">for ((var1=1;var1&lt;15;var1++))</div><div class="line">do</div><div class="line">    if [ $var1 -gt 5 ] &amp;&amp; [ $var1 -lt 10 ] </div><div class="line">    then</div><div class="line">         continue</div><div class="line">    fi</div><div class="line">    echo "Iteration number: $var1"</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ vim continue_test.sh</div><div class="line">biotest@ubuntu:~/loop$ bash continue_test.sh </div><div class="line">Iteration number: 1</div><div class="line">Iteration number: 2</div><div class="line">Iteration number: 3</div><div class="line">Iteration number: 4</div><div class="line">Iteration number: 5</div><div class="line">Iteration number: 10</div><div class="line">Iteration number: 11</div><div class="line">Iteration number: 12</div><div class="line">Iteration number: 13</div><div class="line">Iteration number: 14</div></pre></td></tr></table></figure>
<p>代码解释:当if-then语句的条件满足时，即值大于5小于10，shell会 执行continue命令，跳过此次循环中的剩余命令，但整个循环还会继续，当if-then的条件不再满足后，又继续循环。在while和until循环中也可以使用continue命令，但要谨慎，因为当shell执行continue命令时，它会跳过剩余的部分，如果在其中的条件具条件里对测试条件变量进行增值，问题就会出现，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> improperly using the continue command in a while loop</div><div class="line"></div><div class="line">var1=0</div><div class="line"></div><div class="line">while echo "while iteration; $var1"</div><div class="line">    [ $var1 -lt 15 ]</div><div class="line">do</div><div class="line">    if [ $var1 -gt 5 ] &amp;&amp; [ $var1 -lt 10 ]</div><div class="line">    then</div><div class="line">        continue</div><div class="line">    fi</div><div class="line">    echo "   Inside iteration number: $var1"</div><div class="line">    var1=$[ $var1+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash badtest3.sh|head -20</div><div class="line">while iteration; 0</div><div class="line">   Inside iteration number: 0</div><div class="line">while iteration; 1</div><div class="line">   Inside iteration number: 1</div><div class="line">while iteration; 2</div><div class="line">   Inside iteration number: 2</div><div class="line">while iteration; 3</div><div class="line">   Inside iteration number: 3</div><div class="line">while iteration; 4</div><div class="line">   Inside iteration number: 4</div><div class="line">while iteration; 5</div><div class="line">   Inside iteration number: 5</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div><div class="line">while iteration; 6</div></pre></td></tr></table></figure>
<p>从结果可以看了同，在if-then的条件成立之后，一切都正常，但是当执行了continue命令后，它就跳过了while循环中的剩余部分，则跳过的部分正好是$var1计数变量增值的部分，而这个变量又被用于个渭测试命令中，因此这个值就不再变化，从而连续输出。</p>
<p>continue也可以与break一样，使用n来指定要继续执行哪一级循环，格式为<code>continue n</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> continuing an outer loop</div><div class="line"></div><div class="line">for ((a=1;a&lt;=5;a++))</div><div class="line">do</div><div class="line">    echo "Iteration $a: "</div><div class="line">    for((b=1;b&lt;3;b++))</div><div class="line">    do</div><div class="line">        if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ]</div><div class="line">        then</div><div class="line">            continue 2</div><div class="line">        fi</div><div class="line">        var3=$[ $a*$b ]</div><div class="line">        echo "   The result of $a*$b is $var3"</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test22.sh</div><div class="line">Iteration 1: </div><div class="line">   The result of 1*1 is 1</div><div class="line">   The result of 1*2 is 2</div><div class="line">Iteration 2: </div><div class="line">   The result of 2*1 is 2</div><div class="line">   The result of 2*2 is 4</div><div class="line">Iteration 3: </div><div class="line">Iteration 4: </div><div class="line">   The result of 4*1 is 4</div><div class="line">   The result of 4*2 is 8</div><div class="line">Iteration 5: </div><div class="line">   The result of 5*1 is 5</div><div class="line">   The result of 5*2 is 10</div></pre></td></tr></table></figure></p>
<p>代码解释，其中的if-then部分为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if [ $a -gt 2 ] &amp;&amp; [ $a -lt 4 ]</div><div class="line">        then</div><div class="line">            continue 2</div><div class="line">        fi</div></pre></td></tr></table></figure>
<p>在此处用continue命令来停止处理循环内的命令，但会继续处理外部循环，值为3的那次迭代并没有处理任何内部循环语句，因为尽管continue命令命令会停止了处理过程，但外部循环会继续。（有关<code>break n</code>与<code>continue n</code>的这个原理，再写一篇笔记，我是没弄清楚原理）。</p>
<h2 id="处理循环输出">处理循环输出</h2>
<p>在shell脚本中，可以对循环的输出使用管道或重定向，这可以通过在done命令之后添加一个处理命令来实现。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">for file in /home/biotest/*</div><div class="line"></div><div class="line">do   </div><div class="line">   if [ -d "$file" ]</div><div class="line">   then</div><div class="line">       echo "$file is a directory"</div><div class="line">   elif [ -f "$file" ]</div><div class="line">   then</div><div class="line">       echo "$file is a file"</div><div class="line">   fi</div><div class="line">done &gt; output.tx</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ cat output.txt|head</div><div class="line">/home/biotest/Desktop is a directory</div><div class="line">/home/biotest/Documents is a directory</div><div class="line">/home/biotest/Downloads is a directory</div><div class="line">/home/biotest/examples.desktop is a file</div><div class="line">/home/biotest/filename is a file</div><div class="line">/home/biotest/log. is a file</div><div class="line">/home/biotest/log.180427 is a file</div><div class="line">/home/biotest/loop is a directory</div><div class="line">/home/biotest/miniconda2 is a directory</div><div class="line">/home/biotest/Miniconda2-latest-Linux-x86_64.sh is a file</div></pre></td></tr></table></figure>
<p>第2个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting the for output to a file</div><div class="line"></div><div class="line">for ((a=1;a&lt;10;a++))</div><div class="line">do</div><div class="line">    echo "The number is $a"</div><div class="line">done &gt; test23.txt</div><div class="line">echo "The commmand is finished."</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ cat test23.txt</div><div class="line">The number is 1</div><div class="line">The number is 2</div><div class="line">The number is 3</div><div class="line">The number is 4</div><div class="line">The number is 5</div><div class="line">The number is 6</div><div class="line">The number is 7</div><div class="line">The number is 8</div><div class="line">The number is 9</div></pre></td></tr></table></figure>
<p>代码及结果解释：shell创建了文件test23.txt并将for命令的输出重定向到这个文件，shell在for命令之后正常显示了echo语句。这种方法也同样适用于将循环的结果用通道导入另一个命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> piping a loop to another command</div><div class="line"></div><div class="line">for province in "Chine HK" Henan Guangdong </div><div class="line">do</div><div class="line">    echo "$province is the next place to go"</div><div class="line">done | sort</div><div class="line">echo "This completes out travels"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test24.sh</div><div class="line">Chine HK is the next place to go</div><div class="line">Guangdong is the next place to go</div><div class="line">Henan is the next place to go</div><div class="line">This completes out travels</div></pre></td></tr></table></figure>
<p>代码及结果解释：province的值并没有在for命令列表中以特定次序列出，for命令的输出结果导入到了sort命令中，该命令会改变for命令输出结果的顺序。运行这个脚本实际上说明了结果已经在脚本内部排好序了。</p>
<h2 id="最终案例">最终案例</h2>
<h3 id="第1案例查找可执行文件">第1案例：查找可执行文件</h3>
<p>如果要找出系统中有哪些可执行文件，只需要扫描PATH环境变量中的所有目录即可，下面是这样的一个脚本，如下所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> finding files in the PATH</div><div class="line"></div><div class="line">IFS=:</div><div class="line">for folder in $PATH</div><div class="line">do </div><div class="line">    echo "$folder:"</div><div class="line">    for file in $folder/*</div><div class="line">    do</div><div class="line">        if [ -x $file ]</div><div class="line">        then</div><div class="line">            echo "   $file"</div><div class="line">        fi</div><div class="line">    done</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ bash test25.sh|head -5</div><div class="line">/home/biotest/miniconda2/bin:</div><div class="line">   /home/biotest/miniconda2/bin/2to3</div><div class="line">   /home/biotest/miniconda2/bin/activate</div><div class="line">   /home/biotest/miniconda2/bin/appletviewer</div><div class="line">   /home/biotest/miniconda2/bin/c2ph</div><div class="line">biotest@ubuntu:~/loop$ cat test25.sh</div></pre></td></tr></table></figure>
<h3 id="第2案例创建多个用户账户">第2案例：创建多个用户账户</h3>
<p>如果要创建大量的用户，可以使用while循环来实现，将需要添加的新用户账户放在一个文本文件中，然后创建一个简单的脚本处理，文件文件的格式是这样的<code>userid, user name</code>，第一个条目是新用户的ID，第二个条目是用户的全名。两个值之间使用逗号分隔，这样就形成卫 种名为逗号分隔值的文本文件（或是csv格式文件）。如果要读取这里面的数据，需要将<code>IFS</code>分隔符设置为逗号，并将其放入while语句的条件测试部分。然后使用read命令读取文件中的各行，这一部分 的代码就是<code>while IFS=',',read -r userid name</code>，read命令会自动读取<code>.csv</code>文件的下一行内容，因此不需要创建一个循环，当read命令返回FALSE时（也就是读取完整个文件时），while命令就会退出，完整的脚本如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> process new user accounts</div><div class="line"></div><div class="line">input="user.csv"</div><div class="line">while IFS=',' read -r userid name # -r这个参数表示允许输入的值中包含反斜杠“\”,反斜杠也作为值输出</div><div class="line">do</div><div class="line">    echo "adding $userid"</div><div class="line">    useradd -c "$name" -m $userid #-c表示：加上备注文字。备注文字会保存在passwd的备注栏位中；</div><div class="line">                                  # -m表示自动建立用户的登入目录</div><div class="line">done &lt; "$input" #将input变量中的csv文件输导入到while循环中</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/loop$ cat user.csv </div><div class="line">userid,user name</div><div class="line">501,test01</div><div class="line">502,test02</div><div class="line">503,test03</div><div class="line"></div><div class="line">biotest@ubuntu:~/loop$ sudo bash test26.sh</div><div class="line">[sudo] password for biotest: </div><div class="line">adding userid</div><div class="line">adding 501</div><div class="line">adding 502</div><div class="line">adding 503</div><div class="line"></div><div class="line">biotest@ubuntu:~/loop$ tail /etc/passwd</div><div class="line">kernoops:x:116:65534:Kernel Oops Tracking Daemon,,,:/:/bin/false</div><div class="line">pulse:x:117:124:PulseAudio daemon,,,:/var/run/pulse:/bin/false</div><div class="line">rtkit:x:118:126:RealtimeKit,,,:/proc:/bin/false</div><div class="line">saned:x:119:127::/var/lib/saned:/bin/false</div><div class="line">usbmux:x:120:46:usbmux daemon,,,:/var/lib/usbmux:/bin/false</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div><div class="line">:/home/userid:1002:user name</div><div class="line">:/home/501:1003:test01</div><div class="line">:/home/502:1004:test02</div><div class="line">:/home/503:1005:test03</div></pre></td></tr></table></figure>
<p>从结果可以看出，这3个账户已经生成。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/30/Linux/Linux-shell02-if-then和case语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/Linux/Linux-shell02-if-then和case语句/" itemprop="url">Shell学习笔记（2）——if-then和case语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-30T12:10:54+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,786
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记的参考资料是（<a href="https://item.jd.com/12010266.html" target="_blank" rel="external">《Linux命令行与shell脚本编程大全》</a>（第3版），外加百度辅助，本篇笔记的主要内容是if-then和case语句。</p>
<p>许多程序要求对shell脚本中的命令添加一些逻辑流控制。有一类命令会根据条件使脚本跳过某些命令，这样的命令叫做结构化命令（structured command）。</p>
<h2 id="if-then语句">if-then语句</h2>
<p>if-then语句是最基本的结构化命令，if-then的结构如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if commandA</div><div class="line">then commandB</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>解释：if后面跟一个shell命令commandA，如果commandA命令的退出状态码是0（表示此命令成功运行），位于then后面的commandB命令就会被执行，如果commandA命令的退出状态码是其他值，then后面的commandB就不会被执行，而是继续执行脚本中的下一具命令，fi语句用来表示if-theny语句到此结构。</p>
<h3 id="第1案例简单的if-then">第1案例：简单的if-then</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the if statement</div><div class="line">if pwd</div><div class="line">then</div><div class="line">  echo "It worked"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[20161111.DESKTOP-IVG4HR1] ➤ bash test1.sh</div><div class="line">/home/mobaxterm</div><div class="line">It worked</div></pre></td></tr></table></figure>
<p>代码解释：if部分用了pwd命令，这个命令运行成功后，echo就会显示后面的字符串。</p>
<h3 id="第2案例出错的if-then">第2案例：出错的if-then</h3>
<p>看一段代码，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing a bad command</div><div class="line">if IamNotaCommand;then</div><div class="line">  echo "It worked"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[2018-04-28 10:41.15]  ~</div><div class="line">[20161111.DESKTOP-IVG4HR1] ➤ bash test2.sh</div><div class="line">test2.sh: line 3: IamNotaCommand: command not found</div></pre></td></tr></table></figure>
<p>代码解释：if后面跟的是一个无法工作的命令，它会产生一个非零的退出状态码，bash shell会跳过then部分。</p>
<h3 id="第3案例then部分的多条命令">第3案例：then部分的多条命令</h3>
<p>在if-then语句中，then部分可以输入多条命令，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing multiple commands in the then seciton</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=biotest</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then </div><div class="line">  echo "This is my first command"</div><div class="line">  echo "This is my second command"</div><div class="line">  echo "I can even put in other commands besides echo: "</div><div class="line">  ls -a /home/$testuser/.b*</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test3.sh</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div><div class="line">This is my first command</div><div class="line">This is my second command</div><div class="line">I can even put in other commands besides echo: </div><div class="line">/home/biotest/.bash_history  /home/biotest/.bash_logout  /home/biotest/.bashrc</div></pre></td></tr></table></figure>
<p>代码解释：<code>if grep $testuser /etc/passwd</code>这条代码用于查找某个用户名当前是否在系统上使用，如果有用户使用了这个登录名，脚本会显示出一些文本信息，并列出该用户HOME目录中的bash文件。如果没有这个用户，就什么都不显示，现在将<code>testuser=biotest</code>改为<code>testuser=biotest0</code>，运行，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test3.sh</div><div class="line">biotest@ubuntu:~/test$</div></pre></td></tr></table></figure>
<h2 id="if-then-else语句">if-then-else语句</h2>
<p>if-then使用的场景是：如果if后面的命令成功执行，就输出then后面的内容，如果无法成功执行，什么都不输出。只有一这一种情况。而if-then-else语句则是能够执行其他的命令，它的格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if commandA</div><div class="line">then </div><div class="line">  commandB</div><div class="line">else </div><div class="line">  commandC</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>命令解释：当if语句中的commandA命令返回退出状态状码0时，then部分中的命令commandB会执行，到此if-then-else语句与if-then语句是相同的。如果if语句中的commandA命令返回非零状态码时，bash shell会执行else部分中的命令。看一个案例。</p>
<h3 id="第1案例常规if-then-else语句">第1案例：常规if-then-else语句</h3>
<p>看下面的代码:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing  the else section</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=biotest0</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then </div><div class="line">  echo "The bash files for user $testuser are:   "</div><div class="line">  ls -a /home/$testuser/.b*</div><div class="line">  echo</div><div class="line">else</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  echo</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test4.sh</div><div class="line">The user biotest0 does not exist on this system.</div></pre></td></tr></table></figure>
<p>从代码与结果可以看出，<code>if grep $testuser /etc/passwd</code>命令出错，返回状态码是非0，<code>then</code>后面的命令不会执行，路过，执行<code>else</code>后面的命令。</p>
<h2 id="嵌套if">嵌套if</h2>
<h3 id="第1个案例常规if-then-else语句">第1个案例：常规if-then-else语句</h3>
<p>案例：要检验<code>/etc/passwd</code>文件中是否存在某个用户名以及该用户的目录是否存在，可以使用嵌套的<code>if-then</code>语法，嵌套的<code>if-then</code>语句位于主<code>if-then-else</code>语句的<code>else</code>代码块中，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing nested ifs</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=NoSuchUser</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then</div><div class="line">  echo "The user $testuser exists on this system."</div><div class="line">else</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  if ls -d /home/$testuser/</div><div class="line">  then </div><div class="line">    echo "However, $testuser has a directory."</div><div class="line">    fi</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The user NoSuchUser does not exist on this system.</div><div class="line">ls: cannot access &apos;/home/NoSuchUser/&apos;: No such file or directory</div></pre></td></tr></table></figure>
<p>程序解释：<code>if grep $testuser /etc/passwd</code>这个命令无法运行，状态返回码是非0，跳过了<code>echo &quot;The user $testuser exists on this system.&quot;</code>这个语句，执行后面的语句，即<code>&quot;The user $testuser does not exist on this system.&quot;</code>，接头是个嵌套语句，其中<code>ls -d /home/$testuser/</code>无法执行（因为不存在这个目录），then后面的` `也无法执行。</p>
<p>从结果可以看出，NoSuchUser这个账户不存在，他的目录也不存在。<code>if-then-else</code>还有一个延伸，即<code>elif</code>，它的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if commandA</div><div class="line">then </div><div class="line">  commandB</div><div class="line">elif commandC</div><div class="line">then</div><div class="line">  more commands</div><div class="line">fi</div></pre></td></tr></table></figure>
<p><code>elif</code>语句提供了一个要测序的命令，这类似于原始的if语句，如果elif后命令的退出状态码是0，bash就执行第二个<code>then</code>语句部分的命令，即more commands这一部分，看一个案例（提前在<code>/home/</code>目录下建立一个<code>NoSuchUser</code>目录）：</p>
<h3 id="第2个案例elif语句">第2个案例：elif语句</h3>
<p>这是对第1个案例的修改，所实现的目的是一样的，只是这里用到了elif语句，这种语句在逻辑上更加清晰。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing nested ifs=user elif</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=NoSuchUser</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then</div><div class="line">  echo "The user $testuser exists on this system."</div><div class="line"><span class="meta">#</span></div><div class="line">elif ls -d /home/$testuser</div><div class="line">then</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  echo "Howerve, $testuser has a directory."</div><div class="line"><span class="meta">#</span></div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test6.sh</div><div class="line">/home/NoSuchUser</div><div class="line">The user NoSuchUser does not exist on this system.</div><div class="line">Howerve, NoSuchUser has a directory.</div></pre></td></tr></table></figure>
<p>程序解释：<code>if grep $testuser /etc/passwd</code>这条语句无法执行，执行<code>elif</code>后面的语句，即<code>ls -d /home/$testuser</code>,这条语句可以执行（因为我们提前建立了/home/NoSuchUser这个目录），随后执行then后面的语句。</p>
<h3 id="第3个案例elif扩展">第3个案例：elif扩展</h3>
<p>针对上面的案例，对脚本进行更改，让这个脚本的功能变成：一、检查拥有目录的不存在用户；二、检验没有目录的不存在用户，这是通过在嵌套elif中添加了一个else语句来实现的，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing nested ifs - user elif &amp; else</div><div class="line"><span class="meta">#</span></div><div class="line">testuser=NoSuchUser</div><div class="line"><span class="meta">#</span></div><div class="line">if grep $testuser /etc/passwd</div><div class="line">then</div><div class="line">  echo "The user $testuser exists on this system."</div><div class="line"><span class="meta">#</span></div><div class="line">elif ls -d /home/$testuser</div><div class="line">then</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  echo "Howerve, $testuser has a directory."</div><div class="line"><span class="meta">#</span></div><div class="line">else</div><div class="line">  echo "The user $testuser does not exist on this system."</div><div class="line">  echo "And,$testuser does not have a directory."</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>第1次运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test7.sh</div><div class="line">/home/NoSuchUser</div><div class="line">The user NoSuchUser does not exist on this system.</div><div class="line">Howerve, NoSuchUser has a directory.</div></pre></td></tr></table></figure>
<p>第2次运行结果，现在删除掉<code>/home/NoSuchUser</code>目录，运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ sudo rm -rf /home/NoSuchUser</div><div class="line">biotest@ubuntu:~/test$ bash test7.sh </div><div class="line">ls: cannot access &apos;/home/NoSuchUser&apos;: No such file or directory</div><div class="line">The user NoSuchUser does not exist on this system.</div><div class="line">And,NoSuchUser does not have a directory.</div></pre></td></tr></table></figure>
<p>从两次的运行结果可以看出，在删除/home/NoSuchUser目录之前，即第1次运行，脚本执行的是<code>elif</code>后面的语句，返回状态码是0，删除了目录之后，elif语句返回的是非零状态码，elif块中的else就开始执行。需要注意的是，在elif语句中，紧跟其后的else语句属于elif代码块，它们并不属于if-then代码块。</p>
<h2 id="test命令">Test命令</h2>
<p>test命令是shell环境中测试条件表达式的工具。在前面的案例中，if后面的语句都是普通的shell语句，无法测序命令退出状态码之外的条件。在test命令中，如果test后面列出的条件成立，test命令就会退出并返回退出状态码0，如果条件不成立，test命令就会退出并返回非零的退出状态码，这就会使if-then语句不会被再执行，test的语句格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test condition</div></pre></td></tr></table></figure>
<p>其中，condition是test命令要测试的一系列参数和值，如果test与if-then配合使用的话，格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if test condition</div><div class="line">then</div><div class="line">  commands</div><div class="line">  if</div></pre></td></tr></table></figure>
<p>如果不写test命令的condition部分，它会以非零状态码退出，并执行else语句块，看一个案例。</p>
<h3 id="第1案例常规testtest不添加condition">第1案例：常规test：test不添加condition</h3>
<p>测试一下常规的test功能，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing the test command</div><div class="line"><span class="meta">#</span></div><div class="line">if test</div><div class="line">then</div><div class="line">  echo "No expression returns a True"</div><div class="line">else</div><div class="line">  echo "No expression returns a False"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test8.sh</div><div class="line">No expression returns a False</div></pre></td></tr></table></figure>
<p>程序解释：test后面没有condition，因此它以非零状态码退出，执行else后面的语句，即<code>echo &quot;No expression returns a False&quot;</code>，如果添加上condition，则是下面的案例：</p>
<h3 id="第2案例常规testtest添加condition">第2案例：常规test：test添加condition</h3>
<p>代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing the test command</div><div class="line"><span class="meta">#</span></div><div class="line">my_variable="Full"</div><div class="line"><span class="meta">#</span></div><div class="line">if test $my_variable</div><div class="line">then </div><div class="line">  echo "The $my_variable expression returns a True"</div><div class="line">else</div><div class="line">  echo "The $my_variable expressoion returns a False"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test9.sh</div><div class="line">The Full expression returns a True</div></pre></td></tr></table></figure>
<p>代码解释：test后面有内容（Full），因此当test命令测试条件时，返回的状态为0，执行then后面的语句。如果<code>$my_variable=&quot;&quot;</code>时，没有内容，就会执行else后面的语句，就跟第1个案例一样了。</p>
<h2 id="shell另外一种条件测试方法">shell另外一种条件测试方法</h2>
<p>shell还有另外一种条件测序方法，无需要在if-then语句中使用test命令，其格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if [ condition ]</div><div class="line">then </div><div class="line">  commands</div><div class="line">fi</div></pre></td></tr></table></figure>
<p><code>[ condition ]</code>中定义了测试条件，需要注意提方括号中，condition前后要加上空格，否则就会报错，test命令可以判断三类条件，分别为①数值比较；②字符串比较；③文件比较。</p>
<h3 id="数值比较">数值比较</h3>
<p>test命令常见的情形是对两个数值进行比较，下表就列出了测试两个值可用的条件参数：</p>
<table>
<thead>
<tr class="header">
<th align="center">比较</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">n1 -eq n2</td>
<td align="center">检查n1是否与n2相等</td>
</tr>
<tr class="even">
<td align="center">n1 -ge n2</td>
<td align="center">检查n1是否大于或等于n2</td>
</tr>
<tr class="odd">
<td align="center">n1 -gt n2</td>
<td align="center">检查n1是否大于n2</td>
</tr>
<tr class="even">
<td align="center">n1 -le n2</td>
<td align="center">检查n1是否小于或等于n2</td>
</tr>
<tr class="odd">
<td align="center">n1 -lt n2</td>
<td align="center">检查n1是否小于n2</td>
</tr>
<tr class="even">
<td align="center">n1 -ne n2</td>
<td align="center">检查n1是否不等于n2</td>
</tr>
</tbody>
</table>
<h4 id="第1案例数值比较">第1案例：数值比较</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> Using numeric test evaluations</div><div class="line"><span class="meta">#</span></div><div class="line">value1=10</div><div class="line">value2=11</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $value1 -gt 5 ] # test value1 is great 5 or not</div><div class="line">then </div><div class="line">  echo "The test value $value1 is greater than 5"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $value1 -eq $value2 ] # test value1 and value2 is equal or not</div><div class="line">then </div><div class="line">  echo "The values are equal"</div><div class="line">else</div><div class="line">  echo "The values are different"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test10.sh</div><div class="line">The test value 10 is greater than 5</div><div class="line">The values are different</div></pre></td></tr></table></figure>
<h4 id="第2案例浮点数的比较">第2案例：浮点数的比较</h4>
<p>如果涉及浮点比较时，数值条件测试会有一个限制，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> Using floating point numbers in test evaluations</div><div class="line"><span class="meta">#</span></div><div class="line">value1=5.555</div><div class="line"><span class="meta">#</span></div><div class="line">echo "The test value is $value1"</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $value1 -gt 5 ]</div><div class="line">then </div><div class="line">  echo "The test value $value1 is greater than 5"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test11.sh</div><div class="line">The test value is 5.555</div><div class="line">test11.sh: line 8: [: 5.555: integer expression expected</div></pre></td></tr></table></figure>
<p>结果中提示有问题，因为变量value1中储存提浮点值，脚本对这个值进行了测试，因为bash shell只能处理整数，如果只是要通过echo语句来显示这个结果，没问题，但是如果是基于数字的函数，就会出现了问题，因此需要注意。</p>
<h3 id="字符串比较">字符串比较</h3>
<p>字符串的比较方法如下所示：</p>
<table>
<thead>
<tr class="header">
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>str1 = str2</td>
<td>检查str1是否和str2相同</td>
</tr>
<tr class="even">
<td>str1 != str2</td>
<td>检查str1是否和str3不相同</td>
</tr>
<tr class="odd">
<td>str1 &lt; str2</td>
<td>检查str1是否比str2小</td>
</tr>
<tr class="even">
<td>str1 &gt; str2</td>
<td>检查str1是否比str2大</td>
</tr>
<tr class="odd">
<td>-n str1</td>
<td>检查str1的长度是否非0</td>
</tr>
<tr class="even">
<td>-z str1</td>
<td>检查str1的长度是否为0</td>
</tr>
</tbody>
</table>
<h4 id="字符串比较第1案例">字符串比较第1案例</h4>
<p>代码如下；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!bin/bash</div><div class="line"><span class="meta">#</span> testing string equality</div><div class="line">testuser=biotest</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $USER = $testuser ]</div><div class="line">then</div><div class="line">  echo "Welcom $testuser"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test12.sh</div><div class="line">Welcom biotest</div></pre></td></tr></table></figure>
<h4 id="字符串比较第2案例判断字符串不等的条件">字符串比较第2案例：判断字符串不等的条件</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing string equality</div><div class="line">testuser=baduser</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $USER != $testuser ]</div><div class="line">then </div><div class="line">  echo "This is not $testuser"</div><div class="line">else</div><div class="line">  echo "Welcome $testuser"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test13.sh</div><div class="line">This is not baduser</div></pre></td></tr></table></figure>
<h3 id="字符串的大小">字符串的大小</h3>
<p>在比较字符串方面，有一些事情比较麻烦，主要有两个方面，①大于号和小于号必须要转义，否则shell会将它们当成重定向符号，把字符串值当作文件名；②大于和小于顺序和sort命令所采用的不同，看一个案例。</p>
<h4 id="第1案例大于或小于号的重定向问题">第1案例：大于或小于号的重定向问题</h4>
<p>看下面的案例，注意大于号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> mis-using string comparisons</div><div class="line"><span class="meta">#</span></div><div class="line">val1=baseball</div><div class="line">val2=hockey</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $val1 &gt; $val2 ]</div><div class="line">then</div><div class="line">  echo "$val1 is greater than $val2"</div><div class="line">else</div><div class="line">  echo "$val1 is less than $val2"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash badtest.sh </div><div class="line">val1 is less than val2</div><div class="line">biotest@ubuntu:~/test$ ll</div><div class="line">total 72</div><div class="line">-rw-rw-r--  1 biotest biotest     0 Apr 27 23:21 hockey</div></pre></td></tr></table></figure>
<p>运行结果时，shell没有报错，但是给出的结果却是错的，因为脚本把大于事情解释成了输出重定向，它在当前目录下创建了一个名为hockey的文件，由于重定向的完成，test命令（就是if语句）返回了退出状态码0。</p>
<h4 id="第2案例解决字符串比较时大于号的问题">第2案例：解决字符串比较时，大于号的问题</h4>
<p>如果要解决上述问题，需要对大于号进行转义，前面加上<code>\</code>符号即可，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> mis-using string comparisons</div><div class="line"><span class="meta">#</span></div><div class="line">val1=baseball</div><div class="line">val2=hockey</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $val1 \&gt; $val2 ]</div><div class="line">then</div><div class="line">  echo "$val1 is greater than $val2"</div><div class="line">else</div><div class="line">  echo "$val1 is less than $val2"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash badtest2.sh </div><div class="line">baseball is less than hockey</div></pre></td></tr></table></figure>
<h4 id="sort命令对字符串的排序问题">sort命令对字符串的排序问题</h4>
<p>在处理字符串方面，sort和test的方法正好相反， 看一个案例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing astring osrt order</div><div class="line">val1=Testing</div><div class="line">val2=testing</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $val1 \&gt; $val2 ]</div><div class="line">then</div><div class="line">  echo "$val1 is greater than $val2"</div><div class="line">else</div><div class="line">  echo "$val1 is less than $val2"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test14.sh</div><div class="line">Testing is less than testing</div></pre></td></tr></table></figure>
<p>结查要显示，Testing比testing小，如果是sort，则是下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ cat testfile </div><div class="line">Testing</div><div class="line">testing</div><div class="line">biotest@ubuntu:~/test$ sort testfile </div><div class="line">testing</div><div class="line">Testing</div></pre></td></tr></table></figure>
<p>testing要比Testing大。</p>
<p>在比较测试上，大写字符被认为是小于小写字母的，但是在sort命令中，小写字母会先出现。这是因为比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII为当会来决定排序结果，而sort命令使用的也是ASCII顺序排序，只是默认情况下，sort会按照ASCII从小到大进行排序，如果加上了-r参数，则是按照默认排序的相反顺序进行排序，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ sort -r testfile </div><div class="line">Testing</div><div class="line">testing</div></pre></td></tr></table></figure>
<h4 id="判断字符串是否为0">判断字符串是否为0</h4>
<p><code>-n</code>和<code>-z</code>可以检查一个变量是否含有数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing string length</div><div class="line">val1=testing  </div><div class="line">val2='' </div><div class="line"><span class="meta">#</span></div><div class="line">if [ -n $val1 ]</div><div class="line">then</div><div class="line">  echo "The string '$val1' is not empty"</div><div class="line">else</div><div class="line">  echo "The string '$val1' is empty"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line"></div><div class="line">if [ -z $val2 ]</div><div class="line">then</div><div class="line">  echo "The string '$val2' is empty"</div><div class="line">else</div><div class="line">  echo "The string '$val2' is not empty"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div><div class="line"></div><div class="line">if [ -z $val3 ]</div><div class="line">then</div><div class="line">  echo "The string '$val3' is empty"</div><div class="line">else</div><div class="line">  echo "The string '$val3' is not empty"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test15.sh</div><div class="line">The string &apos;testing&apos; is not empty</div><div class="line">The string &apos;&apos; is empty</div><div class="line">The string &apos;&apos; is empty</div></pre></td></tr></table></figure>
<p>程序解释：①先创建了2个字符串变量，val1包含一个字符串，val2包含的是一个空字符串；②<code>if [ -n $val1 ]</code>表示：判断val1的变量是否长度非0，因为val1并不是一个空字符串，它不是0，因此执行后面的then部分；③<code>if [ -z $val2 ]</code>：判断val2的变量是否长度为0，而val2是一个空字符串，它的长度为0，因此执行then部分；④<code>if [ -z $val3 ]</code>：判断val3的变量是否长度为0，由于这个变量并未在shell脚本中定义过，所以它的字符串长度仍然为0。</p>
<h3 id="文件比较">文件比较</h3>
<p>文件比较是shell编程中使用比较多的形式，它允许用户测试Linux文件系统上的文件和目录的状态，下表列出了这些比较方式，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>比较</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-d file</td>
<td>检查file是否存在并是一个目录</td>
</tr>
<tr class="even">
<td>-e file</td>
<td>检查file是否存在</td>
</tr>
<tr class="odd">
<td>-f file</td>
<td>检查file是否存在并 一个文件</td>
</tr>
<tr class="even">
<td>-r file</td>
<td>检查file是否存在并可读</td>
</tr>
<tr class="odd">
<td>-s file</td>
<td>检查file是否存在并非空</td>
</tr>
<tr class="even">
<td>-w file</td>
<td>检查file是否存在并可写</td>
</tr>
<tr class="odd">
<td>-x file</td>
<td>检查file是否存在并可执行</td>
</tr>
<tr class="even">
<td>-O file</td>
<td>检查file是否存在并属当前用户所有</td>
</tr>
<tr class="odd">
<td>-G file</td>
<td>检查file是否存在并默认组与当前用户相同</td>
</tr>
<tr class="even">
<td>file1 -nt file2</td>
<td>检查file是否比file2新</td>
</tr>
<tr class="odd">
<td>file1 -ot file2</td>
<td>检查file是否比file2旧</td>
</tr>
</tbody>
</table>
<h4 id="检查目录">检查目录</h4>
<p><code>-d</code>测试会检查指定的目录是否存在于系统中如果打算将文件写入目录或是准备切换到某个目录，先进行测试是一种好习惯，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Look before you leap</div><div class="line"><span class="meta">#</span></div><div class="line">jump_directory=/home/arthur</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -d $jump_directory ]</div><div class="line">then</div><div class="line">  echo "The $jump_directory directory exists"</div><div class="line">  cd $jump_directory</div><div class="line">  ls</div><div class="line">else</div><div class="line">  echo "The $jump_directory directory does not exist"</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash directest.sh </div><div class="line">The /home/arthur directory does not exist</div></pre></td></tr></table></figure>
<p>代码解释：<code>-d</code>测试用于检测jump_directory变量是中目录是否存在，如果存在就使用cd命令进入该目录，如果不存在脚本就输出一条信息，然后退出。</p>
<h4 id="检查对象是否存在">检查对象是否存在</h4>
<p><code>-e</code>参数可以使脚本代码在使用文件或上当前检查它们是否存在，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> check if either a directory or file exists</div><div class="line"><span class="meta">#</span></div><div class="line">location=$HOME</div><div class="line">file_name="sentinel"</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -e $location ]</div><div class="line">then # Directory does exist</div><div class="line">  echo "OK on the $location directory."</div><div class="line">  echo "Now checking on the file, $file_name."</div><div class="line"><span class="meta">#</span></div><div class="line">  if [ -e $location/$file_name ]</div><div class="line">  then # file does exist</div><div class="line">    echo "OK on the filename"</div><div class="line">    echo "Updating Current Date..."</div><div class="line">    date &gt;&gt; $location/$file_name</div><div class="line"><span class="meta">#</span></div><div class="line">  else # file does no exist</div><div class="line">    echo "File does not exist"</div><div class="line">    echo "Nothing to update"</div><div class="line">  fi</div><div class="line"><span class="meta">#</span></div><div class="line">else #Directory does exist</div><div class="line">  echo "The $location directory does not exist."</div><div class="line">  echo "Nothing to update"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>第一次运行，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash object_exist.sh </div><div class="line">OK on the /home/biotest directory.</div><div class="line">Now checking on the file, sentinel.</div><div class="line">File does not exist</div><div class="line">Nothing to update</div></pre></td></tr></table></figure>
<p>第二次运行，如果创建了<code>sentinel</code>文件，则如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash object_exist.sh </div><div class="line">OK on the /home/biotest directory.</div><div class="line">Now checking on the file, sentinel.</div><div class="line">OK on the filename</div><div class="line">Updating Current Date...</div><div class="line">biotest@ubuntu:~/test$ cat ~/sentinel </div><div class="line">Sat Apr 28 00:37:31 PDT 2018</div></pre></td></tr></table></figure>
<p>代码解释：第一次检查用了<code>-e</code>比较来判断用户是否有<code>$HOME</code>目录，如果有接下来的<code>-e</code>会检测sentinel文件是否存在于<code>$HOME</code>目录中，如果不存在，shell脚本就会提示该文件不存在，不需要更新。第二次运行时，在<code>$HOME</code>目录下创建了一个<code>sentinel</code>文件，然后重新运行脚本，由于<code>$HOME</code>和<code>sentinel</code>文件都存在，当前的上期和时间就都追加到了这个文本中。</p>
<h4 id="检查文件">检查文件</h4>
<p>如果检查的对象是文件，需要用<code>-f</code>参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Check if either a directory or file exists.</div><div class="line"><span class="meta">#</span></div><div class="line">item_name=$HOME</div><div class="line">echo</div><div class="line">echo "The item being checked: $item_name"</div><div class="line">echo</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -e $item_name ]</div><div class="line">then # Item does exist</div><div class="line">  echo "The item, $item_name, does exist."</div><div class="line">  echo "But is it a file?"</div><div class="line">  echo</div><div class="line"><span class="meta">  #</span></div><div class="line">  if [ -f $item_name ]</div><div class="line">  then # Item is a file</div><div class="line">     echo "Yes, $item_name is a file."</div><div class="line"><span class="meta">  #</span></div><div class="line">  else # Item does not exist</div><div class="line">    echo "No, $item_name is not a file"</div><div class="line">  fi</div><div class="line"></div><div class="line">else #Item doese not exist</div><div class="line">    echo "The item , $item_name, does not exist."</div><div class="line">    echo "Nothing to update"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_file.sh </div><div class="line"></div><div class="line">The item being checked: /home/biotest</div><div class="line"></div><div class="line">The item, /home/biotest, does exist.</div><div class="line">But is it a file?</div><div class="line"></div><div class="line">No, /home/biotest is not a file</div></pre></td></tr></table></figure>
<p>代码解释：首先使用了<code>-e</code>比较测序<code>$HOME</code>是否存在，如果存在，继续使用<code>-f</code>来测试它是不是一个文件，如果它不是文件（肯定不是文件），就会显示一条消息，它不是一个文件，如果更改一下代码，把<code>item_name</code>设置为<code>$HOME/sentinel</code>，即如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Check if either a directory or file exists.</div><div class="line"><span class="meta">#</span></div><div class="line">item_name=$HOME/sentinel</div><div class="line">echo</div><div class="line">echo "The item being checked: $item_name"</div><div class="line">echo</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -e $item_name ]</div><div class="line">then # Item does exist</div><div class="line">  echo "The item, $item_name, does exist."</div><div class="line">  echo "But is it a file?"</div><div class="line">  echo</div><div class="line"><span class="meta">  #</span></div><div class="line">  if [ -f $item_name ]</div><div class="line">  then # Item is a file</div><div class="line">     echo "Yes, $item_name is a file."</div><div class="line"><span class="meta">  #</span></div><div class="line">  else # Item does not exist</div><div class="line">    echo "No, $item_name is not a file"</div><div class="line">  fi</div><div class="line"></div><div class="line">else #Item doese not exist</div><div class="line">    echo "The item , $item_name, does not exist."</div><div class="line">    echo "Nothing to update"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_file2.sh </div><div class="line"></div><div class="line">The item being checked: /home/biotest/sentinel</div><div class="line"></div><div class="line">The item, /home/biotest/sentinel, does exist.</div><div class="line">But is it a file?</div><div class="line"></div><div class="line">Yes, /home/biotest/sentinel is a file.</div></pre></td></tr></table></figure>
<h4 id="检查文件是否可读">检查文件是否可读</h4>
<p>在试图从某个文件中读取数据之前，可以测试一下文件是否可读，参数是<code>-r</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing a file is readable or not</div><div class="line">pwfile=/etc/shadow</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> first, test if the file exists, and is a file</div><div class="line">if [ -f $pwfile ]</div><div class="line">then </div><div class="line">    # Now test if you can read it</div><div class="line">    if [ -r $pwfile ]</div><div class="line">    then </div><div class="line">        tail $pwfile</div><div class="line">    else</div><div class="line">        echo "Sorry, I am unable to read the $pwfile file"</div><div class="line">    fi</div><div class="line">else</div><div class="line">    echo "Sorry, the file $pwfile does not exist"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_read.sh </div><div class="line">Sorry, I am unable to read the /etc/shadow file</div></pre></td></tr></table></figure>
<h4 id="检查空文档">检查空文档</h4>
<p>检查空文档的参数是<code>-s</code>，如果<code>-s</code>比较正确，说明文件中有数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing if a file is empty</div><div class="line"><span class="meta">#</span></div><div class="line">file_name=$HOME/sentinel</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -f $file_name ]</div><div class="line">then</div><div class="line">    if [ -s $file_name ]</div><div class="line">    then</div><div class="line">        echo "The $file_name file exists and has data in it."</div><div class="line">        echo "Will not remove this file."</div><div class="line"><span class="meta">#</span></div><div class="line">    else</div><div class="line">        echo "The $file_name file exists, but is empty."</div><div class="line">        echo "Deleting empty file..."</div><div class="line">        rm $file_name</div><div class="line">    fi</div><div class="line">else</div><div class="line">    echo "File, $file_name, does not exist."</div><div class="line">fi</div><div class="line"><span class="meta">#</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ ls -l $HOME/sentinel</div><div class="line">-rw-rw-r-- 1 biotest biotest 29 Apr 28 00:37 /home/biotest/sentinel</div><div class="line">biotest@ubuntu:~/test$ bash test_empty.sh </div><div class="line">The /home/biotest/sentinel file exists and has data in it.</div><div class="line">Will not remove this file.</div></pre></td></tr></table></figure>
<p>代码解释：首先使用<code>-f</code>测试文件是否存在，如果存在，用<code>-s</code>比较来判断该文件是否为空，空文件会被删除，在运行脚本前，使用<code>ls -l</code>命令检查了<code>$HOME/ssentinel</code>文件，发现不是空的，因此脚本并不会删除它。</p>
<h4 id="检查是否可写">检查是否可写</h4>
<p><code>-w</code>比较会判断当前用户对文件是否有可写权限，下面的一段代码应时检测item_name是否存在、是否为文件，是否可写，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Testing if a file is writable</div><div class="line"><span class="meta">#</span></div><div class="line">file_name=$HOME/sentinel</div><div class="line">echo</div><div class="line">echo "The item being checked: $file_name"</div><div class="line">echo</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -e $file_name ]</div><div class="line">then </div><div class="line">    echo "The item, $file_name, does exist."</div><div class="line">    echo "But is it a file?"</div><div class="line">    echo</div><div class="line">    #</div><div class="line">    if [ -f $file_name ]</div><div class="line">    then</div><div class="line">        echo "Yes, $file_name is a file."</div><div class="line">        echo "But is it writable ?"</div><div class="line">        echo</div><div class="line"></div><div class="line">    #</div><div class="line">        if [ -w $file_name ]</div><div class="line">        then</div><div class="line">            echo "Yes, it is writable."</div><div class="line">            echo "Writing current time to $file_name"</div><div class="line">            date +%H%M &gt;&gt; $file_name</div><div class="line">            echo</div><div class="line">        #</div><div class="line">        else</div><div class="line">            echo "The item, $file_name,is not a writable file"</div><div class="line">            echo "Unable to write to $file_name"</div><div class="line">        fi</div><div class="line"></div><div class="line">    else</div><div class="line">        echo "No, $file_name is not a file."</div><div class="line">    fi</div><div class="line">else</div><div class="line">    echo "The item  $file_name does not exist"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_write.sh </div><div class="line"></div><div class="line">The item being checked: /home/biotest/sentinel</div><div class="line"></div><div class="line">The item, /home/biotest/sentinel, does exit.</div><div class="line">But is it a file?</div><div class="line"></div><div class="line">Yes, /home/biotest/sentinel is a file.</div><div class="line">But is it writable ?</div><div class="line"></div><div class="line">Yes, it is writable.</div><div class="line">Writing current time to /home/biotest/sentinel</div><div class="line">biotest@ubuntu:~/test$ cat /home/biotest/sentinel </div><div class="line">Sat Apr 28 00:37:31 PDT 2018</div><div class="line">0137</div><div class="line">0138</div><div class="line">0141</div></pre></td></tr></table></figure>
<p>现在使用<code>chmod</code>命令关闭文件sentinel的用户写入权限，再测试一下这个脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">chmod u-w $HOME/sentinel</div><div class="line">biotest@ubuntu:~/test$ bash test_write.sh </div><div class="line"></div><div class="line">The item being checked: /home/biotest/sentinel</div><div class="line"></div><div class="line">The item, /home/biotest/sentinel, does exist.</div><div class="line">But is it a file?</div><div class="line"></div><div class="line">Yes, /home/biotest/sentinel is a file.</div><div class="line">But is it writable ?</div><div class="line"></div><div class="line">The item, /home/biotest/sentinel,is not a writable file</div><div class="line">Unable to write to /home/biotest/sentinel</div></pre></td></tr></table></figure>
<h4 id="检查文件是否可以执行">检查文件是否可以执行</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing file execution</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -x test11.sh ]</div><div class="line">then </div><div class="line">    echo "You can run the script: "</div><div class="line">    ./test11.sh</div><div class="line">else</div><div class="line">    echo "Sorry, you are unable to execute the script"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test_ex.sh</div><div class="line">Sorry, you are unable to execute the script</div><div class="line"></div><div class="line">biotest@ubuntu:~/test$ ll test11.sh</div><div class="line">-rw-rw-r-- 1 biotest biotest 195 Apr 27 23:06 test11.sh</div><div class="line">biotest@ubuntu:~/test$ chmod u+x test11.sh</div><div class="line">biotest@ubuntu:~/test$ ll test11.sh</div><div class="line">-rwxrw-r-- 1 biotest biotest 195 Apr 27 23:06 test11.sh*</div><div class="line">biotest@ubuntu:~/test$ bash test_ex.sh </div><div class="line">You can run the script: </div><div class="line">The test value is 5.555</div><div class="line">./test11.sh: line 8: [: 5.555: integer expression expected</div></pre></td></tr></table></figure>
<p>代码及结果解释：代码开头使用了-x参数来判断是滞有权限执行test11.sh脚本，如果有权限就运行这个脚本。在首次运行时，没有权限，随后使用<code>chmod u+x test11.sh</code>命令赋予权限，再次执行，结果显示有权限运行test11.sh这个脚本。</p>
<h4 id="检查所属关系">检查所属关系</h4>
<p><code>-O</code>（大写），测试出某个文件的属主，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> check file ownership</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -O /etc/passwd ]</div><div class="line">then</div><div class="line">    echo "You are the owner of the /etc/passwd file"</div><div class="line">else</div><div class="line">    echo "Sorry, you are not the owner of the /etc/passwd file"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash owner.sh </div><div class="line">Sorry, you are not the owner of the /etc/passwd file</div></pre></td></tr></table></figure>
<p>代码解释：<code>-O</code>田头来测试运行该脚本的用户是否是<code>/etc/passwd</code>文件的属主，这个脚本是运行在普通有入眠账户下的，所以测试失败。</p>
<h4 id="检查默认属组关系">检查默认属组关系</h4>
<p><code>-G</code>比较会检查文件的默认组，如果它匹配了用户的默认组，则测试成功。由于-G比较只会检查默认组而非用户所属的所有组，因此会有一定的局限性，如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> check file group test</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -G $HOME/testing ]</div><div class="line">then </div><div class="line">    echo "Your are in the same group as the file"</div><div class="line">else</div><div class="line">    echo "The file is not owned by your gruop"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ll testing/  #查看HOME目录下的testing目录详细信息</div><div class="line">drwxr-xr-x 24 biotest biotest 4096 Apr 29 02:55 ../ # testing属于biotest组</div><div class="line">biotest@ubuntu:~$ cd test</div><div class="line">biotest@ubuntu:~/test$ bash group.sh # 运行脚本</div><div class="line">You are in the same group as the file  # testing属于当前biotest组</div><div class="line">biotest@ubuntu:~$ cd</div><div class="line">biotest@ubuntu:~$ sudo chgrp sharing $HOME/testing # 将testing所属的biotest组更改为sharing组</div><div class="line">[sudo] password for biotest: </div><div class="line">biotest@ubuntu:~$ ll testing/</div><div class="line">drwxrwxr-x  2 biotest sharing 4096 Apr 29 00:03 ./</div><div class="line">biotest@ubuntu:~$ cd test</div><div class="line">biotest@ubuntu:~/test$ bash group.sh </div><div class="line">The file is not owned by your gruop # testing就不属于了biotest组</div><div class="line">biotest@ubuntu:~/test$ cd ..</div></pre></td></tr></table></figure>
<h4 id="检查文件日期">检查文件日期</h4>
<p>有时候需要比较两个文件的创建日期，<code>-nt</code>比较会判断文件A是否比另外一个文件B新，如果文件A较新，那意味着它的文件创建日期更近。<code>-ot</code>比较会判断一个文件A是否比另外一个文件B旧，如果文件A较旧，则是意味着它的创建日期更早。</p>
<p>先来查看地一下test12.sh文件与test13.sh文件，以及test11.sh和test12.sh文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ ll test11.sh test12.sh test13.sh</div><div class="line">-rwxrw-r-- 1 biotest biotest 196 Apr 28 20:42 test11.sh*</div><div class="line">-rw-rw-r-- 1 biotest biotest 116 Apr 27 23:14 test12.sh</div><div class="line">-rw-rw-r-- 1 biotest biotest 156 Apr 27 23:17 test13.sh</div></pre></td></tr></table></figure>
<p>由上述结果可以发现，test11.sh文件创建于4.28，20:42；test12.sh文件创建于4.27，23:14，test13.sh文件创建于4.27 ，23:17，现在运行下面的脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing file dates</div><div class="line"><span class="meta">#</span></div><div class="line">if [ test12.sh -nt test13.sh ]</div><div class="line">then</div><div class="line">    echo "The test12 file is newer than test13"</div><div class="line">else</div><div class="line">    echo "The test13 file is newer than test12"</div><div class="line">fi</div><div class="line"></div><div class="line">if [ test11.sh -ot test12.sh ]</div><div class="line">then </div><div class="line">    echo "The test11 file is older than the test12 file"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash contrast_file.sh </div><div class="line">The test13 file is newer than test12</div></pre></td></tr></table></figure>
<p>代码及结果解释：<code>test12.sh -nt test13.sh</code>这一句用于判断test12是否比test13更新，结果是否，执行<code>then</code>后面的语句，即<code>echo &quot;The test13 file is newer than test12&quot;。</code>结果也显示，test13文件比test12文件更新，因为test13.sh文件创建的时间（2018-4-27-23:17)比test12.sh文件（2018-4-27-23:14)要晚。在第二个<code>if-then</code>语句中，<code>test11.sh -ot test12.sh</code>语句用于判断，test11文件是否比test12文件更老，由于test11.sh文件创建于2018-4-28-20:42；而test12.sh文件创建于2018-4-27-23:14，test11文件比test12文件创建的时候更晚，因此<code>test11.sh -ot test12.sh</code>这个语句不执行。</p>
<p>再补充一个案例，如果要比较的两个文件不存在，如果仅用<code>-nt</code>来判断，那么还会返回结果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing file dates</div><div class="line"><span class="meta">#</span></div><div class="line">if [ badfile1 -nt badfile2 ]</div><div class="line">then</div><div class="line">    echo "The badfile1 file is newer than badfile2"</div><div class="line">else</div><div class="line">    echo "The badfile2 file is newer than badfile1"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test21.sh</div><div class="line">The badfile2 file is newer than badfile1</div></pre></td></tr></table></figure>
<p>代码运行后，仍然有结果，这就是有问题了，因此在使用<code>-nt</code>时，首先需要判断文件是否存在。</p>
<h2 id="复合条件测试">复合条件测试</h2>
<p>在<code>if-then</code>语句中，还可以使用布尔逻辑来组合测试，有两种布尔运算符可以使用，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ condition1 ] &amp;&amp; [ condition2 ] </div><div class="line"># 使用的是AND布尔运行算来组合两个条件，若要执行then后面的语句，两个条件必须都满足</div><div class="line"></div><div class="line">[ condition1 ] || [ condition2 ]</div><div class="line"># 使用OR布尔运算符来组合两个条件，如果任意条件为TRUE，then后面的语句执行</div></pre></td></tr></table></figure>
<h3 id="and运算符">AND运算符</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing compound comparisons</div><div class="line"><span class="meta">#</span></div><div class="line">if [ -d $HOME ] &amp;&amp; [ -w $HOME/testing ]</div><div class="line">then</div><div class="line">    echo "The file exists and you can write to it"</div><div class="line">else</div><div class="line">    echo "I cannot write to the file"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test22.sh</div><div class="line">The file exists and you can write to it</div></pre></td></tr></table></figure>
<h2 id="if-then的高级特性">if-then的高级特性</h2>
<p>bash sehll提供了2项可在if-then语句中使用的高级特性，第一：用于数学表达式的双括号；第二：用于高级字符串处理的双方括号。</p>
<h3 id="使用双括号">使用双括号</h3>
<p>双括号命令可以使用户在比较过程中使用高级数学表达式。test命令只能在比较中使用简单的自述操作，而双括号命令提供了更多的数学符号，双括号的命令格式为<code>(( expressiton ))</code>。其中<code>expresstion</code>可以是任意的数学赋值或比较表达式，除了test命令使用的标准数学运算答外，下表列出了双括号命令中会用到的其他运算符，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>val++</td>
<td>后增</td>
</tr>
<tr class="even">
<td>val–</td>
<td>后减</td>
</tr>
<tr class="odd">
<td>++val</td>
<td>先增</td>
</tr>
<tr class="even">
<td>–val</td>
<td>先减</td>
</tr>
<tr class="odd">
<td>!</td>
<td>逻辑求反</td>
</tr>
<tr class="even">
<td>~</td>
<td>位求反</td>
</tr>
<tr class="odd">
<td>**</td>
<td>幂运算</td>
</tr>
<tr class="even">
<td>&lt;&lt;</td>
<td>左位移</td>
</tr>
<tr class="odd">
<td>&gt;&gt;</td>
<td>右位移</td>
</tr>
<tr class="even">
<td>&amp;</td>
<td>位布尔和</td>
</tr>
<tr class="odd">
<td>|</td>
<td>位布尔或</td>
</tr>
<tr class="even">
<td>&amp;&amp;</td>
<td>逻辑和</td>
</tr>
<tr class="odd">
<td>||</td>
<td>逻辑或</td>
</tr>
</tbody>
</table>
<h4 id="案例在if语句中使用双括号">案例：在if语句中使用双括号</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using double parenthesis</div><div class="line"><span class="meta">#</span></div><div class="line">val1=10</div><div class="line"><span class="meta">#</span></div><div class="line">if (( $val1 **2 &gt; 90))</div><div class="line">then</div><div class="line">    (( val2=$val1**2 ))</div><div class="line">    echo "The square of $val1 is $val2"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test23.sh</div><div class="line">The square of 10 is 100</div></pre></td></tr></table></figure>
<h3 id="使用双方括号">使用双方括号</h3>
<p>双方括号命令提供了针对字符串比较的高级特性，双方括号命令的格式为<code>[[ expression ]]</code>，双方括号里的<code>expression</code>使用了test命令中采用的标准字符串比较，但它还有另外的一个特性，即模式匹配（pattern matching）。（注：bash shel对中双方括号的支持很好，但其他的shell未必如此）。</p>
<p>在模式匹配中，用户可以定义一个正则表达式来匹配字符串，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using pattern matching</div><div class="line"><span class="meta">#</span></div><div class="line">if [[ $USER == r* ]]</div><div class="line">then</div><div class="line">    echo "Hello $USER"</div><div class="line">else</div><div class="line">    echo "Sorry, I do not know you"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test24.sh</div><div class="line">Sorry, I do not know you</div></pre></td></tr></table></figure></p>
<p>如果将其中<code>$USER == r*</code>改为<code>$USER == b*</code>（当前Linux系统中biotest用户，<code>b*</code>这种格式可以查换所有以b开头的用户，运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test24.sh</div><div class="line">Hello biotest</div></pre></td></tr></table></figure>
<h2 id="case命令">case命令</h2>
<p>如果有一种情况：用户在尝试计算一个变量的值，可以在一组可能的值中寻找特定值。在这种情况下，可以写一段长的<code>if-then-else</code>代码，如下所示：</p>
<h3 id="常规if-then-else代码">常规<code>if-then-else</code>代码</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> Looking for a possible value</div><div class="line"><span class="meta">#</span></div><div class="line">if [ $USER = "rich" ]</div><div class="line">then</div><div class="line">    echo "Welcome $USER"</div><div class="line">    echo "Please enjoy your visit"</div><div class="line">elif [ $USER = "barbara" ]</div><div class="line">then</div><div class="line">    echo "Welcome $USER"</div><div class="line">    echo "Please enjoy your visit"</div><div class="line">elif [ $USER = "testing" ]</div><div class="line">then</div><div class="line">    echo "Special testing account"</div><div class="line">elif [ $USER = "jessica" ]</div><div class="line">then</div><div class="line">    echo "Do not forget to logout when you're done"</div><div class="line">elif [ $USER = "biotest" ]</div><div class="line">then</div><div class="line">    echo "You are currnet user"</div><div class="line">else</div><div class="line">    echo "Sorry, your are not allowed here"</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test25.sh</div><div class="line">You are currnet user</div></pre></td></tr></table></figure>
<p>如果有了<code>case</code>命令，则不需要写出所有的<code>elif</code>语句来不停地检查同一个变量的值，<code>case</code>命令会采用列表格式来检查单个变量的多个值。</p>
<h3 id="case语句"><code>case</code>语句</h3>
<p><code>case</code>语句的格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">case variable in </div><div class="line">pattern1 | pattern2)  command1;;</div><div class="line">pattern3) commands2;;</div><div class="line">*) default commands;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>case命令会将指定的变量与不同械进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令，可以通过竖线操作符在一行中分隔出多个模式。星号会捕获所有与已知模式不匹配的值，现在将前面的<code>if-then-else</code>代码转换为<code>case</code>形式，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the case command</div><div class="line"><span class="meta">#</span></div><div class="line">case $USER in </div><div class="line">rich | barbara)</div><div class="line">    echo "Welcome, $USER"</div><div class="line">    echo "Please enjoy your visit";;</div><div class="line">testing)</div><div class="line">    echo "Special testing account";;</div><div class="line">jessica)</div><div class="line">    echo "Do not forget to log off when you're done";;</div><div class="line">biotest)</div><div class="line">    echo "You are current user";;</div><div class="line">*)</div><div class="line">    echo "Sorry, you are not allowed here";;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test$ bash test26.sh</div><div class="line">You are current user</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/29/Linux/Linux-shell01-基础笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/Linux/Linux-shell01-基础笔记/" itemprop="url">Shell学习笔记（1）——shell脚本基础笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T12:10:54+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,088
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记的参考资料是（<a href="https://item.jd.com/12010266.html" target="_blank" rel="external">《Linux命令行与shell脚本编程大全》</a>（第3版），外加百度辅助，本篇笔记主要内容是Shell脚本的一些基本知识。</p>
<p>使用命令行的一大特点就是能够写脚本，可以将一些命令写到一个脚本中，自动运行。而在Linux的命令行中，一次基本上只能运行一个或几个命令，就像下面的这样，它可以运行两个命令，只是要用分号隔开。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ date;who</div><div class="line">Fri Apr 27 15:56:32 CST 2018</div><div class="line">biotest  tty7         2018-04-27 11:24 (:0)</div></pre></td></tr></table></figure>
<p>这两个命令其实也可以视为一个非常简单的脚本，虽然它只有两个命令，作用就是显示今天的日期以及当前登录到系统中的用户。</p>
<h2 id="创建shell脚本文件">创建shell脚本文件</h2>
<p>如果要将shell命令放到文本文件中，就需要一个文本编辑器，Linux中常用的是vim，写好的脚本文件如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">date;who</div><div class="line"><span class="meta">#</span> this is comments</div></pre></td></tr></table></figure>
<p>将脚本文件保存，命令为test.sh。</p>
<p>现在解释一下这个脚本：</p>
<p>第1行：写入的是<code>#!/bin/bash</code>，#号是用于注释的，shell并不会处理注释，注释只是起到说明的作用，但第1行是个例外，#!的意思是要告诉shell要到哪个shell来运行，这里指定的是bash。</p>
<p>第2行：在第1行中指定了运行脚本的shell后，就可以输入命令了，输入一个命令后，回车，再输入另外一个命令，或者是用分号隔开两个命令。</p>
<p>命令结束后，输入脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ test.sh</div><div class="line">test.sh: command not found</div></pre></td></tr></table></figure>
<p>这是因为，shell是通过PATH环境变量来查找命令的，现在test.sh这个脚本文件并不在环境变量PATH中，因此如果要运行这个脚本，只有2种方法：</p>
<p>第一，将shell脚本文件所在的目录添加到PATH环境中；</p>
<p>第二，使用绝对或相对路径引用shell脚本文件。</p>
<p>现在使用第二种方法，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$</div></pre></td></tr></table></figure>
<p>发现没有反应，此时输入<code>bash test</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ bash test</div><div class="line">Fri Apr 27 16:19:14 CST 2018</div><div class="line">biotest  tty7         2018-04-27 11:24 (:0)</div></pre></td></tr></table></figure>
<p>test是一个脚本文件，通过<code>ls -lF</code>命令查看发现，test不是一个可执行程序，因此运行这个脚本，需要使用bash test，如果要将它设为可执行文件，则如下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls -lF test</div><div class="line">-rw-rw-r-- 1 biotest biotest 42 Apr 27 01:28 test</div><div class="line">biotest@ubuntu:~$ chmod u+x test</div><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$ ./test</div><div class="line">Fri Apr 27 01:29:38 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure>
<p>此时输入的是相对路径<code>./test</code>，如果要直接运行，则需要将test添加到环境变量中去，如下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ./test</div><div class="line">Fri Apr 27 01:36:50 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">biotest@ubuntu:~$ pwd</div><div class="line">/home/biotest</div><div class="line">biotest@ubuntu:~$ echo 'export PATH=$PATH:/home/biotest/'&gt;&gt;~/.bashrc</div><div class="line">biotest@ubuntu:~$ source ~/.bashrc</div><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$ mv test test.sh</div><div class="line">biotest@ubuntu:~$ test.sh</div><div class="line">Fri Apr 27 01:37:57 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure>
<p>添加到环境变量用到了<code>echo 'export PATH=$PATH:/home/biotest/'&gt;&gt;~/.bashrc</code>命令，此外，还有一点，test是用shell写的，原来没有后缀名，输入后无法运行，当添加上上了<code>.sh</code>后，可以正常运行，原理现在还不清楚，懂了再写。</p>
<h2 id="显示消息">显示消息</h2>
<p>多数shell都会产生自己的输出，这些输出会显示脚本所运行的控制台显示器上。很多时候，在自己写脚本时，要添加自己的文本消息来告诉脚本用户正在做什么，需要echo命令，如果在echo命令后面加上一个字符串，就会显示出这个文本字符串，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo This is a test</div><div class="line">This is a test</div><div class="line">biotest@ubuntu:~$ echo "This is a test to see if you're paying attention"</div><div class="line">This is a test to see if you're paying attention</div><div class="line">biotest@ubuntu:~$ ^C</div><div class="line">biotest@ubuntu:~$ echo 'Rich says "scripting is easy".'</div><div class="line">Rich says "scripting is easy".</div></pre></td></tr></table></figure>
<p>从中可以发现：第一，常规情况下字符串并不需要使用引号；第二，如果要使用引号，字符串中间的引号不能与字符串两端的引号重复（即字符串中使用单引号，整个字符串就使用双引号，反之亦然）。</p>
<p>再看一案例，新建一个文件，命名为test1，输入以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> This script displays the date and who's logged on </div><div class="line">echo The time and date are:</div><div class="line">date</div><div class="line">echo "Let's see who's logged into the system:"</div><div class="line">who</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test1</div><div class="line">The time and date are:</div><div class="line">Fri Apr 27 03:01:29 PDT 2018</div><div class="line">Let&apos;s see who&apos;s logged into the system:</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure></p>
<h2 id="使用变量">使用变量</h2>
<p>环境变量是常见的变量之一，在shell脚本中，也能使用环境变量，只需要在环境㸄前加上美元符号（$）即可，下面的脚本中就使用了一些环境变量，如下所示： <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> display user information from the system.</div><div class="line">echo "User info for userid: $USER"</div><div class="line">echo UID:$UID</div><div class="line">echo HOME: $HOME</div></pre></td></tr></table></figure></p>
<p>运行后结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test2</div><div class="line">User info for userid: biotest</div><div class="line">UID:1000</div><div class="line">HOME: /home/biotest</div></pre></td></tr></table></figure>
<p>如果在字符串中使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo "The cost of the item is $15"</div><div class="line">The cost of the item is 5</div></pre></td></tr></table></figure>
<p>这里面的美元符号就不会显示，如果要显示的话，需要添加转义字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo "The cost of the item is \$15"</div><div class="line">The cost of the item is $15</div></pre></td></tr></table></figure>
<h2 id="用户变量">用户变量</h2>
<p>用户变量是用户自己定义的一些变量，这些常见的编程语言中的变量大同小异，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing vairbales</div><div class="line">days=10</div><div class="line">guest="Test"</div><div class="line">echo "$guest checked in $days days ago"</div><div class="line">days=5</div><div class="line">guest="Test01"</div><div class="line">echo "$guest checked in $days days ago"</div></pre></td></tr></table></figure>
<p>运行后结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test3</div><div class="line">Test checked in 10 days ago</div><div class="line">Test01 checked in 5 days ago</div></pre></td></tr></table></figure>
<h3 id="有关美元符号与赋值的另一案例">有关美元符号与赋值的另一案例</h3>
<p>如果引用变量不使用美元符号，会将引用的某个变量名称识别为字符串，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> assigning a variable value to another variable</div><div class="line"></div><div class="line">value1=10</div><div class="line">value2=$value1</div><div class="line">echo The resulting value is $value2</div><div class="line">value3=value1</div><div class="line">echo The resulting value is $value3</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test4</div><div class="line">The resulting value is 10</div><div class="line">The resulting value is value1</div></pre></td></tr></table></figure></p>
<p>从结果可以看出来，当value2=$value1时，就把变量value1的值10赋值给了value2，当使用value3=value1时，由于没加美元符号，就把value1这个字符串赋值给了value3。</p>
<h2 id="命令替换">命令替换</h2>
<p>shell脚本有一个重要的功能就是从命令输出中提取信息，并将值赋给某个变量。有2种方法可以将命令输出赋值给某个变量：</p>
<p>第一：使用反引号（`）； 第二：使用<code>$()</code>格式。 使用这两种方法可以使shell命令的输出赋值给变量，具体用法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">testing=`date`</div><div class="line"># 或者是</div><div class="line">testing=$(date)</div></pre></td></tr></table></figure>
<p>具体的案例如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">testing=$(date)</div><div class="line">echo &quot;The date and time are: &quot; $testing</div></pre></td></tr></table></figure></p>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test5</div><div class="line">The date and time are:  Fri Apr 27 07:10:16 PDT 2018</div></pre></td></tr></table></figure>
<p>第二案例： 以下的案例就是就是通过命令替换获得当前日期，并用它来生成唯一文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># copy the /usr/bin directory listing to a log file</div><div class="line">today=$(date +%y%m%d) </div><div class="line"># there is a blank between +%y%m%d</div><div class="line">ls /usr/bin -al &gt; log.$today</div></pre></td></tr></table></figure>
<p>运行后没有输出信息，但是它会在当前目录下生成一个log文件，名称就是log加上今天的日期（今天是2018年4月27日），则这个文件名称就是log.180427。代码的运行原理是，date命令得到当前日期，经格式化后，赋值给today。关于日期的格式化，可以看下面的案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date</div><div class="line">Fri Apr 27 07:21:17 PDT 2018</div><div class="line">biotest@ubuntu:~$ date +%y%m%d</div><div class="line">180427</div></pre></td></tr></table></figure>
<h2 id="重定向输入和输出">重定向输入和输出</h2>
<p>有时候我们会遇到这样的场景，我想把某个命令的输出结果保存到某个文件中，这个文件我可以用于查看，或者是经后来的命令处理。这就用到了重定向，重定向可以用于输入，也可以用于输出。</p>
<h3 id="输出重定向">输出重定向</h3>
<p>最基本的重定向就是将命令的输出发送到一个文件中，bash shell中使用大于号（&gt;）来完成，格式为<code>command &gt; outputfile</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date &gt; test7</div><div class="line">biotest@ubuntu:~$ ls -l test7</div><div class="line">-rw-rw-r-- 1 biotest biotest 29 Apr 27 07:25 test7</div><div class="line">biotest@ubuntu:~$ less test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">Fri Apr 27 07:25:44 PDT 2018</div><div class="line">biotest@ubuntu:~$ who &gt; test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">biotest@ubuntu:~$ date &gt;&gt; test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">Fri Apr 27 07:28:58 PDT 2018</div></pre></td></tr></table></figure>
<p>使用重定向文件创建了一个文件test7，将date命令的输出结果重定向了到了test7中，如果这个文件存在，则重定向的数据会覆盖原来的数据，如果不想覆盖，只是追加，可以使用双大于号。</p>
<h3 id="输入重定向">输入重定向</h3>
<h4 id="常规的输入重定向">常规的输入重定向</h4>
<p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令。 输入重定向符号是小于号（&lt;），格式为<code>command &lt; inputfile</code>。 如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">Fri Apr 27 07:28:58 PDT 2018</div><div class="line">biotest@ubuntu:~$ wc &lt; test7</div><div class="line"> 2 11 73</div></pre></td></tr></table></figure></p>
<p>在这个案例中，将test7的内容输入到wc命令中，wc命令可以对数据中的文本进行计数（wc的全称为words count），wc的默认输出有3个值，从左到右分别为： ①文本的行数；②文本的词数；③文本的字节数，在前面的案例中，结果就是2行，11个单词，73个字节。</p>
<h4 id="内联输入重定向">内联输入重定向</h4>
<p>内联输入重定向的英文是inline input redirection，这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致，格式为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">command &lt;&lt; marker </div><div class="line">data </div><div class="line">marker</div></pre></td></tr></table></figure></p>
<p>maker是数据的开始，也是结果，data是位于maker之间的文本文件，看一个案例： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ wc &lt;&lt; EOF</div><div class="line">&gt; test string 1</div><div class="line">&gt; test string 2</div><div class="line">&gt; test string 3</div><div class="line">&gt; EOF</div><div class="line"> 3  9 42</div></pre></td></tr></table></figure></p>
<p>当输入wc &lt;&lt; EOF时，命令行会自动变成大于号，接着输入内容，输入完毕后，再输入EOF表示结束，此时命令开始运行，结果为3，9， 42.</p>
<h2 id="管道">管道</h2>
<p>管道的使用场景为，将命令A的输出结果导入到命令B，使A的结果成为B的输入。其实这样可以通过重定向实现，但是太麻烦，管道就是出于此目的而设计的。</p>
<p>举个例子：统计当前的文件数有多少个。</p>
<p>先看一下重定向是如何实现的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls &gt; filename</div><div class="line">biotest@ubuntu:~$ cat filename</div><div class="line">Desktop</div><div class="line">Documents</div><div class="line">Downloads</div><div class="line">examples.desktop</div><div class="line">filename</div><div class="line">log.</div><div class="line">log.180427</div><div class="line">miniconda2</div><div class="line">Miniconda2-latest-Linux-x86_64.sh</div><div class="line">Music</div><div class="line">Pictures</div><div class="line">Public</div><div class="line">Templates</div><div class="line">test1</div><div class="line">test2</div><div class="line">test3</div><div class="line">test4</div><div class="line">test5</div><div class="line">test6</div><div class="line">test7</div><div class="line">test8</div><div class="line">test.sh</div><div class="line">Videos</div><div class="line">biotest@ubuntu:~$ wc filename</div><div class="line"> 23  23 210 filename</div></pre></td></tr></table></figure></p>
<p>使用重定向就是，先用ls列出当前的文件名，重定向到filename文件，然后使用wc命令来统计。</p>
<p>再看一下管道命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls|wc</div><div class="line">     23      23     210</div><div class="line">biotest@ubuntu:~$</div></pre></td></tr></table></figure></p>
<p>管道命令通过一条竖线，将ls的结果导入到wc中。</p>
<h2 id="退出脚本">退出脚本</h2>
<p>shell中运行的每个命令都是使用退出状态码（exit status）告诉shell它已经运行完毕，退出状态码是一个0~255的号数值，在命令结束运行时，由命令传给shell。</p>
<h3 id="查看退出状态码">查看退出状态码</h3>
<p>Linux提供了一个专门的变量<code>$?</code> 来保存上个已执行命令的退出状态码。对于需要进行检查的 命令，必须在其运行完毕后立刻查看或使用 $? 变量。它的值会变成由shell所执行的最后一条命令的退出状态码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date</div><div class="line">Fri Apr 27 07:52:45 PDT 2018</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">0</div></pre></td></tr></table></figure>
<p>通常一个成功结束的命令的退出状态码是0，如果命令结束时有错误，这个代码就是一个正整数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ asd</div><div class="line">No command &apos;asd&apos; found, but there are 22 similar ones</div><div class="line">asd: command not found</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">127</div></pre></td></tr></table></figure>
<h3 id="exit命令">exit命令</h3>
<p>exit 命令允许你在脚本结束时指定一个退出状态码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># testing the exit status</div><div class="line">var1=10</div><div class="line">var2=30</div><div class="line">var3=$[$var1 + $var2]</div><div class="line">echo The answer is $var3</div><div class="line">exit 5</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test9</div><div class="line">The answer is 40</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">5</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">146</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共550.2k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  










  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine@1.1.4/dist/Valine.min.js"></script>
  <script type="text/javascript">
    new Valine({
        av: AV,
        el: '#vcomments' ,
        verify: true,
        notify: true,
        app_id: '4ORLDMxXCFDLSHPJ4wSSDkkw-gzGzoHsz',
        app_key: 'HSWpCY7XlN0pGV5DCrKoC0ic',
        placeholder: 'Comment input placeholder'
    });
  </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
