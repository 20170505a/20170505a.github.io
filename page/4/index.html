<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/4/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/4/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/28/Data Analysis for the life sciences/DALS028_Batch_Effect04_FactorAnalysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/Data Analysis for the life sciences/DALS028_Batch_Effect04_FactorAnalysis/" itemprop="url">DALS028-批次效应04-因子分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T12:00:00+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,761
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第10章批次效应的第3小节，这一部分的主要内容涉及批次效应(Batch Effects)的校正，有关这一部分Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/factor_analysis.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h2><p>在我们介绍另一种用于批量效应校正的统计方法之前，我们先介绍这种方法的核心统计思想：因子分析(Factor Analysis)。因子分子早是在一个多世纪前出现的。卡尔·皮尔森(Karl Pearson)指出，当计算学生之间不同科目的数据时，这些不同科目之间存在着相关性。为了解释这种现象，他提出了一个模型，该模型有一个能解释这种相关性的因子，对于每个学生来说，这个因子在各个学科中都是通用的(common)，如下所示：</p>
<script type="math/tex; mode=display">
Y_ij = \alpha_i W_1 + \varepsilon_{ij}</script><p>其中，$Y_{ij}$ 表示每个人 $i$ 的科目 $j$ 的成绩，而$\alpha_{i} $表示学生 $i$ 获得好成绩的能力。</p>
<p>在这个案例中，$W_{1}$ 是一个常数。这里我们使用一个稍微复杂的情况来说明因子分析，这种情况就类似于批次效应。我们生成一个随机的 $N \times 6$ 矩阵 $Y$ 来表示我们的研究对象，其中6表示不同的学科来表示 $N$ 表示 $N$ 个不同小孩。我们生成数据的方式就是，那些有一定相关性的学科。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">library(MASS)</div><div class="line">library(rafalib)</div><div class="line">n &lt;- 250</div><div class="line">p &lt;- 6</div><div class="line">set.seed(1)</div><div class="line">g &lt;- mvrnorm(n,c(0,0),matrix(c(1,0.5,0.5,1),2,2))</div><div class="line">Ystem &lt;- g[,1] + matrix(rnorm(n*p/2,0,0.65),n,p/2)</div><div class="line">Yhum &lt;- g[,2] + matrix(rnorm(n*p/2,0,0.65),n,p/2)</div><div class="line">Y &lt;- cbind(Ystem,Yhum)</div><div class="line">colnames(Y) &lt;- c(&quot;Math&quot;,&quot;Science&quot;,&quot;CS&quot;,&quot;Eng&quot;,&quot;Hist&quot;,&quot;Classics&quot;)</div></pre></td></tr></table></figure>
<h3 id="样本相关性"><a href="#样本相关性" class="headerlink" title="样本相关性"></a>样本相关性</h3><p>我们要注意一下，这6个学科有着高度的相关性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(cor(Y),2)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; round(cor(Y),<span class="number">2</span>)</div><div class="line">         Math Science   CS  Eng Hist Classics</div><div class="line">Math     <span class="number">1.00</span>    <span class="number">0.67</span> <span class="number">0.64</span> <span class="number">0.34</span> <span class="number">0.29</span>     <span class="number">0.28</span></div><div class="line">Science  <span class="number">0.67</span>    <span class="number">1.00</span> <span class="number">0.65</span> <span class="number">0.29</span> <span class="number">0.29</span>     <span class="number">0.26</span></div><div class="line">CS       <span class="number">0.64</span>    <span class="number">0.65</span> <span class="number">1.00</span> <span class="number">0.35</span> <span class="number">0.30</span>     <span class="number">0.29</span></div><div class="line">Eng      <span class="number">0.34</span>    <span class="number">0.29</span> <span class="number">0.35</span> <span class="number">1.00</span> <span class="number">0.71</span>     <span class="number">0.72</span></div><div class="line">Hist     <span class="number">0.29</span>    <span class="number">0.29</span> <span class="number">0.30</span> <span class="number">0.71</span> <span class="number">1.00</span>     <span class="number">0.68</span></div><div class="line">Classics <span class="number">0.28</span>    <span class="number">0.26</span> <span class="number">0.29</span> <span class="number">0.72</span> <span class="number">0.68</span>     <span class="number">1.00</span></div></pre></td></tr></table></figure>
<p>我们将使用图片来展示一下相关性，从下图我们可以发现，我们可以把学生分为STEM组与人文组（注：STEM与人文学科(humanities )其实就相当于中国的理科和文科，在这个案例中，STEM指的是科学(Science)，计算机(CS)和数学(Math)，人文学科指，古典学(Classics)，历史学(Hist)和英语语言文字(Eng)）。</p>
<p> 在下图中，高度相关性的学科用红色表示，不相关的学科用白色表示，负相关的学科用蓝色表示，代码如下所示：</p>
<figure class="highlight plain"><figcaption><span>correlation_images,fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">library(RColorBrewer)</div><div class="line">mypar(1,2)</div><div class="line">cols=colorRampPalette(rev(brewer.pal(11,&quot;RdBu&quot;)))(100)</div><div class="line">eps = matrix(rnorm(n*p),n,p)</div><div class="line">par(mar = c(8.1, 8.1, 3.5, 2.1))</div><div class="line">image(1:ncol(Y),1:ncol(Y),cor(Y)[,6:1],xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,col=cols,xlab=&quot;&quot;,ylab=&quot;&quot;,zlim=c(-1,1),main=&quot;Actual Data&quot;)</div><div class="line">axis(1,1:ncol(Y),colnames(Y),las=2)</div><div class="line">axis(2,1:ncol(Y),rev(colnames(Y)),las=2)</div><div class="line">image(1:ncol(Y),1:ncol(Y),cor(eps)[,6:1],xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,col=cols,xlab=&quot;&quot;,ylab=&quot;&quot;,zlim=c(-1,1),main=&quot;Independet Data&quot;)</div><div class="line">axis(1,1:ncol(Y),colnames(Y),las=2)</div><div class="line">axis(2,1:ncol(Y),rev(colnames(Y)),las=2)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917125200.jpeg" alt=""></p>
<p>从上图中，我们可以看到以下信息：所有学科之间都有相关性，这表明学生成绩的背景有着某些隐藏因素（例如学术能力），正是这种能力导致了这些学科表现的相关性，因为在一个科目中获得高分的学生往往在其它科目也能获得高分。我们还能看到，这种相关性在STEM类学科之间更强，以及在人文学科之间更强。这就说明了，还有可能存在着另一种隐藏因素，这种因素决定了学生擅长STEM还是人文学科。现在我们使用一个统计模型来解释这种思路。</p>
<h3 id="因子模型"><a href="#因子模型" class="headerlink" title="因子模型"></a>因子模型</h3><p>基于前面的图形展示结果，我们假设这些现象背后有2个隐藏因素 $\mathbf{W}_1$ 和 $\mathbf{W}_2$ ，我们用这两个因素来解释所观察到的相关性结构，现在我们使用下面的公式来建模：</p>
<script type="math/tex; mode=display">
Y_{ij} = \alpha_{i,1} W_{1,j} + \alpha_{i,2} W_{2,j} + \varepsilon_{ij}</script><p>参数解释： $\alpha_{i,1}$ 表示学生 $i$ 的整体学术能力，$\alpha_{i,2}$ 表示学生 $i$ 的这种学术能力在STEM与人文学科之间的差异。现在我们的问题就是，如何估计 $W$ 和 $\alpha$ ？</p>
<h3 id="因子分析与PCA"><a href="#因子分析与PCA" class="headerlink" title="因子分析与PCA"></a>因子分析与PCA</h3><p>结果表明，在某些假设下，前两个主成分是对于 $W_{1}$ 和 $W_{2}$ 的最优估计，因此我们可以按以下方式对它们进行估计：</p>
<p>It turns out that under certain assumptions, the first two principal components are optimal estimates for $W_1$ and $W_2$. So we can estimate them like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(Y)</div><div class="line">What &lt;- t(s$v[,1:2])</div><div class="line">colnames(What)&lt;-colnames(Y)</div><div class="line">round(What,2)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; round(What,<span class="number">2</span>)</div><div class="line">      Math Science    CS  Eng Hist</div><div class="line">[<span class="number">1</span>,]  <span class="number">0.36</span>    <span class="number">0.36</span>  <span class="number">0.36</span> <span class="number">0.47</span> <span class="number">0.43</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">0.44</span>   -<span class="number">0.49</span> -<span class="number">0.42</span> <span class="number">0.34</span> <span class="number">0.34</span></div><div class="line">     Classics</div><div class="line">[<span class="number">1</span>,]     <span class="number">0.45</span></div><div class="line">[<span class="number">2</span>,]     <span class="number">0.39</span></div></pre></td></tr></table></figure>
<p>正如预期，第一个因子接近于一个常数，它有助于解释所有学科之间观察到的相关性，而第二个因子能解释STEM和人文学科之间的不表现。现在我们就以下模型中使用这些估计值：</p>
<script type="math/tex; mode=display">
Y_{ij} = \alpha_{i,1} \hat{W}_{1,j} + \alpha_{i,2} \hat{W}_{2,j} + \varepsilon_{ij}</script><p>我们现在就可以拟合模型，并注意一下，它能解释多大比例的变异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fit = s$u[,1:2]%*% (s$d[1:2]*What)</div><div class="line">var(as.vector(fit))/var(as.vector(Y))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; fit = s$u[,<span class="number">1</span>:<span class="number">2</span>]%*% (s$d[<span class="number">1</span>:<span class="number">2</span>]*What)</div><div class="line">&gt; var(as.vector(fit))/var(as.vector(Y))</div><div class="line">[<span class="number">1</span>] <span class="number">0.7880933</span></div></pre></td></tr></table></figure>
<p>我们在这里学习到的是，当我们有一些相关的单位或数据时，并不适合使用标准的线性模型。我们需要以某种试来解释观察到的结果。而因子分子则是实现这一目标的强大方法。</p>
<h3 id="因子分析的常规用法"><a href="#因子分析的常规用法" class="headerlink" title="因子分析的常规用法"></a>因子分析的常规用法</h3><p>在高通量数据中，我们经常会看到相关结构。例如，我们在下图中展示了样本之间复杂的相关性。下面的这张图是按日期排序后，基因表达实验的数据展示结果：</p>
<figure class="highlight plain"><figcaption><span>gene_expression_correlations, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">library(Biobase)</div><div class="line">library(GSE5859)</div><div class="line">data(GSE5859)</div><div class="line">n &lt;- nrow(pData(e))</div><div class="line">o &lt;- order(pData(e)$date)</div><div class="line">Y=exprs(e)[,o]</div><div class="line">cors=cor(Y-rowMeans(Y))</div><div class="line">cols=colorRampPalette(rev(brewer.pal(11,&quot;RdBu&quot;)))(100)</div><div class="line">mypar()</div><div class="line">image(1:n,1:n,cors,col=cols,xlab=&quot;samples&quot;,ylab=&quot;samples&quot;,zlim=c(-1,1))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917141729.jpeg" alt=""></p>
<p>使用两个因子并不足以对观察到的相关结构进行建模。但是，我们可以使用一个更加普遍的因子模型：</p>
<script type="math/tex; mode=display">
Y_{ij} = \sum_{k=1}^K \alpha_{i,k} W_{j,k} + \varepsilon_{ij}</script><p>我们可以使用PCA来估计$\mathbf{W}_1,\dots,\mathbf{W}_K$。但是，在选择 $k$ 方面并不容易，这就是我们要研究问题的核心。在下面的章节里，我们会介绍一下，如何使用探索性数据分析来辅助我们找到这个 $k$ 。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P448</p>
<h2 id="使用因子分析来对批次效应建模"><a href="#使用因子分析来对批次效应建模" class="headerlink" title="使用因子分析来对批次效应建模"></a>使用因子分析来对批次效应建模</h2><p>继续使用前面的数据集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">library(GSE5859Subset)</div><div class="line">data(GSE5859Subset)</div></pre></td></tr></table></figure>
<p>我们之前展示过一些图形，那些图形中包括了性别效应与月份效应的基因子集，但是，现在我们使用一张图片来展示样本与样本之间的相关性（所有基因），并且展示出数据的复杂结构，如下所示：</p>
<figure class="highlight plain"><figcaption><span>correlation_image, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(RColorBrewer)</div><div class="line">library(genefilter)</div><div class="line">sex &lt;- sampleInfo$group</div><div class="line">batch &lt;- factor(format(sampleInfo$date,&quot;%m&quot;))</div><div class="line">chr &lt;- geneAnnotation$CHR</div><div class="line">tt&lt;-rowttests(geneExpression,batch)</div><div class="line">ind1 &lt;- which(chr==&quot;chrY&quot;) #real differences</div><div class="line">ind2 &lt;- setdiff(c(order(tt$dm)[1:25],order(-tt$dm)[1:25]),ind1)</div><div class="line">set.seed(1)</div><div class="line">ind0 &lt;- setdiff(sample(seq(along=tt$dm),50),c(ind2,ind1))</div><div class="line">geneindex&lt;-c(ind2,ind0,ind1)</div><div class="line">mat&lt;-geneExpression[geneindex,]</div><div class="line">mat &lt;- mat -rowMeans(mat)</div><div class="line">icolors &lt;- colorRampPalette(rev(brewer.pal(11,&quot;RdYlBu&quot;)))(100)</div><div class="line">mypar(1,2)</div><div class="line">image(t(mat),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,col=icolors)</div><div class="line">y &lt;- geneExpression - rowMeans(geneExpression)</div><div class="line">image(1:ncol(y),1:ncol(y),cor(y),col=icolors,zlim=c(-1,1),</div><div class="line">       xaxt=&quot;n&quot;,xlab=&quot;&quot;,yaxt=&quot;n&quot;,ylab=&quot;&quot;)</div><div class="line">axis(2,1:ncol(y),sex,las=2)</div><div class="line">axis(1,1:ncol(y),sex,las=2)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917142426.jpeg" alt=""></p>
<p>我们已经看到了即假设月份能够解释批次效应效应，并且使用线性模型对批次效应进行校正后的方法，这种方法表现很好。但是，这种方法仍然有改进的空间。这有可能是由于月份仅仅是背后一些隐藏因子的外面表现，或者是说是一些实际上导致结构或样本相关性的因子。</p>
<h3 id="什么是一个批次"><a href="#什么是一个批次" class="headerlink" title="什么是一个批次"></a>什么是一个批次</h3><p>现在我画出每个样本的日期图，其中颜色表示月份，如下所示：</p>
<figure class="highlight plain"><figcaption><span>what_is_batch, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">times &lt;-sampleInfo$date </div><div class="line">mypar(1,1)</div><div class="line">o=order(times)</div><div class="line">plot(times[o],pch=21,bg=as.numeric(batch)[o],ylab=&quot;Date&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917142913.jpeg" alt=""></p>
<p>我们注意到，每个月不止有一天。天这个时间单位也会产生影响吗？我们可以使用PCA和EDA来尝试回答一下这个问题。以下是按日期排序后的第一个主成分图：</p>
<figure class="highlight plain"><figcaption><span>PC1_versus_time, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(y)</div><div class="line">mypar(1,1)</div><div class="line">o&lt;-order(times)</div><div class="line">cols &lt;- as.numeric( batch)</div><div class="line">plot(s$v[o,1],pch=21,cex=1.25,bg=cols[o],ylab=&quot;First PC&quot;,xlab=&quot;Date order&quot;)</div><div class="line">legend(&quot;topleft&quot;,c(&quot;Month 1&quot;,&quot;Month 2&quot;),col=1:2,pch=16,box.lwd=0)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917143100.jpeg" alt=""></p>
<p>“天”似乎与第1主成分高度相关，它可以在很大程度上解释变异：</p>
<figure class="highlight plain"><figcaption><span>variance_explained, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(s$d^2/sum(s$d^2),ylab=&quot;% variance explained&quot;,xlab=&quot;Principal component&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917143153.jpeg" alt=""></p>
<p>进一步的研究显示，前6个左右的主成分(PC)似乎都是由日期驱动的：</p>
<figure class="highlight plain"><figcaption><span>PCs_stratified_by_time, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mypar(3,4)</div><div class="line">for(i in 1:12)&#123;</div><div class="line">  days &lt;- gsub(&quot;2005-&quot;,&quot;&quot;,times)  </div><div class="line">  boxplot(split(s$v[,i],gsub(&quot;2005-&quot;,&quot;&quot;,days)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917143257.jpeg" alt=""></p>
<p>如果我们从数据中将前6个主成分移除后，我们使用t检验来看一下结果是什么样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D &lt;- s$d; D[1:4]&lt;-0 #take out first 2</div><div class="line">cleandat &lt;- sweep(s$u,2,D,&quot;*&quot;)%*%t(s$v)</div><div class="line">res &lt;-rowttests(cleandat,factor(sex))</div></pre></td></tr></table></figure>
<p>事实上，这确实消除了批次效应，但是这似乎也消除了我们感兴趣的大部分生物学效应。事实上，没有基因的Q值再小于0.1了，如下所示：</p>
<figure class="highlight plain"><figcaption><span>pval_hist_and_volcano_after_removing_PCs, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">library(qvalue)</div><div class="line">mypar(1,2)</div><div class="line">hist(res$p.value[which(!chr%in%c(&quot;chrX&quot;,&quot;chrY&quot;) )],main=&quot;&quot;,ylim=c(0,1300))</div><div class="line">plot(res$dm,-log10(res$p.value))</div><div class="line">points(res$dm[which(chr==&quot;chrX&quot;)],-log10(res$p.value[which(chr==&quot;chrX&quot;)]),col=1,pch=16)</div><div class="line">points(res$dm[which(chr==&quot;chrY&quot;)],-log10(res$p.value[which(chr==&quot;chrY&quot;)]),col=2,pch=16,</div><div class="line">       xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;chrX&quot;,&quot;chrY&quot;),col=1:2,pch=16)</div><div class="line">qvals &lt;- qvalue(res$p.value)$qvalue</div><div class="line">index &lt;- which(qvals&lt;0.1)</div><div class="line">cat(&quot;Total genes with q-value &lt; 0.1: &quot;,length(index),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrY: &quot;, sum(chr[index]==&quot;chrY&quot;,na.rm=TRUE),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrX: &quot;, sum(chr[index]==&quot;chrX&quot;,na.rm=TRUE),sep=&quot;&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917143622.jpeg" alt=""></p>
<p>这种情况似乎就是过度校正了，因为我们现在恢复了更少的Y染色体基因，并且p值的直方图中小p值的数目更小了，使得分布变得不再均匀。因此性别因素可能与前几个主成分(PC)有关，这就出现了”把婴儿和洗澡水一起倒掉“的情况。</p>
<h3 id="SVA"><a href="#SVA" class="headerlink" title="SVA"></a>SVA</h3><p>前面我们刚提到了我们所遇到的问题，即我们遇到了过度校正，以及消除了与感兴趣结果相关的变异，解决这个问题的方法就是同时使用感兴趣变量的协变量以及那些被认为是批次的模型共同进行拟合。代理变量分析(SVA, Surrogate Variable Analysis)就是这样的一种方法。</p>
<p>SVA的基本思想就是先估计因子，但要注意不要包括感兴趣的结果。为此，SVA使用了一种交互式方法，其中的每一行都赋予一个权重，这个权重能够量化基因与替代变量（而不是感兴趣结果）唯一相关的概率。然后在SVD中使用这些权重，将更高的权重赋予给感兴趣的结果无关，且与批次有关的行。下面是这两次迭代的计算过程。三个图片显示的是，数据乘以权重（对于基因的子集）、权重，以及估计的第一因子，代码如下所示：</p>
<figure class="highlight plain"><figcaption><span>illustration_of_sva,fig.height</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">library(sva)</div><div class="line">library(limma)</div><div class="line">mod &lt;- model.matrix(~sex)</div><div class="line">cind &lt;- order( as.Date(sampleInfo$date) )</div><div class="line">dates &lt;- gsub(&quot;2005-&quot;,&quot;&quot;,sampleInfo$date)</div><div class="line">weights=rep(1,nrow(y))</div><div class="line">par(mar = c(4.1, 2.1, 3.5, 2.1), </div><div class="line">    mgp = c(1.5, 0.5, 0))</div><div class="line">layout(matrix(c(1:6),nrow=2,byrow=TRUE),widths=c(5,1.5,5))</div><div class="line">for(b in 1:2)&#123;</div><div class="line">  image(1:ncol(mat),1:nrow(mat),t(mat[,cind]*weights[geneindex]),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,col=icolors,xlab=&quot;&quot;,ylab=&quot;&quot;)</div><div class="line">  axis(side=1,seq(along=dates),dates[cind],las=2)</div><div class="line">  abline(v=12.5)</div><div class="line">  </div><div class="line">  svafit &lt;- sva(y,mod,B=b,n.sv=5)</div><div class="line">  weights = svafit$pprob.gam*(1-svafit$pprob.b)</div><div class="line">  </div><div class="line">  surrogate &lt;- svd( y*weights)$v[,1]#Weighted SVD</div><div class="line">  </div><div class="line">  image(matrix(weights[geneindex],nrow=1),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,col=brewer.pal(9,&quot;Blues&quot;))</div><div class="line">  plot(surrogate[cind],bg=sex[cind]+1,pch=21,xlab=&quot;&quot;,xaxt=&quot;n&quot;,ylab=&quot;Surrogate variable&quot;,ylim=c(-.5,.5),cex=1.5)</div><div class="line">  axis(side=1,seq(along=dates),dates[cind],las=2)</div><div class="line">  abline(v=12.5)</div><div class="line">  text(1,0.5,&quot;June&quot;)</div><div class="line">  text(13.5,0.5,&quot;Oct&quot;)</div><div class="line">  legend(&quot;bottomright&quot;,c(&quot;0&quot;,&quot;1&quot;),col=c(1,2),pch=16)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917153302.jpeg" alt=""></p>
<p>这个算法会多次迭代这个过程（由<code>B</code>参数控制），并返回替代变量的估计值，这就类似于因子分子中的隐藏因子。在R中，我们使用<code>sva()</code>函数来实现这个过程。在这个案例里，SVA会为我们选择代理值或因子的数量，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">library(limma)</div><div class="line">svafit &lt;- sva(geneExpression,mod)</div><div class="line">svaX&lt;-model.matrix(~sex+svafit$sv)</div><div class="line">lmfit &lt;- lmFit(geneExpression,svaX)</div><div class="line">tt&lt;- lmfit$coef[,2]*sqrt(lmfit$df.residual)/(2*lmfit$sigma)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; svafit &lt;- sva(geneExpression,mod)</div><div class="line">Number of significant surrogate variables is:  <span class="number">5</span> </div><div class="line">Iteration (out of <span class="number">5</span> ):<span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span></div></pre></td></tr></table></figure>
<p>与之前的方法相比，这种方法有了提升：</p>
<figure class="highlight plain"><figcaption><span>pval_hist_and_volcano_sva, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">res &lt;- data.frame(dm= -lmfit$coef[,2],</div><div class="line">                  p.value=2*(1-pt(abs(tt),lmfit$df.residual[1]) ) )</div><div class="line">mypar(1,2)</div><div class="line">hist(res$p.value[which(!chr%in%c(&quot;chrX&quot;,&quot;chrY&quot;) )],main=&quot;&quot;,ylim=c(0,1300))</div><div class="line">plot(res$dm,-log10(res$p.value))</div><div class="line">points(res$dm[which(chr==&quot;chrX&quot;)],-log10(res$p.value[which(chr==&quot;chrX&quot;)]),col=1,pch=16)</div><div class="line">points(res$dm[which(chr==&quot;chrY&quot;)],-log10(res$p.value[which(chr==&quot;chrY&quot;)]),col=2,pch=16,</div><div class="line">       xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;chrX&quot;,&quot;chrY&quot;),col=1:2,pch=16)</div><div class="line">qvals &lt;- qvalue(res$p.value)$qvalue</div><div class="line">index &lt;- which(qvals&lt;0.1)</div><div class="line">cat(&quot;Total genes with q-value &lt; 0.1: &quot;,length(index),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrY: &quot;, sum(chr[index]==&quot;chrY&quot;,na.rm=TRUE),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrX: &quot;, sum(chr[index]==&quot;chrX&quot;,na.rm=TRUE),sep=&quot;&quot;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"Total genes with q-value &lt; 0.1: "</span>,length(index),<span class="string">"\n"</span>,</div><div class="line">+     <span class="string">"Number of selected genes on chrY: "</span>, sum(chr[index]==<span class="string">"chrY"</span>,na.rm=<span class="literal">TRUE</span>),<span class="string">"\n"</span>,</div><div class="line">+     <span class="string">"Number of selected genes on chrX: "</span>, sum(chr[index]==<span class="string">"chrX"</span>,na.rm=<span class="literal">TRUE</span>),sep=<span class="string">""</span>)</div><div class="line">Total genes with q-value &lt; <span class="number">0.1</span>: <span class="number">14</span></div><div class="line">Number of selected genes on chrY: <span class="number">5</span></div><div class="line">Number of selected genes on chrX: <span class="number">8</span></div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917154043.jpeg" alt=""></p>
<p>现在我们通过图形来展示SVA实现了什么，下面是原始数据集分解为性别效应，代理变量和独立噪声的</p>
<p>为了可视化SVA实现了什么，下面是原始数据集通过算法分解为性别效果、代理变量和算法估计的独立噪声的可视化结果：</p>
<figure class="highlight plain"><figcaption><span>different_sources_of_var, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Batch&lt;- lmfit$coef[geneindex,3:7]%*%t(svaX[,3:7])</div><div class="line">Signal&lt;-lmfit$coef[geneindex,1:2]%*%t(svaX[,1:2])</div><div class="line">error &lt;- geneExpression[geneindex,]-Signal-Batch</div><div class="line">##demean for plot</div><div class="line">Signal &lt;-Signal-rowMeans(Signal)</div><div class="line">mat &lt;- geneExpression[geneindex,]-rowMeans(geneExpression[geneindex,])</div><div class="line">mypar(1,4,mar = c(2.75, 4.5, 2.6, 1.1))</div><div class="line">image(t(mat),col=icolors,zlim=c(-5,5),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;)</div><div class="line">image(t(Signal),col=icolors,zlim=c(-5,5),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;)</div><div class="line">image(t(Batch),col=icolors,zlim=c(-5,5),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;)</div><div class="line">image(t(error),col=icolors,zlim=c(-5,5),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190917154225.jpeg" alt=""></p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>P459</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/27/Data Analysis for the life sciences/DALS027_Batch_Effect03_AdjustBatchEffect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/27/Data Analysis for the life sciences/DALS027_Batch_Effect03_AdjustBatchEffect/" itemprop="url">DALS027-批次效应03-校正批次效应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T12:00:00+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,986
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第10章批次效应的第3小节，这一部分的主要内容涉及批次效应(Batch Effects)的校正，有关这一部分Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/adjusting_with_linear_models.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h2><p>在这一部分里，我们要了解如何对批次效应进行校正。</p>
<h3 id="数据案例"><a href="#数据案例" class="headerlink" title="数据案例"></a>数据案例</h3><p>为了说明我们可以使用统计方法来校正批次效应，我们将创建一个数据示例，其中感兴趣的结果与批次之间有某种程度的混杂，但不完全混杂。为了辅助说明和评估我们所示的方法，我们还将选择一个结果用于说明我们期望对哪些基因应该是差异表达的。也就是说，我们想让性别作为我们感兴趣的变量，并且期望 Y 染色体上的基因表达有所差异。我们或许能看到，来源于 X 染色体上的基因是差异表达的，因为有些基因在 X 染色体上并没有失活，而是正常表达，这些数据都包含在以下的数据集中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">##available from course github repository</div><div class="line">library(GSE5859Subset)</div><div class="line">data(GSE5859Subset)</div></pre></td></tr></table></figure>
<p>我们可以看到，性别与月份有相关性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">month &lt;- format(sampleInfo$date,&quot;%m&quot;)</div><div class="line">table(sampleInfo$group, month)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; month &lt;- format(sampleInfo$date,<span class="string">"%m"</span>)</div><div class="line">&gt; table(sampleInfo$group, month)</div><div class="line">   month</div><div class="line">    <span class="number">06</span> <span class="number">10</span></div><div class="line">  <span class="number">0</span>  <span class="number">9</span>  <span class="number">3</span></div><div class="line">  <span class="number">1</span>  <span class="number">3</span>  <span class="number">9</span></div></pre></td></tr></table></figure>
<p>为了说明混杂现在，我们会挑选一些基因绘制热图。现在我们挑选这些基因：(1)所有Y染色体上的基因；(2)某些与批次效应有效的基因；(3)一些随机选择的基因。下面是热图，其中红色表示高表达基因，蓝色表示低表达基因，黄色表示中间表达基因。每列是一个样本，每行就是随机选择的基因，代码如下所示：</p>
<figure class="highlight plain"><figcaption><span>image_of_subset, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(RColorBrewer)</div><div class="line">library(genefilter)</div><div class="line">batch &lt;- factor(format(sampleInfo$date,&quot;%m&quot;))</div><div class="line">chr &lt;- geneAnnotation$CHR</div><div class="line">tt&lt;-rowttests(geneExpression,batch)</div><div class="line">ind1 &lt;- which(chr==&quot;chrY&quot;) ##real differences</div><div class="line">ind2 &lt;- setdiff(c(order(tt$dm)[1:25],order(-tt$dm)[1:25]),ind1)</div><div class="line">set.seed(1)</div><div class="line">ind0 &lt;- setdiff(sample(seq(along=tt$dm),50),c(ind2,ind1))</div><div class="line">geneindex&lt;-c(ind2,ind0,ind1)</div><div class="line">mat&lt;-geneExpression[geneindex,]</div><div class="line">mat &lt;- mat -rowMeans(mat)</div><div class="line">icolors &lt;- colorRampPalette(rev(brewer.pal(11,&quot;RdYlBu&quot;)))(100)</div><div class="line">mypar(1,1)</div><div class="line">image(1:24,1:nrow(mat), t(mat),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,col=icolors,xlab=&quot;&quot;,ylab=&quot;&quot;)</div><div class="line">axis(3,1:24,rep(c(&quot;F&quot;,&quot;M&quot;),each=12),cex.axis=0.5)</div><div class="line">axis(1,1:24,month,cex.axis=0.5)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916180846.jpeg" alt=""></p>
<p>在上图中，前12列是女性（用1表示），后12列是男性（用0表示）。我们可以看到，一些Y染色体上的基因趋向顶部，其中在女性数据中这些是蓝色，在男性数据中这是红色。我们也可以看到一些基因与月份相关，这些基因集中趋向于底部。一些基因在六月份低表达（June，6），一些基因在10月份高表达（October，10），还有一些基因正好相反。月份效应并没有性别效应明显，但是这种效应确实存在。</p>
<p>在接下来的内容里，我们会模拟实际分析中的一些典型分析方法。我们会假设一种情况，在这种情况里，我们假设不知道哪些基因在男女性别有差异，然后我们要找出这些差异基因，通过比较我们所期望的相关性，来评估一下这些方法的优劣。这里需要注意一下，我们虽然只绘制出其中一部分基因，但是我们所分析的基因数目却是8793个。</p>
<h3 id="评估图与总结"><a href="#评估图与总结" class="headerlink" title="评估图与总结"></a>评估图与总结</h3><p>为了说明我们所用方法的优劣，我们将假设常染色体上的基因（这些基因不在染色体X和染色体Y上）有可能是假阳性，位于Y染色体上的基因是真阳性。染色体X上的基因可以是假阳性，可以是真阳性。上述的这些设计就在让我们评估特异性(specificity)与灵敏性(sensitivity)。由于在实际分析中，我们很少能知道“真相”，因此我们在这里做的评估是很在实际分析中实现的。因此模拟常常用于评估目的：我们知道真相，因为分析所用的数据是我们自己构建的。但是，模拟也会有无法捕获真实实验数据细微差异的风险。相比之下，这个数据集就是一个实验性质的数据集。</p>
<p>在接下来的部分中，我们将使用p值的直方图来评估一下批次效应校正程序的特异性(specificity)，特异性表示低假阳性率。因为常染色体应该不会出现由于差异导致的差异表达，我们应该会看到一个平坦的p值直方图。为了评估灵敏性(sensitivity,低假阳性)，我们会报告那些位于X染色体和Y染色体上我们拒绝零假设时，所计算出的基因的数目。我们还会生成一个火山图，用一条水平虚线将那些有显著性差异的基因与无显著性差异的基因区分开来，用于突出显示X染色体和Y染色体的基因。以下是一个应用原始t检验得到的结果，以及q值小于0.1的基因，如下所示：</p>
<figure class="highlight plain"><figcaption><span>pvalue_hist_and_volcano_plots, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">library(qvalue)</div><div class="line">res &lt;- rowttests(geneExpression,as.factor( sampleInfo$group ))</div><div class="line">mypar(1,2)</div><div class="line">hist(res$p.value[which(!chr%in%c(&quot;chrX&quot;,&quot;chrY&quot;) )],main=&quot;&quot;,ylim=c(0,1300))</div><div class="line">plot(res$dm,-log10(res$p.value))</div><div class="line">points(res$dm[which(chr==&quot;chrX&quot;)],-log10(res$p.value[which(chr==&quot;chrX&quot;)]),col=1,pch=16)</div><div class="line">points(res$dm[which(chr==&quot;chrY&quot;)],-log10(res$p.value[which(chr==&quot;chrY&quot;)]),col=2,pch=16,</div><div class="line">       xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;chrX&quot;,&quot;chrY&quot;),col=1:2,pch=16)</div><div class="line">qvals &lt;- qvalue(res$p.value)$qvalue</div><div class="line">index &lt;- which(qvals&lt;0.1)</div><div class="line">abline(h=-log10(max(res$p.value[index])))</div><div class="line">cat(&quot;Total genes with q-value &lt; 0.1: &quot;,length(index),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrY: &quot;, sum(chr[index]==&quot;chrY&quot;,na.rm=TRUE),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrX: &quot;, sum(chr[index]==&quot;chrX&quot;,na.rm=TRUE),sep=&quot;&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916180856.jpeg" alt=""></p>
<p>很明显，我们注意到直方图并不平坦的。相反，低p值的条状过高（原文：low p-values are over-represented）。此外，最终列表上超过一半的基因是常染色体。我们现在介绍两个统计学方法来尝试一下解决这个问题。</p>
<h3 id="使用线性模型来校正批次效应"><a href="#使用线性模型来校正批次效应" class="headerlink" title="使用线性模型来校正批次效应"></a>使用线性模型来校正批次效应</h3><p>我们已经观察到了处理时间(processing date)对基因表达有着某种效应。我们因此会通过将此效应添加到一个模型中来对其进行校正(adjust)。当我们对两组数据进行t检验时，它就相当于对基因 $j$ 进行以下线性模型拟合：</p>
<script type="math/tex; mode=display">
Y_{ij} = \alpha_j + x_i \beta_{j} + \varepsilon_{ij}</script><p>其中，研究对象 $i$ 如果是女性，那么 $x_{i}=1$, 如果是男性则为0，$\beta_{j}$ 表示基因 $j$ 的差异，$\varepsilon_{ij}$ 表示组内变异。现在我们的问题是什么？</p>
<p>在线性模型那一章节中，我们假设错误项(error term)是独立的。我们知道，对于所有的基因来说，这是不可能的，因为我们知道10月份数据中的错误项比6月份中的错误项更相似。我们可以在线性模型中添加一项，用于校正这种错误，如下所示：</p>
<script type="math/tex; mode=display">
Y_{ij} = \alpha_j + x_i \beta_{j} + z_i \gamma_j+\varepsilon_{ij}.</script><p>在这个公式中，如果样本 $i$ 是在10月份处理的，那么 $z_{i}=1$ ，否则为0，另外， $\gamma_{j}$ 是基因$j$的月份效应。这就是 一个线性模型如何比t检验具有更大灵活性的一个例子。</p>
<p>我们构建一个含有批次的模型矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sex &lt;- sampleInfo$group</div><div class="line">X &lt;- model.matrix(~sex+batch)</div></pre></td></tr></table></figure>
<p>现在我们对每个基因拟合一个模型。例如，我们要注意在原始模型和那些含有批次校正模型之间的差异，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">j &lt;- 7635</div><div class="line">y &lt;- geneExpression[j,]</div><div class="line">X0 &lt;- model.matrix(~sex) </div><div class="line">fit &lt;- lm(y~X0-1)</div><div class="line">summary(fit)$coef</div><div class="line">X &lt;- model.matrix(~sex+batch)</div><div class="line">fit &lt;- lm(y~X)</div><div class="line">summary(fit)$coef</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; summary(fit)$coef</div><div class="line">                Estimate Std. Error   t value     Pr(&gt;|t|)</div><div class="line">X0(Intercept)  <span class="number">6.9555747</span>  <span class="number">0.2166035</span> <span class="number">32.112008</span> <span class="number">5.611901e-20</span></div><div class="line">X0sex         -<span class="number">0.6556865</span>  <span class="number">0.3063237</span> -<span class="number">2.140502</span> <span class="number">4.365102e-02</span></div><div class="line">&gt; X &lt;- model.matrix(~sex+batch)</div><div class="line">&gt; fit &lt;- lm(y~X)</div><div class="line">&gt; summary(fit)$coef</div><div class="line">               Estimate Std. Error    t value     Pr(&gt;|t|)</div><div class="line">(Intercept)  <span class="number">7.26329968</span>  <span class="number">0.1605560</span> <span class="number">45.2384140</span> <span class="number">2.036006e-22</span></div><div class="line">Xsex        -<span class="number">0.04023663</span>  <span class="number">0.2427379</span> -<span class="number">0.1657616</span> <span class="number">8.699300e-01</span></div><div class="line">Xbatch10    -<span class="number">1.23089977</span>  <span class="number">0.2427379</span> -<span class="number">5.0709009</span> <span class="number">5.070727e-05</span></div></pre></td></tr></table></figure>
<p>我们然后将这个新模型用于每个基因，例如我们可以使用<code>sapply()</code>函数来恢复估计的系数和p值，如下所示：</p>
<figure class="highlight plain"><figcaption><span>pvalue_hist_and_volcano_plots2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">res &lt;- t( sapply(1:nrow(geneExpression),function(j)&#123;</div><div class="line">  y &lt;- geneExpression[j,]</div><div class="line">  fit &lt;- lm(y~X-1)</div><div class="line">  summary(fit)$coef[2,c(1,4)]</div><div class="line">&#125; ) )</div><div class="line">##turn into data.frame so we can use the same code for plots as above</div><div class="line">res &lt;- data.frame(res)</div><div class="line">names(res) &lt;- c(&quot;dm&quot;,&quot;p.value&quot;)</div><div class="line">mypar(1,2)</div><div class="line">hist(res$p.value[which(!chr%in%c(&quot;chrX&quot;,&quot;chrY&quot;) )],main=&quot;&quot;,ylim=c(0,1300))</div><div class="line">plot(res$dm,-log10(res$p.value))</div><div class="line">points(res$dm[which(chr==&quot;chrX&quot;)],-log10(res$p.value[which(chr==&quot;chrX&quot;)]),col=1,pch=16)</div><div class="line">points(res$dm[which(chr==&quot;chrY&quot;)],-log10(res$p.value[which(chr==&quot;chrY&quot;)]),col=2,pch=16,</div><div class="line">       xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;chrX&quot;,&quot;chrY&quot;),col=1:2,pch=16)</div><div class="line">qvals &lt;- qvalue(res$p.value)$qvalue</div><div class="line">index &lt;- which(qvals&lt;0.1)</div><div class="line">abline(h=-log10(max(res$p.value[index])))</div><div class="line">cat(&quot;Total genes with q-value &lt; 0.1: &quot;,length(index),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrY: &quot;, sum(chr[index]==&quot;chrY&quot;,na.rm=TRUE),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrX: &quot;, sum(chr[index]==&quot;chrX&quot;,na.rm=TRUE),sep=&quot;&quot;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916181644.jpeg" alt=""></p>
<p>从图上我们可以看到，特异性（假阳性较少）有了很大的提高，同时灵敏性也没有过多损失（我们仍然能发现许多Y染色体上的基因）。但是，我们仍然能够从直方图中看到一些偏差，在后面的部分里，我们可以看到月份并不能完美地解释批次效应，应该有更好的估计方法。</p>
<h3 id="注意计算效率"><a href="#注意计算效率" class="headerlink" title="注意计算效率"></a>注意计算效率</h3><p>在上面代码中，当我们重复计算 $(X^\top X)^{-1}$，以及将其应用于每个基因时，设计矩阵并没发生改变。相反，我们可以在一次矩阵代数计算中实现该计算，然后通过将 $(X^\top X)^{-1}X^\top Y$ 与表示所有基因的 $Y$ 列相乘来获得所有的 $\beta$ 。<code>limma</code>包的设计就是基于这个思路（利用了QR分解）。我们来看一下这样的计算有多快：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(limma)</div><div class="line">X &lt;- model.matrix(~sex+batch)</div><div class="line">fit &lt;- lmFit(geneExpression,X)</div></pre></td></tr></table></figure>
<p>每个基因的估计回归系数如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dim( fit$coef)</div><div class="line"># &gt; dim( fit$coef)</div><div class="line"># [1] 8793    3</div></pre></td></tr></table></figure>
<p>我们对每个基因都有一个估计。如果要获得其中一个p值，我们就必须要构建以下的比值(ratio)：</p>
<p>We have one estimate for each gene. To obtain p-values for one of these, we have to construct the ratios:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- 2 ##second coef</div><div class="line">ses &lt;- fit$stdev.unscaled[,k]*fit$sigma</div><div class="line">ttest &lt;- fit$coef[,k]/ses</div><div class="line">pvals &lt;- 2*pt(-abs(ttest),fit$df)</div></pre></td></tr></table></figure>
<h2 id="Combat"><a href="#Combat" class="headerlink" title="Combat"></a>Combat</h2><p> <a href="http://biostatistics.oxfordjournals.org/content/8/1/118.short" target="_blank" rel="external">Combat</a> 是一种基于线性模型的算法，常用于校正批次效应。这种方法能够对估计值拟合一个分层模型，并且移除行的特定批次效应。Combat使用了一个模块块的方法(a modular approach)。第一步就是删除那些被认为是批次效应的内容，如下所示：</p>
<figure class="highlight plain"><figcaption><span>message</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(sva) #available from Bioconductor</div><div class="line">mod &lt;- model.matrix(~sex)</div><div class="line">cleandat &lt;- ComBat(geneExpression,batch,mod)</div></pre></td></tr></table></figure>
<p>然后，将剩下的结果用于拟合我们感兴趣的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res&lt;-genefilter::rowttests(cleandat,factor(sex))</div></pre></td></tr></table></figure>
<p>在这种情况下，与我们通过拟合简单线性模型得到的结果相比，通过上面计算得到的结果缺乏特异性（原文：the results are less specific than what we obtain by fitting the simple linear model）：</p>
<figure class="highlight plain"><figcaption><span>pvalue_hist_and_volcano_plots3, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mypar(1,2)</div><div class="line">hist(res$p.value[which(!chr%in%c(&quot;chrX&quot;,&quot;chrY&quot;) )],main=&quot;&quot;,ylim=c(0,1300))</div><div class="line">plot(res$dm,-log10(res$p.value))</div><div class="line">points(res$dm[which(chr==&quot;chrX&quot;)],-log10(res$p.value[which(chr==&quot;chrX&quot;)]),col=1,pch=16)</div><div class="line">points(res$dm[which(chr==&quot;chrY&quot;)],-log10(res$p.value[which(chr==&quot;chrY&quot;)]),col=2,pch=16,</div><div class="line">       xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;chrX&quot;,&quot;chrY&quot;),col=1:2,pch=16)</div><div class="line">qvals &lt;- qvalue(res$p.value)$qvalue</div><div class="line">index &lt;- which(qvals&lt;0.1)</div><div class="line">abline(h=-log10(max(res$p.value[index])))</div><div class="line">cat(&quot;Total genes with q-value &lt; 0.1: &quot;,length(index),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrY: &quot;, sum(chr[index]==&quot;chrY&quot;,na.rm=TRUE),&quot;\n&quot;,</div><div class="line">    &quot;Number of selected genes on chrX: &quot;, sum(chr[index]==&quot;chrX&quot;,na.rm=TRUE),sep=&quot;&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916181815.jpeg" alt=""></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P442</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/26/Data Analysis for the life sciences/DALS026_Batch_Effect02_DiscoteryBatchEffect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/Data Analysis for the life sciences/DALS026_Batch_Effect02_DiscoteryBatchEffect/" itemprop="url">DALS026-批次效应02-发现批次效应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T12:00:00+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,150
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第10章批次效应的第2小节，这一部分的主要内容涉及批次效应(Batch Effects)的发现与处理，有关这一部分Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/tree/master/batch/eda_with_pca.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经介绍过了PCA，我们在实际运用过程中就可以使用PCA来进行探索性数据分析了。为了说明这一点，我们将会使用一个现实中存在的数据集，出于我们教学的目的，这个数据还是原始数据，并没有经过数据清洗。我们首先从公共数据库中下载这个原始数据，接着你要做的就是预处理这些数据，并使用Bioconductor中的一个包进行后续的数据分析。</p>
<h2 id="基因表达数据"><a href="#基因表达数据" class="headerlink" title="基因表达数据"></a>基因表达数据</h2><p>第一步，下载数据，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="comment"># devtools::install_github("genomicsclass/GSE5859")</span></div><div class="line"><span class="keyword">library</span>(GSE5859) <span class="comment">##Available from GitHub</span></div><div class="line">data(GSE5859)</div></pre></td></tr></table></figure>
<p>注：这里书本中有所出入，如果使用<code>install_github</code> 下载不顺利，那么直接去Github上下载原代码即可。</p>
<p>第二步，数据探索。这里先从探索样本相关性矩阵开始，我们注意到有一对样本的相关性是1。这就说明这里面有一个样本被上传到了公共数据库2次，但是上传后的名称不同，下面的代码将会剔除这个样本，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cors &lt;- cor(exprs(e))</div><div class="line">Pairs=which(abs(cors)&gt;<span class="number">0.9999</span>,arr.ind=<span class="literal">TRUE</span>)</div><div class="line">out = Pairs[which(Pairs[,<span class="number">1</span>]&lt;Pairs[,<span class="number">2</span>]),,drop=<span class="literal">FALSE</span>]</div><div class="line"><span class="keyword">if</span>(length(out[,<span class="number">2</span>])&gt;<span class="number">0</span>) e=e[,-out[<span class="number">2</span>]]</div></pre></td></tr></table></figure>
<p>还可以移除对照组的探针名，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">out &lt;- grep(<span class="string">"AFFX"</span>,featureNames(e))</div><div class="line">e &lt;- e[-out,]</div></pre></td></tr></table></figure>
<p>第三步，处理数据。现在我们创建一个去趋势(detrended)基因表达数据矩阵，并从样本注释表中提取日期与结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y &lt;- exprs(e)-rowMeans(exprs(e))</div><div class="line">dates &lt;- pData(e)$date</div><div class="line">eth &lt;- pData(e)$ethnicity</div></pre></td></tr></table></figure>
<p>原始数据集中不包括样本信息中的性别。但是，我们为了出于教学的目的，我们使用下面的数据来研究一下这个性别问题，也就是说，在下面的代码中，我们会展示一下如何预测每个样本的性别。这种计算的基本思路就是观察Y染色体中基因的中位数基因表达水平。男性的这个数字应该更高。为此，我们需要使用一个注释包，用于提供这个实验中所用平台的一些特征信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">annotation(e)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; annotation(e)</div><div class="line">[<span class="number">1</span>] <span class="string">"hgfocus"</span></div></pre></td></tr></table></figure>
<p>此时，我们需要下载并安装<code>hgfocus.db</code>包，然后提取染色体位置的信息，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">map2gene &lt;- mapIds(hgfocus.db, keys=featureNames(e),</div><div class="line">                   column=<span class="string">"ENTREZID"</span>, keytype=<span class="string">"PROBEID"</span>,</div><div class="line">                   multiVals=<span class="string">"first"</span>)</div><div class="line"><span class="keyword">library</span>(Homo.sapiens)</div><div class="line">map2chr &lt;- mapIds(Homo.sapiens, keys=map2gene,</div><div class="line">                  column=<span class="string">"TXCHROM"</span>, keytype=<span class="string">"ENTREZID"</span>,</div><div class="line">                  multiVals=<span class="string">"first"</span>)</div><div class="line">chryexp &lt;- colMeans(y[which(unlist(map2chr)==<span class="string">"chrY"</span>),])</div></pre></td></tr></table></figure>
<p>如果我们创建Y染色体中位数基因表达水平的直方图，我们就能清楚地看到差异，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">hist(chryexp)</div></pre></td></tr></table></figure>
<p>现在我们预测一下性别，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sex &lt;- factor(ifelse(chryexp&lt;<span class="number">0</span>,<span class="string">"F"</span>,<span class="string">"M"</span>))</div></pre></td></tr></table></figure>
<h3 id="计算主成分"><a href="#计算主成分" class="headerlink" title="计算主成分"></a>计算主成分</h3><p>现在我们计算一下主成分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(y)</div><div class="line">dim(s$v)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; s &lt;- svd(y)</div><div class="line">&gt; dim(s$v)</div><div class="line">[<span class="number">1</span>] <span class="number">207</span> <span class="number">207</span></div></pre></td></tr></table></figure>
<p>我们也可以使用<code>prcomp()</code>函数来创建一个主成分对象。</p>
<h3 id="变异解释"><a href="#变异解释" class="headerlink" title="变异解释"></a>变异解释</h3><p>第一步就是解释由结构(structure)导致的样本的相关性程度是什么样的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(RColorBrewer)</div><div class="line">cols=colorRampPalette(rev(brewer.pal(<span class="number">11</span>,<span class="string">"RdBu"</span>)))(<span class="number">100</span>)</div><div class="line">image ( cor(y) ,col=cols,zlim=c(-<span class="number">1</span>,<span class="number">1</span>))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916131005.jpeg" alt=""></p>
<p>上图显示了相关性。每个小单元络的i与j代表了样本i和样本j的相关性。红色表示高，白色表示0，蓝色表示低。</p>
<p>这时我们使用了术语结构(structure)，结构是指，如果样本实际上是相互独立时我们所能发现的偏差。从上面图片上我们可以明显看到，样本实际上有分组，也就是说，不同组内的样本相关性比组外的更强。</p>
<p>我们需要生成一个简单的探索性图来确定我们需要多少主成分来描述这种结构，这就是方差解释图。 如果数据是独立的，那么方差的解释就如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y0 &lt;- matrix( rnorm( nrow(y)*ncol(y) ) , nrow(y), ncol(y) )</div><div class="line">d0 &lt;- svd(y0)$d</div><div class="line">plot(d0^<span class="number">2</span>/sum(d0^<span class="number">2</span>),ylim=c(<span class="number">0</span>,<span class="number">.25</span>))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916133405.jpeg" alt=""></p>
<p> 事实上，我们看到的方差解释图是下面的这个样子：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916133542.jpeg" alt=""></p>
<p>至少有20个PC高于我们对独立数据的预期。我们下一步就是尝试用检测的变量来解释这些PC。这些PC是由种族(ethnicity)，性别(sex)还是时间(date)或其它的因素驱动的吗？</p>
<h3 id="MDS图"><a href="#MDS图" class="headerlink" title="MDS图"></a>MDS图</h3><p>如前面一样，我们可以先用MDS图来探索一下数据，回答上述提到的问题。探索感兴趣的变量和PC之间的关系的一种方法就是使用颜色来表示这些变量，例如，以下是使用表示了颜色来标记种族(ethnicity)这个变量，通过前两个PC来展示的数据结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cols = as.numeric(eth)</div><div class="line">mypar()</div><div class="line">plot(s$v[,<span class="number">1</span>],s$v[,<span class="number">2</span>],col=cols,pch=<span class="number">16</span>,</div><div class="line">     xlab=<span class="string">"PC1"</span>,ylab=<span class="string">"PC2"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(eth),col=seq(along=levels(eth)),pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916134050.jpeg" alt=""></p>
<p>从上图来看，第1 PC与种族(ethnicity)有着很强的联系。但是，我们也会看到一些橙色的点有的形成了亚簇(subslusters)。我们从以前的预分析中也知道，种族(ethnicity)和预处理时间(preprocessing date)有相关性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">year = factor(format(dates,<span class="string">"%y"</span>))</div><div class="line">table(year,eth)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; table(year,eth)</div><div class="line">    eth</div><div class="line">year ASN CEU HAN</div><div class="line">  <span class="number">02</span>   <span class="number">0</span>  <span class="number">32</span>   <span class="number">0</span></div><div class="line">  <span class="number">03</span>   <span class="number">0</span>  <span class="number">54</span>   <span class="number">0</span></div><div class="line">  <span class="number">04</span>   <span class="number">0</span>  <span class="number">13</span>   <span class="number">0</span></div><div class="line">  <span class="number">05</span>  <span class="number">80</span>   <span class="number">3</span>   <span class="number">0</span></div><div class="line">  <span class="number">06</span>   <span class="number">2</span>   <span class="number">0</span>  <span class="number">23</span></div></pre></td></tr></table></figure>
<p>因此，我们通过与前面相同的图来研究一下，日期作为主要变异来源的可能性，在下面的图形中，我们使用颜色来表示年，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cols = as.numeric(year)</div><div class="line">mypar()</div><div class="line">plot(s$v[,<span class="number">1</span>],s$v[,<span class="number">2</span>],col=cols,pch=<span class="number">16</span>,</div><div class="line">     xlab=<span class="string">"PC1"</span>,ylab=<span class="string">"PC2"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(year),col=seq(along=levels(year)),pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916140347.jpeg" alt=""></p>
<p>从上面图形我们看到，日期（以年为单位）也与第1 PC非常相关。那么到底是哪个变量导致了这种情况呢？由于存在着很高的混杂(confounding)效应，现在还不清楚是哪个因素起了重要作用。但是，在解决这个问题方面，我们还会进一步探索数据。</p>
<h3 id="PC箱线图"><a href="#PC箱线图" class="headerlink" title="PC箱线图"></a>PC箱线图</h3><p>样本之间的相关性的图形可以展示出一个复杂的结构，它似乎有5个以上的因素（其中一个是年份）参与其中。很明显，这种复杂程度远非种族(ethnicity)这一个因素能解释的。我们此时还探索一下月份之间的相关性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">month &lt;- format(dates,<span class="string">"%y%m"</span>)</div><div class="line">length( unique(month))</div><div class="line">variable &lt;- as.numeric(month)</div><div class="line">mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">4</span>)&#123;</div><div class="line">  boxplot(split(s$v[,i],variable),las=<span class="number">2</span>,range=<span class="number">0</span>)</div><div class="line">  stripchart(split(s$v[,i],variable),add=<span class="literal">TRUE</span>,vertical=<span class="literal">TRUE</span>,pch=<span class="number">1</span>,cex=<span class="number">.5</span>,col=<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一共有21个月份，下图是按照不同月份划分场次层后，根据第1 PC到第4 PC来绘制的箱线图，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916141037.jpeg" alt=""></p>
<p>从上图我们可以看到，月份与第1 PC有着非常强烈的相关性，即使按照种族(ethnicity)和其它因素来划分层次，也是如此。我们要知道，2002-2004之间处理的样本都来自于同一种族群体。在这样的情况下，我们可以使用方差分析来查看一下PC与哪个月份相关，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">corr &lt;- sapply(<span class="number">1</span>:ncol(s$v),<span class="keyword">function</span>(i)&#123;</div><div class="line">  fit &lt;- lm(s$v[,i]~as.factor(month))</div><div class="line">  <span class="keyword">return</span>( summary(fit)$adj.r.squared )</div><div class="line">&#125;)</div><div class="line">mypar()</div><div class="line">plot(seq(along=corr), corr, xlab=<span class="string">"PC"</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916141913.jpeg" alt=""></p>
<p>从上图我们可以看到，第1 PC的相关性非常强，而对于前20左右的PC，相关性较强。我们还可以计算一下月份内与月份之间的F统计量，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Fstats&lt;- sapply(<span class="number">1</span>:ncol(s$v),<span class="keyword">function</span>(i)&#123;</div><div class="line">  fit &lt;- lm(s$v[,i]~as.factor(month))</div><div class="line">  Fstat &lt;- summary(aov(fit))[[<span class="number">1</span>]][<span class="number">1</span>,<span class="number">4</span>]</div><div class="line">  <span class="keyword">return</span>(Fstat)</div><div class="line">&#125;)</div><div class="line">mypar()</div><div class="line">plot(seq(along=Fstats),sqrt(Fstats))</div><div class="line">p &lt;- length(unique(month))</div><div class="line">abline(h=sqrt(qf(<span class="number">0.995</span>,p-<span class="number">1</span>,ncol(s$v)-<span class="number">1</span>)))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190916142249.jpeg" alt=""></p>
<p>上图展示的是，方差分析的F平方根，用于解释PC与月份的关系。</p>
<p>至此为止，我们就了解了如何使用PCA联合EDA来做为一个强大的功能检测并理解批次效应的。在后面的部分里，我们将会了解如何使用PC用于因子分析(factor analysis)，用于改进模型估计。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P431</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/25/Data Analysis for the life sciences/DALS025_Batch_Effect01_Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/Data Analysis for the life sciences/DALS025_Batch_Effect01_Introduction/" itemprop="url">DALS025-批次效应01-什么是批次效应</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T12:00:00+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,746
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第10章批次效应的第1小节，这一部分的主要内容涉及批次效应(Batch Effects)的介绍，有关批次效应的前言部分Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/intro_to_batch_effects.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="什么是批次效应"><a href="#什么是批次效应" class="headerlink" title="什么是批次效应"></a>什么是批次效应</h2><p>高通量研究中一个经常被忽视的问题就是批次效应(batch effects)，批次效应受到当时检测的实验室条件、试剂批次和人员差异的影响。当批次效应与我们目标结果混淆并导致不正确的结果时，这就成了一个主要问题。在这一章中，我们将详细地描述批次效应：对于批次效应如何检测、解释、建模和调整。</p>
<p>批次效应是基因组学研究中面临的最大挑战，尤其是在精确医学这个背景下更是如此。在大多数情况（但并非全部）下，高通量技术已经被报道存在着一种形式或另外一种形式的批次效应[Leek et al. (2010) Nature Reviews Genetics 11, 733-739]。但是，批次效应并非基因组学所特有的。实际上， 在1972年一篇文献中，Mj Youden就在对物理常数的经验估计的背景下提到了批次效应。他指出，物理常数“存在着主观估计的特征”，以及如何在不同实验室之间变化的。例如，在下面的Table1中，Youden就展示了来自于不同实验室的天文单的估计值。这些报告包括对离差(spread)（现在我们称之为置信区间）的估计。</p>
<figure class="highlight plain"><figcaption><span>astronomical_units,echo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(downloader)</div><div class="line">##Download the data from</div><div class="line">url &lt;- &quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/astronomicalunit.csv&quot;</div><div class="line">filename &lt;- tempfile() </div><div class="line">if (!file.exists(filename)) download(url, destfile=filename)</div><div class="line"></div><div class="line">dat &lt;- read.csv(filename)</div><div class="line">year &lt;-  jitter(dat[,2]) ##add jitter so points are not on top of each other</div><div class="line"></div><div class="line">##Use color to denote the labs that reported more than one measurement</div><div class="line">labs &lt;- as.character(dat[,1]) ##what lab did it</div><div class="line">labs[ !labs%in%c(&quot;Jodrell Bank&quot;,&quot;Spencer Jones&quot;)] &lt;- &quot;Others&quot;</div><div class="line">labs &lt;- factor(labs, levels=c(&quot;Others&quot;,&quot;Spencer Jones&quot;,&quot;Jodrell Bank&quot;))</div><div class="line">cols=as.numeric(labs)</div><div class="line"></div><div class="line">current &lt;- 92.956039 ##this is the current estimate in millions of mph</div><div class="line"></div><div class="line">mypar()</div><div class="line">plot(year, dat[,3], ylim=c(min(dat[,4]),max(dat[,5])), pch=16, col=cols, </div><div class="line">     xlab=&quot;Year&quot;,ylab=&quot;Astronomical unit (millions of miles)&quot;)</div><div class="line">for(i in 1:nrow(dat))</div><div class="line">  lines(c(year[i],year[i]),c(dat[i,4],dat[i,5]),col=cols[i],lwd=3)</div><div class="line">legend(&quot;topright&quot;, legend=levels(labs), col=seq_along( labs ) ,cex=0.75, lty=1,pch=16)</div><div class="line">abline(h=current,lty=2)</div><div class="line">text(1905,current,&quot;Current estimate&quot;,pos=3)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914105414.jpeg" alt=""></p>
<p>从不同实验室之间的可变性以及报道的界限（可以理解为置信区间）来看，都不能解释这种可变性，这就清楚地表明不同实验室之间，而非某个实验室内部存在着某些效应。这种类型的变异就是我们所谓的批次效应。请注意，有些实验室报告了两个估计值（紫色和橙色），这样我们就在相同的实验室也看到了批次效应。<br>我们可以使用统计学符号来精确地描述这个问题。我们使用下面的公式来表示这些检测值：</p>
<script type="math/tex; mode=display">
Y_{i,j} = 
\mu + \varepsilon_{i,j}, j=1,\dots,N</script><p>其中，$Y_{i,j}$ 表示第 $i$ 个实验室的第 $j$ 个检测值，而 $\mu$ 表示真实的物理常数，$\varepsilon_{i,j}$ 表示独立的检测误差。为了解释可变性，我们引应与我们的目标结果入了 $\varepsilon_{i,j}$ ，随后我们根据数据来计算标准误。就像本书前面提到的那样，我们使用 $N$ 值均值来估计物理物理常数，如下所示：</p>
<script type="math/tex; mode=display">
\bar{Y}_i = 
\frac{1}{N} \sum_{i=1}^{N} Y_{i,j}</script><p>再来构建一个置信区间：</p>
<script type="math/tex; mode=display">
\bar{Y}_i 
 \pm 2 s_i / \sqrt{N} \mbox{ with }
s_i^2= 
\frac{1}{N-1} \sum_{i=1}^N (Y_{i,j} - 
\bar{Y}_i)^2</script><p>但是，这个置信区间太小，它无法覆盖批次效应的变异，下面是一个更加合适的模型：</p>
<script type="math/tex; mode=display">
Y_{i,j} = \mu +
\gamma_i + \varepsilon_{i,j}, j=1, \dots, N</script><p>其中 $\gamma_i$ 表示一个实验室特定的偏差或批次效应(batch effect)。从图片上我们可以明显看出来，实验室之间 $\gamma$ 的变化要远大于一个实验室内部 $\varepsilon$ 的变化。用统计学的术语来描述这个问题就是，$\mu$ 和 $\gamma$ 无法被识别。我们可以估计 $\mu_i+\gamma_i$ ，但是无法区分开。我们可以将 $\gamma$ 视为一个随机变量。在这个案例中，每个实验室都有一个错误项 $\gamma_i$ ，这一项在贯穿于该实验室的所有检测值，在每个检测值中，这一项是相同的，但是实验室与实验室间的这一项则不同。因此，这个问题就可以用以下方程表示：</p>
<script type="math/tex; mode=display">
 s_i / \sqrt{N} \mbox{ with } 
 s_i^2= 
\frac{1}{N-1} \sum_{i=1}^N (Y_{ij} - 
\bar{Y}_i)^2</script><p>这是对标准差的低估，因为它没有解释由 $\gamma$ 导致的实验室内的相关性（这一句不懂，原文如下：</p>
<blockquote>
<p>Under this interpretation the problem is that:is an underestimate of the standard error since it does not account for the within lab correlation induced by $\gamma$.</p>
</blockquote>
<p>如果我们假设 $\gamma=0$ ，那么利用来自几个实验室的数据，我们实际上可以估计出 $\gamma$ 。或者说我们可以将它们视为随机效应，简单地将它们当成一个新的估计值，并使用所有的检测值来计算其标准差。以下是我们将报告中的均值值视为随机观察值的置信区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">avg &lt;- mean(dat[,3])</div><div class="line">se &lt;- sd(dat[,3]) / sqrt(nrow(dat))</div><div class="line">cat(&quot;95% confidence interval is: [&quot;,avg-1.96*se,&quot;,&quot;, avg+1.96*se,&quot;]&quot;)</div><div class="line">cat(&quot;which does include the current estimate is:&quot;,current)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; cat(<span class="string">"95% confidence interval is: ["</span>,avg-<span class="number">1.96</span>*se,<span class="string">","</span>, avg+<span class="number">1.96</span>*se,<span class="string">"]"</span>)</div><div class="line"><span class="number">95</span>% confidence interval is: [ <span class="number">92.8727</span> , <span class="number">92.98542</span> ]&gt; cat(<span class="string">"which does include the current estimate is:"</span>,current)</div><div class="line">which does include the current estimate is: <span class="number">92.95604</span></div></pre></td></tr></table></figure>
<p>Youden的论文还包括最近关于光速以及策略常数的批次效应估计的案例。在这一章里，我们只展示高通量生物数据中批次效应的广泛性和复杂性。</p>
<h2 id="混杂"><a href="#混杂" class="headerlink" title="混杂"></a>混杂</h2><p>书中有一个术语，即<code>confounding</code>，这里译为<code>混杂</code>。这一部分内容的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/batch/confounding.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>当批次效应与我们的目标结果混杂时，就会导致严重的后果。这里我们描述一下混杂(confounding)，以及它与我们数据解释的关系。</p>
<p>我们从这本书或者说从任何其它数据分析课程中尝到最重要的思想之一就是“相关不等于因果”。这句话多数情况就是真的，一个常见的案例就是混杂(confounding)。简单地讲，当我们观察到 $X$ 和 $Y$ 之间存在着相关(correlation)或关联(association)时，往往就会存在着混杂，但严格来说，这是因为 $X$ 和 $Y$ 都依赖于一个无关的变量 $Z$ 。这里我们会描述一个Simposon悖论，这是一个基于一个著名的法律案件的案例，接着，我们还会提到一个在高通量生物学研究中的一个混杂案例。</p>
<h3 id="案例之Simpson悖论"><a href="#案例之Simpson悖论" class="headerlink" title="案例之Simpson悖论"></a>案例之Simpson悖论</h3><p>加州大学伯克分校(UCB)1973年的入学数据显示，在录取的学生中，44%是男性，30%是女性，显著男性更多，以下是这些数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">library(dagdata)</div><div class="line">data(admissions)</div><div class="line">admissions$total=admissions$Percent*admissions$Number/100</div><div class="line">##percent men get in</div><div class="line">sum(admissions$total[admissions$Gender==1]/sum(admissions$Number[admissions$Gender==1]))</div><div class="line">##percent women get in</div><div class="line">sum(admissions$total[admissions$Gender==0]/sum(admissions$Number[admissions$Gender==0]))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; sum(admissions$total[admissions$Gender==<span class="number">1</span>]/sum(admissions$Number[admissions$Gender==<span class="number">1</span>]))</div><div class="line">[<span class="number">1</span>] <span class="number">0.4451951</span></div><div class="line">&gt; <span class="comment">##percent women get in</span></div><div class="line">&gt; sum(admissions$total[admissions$Gender==<span class="number">0</span>]/sum(admissions$Number[admissions$Gender==<span class="number">0</span>]))</div><div class="line">[<span class="number">1</span>] <span class="number">0.3033351</span></div></pre></td></tr></table></figure>
<p>卡方检验的结果明确拒绝零假设，即录取的性别是独立的，两者不受影响（也就是说，男女录取公平），如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">##make a 2 x 2 table</div><div class="line">index = admissions$Gender==1</div><div class="line">men = admissions[index,]</div><div class="line">women = admissions[!index,]</div><div class="line">menYes = sum(men$Number*men$Percent/100)</div><div class="line">menNo = sum(men$Number*(1-men$Percent/100))</div><div class="line">womenYes = sum(women$Number*women$Percent/100)</div><div class="line">womenNo = sum(women$Number*(1-women$Percent/100))</div><div class="line">tab = matrix(c(menYes,womenYes,menNo,womenNo),2,2)</div><div class="line">print(chisq.test(tab)$p.val)</div></pre></td></tr></table></figure>
<p>p值如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; print(chisq.test(tab)$p.val)</div><div class="line">[<span class="number">1</span>] <span class="number">9.139492e-22</span></div></pre></td></tr></table></figure>
<p>但经过更仔细的观察会发现一个自相矛盾的结果，以下是按专业划分后，不同性别的录取百分比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,c(1,3)],admissions[7:12,3])</div><div class="line">colnames(y)[2:3]=c(&quot;Male&quot;,&quot;Female&quot;)</div><div class="line">y</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; y</div><div class="line">  Major Male Female</div><div class="line"><span class="number">1</span>     A   <span class="number">62</span>     <span class="number">82</span></div><div class="line"><span class="number">2</span>     B   <span class="number">63</span>     <span class="number">68</span></div><div class="line"><span class="number">3</span>     C   <span class="number">37</span>     <span class="number">34</span></div><div class="line"><span class="number">4</span>     D   <span class="number">33</span>     <span class="number">35</span></div><div class="line"><span class="number">5</span>     E   <span class="number">28</span>     <span class="number">24</span></div><div class="line"><span class="number">6</span>     <span class="literal">F</span>    <span class="number">6</span>      <span class="number">7</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，不同专业之间没有性别偏见。</p>
<p>但是，我们在前面使用了卡方检验发现，入学和性别之间存在着某种关系。然而，当我们的数据按照不同专业进行分组时，这种依赖性似乎消失了，这是怎么一回事呢？</p>
<p>这就是Simpson悖论的一个案例。</p>
<p>我们上面进行的卡方检验表明，入学和性别之间存在依赖关系。然而，当数据按专业分组时，这种依赖性似乎消失了。到底怎么回事？现在我们绘制一个能显示申请专业的人，以及最终进入这个专业读书的人的百分比的图形，用于说明男女在录取比例方面的问题，如下所示：</p>
<figure class="highlight plain"><figcaption><span>hard_major_confounding, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,5],admissions[7:12,5])</div><div class="line">y=sweep(y,2,colSums(y),&quot;/&quot;)*100</div><div class="line">x=rowMeans(cbind(admissions[1:6,3],admissions[7:12,3]))</div><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">matplot(x,y,xlab=&quot;percent that gets in the major&quot;,</div><div class="line">        ylab=&quot;percent that applies to major&quot;,</div><div class="line">        col=c(&quot;blue&quot;,&quot;red&quot;),cex=1.5)</div><div class="line">legend(&quot;topleft&quot;,c(&quot;Male&quot;,&quot;Female&quot;),col=c(&quot;blue&quot;,&quot;red&quot;),pch=c(&quot;1&quot;,&quot;2&quot;),box.lty=0)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914162851.jpeg" alt=""></p>
<p>从图片上我们可以发现，男生更想申请那些“容易”的专业。也就是说，男生这个变量与“容易”专业这个变量发生了混杂。</p>
<h3 id="混杂的图形解释"><a href="#混杂的图形解释" class="headerlink" title="混杂的图形解释"></a>混杂的图形解释</h3><p>在这一部分里，我们将混杂图形化。在下面的图形中，每个字母表示一个学生。被录取的人用绿色表示，字母表示专业。在第1张图中，所有相同性别的学生都被放在一起，我们可以发现，男生中绿色的比较更大，如下所示：</p>
<figure class="highlight plain"><figcaption><span>simpsons_paradox_illustration, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">###make data for plot</div><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">CEX=0.5</div><div class="line">NC &lt;- 70</div><div class="line">tmp=rowSums(tab)</div><div class="line">FNC &lt;- round(NC*tmp[2]/tmp[1])</div><div class="line">SCALE &lt;- 1</div><div class="line">makematrix&lt;-function(x,n,addx=0,addy=0)&#123;</div><div class="line">  m&lt;-ceiling(length(x)/n)</div><div class="line">  expand.grid(1:n+addx,addy+1:m)[seq(along=x),] </div><div class="line">&#125;</div><div class="line">males&lt;- sapply(1:6,function(i)&#123;</div><div class="line">  tot=admissions[i,2]*SCALE</div><div class="line">  p=admissions[i,3]/100</div><div class="line">  x=rep(c(0,1),round(tot*c(1-p,p)))</div><div class="line">&#125;)</div><div class="line">allmales&lt;-Reduce(c,males)</div><div class="line">females&lt;- sapply(7:12,function(i)&#123;</div><div class="line">  tot=admissions[i,2]*SCALE</div><div class="line">  p=admissions[i,3]/100</div><div class="line">  rep(c(0,1),round(tot*c(1-p,p)))</div><div class="line">&#125;)</div><div class="line">allfemales&lt;-Reduce(c,females)</div><div class="line">mypar(1,1)</div><div class="line">malepoints &lt;- makematrix(allmales,NC)</div><div class="line">femalepoints &lt;- makematrix(allfemales,FNC,NC+NC/10)</div><div class="line">NR &lt;- max(c(malepoints[,2],femalepoints[,2]))</div><div class="line">plot(0,type=&quot;n&quot;,xlim=c(min(malepoints[,1]),max(femalepoints[,1])),ylim=c(0,NR),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;)</div><div class="line">PCH=LETTERS[rep(1:6,sapply(males,length))]</div><div class="line">o&lt;-order(-allmales)</div><div class="line">points(malepoints,col=2-allmales[o],pch=PCH[o],cex=CEX)</div><div class="line">PCH=LETTERS[rep(1:6,sapply(females,length))]</div><div class="line">o&lt;-order(-allfemales)</div><div class="line">points(femalepoints,col=2-allfemales[o],pch=PCH[o],cex=CEX)</div><div class="line">abline(v=NC+NC/20)</div><div class="line">axis(side=3,c(NC/2,NC+NC/2),c(&quot;Male&quot;,&quot;Female&quot;),tick=FALSE)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163227.jpeg" alt=""></p>
<p>现在我们按照专业对不同性别的学生进行分级。这里我们要注意，大多数被录取的学生（绿色）来源于两个容易的专业，即A和B，如下所示：</p>
<figure class="highlight plain"><figcaption><span>simpsons_paradox_illustration2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">malepoints &lt;- vector(&quot;list&quot;,length(males))</div><div class="line">femalepoints &lt;- vector(&quot;list&quot;,length(males))</div><div class="line">N&lt;- length(males)</div><div class="line"> </div><div class="line">ADDY &lt;- vector(&quot;numeric&quot;,N+1)</div><div class="line">for(i in 1:N)&#123;</div><div class="line">  malepoints[[i]] &lt;- makematrix(males[[i]],NC,0,ADDY[i])</div><div class="line">  femalepoints[[i]] &lt;- makematrix(females[[i]],FNC,NC+NC/10,ADDY[i])</div><div class="line">   ADDY[i+1] &lt;- max(malepoints[[i]][,2],femalepoints[[i]][,2])+1</div><div class="line">&#125;</div><div class="line">plot(0,type=&quot;n&quot;,</div><div class="line">     xlim=c( min(sapply(malepoints,function(x)min(x[,1]))),max(sapply(femalepoints,function(x)max(x[,1])))),</div><div class="line">  ylim=c(0,max(sapply(femalepoints,function(x)max(x[,2])))),xaxt=&quot;n&quot;,yaxt=&quot;n&quot;,xlab=&quot;&quot;,ylab=&quot;&quot;)</div><div class="line">          </div><div class="line">for(i in 1:N)&#123;</div><div class="line">  points(malepoints[[i]],col=2+sort(-males[[i]]),pch=LETTERS[i],cex=CEX)</div><div class="line">  points(femalepoints[[i]],col=2+sort(-females[[i]]),pch=LETTERS[i],cex=CEX)</div><div class="line">  if(i&gt;1) abline(h=ADDY[i])</div><div class="line">  &#125;</div><div class="line">abline(v=NC+NC/20)</div><div class="line">axis(side=3,c(NC/2,NC+FNC/2),c(&quot;Male&quot;,&quot;Female&quot;),tick=FALSE)</div><div class="line">axis(side=2,ADDY[-1]/2+ADDY[-length(ADDY)]/2,LETTERS[1:N],tick=FALSE,las=1)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163301.jpeg" alt=""></p>
<h3 id="分层后的均值"><a href="#分层后的均值" class="headerlink" title="分层后的均值"></a>分层后的均值</h3><p>在下图中，我们可以看到，我们根据专业设定条件或分层后，然后再看差异，也就是说，当我们控制了混杂项后，这就混杂效应就消失了，如下所示：</p>
<figure class="highlight plain"><figcaption><span>admission_by_major, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">y=cbind(admissions[1:6,3],admissions[7:12,3])</div><div class="line">matplot(1:6,y,xaxt=&quot;n&quot;,xlab=&quot;major&quot;,ylab=&quot;percent&quot;,col=c(&quot;blue&quot;,&quot;red&quot;),cex=1.5)</div><div class="line">axis(1,1:6,LETTERS[1:6])</div><div class="line">legend(&quot;topright&quot;,c(&quot;Male&quot;,&quot;Female&quot;),col=c(&quot;blue&quot;,&quot;red&quot;),pch=c(&quot;1&quot;,&quot;2&quot;),</div><div class="line">       box.lty=0)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914163912.jpeg" alt=""></p>
<p>事实上，在不同专业录取的学生中，性别差异仅表示为，男生比女生高3.5%，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mean(y[,1]-y[,2])</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y[,<span class="number">1</span>]-y[,<span class="number">2</span>])</div><div class="line">[<span class="number">1</span>] -<span class="number">3.5</span></div></pre></td></tr></table></figure>
<h3 id="棒球中的Simpson悖论"><a href="#棒球中的Simpson悖论" class="headerlink" title="棒球中的Simpson悖论"></a>棒球中的Simpson悖论</h3><p>在棒球比赛的统计中我们也经常看到Simpson悖论，现在我们来看一个有名的案例，在1995年和1996年，David Justice的平均击球率高于Derek Jeter，但是Jeter的击球率却高于整体平均水平，如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>1995</th>
<th>1996</th>
<th>Combined</th>
</tr>
</thead>
<tbody>
<tr>
<td>Derek Jeter</td>
<td>12/48 (.250)</td>
<td>183/582 (.314)</td>
<td>195/630 (.310)</td>
</tr>
<tr>
<td>David Justice</td>
<td>104/411 (.253)</td>
<td>45/140 (.321)</td>
<td>149/551 (.270)</td>
</tr>
</tbody>
</table>
</div>
<p>这里的混杂项就是比赛场次，Jeter的比赛场次数目更多，但是结果却是Justice击球率更高。</p>
<h3 id="混杂之高通量案例"><a href="#混杂之高通量案例" class="headerlink" title="混杂之高通量案例"></a>混杂之高通量案例</h3><p>为了描述我们在生物学中遇到的混杂问题，我们将会使用<a href="https://www.ncbi.nlm.nih.gov/pubmed/17206142" target="_blank" rel="external">《Common genetic variants account for differences in gene expression among ethnic groups》</a>这篇文献中的数据集，这篇文献指出，两个不同种族的血液大约有50%的差异基因，现在我们来下载这个数据集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(Biobase) ##available from Bioconductor</div><div class="line">library(genefilter) </div><div class="line">load(&quot;GSE5859.rda&quot;) ##available from github</div></pre></td></tr></table></figure>
<p>我们使用Bioconductor中的函数<code>exprs</code>和<code>pData</code>就能提取基因的表达数据与样本信息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">geneExpression = exprs(e)</div><div class="line">sampleInfo = pData(e)</div></pre></td></tr></table></figure>
<p>需要注意，样本按照不同的时间进行了处理，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">head(sampleInfo)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(sampleInfo)</div><div class="line">  ethnicity       date        filename</div><div class="line"><span class="number">1</span>       CEU <span class="number">2003</span>-<span class="number">02</span>-<span class="number">04</span> GSM25349.CEL.gz</div><div class="line"><span class="number">2</span>       CEU <span class="number">2003</span>-<span class="number">02</span>-<span class="number">04</span> GSM25350.CEL.gz</div><div class="line"><span class="number">3</span>       CEU <span class="number">2002</span>-<span class="number">12</span>-<span class="number">17</span> GSM25356.CEL.gz</div><div class="line"><span class="number">4</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">30</span> GSM25357.CEL.gz</div><div class="line"><span class="number">5</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">03</span> GSM25358.CEL.gz</div><div class="line"><span class="number">6</span>       CEU <span class="number">2003</span>-<span class="number">01</span>-<span class="number">16</span> GSM25359.CEL.gz</div></pre></td></tr></table></figure>
<p>日期是一个无关的变量，它理论上不影响这个数据集中基因的表达值，然而，正如我们在前面分析中看到的那样，这个日期似乎也起了一些作用，因此我们在这里就来讲一下这个日期的因素。<br>我们可以明显看到，日期和种族这两个因素几乎完全混杂了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">year = factor( format(sampleInfo$date,&quot;%y&quot;) )</div><div class="line">tab = table(year,sampleInfo$ethnicity)</div><div class="line">print(tab)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; print(tab)</div><div class="line">    </div><div class="line">year ASN CEU HAN</div><div class="line">  <span class="number">02</span>   <span class="number">0</span>  <span class="number">32</span>   <span class="number">0</span></div><div class="line">  <span class="number">03</span>   <span class="number">0</span>  <span class="number">54</span>   <span class="number">0</span></div><div class="line">  <span class="number">04</span>   <span class="number">0</span>  <span class="number">13</span>   <span class="number">0</span></div><div class="line">  <span class="number">05</span>  <span class="number">80</span>   <span class="number">3</span>   <span class="number">0</span></div><div class="line">  <span class="number">06</span>   <span class="number">2</span>   <span class="number">0</span>  <span class="number">24</span></div></pre></td></tr></table></figure>
<p>通过t检验以及生成的火山图我们可以发现，不同种族之间似乎存在着数千个差异基因。但是，当我们仅仅对2002年和2003年的CEU人群进行比较发现，我们又发现了数千个差异基因：</p>
<figure class="highlight plain"><figcaption><span>volcano_plots, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">library(genefilter)</div><div class="line">##remove control genes</div><div class="line">out &lt;- grep(&quot;AFFX&quot;,rownames(geneExpression))</div><div class="line">eth &lt;- sampleInfo$ethnicity</div><div class="line">ind&lt;- which(eth%in%c(&quot;CEU&quot;,&quot;ASN&quot;))</div><div class="line">res1 &lt;- rowttests(geneExpression[-out,ind],droplevels(eth[ind]))</div><div class="line">ind &lt;- which(year%in%c(&quot;02&quot;,&quot;03&quot;) &amp; eth==&quot;CEU&quot;)</div><div class="line">res2 &lt;- rowttests(geneExpression[-out,ind],droplevels(year[ind]))</div><div class="line">XLIM &lt;- max(abs(c(res1$dm,res2$dm)))*c(-1,1)</div><div class="line">YLIM &lt;- range(-log10(c(res1$p,res2$p)))</div><div class="line">mypar(1,2)</div><div class="line">plot(res1$dm,-log10(res1$p),xlim=XLIM,ylim=YLIM,</div><div class="line">     xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;,main=&quot;Populations&quot;)</div><div class="line">plot(res2$dm,-log10(res2$p),xlim=XLIM,ylim=YLIM,</div><div class="line">     xlab=&quot;Effect size&quot;,ylab=&quot;-log10(p-value)&quot;,main=&quot;2003 v 2002&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190914165820.jpeg" alt=""></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P419</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/24/Data Analysis for the life sciences/DALS024_Basic_Machine_Learning03_Class_Prediction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/24/Data Analysis for the life sciences/DALS024_Basic_Machine_Learning03_Class_Prediction/" itemprop="url">DALS024-机器学习03-分类预测</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-24T12:00:00+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,035
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第3小节，这一部分的主要内容涉及类预测(Class Prediction)，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/machine_learning.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在这一部分中我们主要介绍分类预测(class prediction)。实际上，许多人将分类预测称为机器学习，有的时候我们会交替使用这两个术语。我们会对这个庞杂的主题做一个非常简单的介绍，重点关注一些具体的案例。</p>
<p>我们这里使用的案例来源于统计学的经典书籍，即Trevor Hastie, Robert Tibshirani and Jerome Friedman的《<em>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</em>》。与回归中的推断类似，机器学习(ML)也是研究结果 $Y$ 和协变量 $X$ 之间的关系。在ML中，我们将 $X$ 称为预测因子或特征值，ML和推断之间的主要区别在于，在ML中，我们主要研究使用 $X$ 来预测 $Y$ 。关于统计模型，我在常规的推断中，我们主要用来估计和解释模型参数，但在ML中，统计模型只是我们达到目的的手段，即预测 $Y$ 。</p>
<p>这里我们介绍理解ML的主要概念，以及两个具体的算法：回归(regression)和k近似算法(kNN,k nearest neighbors)。我们需要知道，绐中学习有几十种流行的算法，我们这里不一一列举。</p>
<p>在前面部分里，我们介绍了非常简单的单一预测因子案例。但是，大多数与这种案例相关的案例往往不止一个预测因子。为了说明这个问题，我们现在再介绍一个案例，其中 $X$ 是一个二维数据，$Y$ 是一个二分类结果。这个案例来源于Hastie, Tibshirani 和 Friedman的书中，在这个案例中， $X$ 和 $Y$ 并不线性关系。在下面的图形中，使用不 的颜色表示了实际的 $f(x_1,x_2)=E(Y \mid X_1=x_1,X_2=x_2)$ 值。下面的代码用于生成一个相对复杂的条件概率函数。我们随后会使用测试数据集与训练数据集。在下图中，我们使用红色来表示 $f(x_1,x_2)$中接近于1的数据，使用蓝色表示接近于0的数据，中间过渡态使用黄色表示，如下所示：</p>
<figure class="highlight plain"><figcaption><span>conditional_prob, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">library(RColorBrewer)</div><div class="line">hmcol &lt;- colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(100)</div><div class="line">mycols=c(hmcol[1],hmcol[100])</div><div class="line">set.seed(1)</div><div class="line">##create covariates and outcomes</div><div class="line">##outcomes are alwasy 50 0s and 50 1s</div><div class="line">s2=0.15</div><div class="line">##pick means to create a non linear conditional expectation</div><div class="line">library(MASS)</div><div class="line">M0 &lt;- mvrnorm(10,c(1,0),s2*diag(2)) ##generate 10 means</div><div class="line">M1 &lt;- rbind(mvrnorm(3,c(1,1),s2*diag(2)),</div><div class="line">            mvrnorm(3,c(0,1),s2*diag(2)),</div><div class="line">            mvrnorm(4,c(0,0),s2*diag(2)))</div><div class="line">###funciton to generate random pairs</div><div class="line">s&lt;- sqrt(1/5)</div><div class="line">N=200</div><div class="line">makeX &lt;- function(M,n=N,sigma=s*diag(2))&#123;</div><div class="line">  z &lt;- sample(1:10,n,replace=TRUE) ##pick n at random from above 10</div><div class="line">  m &lt;- M[z,] ##these are the n vectors (2 components)</div><div class="line">  return(t(apply(m,1,function(mu) mvrnorm(1,mu,sigma)))) ##the final values</div><div class="line">&#125;</div><div class="line">###create the training set and the test set</div><div class="line">x0 &lt;- makeX(M0)##the final values for y=0 (green)</div><div class="line">testx0 &lt;- makeX(M0)</div><div class="line">x1 &lt;- makeX(M1)</div><div class="line">testx1 &lt;-makeX(M1)</div><div class="line">x &lt;- rbind(x0,x1) ##one matrix with everything</div><div class="line">test &lt;- rbind(testx0,testx1)</div><div class="line">y &lt;- c(rep(0,N),rep(1,N)) #the outcomes</div><div class="line">ytest &lt;- c(rep(0,N),rep(1,N))</div><div class="line">cols &lt;- mycols[c(rep(1,N),rep(2,N))]</div><div class="line">colstest &lt;- cols</div><div class="line">##Create a grid so we can predict all of X,Y</div><div class="line">GS &lt;- 150 ##grid size is GS x GS</div><div class="line">XLIM &lt;- c(min(c(x[,1],test[,1])),max(c(x[,1],test[,1])))</div><div class="line">tmpx &lt;- seq(XLIM[1],XLIM[2],len=GS)</div><div class="line">YLIM &lt;- c(min(c(x[,2],test[,2])),max(c(x[,2],test[,2])))</div><div class="line">tmpy &lt;- seq(YLIM[1],YLIM[2],len=GS)</div><div class="line">newx &lt;- expand.grid(tmpx,tmpy) #grid used to show color contour of predictions</div><div class="line">###Bayes rule: best possible answer</div><div class="line">p &lt;- function(x)&#123; ##probability of Y given X</div><div class="line">  p0 &lt;- mean(dnorm(x[1],M0[,1],s)*dnorm(x[2],M0[,2],s))</div><div class="line">  p1 &lt;- mean(dnorm(x[1],M1[,1],s)*dnorm(x[2],M1[,2],s))</div><div class="line">  p1/(p0+p1)</div><div class="line">&#125;</div><div class="line">###Create the bayesrule prediction</div><div class="line">bayesrule &lt;- apply(newx,1,p)</div><div class="line">colshat &lt;- bayesrule</div><div class="line">colshat &lt;- hmcol[floor(bayesrule*100)+1]</div><div class="line">mypar()</div><div class="line">plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912170040.jpeg" alt=""></p>
<p>如果我们将那些 $E(Y \mid X=x)&gt;0.5$ 的点用红色表示，剩下的点用蓝色表示，我们就能看到一条明显的分界线，它将0与1的区域分开了，如下所示：</p>
<figure class="highlight plain"><figcaption><span>bayes_rule,fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">colshat[bayesrule&gt;=0.5] &lt;- mycols[2]</div><div class="line">colshat[bayesrule&lt;0.5] &lt;- mycols[1]</div><div class="line">plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div><div class="line">contour(tmpx,tmpy,matrix(round(bayesrule),GS,GS),levels=c(1,2),</div><div class="line">        add=TRUE,drawlabels=FALSE)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912170527.jpeg" alt=""></p>
<p>通过上面的图形我们并没有看到“真相”(truth)。大多数的ML方法涉及估计的 $f(x)$ 。通常第一步就是将一个样本作为参数，也就是训练集(training set)，用它来估计 $f(x)$ 。我们将回顾一下两种具体的ML技术。首先，我们需要回顾一下我们用评估这些方法性能的主要概念。</p>
<h3 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h3><p>在第一张图中，我们创建了一个训练集和一个测试集，现在我们画出来，如下所示：</p>
<figure class="highlight plain"><figcaption><span>test_train, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#x, test, cols, and coltest were created in code that was not shown</div><div class="line">#x is training x1 and x2, test is test x1 and x2</div><div class="line">#cols (0=blue, 1=red) are training observations</div><div class="line">#coltests are test observations</div><div class="line">mypar(1,2)</div><div class="line">plot(x,pch=21,bg=cols,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">plot(test,pch=21,bg=colstest,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912171217.jpeg" alt=""></p>
<p>从上面我们可以看到，训练集（左侧）与测试集（右侧）有着相似的全局属性，因为它们是用相同的随机谈量生成的（蓝色点都趋向分布于右下角），但是它们的构建的过程还是不同的。原因在于，我们创建测试集和训练集的原因是通过测试与用于拟合模型或训练算法的数据不同的数据来检测过度训练。 我们将在下面看到它的重要性。</p>
<h4 id="利用回归进行预测"><a href="#利用回归进行预测" class="headerlink" title="利用回归进行预测"></a>利用回归进行预测</h4><p>关于ML问题的第一个简单方法就是拟合一个双变量线性回归模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##x and y were created in the code (not shown) for the first plot</div><div class="line">#y is outcome for the training set</div><div class="line">X1 &lt;- x[,1] ##these are the covariates</div><div class="line">X2 &lt;- x[,2] </div><div class="line">fit1 &lt;- lm(y~X1+X2)</div></pre></td></tr></table></figure>
<p>一旦我们有了这些拟合的数据，我们就能使用 $\hat{f}(x_1,x_2)=\hat{\beta}_0 + \hat{\beta}_1x_1 +\hat{\beta}_2 x_2$ 来估计 $f(x_1,x_2)$ 。为了提供一个实际的预测结果，我们仅仅预测当 $\hat{f}(x_1,x_2)&gt;0.5$ 时结果为1（这一段不懂）。我们现在检测一个在训练集与测试集中的错误率，并绘制出边界区域，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">##prediction on train</div><div class="line">yhat &lt;- predict(fit1)</div><div class="line">yhat &lt;- as.numeric(yhat&gt;0.5)</div><div class="line">cat(&quot;Linear regression prediction error in train:&quot;,1-mean(yhat==y),&quot;\n&quot;)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Linear regression prediction error <span class="keyword">in</span> train: <span class="number">0.295</span></div></pre></td></tr></table></figure>
<p>我们使用<code>predict()</code>函数就能很快地从任意数据集中来获得预测值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yhat &lt;- predict(fit1,newdata=data.frame(X1=newx[,1],X2=newx[,2]))</div></pre></td></tr></table></figure>
<p>现在我们生成图片，用于展示我们预测的1和0在图片上的分布，以及边界。我们还可以使用<code>predict()</code>函数从我们的测试集中生成预测数据。需要注意的是，我们无法在测试集中拟合模型：</p>
<figure class="highlight plain"><figcaption><span>regression_prediction, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">colshat &lt;- yhat</div><div class="line">colshat[yhat&gt;=0.5] &lt;- mycols[2]</div><div class="line">colshat[yhat&lt;0.5] &lt;- mycols[1]</div><div class="line">m &lt;- -fit1$coef[2]/fit1$coef[3] #boundary slope</div><div class="line">b &lt;- (0.5 - fit1$coef[1])/fit1$coef[3] #boundary intercept</div><div class="line">##prediction on test</div><div class="line">yhat &lt;- predict(fit1,newdata=data.frame(X1=test[,1],X2=test[,2]))</div><div class="line">yhat &lt;- as.numeric(yhat&gt;0.5)</div><div class="line">cat(&quot;Linear regression prediction error in test:&quot;,1-mean(yhat==ytest),&quot;\n&quot;)</div><div class="line">plot(test,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">abline(b,m)</div><div class="line">points(newx,col=colshat,pch=16,cex=0.35)</div><div class="line">##test was created in the code (not shown) for the first plot</div><div class="line">points(test,bg=cols,pch=21)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912173537.jpeg" alt=""></p>
<p>在上图中，我们使用 $X_{1}$和 $X_{2}$ 作为预测因子估计了1的概率，预测的结果将高于0.5的数据标注成了红色，低于0.5的标注为了蓝色。</p>
<p>从计算结果来年地，训练集与测试集的错误率非常相似。因此我们可以相信似乎没有过度训练。这并不奇怪，因为我们使用了2参数模型来拟合400个数据点。不过需要注意的是，边界是一个直线。因为我们为这些数据拟合了一个平面，所以这里没有其它选择。线性回归方法过于僵化。这种僵化会让它稳定，并且避免过度训练。，但是线性回归也不能适合对 $Y$ 和 $X$ 之间的非线性关系进行拟合。我们之前在平滑部分中看到了这些东西。下一个ML技术将会达到我们之间平滑处理的那种效果。</p>
<h4 id="kNN"><a href="#kNN" class="headerlink" title="kNN"></a>kNN</h4><p>kNN的全称是K-nearest neighbors，即<code>k最近邻</code>，这种算法类似于微区间平滑处理，但是kNN更适合于多维数据。总的来说，只要给定我们想要估计的任意点 $x$ ，我们会寻找k个最近的点，然后取这些点的平均值。这就会估计  $f(x_1,x_2)$ , 跟微区间平滑处理生成一个条曲线类似。我们现在通过 $k$ 来控制灵活性。这时我们比较一下 $k=1$ 和 $k=100$ 时的计算结果：</p>
<figure class="highlight plain"><figcaption><span>message</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">mypar(2,2)</div><div class="line">for(k in c(1,100))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=k)</div><div class="line">  cat(&quot;KNN prediction error in train:&quot;,1-mean((as.numeric(yhat)-1)==y),&quot;\n&quot;)</div><div class="line">  ##make plot</div><div class="line">  yhat &lt;- knn(x,test,y,k=k)</div><div class="line">  cat(&quot;KNN prediction error in test:&quot;,1-mean((as.numeric(yhat)-1)==ytest),&quot;\n&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; mypar(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">&gt; <span class="keyword">for</span>(k <span class="keyword">in</span> c(<span class="number">1</span>,<span class="number">100</span>))&#123;</div><div class="line">+   <span class="comment">##predict on train</span></div><div class="line">+   yhat &lt;- knn(x,x,y,k=k)</div><div class="line">+   cat(<span class="string">"KNN prediction error in train:"</span>,<span class="number">1</span>-mean((as.numeric(yhat)-<span class="number">1</span>)==y),<span class="string">"\n"</span>)</div><div class="line">+   <span class="comment">##make plot</span></div><div class="line">+   yhat &lt;- knn(x,test,y,k=k)</div><div class="line">+   cat(<span class="string">"KNN prediction error in test:"</span>,<span class="number">1</span>-mean((as.numeric(yhat)-<span class="number">1</span>)==ytest),<span class="string">"\n"</span>)</div><div class="line">+ &#125;</div><div class="line">KNN prediction error <span class="keyword">in</span> train: <span class="number">0</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> test: <span class="number">0.375</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> train: <span class="number">0.2425</span> </div><div class="line">KNN prediction error <span class="keyword">in</span> test: <span class="number">0.2825</span></div></pre></td></tr></table></figure>
<p>为了说明，当我们设定 $k=1$时，训练集中没有错误，以及 $k=100$ 时错误升高的原因，我们用图片直观地展示一下上面的结果，如下所示：</p>
<figure class="highlight plain"><figcaption><span>knn, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">mypar(2,2)</div><div class="line">for(k in c(1,100))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=k)</div><div class="line">  ##make plot</div><div class="line">  yhat &lt;- knn(x,newx,y,k=k)</div><div class="line">  colshat &lt;- mycols[as.numeric(yhat)]</div><div class="line">  plot(x,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">  points(newx,col=colshat,cex=0.35,pch=16)</div><div class="line">  contour(tmpx,tmpy,matrix(as.numeric(yhat),GS,GS),levels=c(1,2),</div><div class="line">          add=TRUE,drawlabels=FALSE)</div><div class="line">  points(x,bg=cols,pch=21)</div><div class="line">  title(paste(&quot;Train: KNN (&quot;,k,&quot;)&quot;,sep=&quot;&quot;))</div><div class="line">  </div><div class="line">  plot(test,type=&quot;n&quot;,xlab=&quot;X1&quot;,ylab=&quot;X2&quot;,xlim=XLIM,ylim=YLIM)</div><div class="line">  points(newx,col=colshat,cex=0.35,pch=16)</div><div class="line">  contour(tmpx,tmpy,matrix(as.numeric(yhat),GS,GS),levels=c(1,2),</div><div class="line">          add=TRUE,drawlabels=FALSE)</div><div class="line">  points(test,bg=cols,pch=21)</div><div class="line">  title(paste(&quot;Test: KNN (&quot;,k,&quot;)&quot;,sep=&quot;&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912174226.jpeg" alt=""></p>
<p>从图上我们可以发现，当 $k=1$ 时，在训练集中并没有出现错误，因为每个点都是它最接近的点，这个就是它自身。但是，我们可以看到一些蓝色的岛（由几个点构成的区域）在红色区域中，一旦我们将数据集移向测试集，就会出现一些错误。当 $k=100$ 时，我们没有这个问题（也就是说红蓝区域分得很开），我们可以看到，错误率比线性回归有着明显的降低。我们还看到，我们估计的 $f(x_1,x_2)$ 比较接近于真实情况。</p>
<h4 id="贝叶斯规则"><a href="#贝叶斯规则" class="headerlink" title="贝叶斯规则"></a>贝叶斯规则</h4><p>在这一部分里，我们会比较了不同 $k$ 值下的训练集与测试集。我们还会比较当我们知道 $\mbox{E}(Y \mid X_1=x1,X_2=x_2)$ 时的错误率，这也就是所谓的贝叶斯规则(Bayes Rule)。</p>
<p>我们先来计算一下错误率，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">###Bayes Rule</div><div class="line">yhat &lt;- apply(test,1,p)</div><div class="line">cat(&quot;Bayes rule prediction error in train&quot;,1-mean(round(yhat)==y),&quot;\n&quot;)</div><div class="line">bayes.error=1-mean(round(yhat)==y)</div><div class="line">train.error &lt;- rep(0,16)</div><div class="line">test.error &lt;- rep(0,16)</div><div class="line">for(k in seq(along=train.error))&#123;</div><div class="line">  ##predict on train</div><div class="line">  yhat &lt;- knn(x,x,y,k=2^(k/2))</div><div class="line">  train.error[k] &lt;- 1-mean((as.numeric(yhat)-1)==y)</div><div class="line">  ##prediction on test    </div><div class="line">  yhat &lt;- knn(x,test,y,k=2^(k/2))</div><div class="line">  test.error[k] &lt;- 1-mean((as.numeric(yhat)-1)==y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后绘制出不同 $k$ 值下的错误率。我们还以一条水平线来展示贝叶斯规则错误率，如下所示</p>
<figure class="highlight plain"><figcaption><span>bayes_rule2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ks &lt;- 2^(seq(along=train.error)/2)</div><div class="line">mypar()</div><div class="line">plot(ks,train.error,type=&quot;n&quot;,xlab=&quot;K&quot;,ylab=&quot;Prediction Error&quot;,log=&quot;x&quot;,</div><div class="line">     ylim=range(c(test.error,train.error)))</div><div class="line">lines(ks,train.error,type=&quot;b&quot;,col=4,lty=2,lwd=2)</div><div class="line">lines(ks,test.error,type=&quot;b&quot;,col=5,lty=3,lwd=2)</div><div class="line">abline(h=bayes.error,col=6)</div><div class="line">legend(&quot;bottomright&quot;,c(&quot;Train&quot;,&quot;Test&quot;,&quot;Bayes&quot;),col=c(4,5,6),lty=c(2,3,1),box.lwd=0)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913013135.jpeg" alt=""></p>
<p>在上图中，粉色是训练集的错误率，绿色的是测试集的错误率。黄色是贝叶斯规则的错误率。</p>
<p>我们要知道，错误率是一个随机变量，它有着标准差。在下面的部分里，我们会提到交叉验证，这种方法有助于降低一些变异（这里我自己的理解就是错误率的变异）。然而即使将这些变异降低，从图中我们就可以看出来，当 $k$ 低于20时就会出现过拟合(over-fitting)，当 $k$ 超过100时就会出现低拟合(under-fitting)。</p>
<h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><p>这里我们描述一下交叉验证(cross-validation)，交叉验证是机器学习中有关方法评估的一个基础工具，它能在一项预测或机器学习任务中进行参数选择。假设我们有一组许多特征值的观测值，并且每个观测值都与一个标签关联。我们将这个集合称为我们的训练集。我们的任务就是通过从训练数据中学习模式来预测任何新样本的标签。对于一个具体的例子来说，例如我们会将每个基因看作是一个特征值，然后我们再来计算一组没有标签的数据（测试数据集），看一下这组数据是新样本中的哪些组织类型。</p>
<p>如果我们选择了一个可调参数的机器学习算法，那么我们必须要有一个策略来这个参数选择一个最佳值。我们可以尝试着先计算一批数据，例如可以把一些已知样本的数据当作训练集，然后算法会计算出这些值产生的错误数据，然后我们会选择在我们的训练集中表现最好的值。</p>
<p>现在我们使用前面提到过的组织基要因表达数据集来看一下，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">library(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div></pre></td></tr></table></figure>
<p>为了说明我们这么做的目的，我们把那些样本数目较少的组织剔除掉，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">table(tissue)</div><div class="line">ind &lt;- which(tissue != &quot;placenta&quot;)</div><div class="line">y &lt;- tissue[ind]</div><div class="line">X &lt;- t( e[,ind] )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; table(tissue)</div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们把<code>placenta(胎盘)</code>这个组织去掉了，现在我们使用kNN法来进行归类，先使用 $k=5$ 这个参数试一下。当我们把这个参数用于训练集和测试集时，我们在预测训练集中的组织时，平均误差是多少呢？</p>
<p>计算过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(class)</div><div class="line">pred &lt;- knn(train =  X, test = X, cl=y, k=5)</div><div class="line">mean(y != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当我们使用 $k=5$ 这个参数时，没有发现错误，如果是 $k=1$ 呢？如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pred &lt;- knn(train=X, test=X, cl=y, k=1)</div><div class="line">mean(y != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; mean(y != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0</span></div></pre></td></tr></table></figure>
<p>当我们试图通过对观测值进行分类用于训练(train)模型时，这一过程可能有误导性。事实时，对于kNN法来说，使用 $k=1$ 这个参数时，总是能在训练集中得到0个分类错误，因为我们使用的是数据本身。了解算法是否可靠的方法就让它对未见过的样本进行预测。类似地，如果我们想知道可调参数的最佳值是什么，我们查看不同的参数值在那些不在训练集中的样本上表现如何。</p>
<p>交叉验证是机器学习中广泛使用的一种方法，它解决了训练集和测试集的问题，同时它仍然可以使用所有的数据用于检测预测的准确性。它通过将所有的数据分散成一定数据的折叠(fold)（注：这里有关交叉验证的问题，可以参考以前的文章<a href="http://rvdsd.top/2018/07/05/StatQuest/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B022-%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/">《StatQuest学习笔记22——交叉验证》</a>）。如果我们有 $N$ 个折叠，那么算法的第一步就是使用 $(N-1)$ 个折叠来训练算法，并且剩下一个折叠用于测试算法的准确性。然后重复 $N$ 次，直到所有的折叠都在测试集中一样被使用。如果我们有M个参数需要进行尝试，那么我们需要在外部循环中完成这个过程，因为我们需要总共拟合 $N \times M$次。</p>
<p>在R中，我们使用<code>caret</code>包中的<code>createFolds()</code>函数来实现这个过程,在下面的案例中，我们使用5个折叠来计算我们的基因表达数据，这个数字与组织的数目比较接近。此外，<code>createFold()</code>函数中有个参数<code>k</code>，这里不要与kNN算法中的<code>k</code>混淆，它们只是相同的字符，具体意义不一样，它们完全不相关。<code>createFolds()</code>会寻问用户要创建多少个折叠，也就是上文提到的 $N$ 。而<code>knn()</code>中的参数<code>k</code>则是说明在一个新的样本中，使用多少个最接近的观测值。现在我们创建10个折叠，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">library(caret)</div><div class="line">set.seed(1)</div><div class="line">idx &lt;- createFolds(y, k=10)</div><div class="line">sapply(idx, length)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; sapply(idx, length)</div><div class="line">Fold01 Fold02 Fold03 Fold04 Fold05 Fold06 Fold07 Fold08 Fold09 Fold10 </div><div class="line">    <span class="number">18</span>     <span class="number">19</span>     <span class="number">17</span>     <span class="number">17</span>     <span class="number">18</span>     <span class="number">20</span>     <span class="number">19</span>     <span class="number">19</span>     <span class="number">20</span>     <span class="number">16</span></div></pre></td></tr></table></figure>
<p>折叠会以数字索引列表的形式返回，因此数据的第一个折叠是：</p>
<p>The folds are returned as a list of numeric indices. The first fold of data is therefore:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y[idx[[1]]] ##the labels</div><div class="line">head( X[idx[[1]], 1:3] ) ##the genes (only showing the first 3 genes...)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; y[idx[[<span class="number">1</span>]]] <span class="comment">##the labels</span></div><div class="line"> [<span class="number">1</span>] <span class="string">"kidney"</span>      <span class="string">"kidney"</span>      <span class="string">"hippocampus"</span> <span class="string">"hippocampus"</span> <span class="string">"hippocampus"</span> <span class="string">"cerebellum"</span> </div><div class="line"> [<span class="number">7</span>] <span class="string">"cerebellum"</span>  <span class="string">"cerebellum"</span>  <span class="string">"colon"</span>       <span class="string">"colon"</span>       <span class="string">"colon"</span>       <span class="string">"colon"</span>      </div><div class="line">[<span class="number">13</span>] <span class="string">"kidney"</span>      <span class="string">"kidney"</span>      <span class="string">"endometrium"</span> <span class="string">"endometrium"</span> <span class="string">"liver"</span>       <span class="string">"liver"</span>      </div><div class="line">&gt; head( X[idx[[<span class="number">1</span>]], <span class="number">1</span>:<span class="number">3</span>] ) <span class="comment">##the genes (only showing the first 3 genes...)</span></div><div class="line">                1007_s_at  1053_at   117_at</div><div class="line">GSM12075.CEL.gz  <span class="number">9.966782</span> <span class="number">6.060069</span> <span class="number">7.644452</span></div><div class="line">GSM12098.CEL.gz  <span class="number">9.945652</span> <span class="number">5.927861</span> <span class="number">7.847192</span></div><div class="line">GSM21214.cel.gz <span class="number">10.955428</span> <span class="number">5.776781</span> <span class="number">7.493743</span></div><div class="line">GSM21218.cel.gz <span class="number">10.757734</span> <span class="number">5.984170</span> <span class="number">8.525524</span></div><div class="line">GSM21230.cel.gz <span class="number">11.496114</span> <span class="number">5.760156</span> <span class="number">7.787561</span></div><div class="line">GSM87086.cel.gz  <span class="number">9.798633</span> <span class="number">5.862426</span> <span class="number">7.279199</span></div></pre></td></tr></table></figure>
<p>我们可以看到，事实上组织在10个折叠中表现非常平均：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sapply(idx, function(i) table(y[i]))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; sapply(idx, <span class="keyword">function</span>(i) table(y[i]))</div><div class="line">            Fold01 Fold02 Fold03 Fold04 Fold05 Fold06 Fold07 Fold08 Fold09 Fold10</div><div class="line">cerebellum       <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span></div><div class="line">colon            <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">3</span></div><div class="line">endometrium      <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span></div><div class="line">hippocampus      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span></div><div class="line">kidney           <span class="number">4</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span>      <span class="number">4</span></div><div class="line">liver            <span class="number">2</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span>      <span class="number">2</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span></div></pre></td></tr></table></figure>
<p>因为不同组织的表达谱不一样，因此使用所有的基因来预测组织非常容易。为了说明这种算法的原理，我们这里只使用二维数据来进行预测，现在我们使用<code>cmdscale()</code>函数进行降低处理：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">Xsmall &lt;- cmdscale(dist(X))</div><div class="line">plot(Xsmall,col=as.fumeric(y))</div><div class="line">legend(<span class="string">"topleft"</span>,levels(factor(y)),fill=seq_along(levels(factor(y))))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913180841.jpeg" alt=""></p>
<p>现在我们在单个折叠上试一下kNN法。我们使用<code>Xsmall</code>中的样本（不用第1个样本），用<code>knn()</code>函数计算一下。我们使用<code>-idx[[1]]</code>移除第1个样本，这样将剩下来的样本当作测试集。参数<code>cl</code>用于指定真分类（true classificaiton）或者是训练集的标签（这里指的是组织）。现在我们使用5个观测值来为我们的kNN算法指定分类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pred &lt;- knn(train=Xsmall[ -idx[[1]] , ], test=Xsmall[ idx[[1]], ], cl=y[ -idx[[1]] ], k=5)</div><div class="line">table(true=y[ idx[[1]] ], pred)</div><div class="line">mean(y[ idx[[1]] ] != pred)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=y[ idx[[<span class="number">1</span>]] ], pred)</div><div class="line">             pred</div><div class="line">true          cerebellum colon endometrium hippocampus kidney liver</div><div class="line">  cerebellum           <span class="number">2</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  colon                <span class="number">0</span>     <span class="number">4</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  endometrium          <span class="number">0</span>     <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span></div><div class="line">  hippocampus          <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">2</span>      <span class="number">0</span>     <span class="number">0</span></div><div class="line">  kidney               <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">4</span>     <span class="number">0</span></div><div class="line">  liver                <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      <span class="number">0</span>     <span class="number">2</span></div><div class="line">&gt; mean(y[ idx[[<span class="number">1</span>]] ] != pred)</div><div class="line">[<span class="number">1</span>] <span class="number">0.1666667</span></div></pre></td></tr></table></figure>
<p>现在我们出现了一些分类错误，我们计算一下剩余折叠，看一下情况怎么样？</p>
<p>Now we have some misclassifications. How well do we do for the rest of the folds?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (i in 1:10) &#123;</div><div class="line">  pred &lt;- knn(train=Xsmall[ -idx[[i]] , ], test=Xsmall[ idx[[i]], ], cl=y[ -idx[[i]] ], k=5)</div><div class="line">  print(paste0(i,&quot;) error rate: &quot;, round(mean(y[ idx[[i]] ] != pred),3)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>) &#123;</div><div class="line">+   pred &lt;- knn(train=Xsmall[ -idx[[i]] , ], test=Xsmall[ idx[[i]], ], cl=y[ -idx[[i]] ], k=<span class="number">5</span>)</div><div class="line">+   print(paste0(i,<span class="string">") error rate: "</span>, round(mean(y[ idx[[i]] ] != pred),<span class="number">3</span>)))</div><div class="line">+ &#125;</div><div class="line">[<span class="number">1</span>] <span class="string">"1) error rate: 0.111"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"2) error rate: 0.105"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"3) error rate: 0.118"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"4) error rate: 0.118"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"5) error rate: 0.278"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"6) error rate: 0.1"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"7) error rate: 0.105"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"8) error rate: 0.158"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"9) error rate: 0.15"</span></div><div class="line">[<span class="number">1</span>] <span class="string">"10) error rate: 0.312"</span></div></pre></td></tr></table></figure>
<p>所以，我们会看到每个折叠都会发生一些变化，其错误率徘徊在0.1-0.3之间。但是，$k=5$ 是最佳的参数吗？为了研究 $k$ 的最佳数值，我们需要创建一个外部循环，我们会在其中尝试不同的 $k$ 值，然后计算出所有折叠的平均测试集误差。我们将会尝试从1到12的每个 $k$ 值。不过这里我们不使用<code>for</code>循环，我们将使用<code>sapply</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">set.seed(1)</div><div class="line">ks &lt;- 1:12</div><div class="line">res &lt;- sapply(ks, function(k) &#123;</div><div class="line">  ##try out each version of k from 1 to 12</div><div class="line">  res.k &lt;- sapply(seq_along(idx), function(i) &#123;</div><div class="line">    ##loop over each of the 10 cross-validation folds</div><div class="line">    ##predict the held-out samples using k nearest neighbors</div><div class="line">    pred &lt;- knn(train=Xsmall[ -idx[[i]], ],</div><div class="line">                test=Xsmall[ idx[[i]], ],</div><div class="line">                cl=y[ -idx[[i]] ], k = k)</div><div class="line">    ##the ratio of misclassified samples</div><div class="line">    mean(y[ idx[[i]] ] != pred)</div><div class="line">  &#125;)</div><div class="line">  ##average over the 10 folds</div><div class="line">  mean(res.k)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>对于每个 $k$ 值，我们都有一个来自于交叉验证的关联测试集错误率，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; res</div><div class="line"> [<span class="number">1</span>] <span class="number">0.1978212</span> <span class="number">0.1703423</span> <span class="number">0.1882933</span> <span class="number">0.1750989</span> <span class="number">0.1613291</span> <span class="number">0.1500791</span> <span class="number">0.1552670</span> <span class="number">0.1884813</span></div><div class="line"> [<span class="number">9</span>] <span class="number">0.1822020</span> <span class="number">0.1763197</span> <span class="number">0.1761318</span> <span class="number">0.1813197</span></div></pre></td></tr></table></figure>
<p>我们可以绘制出每个 $k$ 值下的错误率图，它可以帮助我们查看哪个区域中的错误率最小，如下所示：</p>
<figure class="highlight plain"><figcaption><span>misclassification_error, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(ks, res, type=&quot;o&quot;,ylab=&quot;misclassification error&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913184146.jpeg" alt=""></p>
<p>我们要记住一点就是，训练集是一个随机变量，因为我们生成折叠的程序涉随机数的生成，因此，在产生“最好”的 $k$ 值时，这个 $k$ 值的产生过程也是一个随机变量。如果我们有新的训练集，并且如果我们再创建折叠，那么我们有可能会得到一个新的优化的 $k$ 值。</p>
<p>最后，为了说明基因表达数据能够很好的预测组织类型，我们使用5维数据，而非是2维数据来展示这个过程，毕竟5维数据的信息量更丰富，如下所示：</p>
<figure class="highlight plain"><figcaption><span>misclassification_error2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Xsmall &lt;- cmdscale(dist(X),k=5)</div><div class="line">set.seed(1)</div><div class="line">ks &lt;- 1:12</div><div class="line">res &lt;- sapply(ks, function(k) &#123;</div><div class="line">  res.k &lt;- sapply(seq_along(idx), function(i) &#123;</div><div class="line">    pred &lt;- knn(train=Xsmall[ -idx[[i]], ],</div><div class="line">                test=Xsmall[ idx[[i]], ],</div><div class="line">                cl=y[ -idx[[i]] ], k = k)</div><div class="line">    mean(y[ idx[[i]] ] != pred)</div><div class="line">  &#125;)</div><div class="line">  mean(res.k)</div><div class="line">&#125;)</div><div class="line">plot(ks, res, type=&quot;o&quot;,ylim=c(0,0.20),ylab=&quot;misclassification error&quot;)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190913184233.jpeg" alt=""></p>
<p>上图显示的是，使用5维数据后，错误分配与 $k$ 值变化的关系。</p>
<p>重要提示：我们使用<code>cmdscale()</code>函数来计算整个数据集，用于创建一个较小的数据集来说明kNN的计算过程。然而在真正的机器学习应用中，这样的处理会低估小样本测试数据集的错误，但是，使用未标记的完全数据集进行降维会改善这种情况。一个种更安全的做法就是为每个折叠分别转换数据（这句不懂， 我个人的猜测就是，对每个折叠进行计算，把几个折叠中的每一个都当作测试集，而不是将几个折叠放一块当作测试集），方法就是仅用训练集来计算旋转和降维，并将其应用于测试集。</p>
<p>最后一段实在没读懂，这里放原文：</p>
<blockquote>
<p> However, in a real machine learning application, this may result in an underestimation of test set error for small sample sizes, where dimension reduction using the unlabeled full dataset gives a boost in performance. A safer choice would have been to transform the data separately for each fold, by calculating a rotation and dimension reduction using the training set only and applying this to the test set.</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P407</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/23/Data Analysis for the life sciences/DALS023_Basic_Machine_Learning02_Loess/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/Data Analysis for the life sciences/DALS023_Basic_Machine_Learning02_Loess/" itemprop="url">DALS023-机器学习02-条件概率与Loess拟合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T12:00:00+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,211
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第2小节，这一部分的主要内容涉及条件概率与Loess回归，这一部分相关的Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/tree/master/ml/conditional_expectation.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="条件概率与期望"><a href="#条件概率与期望" class="headerlink" title="条件概率与期望"></a>条件概率与期望</h2><p>预测问题的结果可以分为两类，分别为分类结果(categorical outcomes)和连续型结果(continuous outcomes)。但是，许多算法都可以应用于这两种情况，这是因为条件概率(conditional probabilities)和条件期望(conditional expectations)之间有着一定联系。</p>
<p>对于分类数据，例如二分类结果，如果我们知道给在一组预测因子$X=(X_1,\dots,X_p)^\top$下预测的概率$Y$可能是$k$个结果中的任意一个，这种情况用方程表示就是：</p>
<script type="math/tex; mode=display">
f_k(x) = \mbox{Pr}(Y=k \mid X=x)</script><p>我们就可以优化我们的预测结果。尤其是，对于任意的 $x$ ，我们可能预测出最大概率 $f_k(x)$ 时的 $k$ 。</p>
<p>为了简化我们的描述，我们只考虑二分类变量。我们可以认为 $\mbox{Pr}(Y=1 \mid X=x)$ 是当 $X=x$ 时，第1层的某结果在总体中的比例。考虑到期望是所有 $Y$ 值的均值，在这个案例中，期望的概率就等于：$f(x) \equiv \mbox{E}(Y \mid X=x)=\mbox{Pr}(Y=1 \mid X=x)$。因此，我们在后面的描述中，就会使用期望，因为这种表示更加普遍。</p>
<p>通常来说，期望值是有着比较受欢迎的数学属性，因为它能够缩小预测值 $\hat{Y}$ 和 $Y$ 之间的距离：</p>
<script type="math/tex; mode=display">
\mbox{E}\{ (\hat{Y} - Y)^2  \mid  X=x \}</script><h4 id="预测中的回归问题"><a href="#预测中的回归问题" class="headerlink" title="预测中的回归问题"></a>预测中的回归问题</h4><p>我们在前面使用了父子的身高数据来介绍了回归，这里我们使用机器学习来解释一下这个数据分析过程。在我们前面的那个案例中，我们试图通常父母的身高$X$来预测儿子的身高$Y$。这里我们只有一个预测值(predictor)。现在如果我们被问到随机选择一个儿子，这个儿子的身高是多少，我们也许会使用平均值来回答，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line"><span class="keyword">library</span>(UsingR)</div><div class="line">data(<span class="string">"father.son"</span>)</div><div class="line">x=round(father.son$fheight) <span class="comment">##round to nearest inch</span></div><div class="line">y=round(father.son$sheight)</div><div class="line">hist(y,breaks=seq(min(y),max(y)))</div><div class="line">abline(v=mean(y),col=<span class="string">"red"</span>,lwd=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911232411.jpeg" alt=""></p>
<p>在这个案例中，我们也可以使用$Y$的分布近似服从正态分布来进行预测，那么也就是说，当我们回答平均值的时候，回答对的概率最大。</p>
<p>现在我们再来考虑一些情况，当我们有了更多的信息后，如何进行预测。例如，我们被告之，这个随机选择的这个儿子的父亲身高是71英寸（高于均值1.25个SD）。那么我们如何预测？</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(x,y,xlab=<span class="string">"Father's height in inches"</span>,ylab=<span class="string">"Son's height in inches"</span>,main=paste(<span class="string">"correlation ="</span>,signif(cor(x,y),<span class="number">2</span>)))</div><div class="line">abline(v=c(-<span class="number">0.35</span>,<span class="number">0.35</span>)+<span class="number">71</span>,col=<span class="string">"red"</span>)</div><div class="line">hist(y[x==<span class="number">71</span>],xlab=<span class="string">"Heights"</span>,nc=<span class="number">8</span>,main=<span class="string">""</span>,xlim=range(y))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911232626.jpeg" alt=""></p>
<p>上图的左侧是儿子身高的散点图，其中红色围起来的部分是给定父亲身高是71英寸这个数据后，对应的儿子的身高。条件分布：儿子的身高数据分布就是被父亲71英寸这个数据限定了。</p>
<p>有了父亲身高是71英寸这个数据后，那么我们来猜儿子的身高时，最好的回答还是期望值(expectation)，但是，我们的数据层(strata)已经发生了改变，也就是说，我们来猜测儿子身高$Y$时，要考虑到限制因素，即$Y=71$。因此，我们可以在这个条件之上，再来计算均值，这个均值就是条件期望(conditional expectation)，因此我们对于任意$x$值来预测时，公式如下所示：</p>
<script type="math/tex; mode=display">
f(x) = E(Y \mid X=x)</script><p>通过微积分我们可以发现，这个结果更加接近于二元正态分布，我们可以换成下面的表示形式：</p>
<script type="math/tex; mode=display">
f(x) = \mu_Y + \rho \frac{\sigma_Y}{\sigma_X} (X-\mu_X)</script><p>如果我们使用样本的数据来估计这5个参数，那么我们就会得到回归线：</p>
<figure class="highlight plain"><figcaption><span>regression, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mypar(1,2)</div><div class="line">plot(x,y,xlab=&quot;Father&apos;s height in inches&quot;,ylab=&quot;Son&apos;s height in inches&quot;,</div><div class="line">     main=paste(&quot;correlation =&quot;,signif(cor(x,y),2)))</div><div class="line">abline(v=c(-0.35,0.35)+71,col=&quot;red&quot;)</div><div class="line">fit &lt;- lm(y~x)</div><div class="line">abline(fit,col=1)</div><div class="line">hist(y[x==71],xlab=&quot;Heights&quot;,nc=8,main=&quot;&quot;,xlim=range(y))</div><div class="line">abline(v = fit$coef[1] + fit$coef[2]*71, col=1)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911234623.jpeg" alt=""></p>
<p>在这个特殊的案例中，回归线提供了对 $Y$ 更优化的预测函数，但是通常情况下这种情况并不真实，因为在典型的机器学习问题中，优化后的 $f(x)$ 很少是一条直线。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P379</p>
<h2 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h2><p>相关的Rmarkdown文档见作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/smoothing.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在所有的数据分析中，平滑(Smoothing)是一个非常强大的工具。当数据的分布的形状未知时，我们可以假定这些数据是平滑(smooth)的，我们就能够估计 $f(x)$ 。平滑的主要思路就是将那些有着类似期望的数据归类，然后计算这些归类后的平均值，或者是对其进行简单的参数模型拟合。我们使用基因表达数据来介绍两个平滑工具。</p>
<p>下面的数据是源于相同RNA样本的基因表达数据。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##Following three packages are available from Bioconductor</span></div><div class="line"><span class="keyword">library</span>(Biobase)</div><div class="line"><span class="comment"># BiocManager::install("SpikeIn")</span></div><div class="line"><span class="keyword">library</span>(SpikeIn)</div><div class="line"><span class="comment"># BiocManager::install("hgu95acdf")</span></div><div class="line"><span class="keyword">library</span>(hgu95acdf)</div><div class="line">data(SpikeIn95)</div></pre></td></tr></table></figure>
<p>我们可以使用MA图 ($Y$ = log ratios and $X$ = averages) 来比较这两个重复样本的质量，我们可能通过一种方式对这些数据进行采样，这些采样方式要能平衡 $X$ 中不同层的数据点的数目，如下所示：</p>
<figure class="highlight plain"><figcaption><span>echo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">##Example with two columns</div><div class="line">i=10;j=9</div><div class="line">##remove the spiked in genes and take random sample</div><div class="line">library(GEOquery)</div><div class="line">siNames&lt;-colnames(pData(SpikeIn95))</div><div class="line">ind &lt;- which(!probeNames(SpikeIn95)%in%siNames)</div><div class="line">pms &lt;- pm(SpikeIn95)[ ind ,c(i,j)]</div><div class="line">##pick a representative sample for A and order A</div><div class="line">Y=log2(pms[,1])-log2(pms[,2])</div><div class="line">X=(log2(pms[,1])+log2(pms[,2]))/2</div><div class="line">set.seed(4)</div><div class="line">ind &lt;- tapply(seq(along=X),round(X*5),function(i)</div><div class="line">  if(length(i)&gt;20) return(sample(i,20)) else return(NULL))</div><div class="line">ind &lt;- unlist(ind)</div><div class="line">X &lt;- X[ind]</div><div class="line">Y &lt;- Y[ind]</div><div class="line">o &lt;-order(X)</div><div class="line">X &lt;- X[o]</div><div class="line">Y &lt;- Y[o]</div></pre></td></tr></table></figure>
<p>采样结束后，我们来绘制散点图，如下所示：</p>
<figure class="highlight plain"><figcaption><span>MAplot, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">mypar()</div><div class="line">plot(X,Y)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912000435.jpeg" alt=""></p>
<p>在上面的MA图中我们可以看到 $Y$ 取决于 $X$。这种取决关系存在着偏差，因为我们发现，它们在重复性方面有着偏差，这就意味着，如果不考虑 $X$， 那么 $Y$ 的均值就是0。现在我们想预测 $f(x)=\mbox{E}(Y \mid X=x)$  ，以便于移除假这种偏差。线性回归无法捕捉到表示上图曲线 $f(x)$ 的曲率(curvature)，如下所示：</p>
<figure class="highlight plain"><figcaption><span>MAplot_with_regression_line, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">plot(X,Y)</div><div class="line">fit &lt;- lm(Y~X)</div><div class="line">points(X,Y,pch=21,bg=ifelse(Y&gt;fit$fitted,1,3))</div><div class="line">abline(fit,col=2,lwd=4,lty=2)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912000854.jpeg" alt=""></p>
<h2 id="微区间平滑-Bin-Smoothing"><a href="#微区间平滑-Bin-Smoothing" class="headerlink" title="微区间平滑(Bin Smoothing)"></a>微区间平滑(Bin Smoothing)</h2><p>对于上述的数据，我们无法使用直线进行拟合，此时我们就要使用平滑处理的思想，也就是说把这些点分散到不同的组里，计算这些不同组的均值，这就是所谓的<code>微区间平滑</code>处理（我没有找到bin smoothing相应的中文翻译，这里说的<code>微区间平滑</code>是我自己造的词）。这种处理的通常思路就是，我们假定这些数据点分为很多微区间(bin)，这样拟合的曲线是足够”平滑“的，那么在这个微区间中的这个曲线就会近似于常数(approximately constant)。如果我们假设这个曲线是常数(constant)的，那么所有位于某个微区间(bin)中的 $Y$ 就有了相同的期望值。例如，在下面的图形中，如果我们将微区间的宽度设为1，我们标记出了在8.6和12.1处的微区间。我们还显示了，在这两个区间中拟合的 $Y$ 的均值，如下所示： </p>
<figure class="highlight plain"><figcaption><span>binsmoother, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mypar()</div><div class="line">centers &lt;- seq(min(X),max(X),0.1)</div><div class="line">plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">windowSize &lt;- .5</div><div class="line">i &lt;- 25</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-mean(Y)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">lines(c(min(X[ind]),max(X[ind])),c(fit,fit),col=2,lty=2,lwd=4)</div><div class="line">i &lt;- 60</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-mean(Y[ind])</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">lines(c(min(X[ind]),max(X[ind])),c(fit,fit),col=2,lty=2,lwd=4)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001103.jpeg" alt=""></p>
<p>我们通过计算每一个点附近的小区间，我们就能对构成的曲线的函数 $f(x) $ 进行估计。下图显示了这个计算过程，即我们从最小的 $x$ 值扩展到最大值过程中的这个估计值，同时我们还展示了最小值与最大值之间的10个值，一共是10张图片，如下所示：</p>
<figure class="highlight plain"><figcaption><span>bin_smoothing_demo, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">windowSize&lt;-0.5</div><div class="line">smooth&lt;-rep(NA,length(centers))</div><div class="line">mypar (4,3)</div><div class="line">for(i in seq(along=centers))&#123;</div><div class="line">  center&lt;-centers[i]</div><div class="line">  ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">  smooth[i]&lt;-mean(Y[ind])</div><div class="line">  if(i%%round(length(centers)/12)==1)&#123; ##we show 12</div><div class="line">    plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">    points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">    lines(c(min(X[ind]),max(X[ind])),c(smooth[i],smooth[i]),col=2,lwd=2)</div><div class="line">    lines(centers[1:i],smooth[1:i],col=&quot;black&quot;)</div><div class="line">    points(centers[i],smooth[i],col=&quot;black&quot;,pch=16,cex=1.5)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001146.jpeg" alt=""></p>
<p>最终的结果就如下所示：</p>
<figure class="highlight plain"><figcaption><span>bin_smooth_final, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(centers,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912001229.jpeg" alt=""></p>
<p>在R中有许多函数可以进行平滑处理(bin smoothers)，例如<code>ksmooth</code>。但是在实际计算过程中，我们更偏向使用一些稍微复杂的模型来对数据进行拟合。在最后一个案例，也就是最后一张图，这个曲线就不怎么平滑，有一些粗糙。我们后面会介绍<code>loess</code>方法会改善这一点。</p>
<h2 id="Loess"><a href="#Loess" class="headerlink" title="Loess"></a>Loess</h2><p>Loess的全称是Local weighted regression，即局部权重回归，它在原理上类似于微区间平滑处理。但Loess与微区间平滑处理的主要区别就在于，在微区间中我是使用直线，还是抛物线进行拟合。Loess计算会增大微区间的数目，但这会使我们的估计更稳定。下图展示了两个微区间的拟合曲线，这两个区间比较宽，使用宽区间主要是因为拟合曲线提供了更多的灵活性，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">centers &lt;- seq(min(X),max(X),0.1)</div><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">windowSize &lt;- 1.25</div><div class="line">i &lt;- 25</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-lm(Y~X,subset=ind)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lty=2,lwd=3)</div><div class="line">i &lt;- 60</div><div class="line">center&lt;-centers[i]</div><div class="line">ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">fit&lt;-lm(Y~X,subset=ind)</div><div class="line">points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lty=2,lwd=3)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912124609.jpeg" alt="当我们"></p>
<p>现在我们展示一下通过12步处理来对这些数据进行loess拟合，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess_demo, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">mypar (4,3)</div><div class="line">windowSize&lt;-1.25</div><div class="line">smooth&lt;-rep(NA,length(centers))</div><div class="line">for(i in seq(along=centers))&#123;</div><div class="line">  center&lt;-centers[i]</div><div class="line">  ind=which(X&gt;center-windowSize &amp; X&lt;center+windowSize)</div><div class="line">  fit&lt;-lm(Y~X,subset=ind)</div><div class="line">  smooth[i]&lt;-fit$coef[1]+fit$coef[2]*center</div><div class="line">  if(i%%round(length(centers)/12)==1)&#123; ##we show 12</div><div class="line">    plot(X,Y,col=&quot;grey&quot;,pch=16)</div><div class="line">    points(X[ind],Y[ind],bg=3,pch=21)</div><div class="line">    a &lt;- min(X[ind]);b &lt;- max(X[ind])</div><div class="line">    lines(c(a,b),fit$coef[1]+fit$coef[2]*c(a,b),col=2,lwd=2)</div><div class="line">    </div><div class="line">    lines(centers[1:i],smooth[1:i],col=&quot;black&quot;)</div><div class="line">    points(centers[i],smooth[i],col=&quot;black&quot;,pch=16,cex=1.5)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912124842.jpeg" alt=""></p>
<p>最终的结果就是生成一条更加平滑的拟合曲线用于估计我们的局部参数，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess_final, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mypar (1,1)</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(centers,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912125359.jpeg" alt=""></p>
<p>R中的函数<code>loess()</code>可以进行上述的分析，如下所示：</p>
<figure class="highlight plain"><figcaption><span>loess2, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fit &lt;- loess(Y~X, degree=1, span=1/3)</div><div class="line">newx &lt;- seq(min(X),max(X),len=100) </div><div class="line">smooth &lt;- predict(fit,newdata=data.frame(X=newx))</div><div class="line">mypar ()</div><div class="line">plot(X,Y,col=&quot;darkgrey&quot;,pch=16)</div><div class="line">lines(newx,smooth,col=&quot;black&quot;,lwd=3)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190912125636.jpeg" alt=""></p>
<p><code>loess()</code>函数与其它的曲线平滑处理函数(bin smoother)还有三点重要的区别：</p>
<p>第一，<code>loess()</code>函数会保持局部拟合中的点数不变，而非保持区间的数目不变。局部拟合中的点数是通过<code>span</code>参数决定的，这是一个比值。例如，如果 <code>N</code> 是数据点的数目，那么 <code>span = 0.5</code> 则表示针对一个确定的 <code>x</code> ， <code>loess()</code>将会使用 <code>0.5*N</code> 个最接近的点对 <code>x</code> 进行拟合。</p>
<p>第二，使用参数模型来对 $f(x)$ 进行拟合时，<code>loess()</code>会使用加权最小平方和来进行计算，那些权重比较大的点就是那些更接近 <code>x</code> 的点。</p>
<p>第三，<code>loess()</code>函数会选择更稳健(robustly)的局部模型来进行拟合。这是一种迭代算法，其中在一次迭代中拟合了模型之后，对于那些检测到的异常值就会在下一次迭代中降低其权重。如果要想使用这个参数，可以设定<code>family = &quot;symmetric&quot;</code>。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>P389</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/22/Data Analysis for the life sciences/DALS022_Basic_Machine_Learning01_ Cluster_heatmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/Data Analysis for the life sciences/DALS022_Basic_Machine_Learning01_ Cluster_heatmap/" itemprop="url">DALS022-机器学习01-聚类与热图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:00:00+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,120
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第9章机器学习的第1小节，这一部分的主要内容涉及聚类与热图，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/ml/clustering_and_heatmaps.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>机器学习是一个非常广泛的主题和高度活跃的研究领域。 在生命科学中，涉及到“精准医学”的大部分内容都是与机器学习在生物医学数据方面的处理有关。 常规的思路就是从检测的指标中预测或发现一些信息。例如，我们能够从基因表达谱中发现新的癌症吗？我们能通过一系列的基因型来预测药物反应吗？在这一部分中，我们主要介绍两个机器学习的方法，即聚类(clustering)和类预测(class prediction)。</p>
<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p>我们还使用前面的组织基因表达的数据来深圳一下聚类的概念和思路：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div></pre></td></tr></table></figure>
<p>为了说明聚类在生命科学方面的应用，我们先假设我们并不知道上面的几个样本是不同的组织，我们通过聚类来看一下它们的表达谱情况，第一步就是计算不同的样本之间的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist( t(e) )</div></pre></td></tr></table></figure>
<h3 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h3><p>当我们计算了每对样本之间的距离后，我们需要使用聚类算法将它们聚成不同的组。层次聚类算是众多聚类算法中的一个。每个样本首先会被当作一组(group)，然后不断地通过聚类算法迭代，将两个相似的组结合起来，一直到所有的样本都聚为一组。对于样本之间的距离我们已经了解了，但是，不同组之间的距离我们并不了解。关于组与组之间的距离计算方法有很多种，这些方法的核心都是通过计算组与组之间的成员的距离实现的。具体的可以查看<code>hclust()</code>函数的帮助文档。</p>
<p>我们通过<code>hclust()</code>函数来对不同组之间的距离进行层次聚类分析。这个函数会返回一个<code>hclust</code>对象，它描述的我们通过上述算法进行的组划分(grouping)。随后使用<code>plot()</code>函数绘制出树状图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">hc &lt;- hclust(d)</div><div class="line">hc</div><div class="line">plot(hc,labels=tissue,cex=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">library</span>(rafalib)</div><div class="line">&gt; mypar()</div><div class="line">&gt; hc &lt;- hclust(d)</div><div class="line">&gt; hc</div><div class="line"></div><div class="line">Call:</div><div class="line">hclust(d = d)</div><div class="line"></div><div class="line">Cluster method   : complete </div><div class="line">Distance         : euclidean </div><div class="line">Number of objects: <span class="number">189</span></div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215025.jpeg" alt=""></p>
<p>使用这种算法能否发现不同组织的簇(clusters)？在上面的这个图形里，我们不太容易发现这些不同的组织，因此我们需要使用<code>myclust()</code>函数来给它们加上颜色，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">myplclust(hc, labels=tissue, lab.col=as.fumeric(tissue), cex=<span class="number">0.5</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215224.jpeg" alt=""></p>
<p>从图形上我们可以看出来，似乎聚类算法能够发现这些不同的组织。但是，层次聚类并没有定义特定的簇，而是定义了上在树状图。从树状图上我们可以描述任意两组之间的距离。为了定义一些簇，我们需要将把树在某些距离上”切开“，所有的样本在这个距离以下分成不同的组。我们可以绘制出一条水平线，我们就使用120这个距离来切，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myplclust(hc, labels=tissue, lab.col=as.fumeric(tissue),cex=<span class="number">0.5</span>)</div><div class="line">abline(h=<span class="number">120</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911215559.jpeg" alt=""></p>
<p>当我们在高度为120上对树进行切割时，我们可以看一下这个线能够把线以下的样本分为几组，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hclusters &lt;- cutree(hc, h=<span class="number">120</span>)</div><div class="line">table(true=tissue, cluster=hclusters)</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=tissue, cluster=hclusters)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span>  <span class="number">0</span> <span class="number">12</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">9</span> <span class="number">18</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>从上面可以看出来，分为了8组，另外通过<code>cutreee()</code>函数，我们可以直接指定返回几组簇，这个函数会自动返回结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hclusters &lt;- cutree(hc, k=<span class="number">8</span>)</div><div class="line">table(true=tissue, cluster=hclusters)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; hclusters &lt;- cutree(hc, k=<span class="number">8</span>)</div><div class="line">&gt; table(true=tissue, cluster=hclusters)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span> <span class="number">12</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney      <span class="number">37</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">6</span></div></pre></td></tr></table></figure>
<p>从上面两组计算方法我们可以看出来，除了个别情况外（例如endometrium和kidney），其余的簇中，基本上每簇代表一个组织。在某些情况下，一个组织有可能存在于两个簇中，这是因为选择的簇太多了。在聚类分析中，关于如何选择簇的个数也是一个很活跃的研究领域。</p>
<h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><p>我们还可以使用<code>kmeans()</code>函数来进行k-means聚类。现在我们来演示一下如何使用这个函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">km &lt;- kmeans(t(e[<span class="number">1</span>:<span class="number">2</span>,]), centers=<span class="number">7</span>)</div><div class="line">names(km)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(e[<span class="number">1</span>,], e[<span class="number">2</span>,], col=as.fumeric(tissue), pch=<span class="number">16</span>)</div><div class="line">plot(e[<span class="number">1</span>,], e[<span class="number">2</span>,], col=km$cluster, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; set.seed(<span class="number">1</span>)</div><div class="line">&gt; km &lt;- kmeans(t(e[<span class="number">1</span>:<span class="number">2</span>,]), centers=<span class="number">7</span>)</div><div class="line">&gt; names(km)</div><div class="line">[<span class="number">1</span>] <span class="string">"cluster"</span>      <span class="string">"centers"</span>      <span class="string">"totss"</span>        <span class="string">"withinss"</span>     <span class="string">"tot.withinss"</span></div><div class="line">[<span class="number">6</span>] <span class="string">"betweenss"</span>    <span class="string">"size"</span>         <span class="string">"iter"</span>         <span class="string">"ifault"</span></div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911220200.jpeg" alt=""></p>
<p>上图我们使用的是不同组织的前2个基因表达情况，其中颜色表示不同的组织。在在图中，颜色表示通过<code>kmeans()</code>函数计算的聚类结果。从下面的这个列表中我们就可以看到，这个聚类效果并不好：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(true=tissue,cluster=km$cluster)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; </div><div class="line">&gt; table(true=tissue,cluster=km$cluster)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">0</span> <span class="number">23</span></div><div class="line">  colon        <span class="number">2</span> <span class="number">11</span>  <span class="number">2</span> <span class="number">15</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">8</span></div><div class="line">  hippocampus <span class="number">19</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span> <span class="number">10</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">7</span>  <span class="number">8</span> <span class="number">20</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></div><div class="line">  liver        <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">18</span>  <span class="number">8</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">4</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span></div></pre></td></tr></table></figure>
<p>这个结果不太好很有可能就是我们选择的这2个基因信息量不足以将不同组织区分开来，如果我们使用所有的基因进行kmeans计算，那么我们就能极大地改善聚类结果，现在我们使用MDS图来展示这个结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">km &lt;- kmeans(t(e), centers=<span class="number">7</span>)</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(mds[,<span class="number">1</span>], mds[,<span class="number">2</span>])</div><div class="line">plot(mds[,<span class="number">1</span>], mds[,<span class="number">2</span>], col=km$cluster, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911220820.jpeg" alt=""></p>
<p>上图礣是使用前两个PC来绘制的聚类结果，右图是使用所有的基因来绘制的MDS图，使用颜色标明了不同的组织。</p>
<p>通过查看结果中的列表，我们就可以看到聚类的效果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table(true=tissue,cluster=km$cluster)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; table(true=tissue,cluster=km$cluster)</div><div class="line">             cluster</div><div class="line">true           <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line">  cerebellum   <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">2</span>  <span class="number">0</span></div><div class="line">  colon        <span class="number">0</span> <span class="number">34</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  endometrium  <span class="number">0</span> <span class="number">15</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  hippocampus  <span class="number">0</span>  <span class="number">0</span> <span class="number">31</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">  kidney       <span class="number">0</span> <span class="number">37</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span></div><div class="line">  liver        <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">24</span></div><div class="line">  placenta     <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">6</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div></pre></td></tr></table></figure>
<h2 id="热图"><a href="#热图" class="headerlink" title="热图"></a>热图</h2><p>在遗传学文献中，热图的使用非常广泛。它们能够查看所有样本的不同基因的表达情况，有的时候还会在热图的上面或旁边添加上聚类后的树状图。现在我们来看一下如何创建热图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(RColorBrewer)</div><div class="line">hmcol &lt;- colorRampPalette(brewer.pal(<span class="number">9</span>, <span class="string">"GnBu"</span>))(<span class="number">100</span>)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line"></div><div class="line">rv &lt;- rowVars(e)</div><div class="line"><span class="comment"># We will create heatmp using th e50 most variable genes and the function heatmap.2</span></div><div class="line"></div><div class="line">idx &lt;- order(-rv)[<span class="number">1</span>:<span class="number">40</span>]</div></pre></td></tr></table></figure>
<p>现在我们使用<code>gplots</code>包中的<code>heatmap.2</code>了娄来绘制热图，并在热图的顶部添加组织信息，如下所示</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(gplots) <span class="comment">##Available from CRAN</span></div><div class="line">cols &lt;- palette(brewer.pal(<span class="number">8</span>, <span class="string">"Dark2"</span>))[as.fumeric(tissue)]</div><div class="line">head(cbind(colnames(e),cols))</div><div class="line"></div><div class="line">heatmap.2(e[idx,], labCol=tissue,</div><div class="line">          trace=<span class="string">"none"</span>,</div><div class="line">          ColSideColors=cols,</div><div class="line">          col=hmcol)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(cbind(colnames(e),cols))</div><div class="line">                       cols     </div><div class="line">[<span class="number">1</span>,] <span class="string">"GSM11805.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">2</span>,] <span class="string">"GSM11814.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">3</span>,] <span class="string">"GSM11823.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">4</span>,] <span class="string">"GSM11830.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">5</span>,] <span class="string">"GSM12067.CEL.gz"</span> <span class="string">"#1B9E77"</span></div><div class="line">[<span class="number">6</span>,] <span class="string">"GSM12075.CEL.gz"</span> <span class="string">"#1B9E77"</span></div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911221507.jpeg" alt=""></p>
<p>在热图中我们并没有使用组织信息，我们仅用了最显著的40个基因就发现了不同的组织。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P374</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/21/Data Analysis for the life sciences/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/Data Analysis for the life sciences/DALS021_Distance_and_Dimension_Reduction2_MDS_PCA/" itemprop="url">DALS021-MDS与PCA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T12:00:00+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,527
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第2小节，这一部分的主要内容涉及MDS和PCA，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/highdim/mds.Rmd" target="_blank" rel="external">Github</a>。</p>
<h2 id="MDS"><a href="#MDS" class="headerlink" title="MDS"></a>MDS</h2><p>MDS的全称为multi-dimensional scaling，即多维数据缩放。在这 一部分中，我们会使用基因表达的数据来作为案例讲解一下。为了简化说明，我们仅考虑3个组织：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">colind &lt;- tissue%<span class="keyword">in</span>%c(<span class="string">"kidney"</span>,<span class="string">"colon"</span>,<span class="string">"liver"</span>)</div><div class="line">mat &lt;- e[,colind]</div><div class="line">group &lt;- factor(tissue[colind])</div><div class="line">dim(mat)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; dim(mat)</div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>    <span class="number">99</span></div></pre></td></tr></table></figure>
<p>现在我们要研究一下这个数据集，我们想知道，储存在<code>mat</code>列中的基因表达谱的数据在不同的组织间的相似性如何。由于数据很大，无法直接画出相应的多维点图。我们通常只能绘制出二维图形，如果我们要绘制出每两个样本之间的基因表达情况不现实。而MDS图形就是为了解决这个问题而提出来的。</p>
<h3 id="MDS背后的数学原理"><a href="#MDS背后的数学原理" class="headerlink" title="MDS背后的数学原理"></a>MDS背后的数学原理</h3><p>前面我们已经知道了SVD和矩阵代数，那么我们理解MDS就相对清楚了。为了说明MDS，我们先来看一下SVD分解，如下所示：</p>
<script type="math/tex; mode=display">
\mathbf{Y} = \mathbf{UDV}^\top</script><p>我们假设 $\mathbf{U^\top Y=DV^\top}$ 的前两列的平方和剩余列的平方和。因此它们可以写为$d_1+ d_2 \gg d_3 + \dots + d_n$ 其中 $d_i$ 是$\mathbf{D}$ 是第i列（原文是i-th entry）。当出现这种情况时，我们就会得到如下公式：</p>
<script type="math/tex; mode=display">
\mathbf{Y}\approx [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&0\\
    0&d_{2}\\
  \end{pmatrix}
  [\mathbf{V}_1 \mathbf{V}_2]^\top</script><p>这就表明，第$i$列近似等于：</p>
<script type="math/tex; mode=display">
\mathbf{Y}_i \approx
[\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1}&0\\
    0&d_{2}\\
  \end{pmatrix}
  \begin{pmatrix}
    v_{i,1}\\
    v_{i,2}\\
     \end{pmatrix}
    =
    [\mathbf{U}_1 \mathbf{U}_2] 
  \begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}</script><p>如果我们们定义下面的二维向量：</p>
<script type="math/tex; mode=display">
\mathbf{Z}_i=\begin{pmatrix}
    d_{1} v_{i,1}\\
    d_{2} v_{i,2}
 \end{pmatrix}</script><p>那么：</p>
<script type="math/tex; mode=display">
\begin{align*}
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) &\approx \left\{ [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \right\}^\top \left\{[\mathbf{U}_1 \mathbf{U}_2]  (\mathbf{Z}_i-\mathbf{Z}_j)\right\}\\
&= (\mathbf{Z}_i-\mathbf{Z}_j)^\top [\mathbf{U}_1 \mathbf{U}_2]^\top [\mathbf{U}_1 \mathbf{U}_2] (\mathbf{Z}_i-\mathbf{Z}_j) \\
&=(\mathbf{Z}_i-\mathbf{Z}_j)^\top(\mathbf{Z}_i-\mathbf{Z}_j)\\
&=(Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2
\end{align*}</script><p>上面的这个推导告诉我们，在样本$i$和样本$j$之最的距离近拟等于下面二维数据点的距离：</p>
<script type="math/tex; mode=display">
(\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j) \approx
 (Z_{i,1}-Z_{j,1})^2 + (Z_{i,2}-Z_{j,2})^2</script><p>因为$Z$是一个二维向量，因此我们可以通过绘制$\mathbf{Z_{1}}$和$\mathbf{Z_{2}}$来发展示这两个样本的距离。现在我们绘制出它们的距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(mat-rowMeans(mat))</div><div class="line">PC1 &lt;- s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 &lt;- s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC1,PC2,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090640.jpeg" alt=""></p>
<p>从图片上我们可以看出，数据点按照相应的组织区分开来了。上面的这种分开的精确近似取决于前两个主成分解释变异的程度。像上面那样所示，我们可以绘制出每个主成分可以解释的变异程度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911090819.jpeg" alt=""></p>
<p>虽然前两个主成分解释了超过50%的变异，不过前面的图形还是没有展示出大量的信息。但是这种图已经足够用于进行可视化大量的数据了。此外，我们还可以注意到，我们能够绘制其它的主成分来研究这些数据点，例如我们绘制第3个和第4个主成分：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">PC3 &lt;- s$d[<span class="number">3</span>]*s$v[,<span class="number">3</span>]</div><div class="line">PC4 &lt;- s$d[<span class="number">4</span>]*s$v[,<span class="number">4</span>]</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(PC3,PC4,pch=<span class="number">21</span>,bg=as.numeric(group))</div><div class="line">legend(<span class="string">"bottomright"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>,cex=<span class="number">1.5</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091057.jpeg" alt=""></p>
<p>从上面图形中我们可以看到，第4个主成分能够将肾脏组织的样本强烈分开。在后面的部分中，我们会讲到批次效应(batch effects)会解释这种情况。</p>
<h3 id="cmdscale-函数"><a href="#cmdscale-函数" class="headerlink" title="cmdscale()函数"></a><code>cmdscale()</code>函数</h3><p>我们在上面使用了<code>svd()</code>函数来进行计算，不过R中有一个专门的函数用于计算MDS，生成MDS图。这个函数就是<code>cmdscale()</code>函数，这个函数将距离对象作为参数，然后使用主成分分析来对这些距离进行近似计算。这个函数比使用<code>svd()</code>函数更高效（因为不可能实现完全的<code>svd()</code>函数计算，那样比较花时间）。此函数默认返回二维的数据，不过我们通过设定参数<code>k</code>（默认情况下，<code>k=2</code>）可以改变结果中的维度：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(mat))</div><div class="line">mds &lt;- cmdscale(d)</div><div class="line">mypar()</div><div class="line">plot(mds[,<span class="number">1</span>],mds[,<span class="number">2</span>],bg=as.numeric(group),pch=<span class="number">21</span>,</div><div class="line">xlab=<span class="string">"First dimension"</span>,ylab=<span class="string">"Second dimension"</span>)</div><div class="line">legend(<span class="string">"bottomleft"</span>,levels(group),col=seq(along=levels(group)),pch=<span class="number">15</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911091915.jpeg" alt=""></p>
<p>再看另外一个：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">2</span>)&#123;</div><div class="line">plot(mds[,i],s$d[i]*s$v[,i],main=paste(<span class="string">"PC"</span>,i))</div><div class="line">b = ifelse( cor(mds[,i],s$v[,i]) &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</div><div class="line">abline(<span class="number">0</span>,b) <span class="comment">##b is 1 or -1 depending on the arbitrary sign "flip"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911092010.jpeg" alt=""></p>
<h3 id="任意符号"><a href="#任意符号" class="headerlink" title="任意符号"></a>任意符号</h3><p>SVD并非是唯一的，只要我们用<code>-1</code>乘以$\mathbf{U}$的样本列，我们就能使用<code>-1</code>乘以$\mathbf{V}$的任意列，通过下面的转换我们就能看出来（这一段不懂）：</p>
<script type="math/tex; mode=display">
\mathbf{-1UD(-1)V}^\top = \mathbf{UDV}^\top</script><h3 id="扣除平均值"><a href="#扣除平均值" class="headerlink" title="扣除平均值"></a>扣除平均值</h3><p>在所有的计算中，当我们计算SVD时，都会扣除行(row)的均值。如果我们要试图计算两列之间的近似距离，那么在$\mathbf{Y}_{i}$和$\mathbf{Y}_{j}$之间的距离就与$\mathbf{Y}_i - \mathbf{\mu}$和$\mathbf{Y}_j - \mathbf{\mu}$之间的距离相同，因为当我们过计算时，中间的$\mu$就会被消去：</p>
<script type="math/tex; mode=display">
\left\{ ( \mathbf{Y}_i- \mathbf{\mu} ) - ( \mathbf{Y}_j - \mathbf{\mu} ) \right\}^\top \left\{ (\mathbf{Y}_i- \mathbf{\mu}) - (\mathbf{Y}_j - \mathbf{\mu} ) \right\} = \left\{  \mathbf{Y}_i-  \mathbf{Y}_j  \right\}^\top \left\{ \mathbf{Y}_i - \mathbf{Y}_j  \right\}</script><p>因为扣除行均值可以降低总的变异，它可以使得SVD的结果近更为逼近。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P357</p>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>PCA的相关资料可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/PCA.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经提到了PCA，这里继续深入一步，讲一下PCA背后的数学原理。</p>
<h3 id="案例：双胞胎身高"><a href="#案例：双胞胎身高" class="headerlink" title="案例：双胞胎身高"></a>案例：双胞胎身高</h3><p>我们先使用模拟数据的案例展示一个旋转，这个旋转与PCA有着很大的有关系：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">Y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(Y[<span class="number">1</span>,], Y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=thelim, ylim=thelim)</div><div class="line">points(Y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], Y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911094030.jpeg" alt=""></p>
<p>这里我们专门来解释一下什么是什么成分（principla components）。</p>
<p>我们使用 $\mathbf{Y}$ 这个 $2 \times N$ 矩阵来表示我们的数据。这个类似于我们检测了两组基因的信息，每列表示1个样本。现在我们的任何就是，找到一个  $2 \times 1$ 向量 $\mathbf{u}_1$ ，使其满足 $\mathbf{u}_1^\top \mathbf{v}_1 = 1$，它能使 $(\mathbf{u}_1^\top\mathbf{Y})^\top (\mathbf{u}_1^\top\mathbf{Y})$ 最大。这个过程可以被视为每个样本，或$\mathbf{Y}$向子空间 $\mathbf{u}_1$ 的投影。因此，我们需要将坐标系进行置换，使新的坐标系能够显示出最大变异。</p>
<p>我先试一下 $\mathbf{u}=(1,0)^\top$。这个投影公仅能够给出双胞胎1的身高（橘黄色）。图片标题中显示的是平方和。</p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1, fig.align</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(t(Y), xlim=thelim, ylim=thelim,</div><div class="line">     main=paste(&quot;Sum of squares :&quot;,round(crossprod(Y[1,]),1)))</div><div class="line">abline(h=0)</div><div class="line">apply(Y,2,function(y) segments(y[1],0,y[1],y[2],lty=2))</div><div class="line">points(Y[1,],rep(0,ncol(Y)),col=2,pch=16,cex=0.75)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911160126.jpeg" alt=""></p>
<p>我们能否找到一个方向，使得坐标系旋转后，能够表示更高的变异？例如</p>
<p>$\mathbf{u} =\begin{pmatrix}1\-1\end{pmatrix}$ 这个怎么样？它不满足 $\mathbf{u}^\top\mathbf{u}= 1$ ，因此我们可以使用另外一个向量，即<br>$\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\-1/\sqrt{2}\end{pmatrix}$ </p>
<figure class="highlight plain"><figcaption><span>projection_not_PC1_either, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">library(rafalib)</div><div class="line">u &lt;- matrix(c(1,-1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar(1,1)</div><div class="line">plot(t(Y),</div><div class="line">     main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),xlim=thelim,ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,-1,col=2)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i],Z[2,i],Y[1,i],Y[2,i],lty=2)</div><div class="line">points(t(Z), col=2, pch=16, cex=0.5)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161254.jpeg" alt=""></p>
<p>这个图形与双胞胎的差异有关，我们知道这个差异很少的。通常平方和我们可以确实这一点，最后我们试一下这个向量：</p>
<script type="math/tex; mode=display">
\mathbf{u} =\begin{pmatrix}1/\sqrt{2}\\1/\sqrt{2}\end{pmatrix}</script><figure class="highlight plain"><figcaption><span>PC1, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">u &lt;- matrix(c(1,1)/sqrt(2),ncol=1)</div><div class="line">w=t(u)%*%Y</div><div class="line">mypar()</div><div class="line">plot(t(Y), main=paste(&quot;Sum of squares:&quot;,round(tcrossprod(w),1)),</div><div class="line">     xlim=thelim, ylim=thelim)</div><div class="line">abline(h=0,lty=2)</div><div class="line">abline(v=0,lty=2)</div><div class="line">abline(0,1,col=2)</div><div class="line">points(u%*%w, col=2, pch=16, cex=1)</div><div class="line">Z = u%*%w</div><div class="line">for(i in seq(along=w))</div><div class="line">  segments(Z[1,i], Z[2,i], Y[1,i], Y[2,i], lty=2)</div><div class="line">points(t(Z),col=2,pch=16,cex=0.5)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911161447.jpeg" alt=""></p>
<p>这个图形与重新缩放(re-scaled)后的平均高度有关，它有着最大的平方和。这是一个数学计算程序，它能够计算出一个 $\mathbf{v}$ ，能够使平方和最大，SVD就是这样的一个程序。</p>
<h4 id="主成分"><a href="#主成分" class="headerlink" title="主成分"></a>主成分</h4><p>正交向量能够使平方和最大：</p>
<script type="math/tex; mode=display">
(\mathbf{u}_1^\top\mathbf{Y})^\top(\mathbf{u}_1^\top\mathbf{Y})</script><p>$\mathbf{u}_1^\top\mathbf{Y}$ 指的就是第1PC。e用于获得PC的加权(weights) $\mathbf{u}$ 指的就是因子载荷(loadings)。使用旋转这种操作，它指的就是第1PC的旋转方向。</p>
<p>为了获得第2PC，我们可以重复上述操作，但是残差如下：</p>
<script type="math/tex; mode=display">\mathbf{r} = \mathbf{Y} - \mathbf{u}_1^\top \mathbf{Yv}_1</script><p>第2PC的向量含有以下性质：</p>
<script type="math/tex; mode=display">\mathbf{v}_2^\top \mathbf{v}_1=0</script><p>它能使  $(\mathbf{rv}_2)^\top \mathbf{rv}_2$最大，</p>
<p>当 $Y$ 是 $N \times m$ 时，我们可以重复地找到第3，第4，第5，等主成分。</p>
<h4 id="prcomp"><a href="#prcomp" class="headerlink" title="prcomp"></a><code>prcomp</code></h4><p>我们已经介绍了如何使用SVD来计算PC。介理，R中有一个专门的函数可以用于找到主成分，即<code>prcomp()</code>，在这个案例中，数据默认中心化的，这个函数的使用如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc &lt;- prcomp( t(Y) )</div></pre></td></tr></table></figure>
<p>计算出的结果与SVD相同，直到符号翻转（produces the same results as the SVD up to arbitrary sign flips，实在没理解这句话什么意思）</p>
<figure class="highlight plain"><figcaption><span>pca_svd, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd( Y - rowMeans(Y) )</div><div class="line">mypar(1,2)</div><div class="line">for(i in 1:nrow(Y) )&#123;</div><div class="line">  plot(pc$x[,i], s$d[i]*s$v[,i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190911165120.jpeg" alt=""></p>
<p>因子载荷可以通过下面方式计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$rotation</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; pc$rotation</div><div class="line">           PC1        PC2</div><div class="line">[<span class="number">1</span>,] <span class="number">0.7072304</span>  <span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.7069831</span> -<span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>它就相当于 (up to a sign flip？这个不懂) :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s$u</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; s$u</div><div class="line">           [,<span class="number">1</span>]       [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.7072304</span> -<span class="number">0.7069831</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">0.7069831</span>  <span class="number">0.7072304</span></div></pre></td></tr></table></figure>
<p>解释的方差等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pc$sdev</div></pre></td></tr></table></figure>
<p>计算结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; pc$sdev</div><div class="line">[<span class="number">1</span>] <span class="number">1.2542672</span> <span class="number">0.2141882</span></div></pre></td></tr></table></figure>
<p>现在我们将<code>Y</code>转置一下，因为<code>prcomp()</code>函数与我们平时所用的高通量数据储存有点不太一样，平时我们的数据是列为样本，行为特征值，而<code>prcomp()</code>函数则是正好相反，它处理的数据列是特征值，行是样本名。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/20/Data Analysis for the life sciences/DALS020_Distance_and_Dimension_Reduction1_SVD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/Data Analysis for the life sciences/DALS020_Distance_and_Dimension_Reduction1_SVD/" itemprop="url">DALS020-距离与降维</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T12:00:00+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,045
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  29
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第8章统计模型的第1小节，这一部分的主要内容涉及降维分析的一些原理，例如SVD，投影，旋转等，相应的Rmarkdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/distance.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>距离(distance)的概念非常直接，例如，当我们把动物聚为亚群时，我们其实就是隐含地定义了一个距离，从而使我们可以说亚群内的动物彼此“接近”，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909115530.png" alt=""></p>
<p>我们使用的分析高通量数据的方法地都直接或间接地与距离有关。许多聚类方法和机器学习方法都需要使用特征值或预测因子来定义距离。例如热图是基因组学与高通量数据领域里使用最为广泛的工具，如果我们要生成热图，就需要明确计算距离，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130059.png" alt=""></p>
<p>在上面的热图中，每个方格代表的数值储存在一个矩阵里，每具方格的行与列被聚类后（注：热图常用红色与绿色表示，但是对色盲人士来说，这两种颜色是最难分辨的颜色）用不同的颜色表示。在这一部分中，我们将学习必要的数学知识与计算技能来了解和创建热图。我们先来回顾一下数学上对距离的定义。</p>
<h2 id="欧氏距离-Euclidean-Distance"><a href="#欧氏距离-Euclidean-Distance" class="headerlink" title="欧氏距离(Euclidean Distance)"></a>欧氏距离(Euclidean Distance)</h2><p>现在我们在一个笛卡尔坐标系(Cartesian plane)中定义A点与B点的距离，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>),pch=<span class="number">16</span>,cex=<span class="number">2</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,bty=<span class="string">"n"</span>,xlim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>),ylim=c(-<span class="number">0.25</span>,<span class="number">1.25</span>))</div><div class="line">lines(c(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>),c(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</div><div class="line">text(<span class="number">0</span>,<span class="number">.2</span>,expression(paste(<span class="string">'(A'</span>[x]*<span class="string">',A'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(<span class="number">1</span>,<span class="number">1.2</span>,expression(paste(<span class="string">'(B'</span>[x]*<span class="string">',B'</span>[y]*<span class="string">')'</span>)),cex=<span class="number">1.5</span>)</div><div class="line">text(-<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">"A"</span>,cex=<span class="number">2</span>)</div><div class="line">text(<span class="number">1.1</span>,<span class="number">1</span>,<span class="string">"B"</span>,cex=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909130731.jpeg" alt=""></p>
<p>其中，欧氏距离的定义如下所示：</p>
<script type="math/tex; mode=display">
\sqrt{ (A_x-B_x)^2 + (A_y-B_y)^2}</script><h2 id="高维数据的距离"><a href="#高维数据的距离" class="headerlink" title="高维数据的距离"></a>高维数据的距离</h2><p>现在我们使用一个数据集，这个数据集中含有189个样本，22215个基因，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(devtools)</div><div class="line"><span class="comment"># install_github("genomicsclass/tissuesGeneExpression")</span></div><div class="line"></div><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div></pre></td></tr></table></figure>
<p>这些数据代表了8个组织（每个组织中有多个样本）的RNA表达水平，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; dim(e) <span class="comment">##e contains the expression data</span></div><div class="line">[<span class="number">1</span>] <span class="number">22215</span>   <span class="number">189</span></div><div class="line">&gt; table(tissue) <span class="comment">##tissue[i] tells us what tissue is represented by e[,i]</span></div><div class="line">tissue</div><div class="line"> cerebellum       colon endometrium hippocampus      kidney       liver    placenta </div><div class="line">         <span class="number">38</span>          <span class="number">34</span>          <span class="number">15</span>          <span class="number">31</span>          <span class="number">39</span>          <span class="number">26</span>           <span class="number">6</span></div></pre></td></tr></table></figure>
<p>我们现在描述一下在这个数据集中，不同样本之间的距离。我们也许对在不同样本中表达相似的基因感兴趣。</p>
<p>为了定义这个距离，我们需要知道这些点是什么，因为我们计算数学上的距离需要这些点。由于这个数据集是高维数据集，这些点就无法直接放在笛卡尔坐标系中。相反，我们会把这个数据集放在更高维度的坐标系中。例如样本$i$是由22215维空间的一个点定义的（这个空间可以写为$(Y_{1,i},\dots,Y_{22215,i})^\top$）。特征值$g$是由一个189维空间的一个点定义的（这个空间可以写为$(Y_{g,1},\dots,Y_{g,189})^\top$）。</p>
<p>一旦我们定义好了这些点，那么欧氏距离就可以使用我们前面类似的方法进行计算，例如，两个样本$i$和$j$的距离为：</p>
<script type="math/tex; mode=display">
\mbox{dist}(i,j) = \sqrt{ \sum_{g=1}^{22215} (Y_{g,i}-Y_{g,j })^2 }</script><p>两个特征值$h$和$g$的距离为：</p>
<script type="math/tex; mode=display">
\mbox{dist}(h,g) = \sqrt{ \sum_{i=1}^{189} (Y_{h,i}-Y_{g,i})^2 }</script><h3 id="矩阵代数与距离"><a href="#矩阵代数与距离" class="headerlink" title="矩阵代数与距离"></a>矩阵代数与距离</h3><p>样本$i$和$j$之间的距离可以写为：</p>
<script type="math/tex; mode=display">
\mbox{dist}(i,j) = (\mathbf{Y}_i - \mathbf{Y}_j)^\top(\mathbf{Y}_i - \mathbf{Y}_j)</script><p>其中，$\mbox{Y}_{i}$和$\mbox{Y}_{j}$代表第$i$列和第$j$列。这种写法在实际计算中非常方便。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>现在我们使用上面的矩阵代数来计算一下距离。现在我们计算样本1与样本2（它们都是肾脏组织）的距离，然后再过计算样本87的距离（结肠），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x &lt;- e[,<span class="number">1</span>]</div><div class="line">y &lt;- e[,<span class="number">2</span>]</div><div class="line">z &lt;- e[,<span class="number">87</span>]</div><div class="line">sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt(sum((x-y)^<span class="number">2</span>)) <span class="comment"># Kindey</span></div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; sqrt(sum((x-z)^<span class="number">2</span>)) <span class="comment"># Colon</span></div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，肾脏组织之间距离比较近。另外一种计算距离更快的方式就是使用矩阵代数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqrt( crossprod(x-y) )</div><div class="line">sqrt( crossprod(x-z) )</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; sqrt( crossprod(x-y) )</div><div class="line">        [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">85.8546</span></div><div class="line">&gt; sqrt( crossprod(x-z) )</div><div class="line">         [,<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>,] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>现在我们一次计算出所有的距离，我们可以使用<code>dist()</code>函数，这个函数可以计算出每行之间的距离，现在我们感兴趣的是不同样本之间的相似性，因此我们需要使用<code>t()</code>来转换一下矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- dist(t(e))</div><div class="line">class(d)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- dist(t(e))</div><div class="line">&gt; class(d)</div><div class="line">[<span class="number">1</span>] <span class="string">"dist"</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，计算结果<code>d</code>是一个<code>dist</code>类，为了得到它的具体数值，我们需要将其强行转换为矩阵，并使用索引操作，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">85.8546</span></div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">87</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">122.8919</span></div></pre></td></tr></table></figure>
<p>这里我们需要注意的是，我们对数据集<code>e</code>使用了函数<code>dist()</code>，这个函数计算的是基因之间所有两两矩离，它最终会形成一个$22215\times 22215$的矩阵。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P322</p>
<h2 id="降维操作"><a href="#降维操作" class="headerlink" title="降维操作"></a>降维操作</h2><p>相应的Rmarkdown见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/pca_motivation.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>可视化数据是分析高通量数据中最重要的步骤之一。正确的可视化方法可能会发现实验数据的问题，这些数据可以呈现标准分析的结果。我们已经展示了可视化数据的全局方法，但是由于数据的高维特性，使得发现列之间或行之间关系的图形变得复杂。例如，如果要比较189个样本之间的特性，我们必不得不创建17766个MA图。创建一个单独的散点图明显不合适，因为数据量太大。</p>
<p>我们将介绍其于降维的探索性数据分析的强大技巧。一般的想法就是将数据集降至较低维度的同时又保留重要的特性，例如样本之间的距离。如果我们能够将数据降低到2维，那么我们就能很容易地画出图形。降维的背后就是奇异值分解(Singular value decomposition, SVD)，这种思路也可以应用于其他情况。在介绍SVD背后的复杂数学原理之前，我们将会使用一个简单的案例来介绍一下它的思路。</p>
<h3 id="案例：将2维数据降低至1维"><a href="#案例：将2维数据降低至1维" class="headerlink" title="案例：将2维数据降低至1维"></a>案例：将2维数据降低至1维</h3><p>现在我们来看一个案例，这个案例是有关双胞胎身高的。我们来模拟生成100个二维数据点，它们表示每个人与其均值的偏离的标准差的数目，每对数据点表示一对又胞胎，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">mypar()</div><div class="line">plot(y[<span class="number">1</span>,], y[<span class="number">2</span>,], xlab=<span class="string">"Twin 1 (standardized height)"</span>, </div><div class="line">     ylab=<span class="string">"Twin 2 (standardized height)"</span>, xlim=c(-<span class="number">3</span>,<span class="number">3</span>), ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>], y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>], col=<span class="number">2</span>, pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909151311.jpeg" alt=""></p>
<p>为了辅助说明问题，我们可以将上面的模拟数据视为高通量基因表达数据，其中双胞胎的配对数据表示了N个样本，双胞胎的2个身高表示基因表达数据。我们是对任意2个之间的距离感兴趣。我们可以使用<code>dist()</code>函数来进行计算。例如，上图的2个橙色数据点的距离为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d=dist(t(y))</div><div class="line">as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d=dist(t(y))</div><div class="line">&gt; as.matrix(d)[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">1.140897</span></div></pre></td></tr></table></figure>
<p>如果两维数据太复杂（这里只是假设），我们只想制备一维图，那怎么办呢？例如，我们能否将这些数据减化为一维矩阵，同时保留这些点与点之间的距离信息呢？</p>
<p>如果我们回顾再来看这张图，在任何一对数据点之间画一条线，那么这条线的长度就是这两点这之间的距离。这些线倾向于沿着对角线的方向分布。我们以前到过MA图，这种图就是将原始散点图的对角线“旋转”了一下，将原来的对角线旋转到与x轴平行的位置形成的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">z1 = (y[<span class="number">1</span>,]+y[<span class="number">2</span>,])/<span class="number">2</span> <span class="comment">#the sum</span></div><div class="line">z2 = (y[<span class="number">1</span>,]-y[<span class="number">2</span>,]) <span class="comment">#the difference</span></div><div class="line">z = rbind( z1, z2) <span class="comment">#matrix now same dimensions as y</span></div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized \</span></div><div class="line"><span class="string">height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece \</span></div><div class="line"><span class="string">in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909153046.jpeg" alt=""></p>
<p>上图的左图就是原始的散点图，右图则是MA图。</p>
<p>在后面章节中，我们将会使用线性代数来表示这些数据的变换（也就是旋转）。这里我们可以通过将<code>y</code>的相乘来得到<code>z</code>，如下所示：</p>
<script type="math/tex; mode=display">
A = \,
\begin{pmatrix}
1/2&1/2\\
1&-1\\
\end{pmatrix}
\implies 
z = A y</script><p> 我们将两侧都乘以$A^{-1}$，则得到z，如下所示：</p>
<script type="math/tex; mode=display">
A^{-1} = \,
\begin{pmatrix}
1&1/2\\
1&-1/2\\
\end{pmatrix}
\implies 
y = A^{-1} z</script><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>在上图相，相对于其它点之间的距离，两个橙色上炽之间的距离大致保持一致。所以的点其实都是如此。对上面转换进行简单的重新缩放，将会使前后的距离完全相同。我们要做的就是乘以一个标量，从而保留每个数据点的标准差。如果你认为<code>y</code>的列是一个独立随机变量，其标准差为$\sigma$，那么我们要注意到$M$与$A$的标准差如下所示：</p>
<script type="math/tex; mode=display">
\mbox{sd}[ Z_1 ] = \mbox{sd}[ (Y_1 + Y_2) / 2 ] = \frac{1}{\sqrt{2}} \sigma \mbox{ and } \mbox{sd}[ Z_2] = \mbox{sd}[ Y_1 - Y_2  ] = {\sqrt{2}} \sigma</script><p>这就说明，如果我们将上面的转换变为如下形式：</p>
<script type="math/tex; mode=display">
A = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1&1\\
1&-1\\
\end{pmatrix}</script><p>那么$Y$列的SD就会变得与$Z$列的方差一样。此外，我们要注意到，$A^{-1}A=I$。我们称这种特性为<code>正交</code>(orthogonal)，并且它保留了上述SD的特性。因此就保留了距离信息：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">A &lt;- <span class="number">1</span>/sqrt(<span class="number">2</span>)*matrix(c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z &lt;- A%*%y</div><div class="line">d &lt;- dist(t(y))</div><div class="line">d2 &lt;- dist(t(z))</div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d2)) <span class="comment">#as.numeric turns distnaces into long vector</span></div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154417.jpeg" alt=""></p>
<p>我们称这种转换为<code>y</code>的旋转：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">thelim &lt;- c(-<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=thelim,ylim=thelim)</div><div class="line">points(y[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],y[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlim=thelim,ylim=thelim,xlab=<span class="string">"Average height"</span>,ylab=<span class="string">"Differnece in height"</span>)</div><div class="line">points(z[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>],z[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>],col=<span class="number">2</span>,pch=<span class="number">16</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909154529.jpeg" alt=""></p>
<p>我们之所以优先使用这种转换，是因为我们注意到所有的点是沿着对角线进行分布的，我们将对角线进行转换后，对角线与x轴平行。所以这个旋转实际上就达到了我们最初的要求：我们只需要一个维度就可以保留点与点之间的距离。现在让我们删除了第二个维度<code>z</code>，并重新计算一下距离：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d3 = dist(z[<span class="number">1</span>,]) <span class="comment">##distance computed using just first dimension</span></div><div class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(as.numeric(d),as.numeric(d3))</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909155706.jpeg" alt=""></p>
<p>仅用一维数据进行的距离计算就很接近实际距离，并且降低了维度，将2维降低到了1维。转换后的数据的第1约就是第一主成分。这一思想促进了使用主成分分析(PCA)和奇异值分解(SVD)来实现更广泛的降维。</p>
<h3 id="关于与其他解释区别的重要说明"><a href="#关于与其他解释区别的重要说明" class="headerlink" title="关于与其他解释区别的重要说明"></a>关于与其他解释区别的重要说明</h3><p>如果你在网上搜索PCA的描述，你会注意到网上的描述与我们这里描述在符号上有些出入。这主要是因为在PCA中，通常使用行来表示实验单元（就是样本）。因此，在我们这里的实验中，$Y$通常会被转换为$N \times 2$矩阵。在统计学中，这也是最为普遍的表示数据的方式：每行表示一个样本。然而，由于实际原因，在遗传学中，通常使用列表示样本。例如行表示基因，列表示样本。由于这个原因，在这本书中，我们会解释PCA和与之相应的数学计算会与常规的方式有所不同。因此，在网上找到的相关的许多PCA的解释都是先从样本的协方差矩阵开始的，它通常使用$\mathbf{X}^\top\mathbf{X}$表示，并且每个单元格表示两个实验单元之间的协方差。然而，要做到这一点，我们需要使用$\mbox{X}$的行表示实验单元。因此，在我们上面的符号中，在经过缩放后，你必须要使用$\mathbf{Y}\mathbf{Y}^\top$来进行计算。总之，如果你想让我们的解释与其他有关的PCA内容相符，就必须对这本书中使用的矩阵进行转置。</p>
<h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>相关的Rmarkdown参考作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/svd.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>在前面的部分中，我们展示了降维分析，以及如何让我们使用一维数据来替代原来的二维数据，近似地表示点与点之间的距离。奇异值分解(SVD)是我们这种方法的推广。在这个案例中，SVD对原始数据进行了转换。这种转换具有一些非常有用的属性。 </p>
<p>SVD计算的主要结果就是，我们可以写为一个$m\times n$矩阵，对于矩阵$\mbox{Y}$就写为：</p>
<script type="math/tex; mode=display">
\mathbf{U}^\top\mathbf{Y} = \mathbf{DV}^\top</script><p>其中，</p>
<ul>
<li>$\mathbf{U}$ 是一个 $m \times p$ 正交矩阵；</li>
<li>$\mathbf{V}$ 是一个 $p \times p$ 正交矩阵；</li>
<li>$\mathbf{D}$ 是一个 $n \times p$ 对角矩阵。</li>
</ul>
<p>其中，$p=\mbox{min}(m,n)$，$\mathbf{U}^\top$对数据$\mathbf{Y}$进行旋转，这一步非常有用，因为$\mathbf{U}^\top \mathbf{Y}=\mathbf{VD}$列的变异（精确的平方和）会下降。因此$\mathbf{U}$是正交辞职，我们可以将SVD写为如下形式：</p>
<script type="math/tex; mode=display">
\mathbf{Y} = \mathbf{UDV}^\top</script><p>实际上这个公式更加普遍，我们也可以将转换写为如下形式：</p>
<script type="math/tex; mode=display">
\mathbf{YV} = \mathbf{UD}</script><p>$Y$的这种转换也会生成一个矩阵，这个矩阵的列的乘方和是递减的。</p>
<p>将SVD应用到我们的案例中，就是如下结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n &lt;- <span class="number">100</span></div><div class="line">y &lt;- t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>), matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">s &lt;- svd(y)</div></pre></td></tr></table></figure>
<p>我们可以马上就是看到使用了SVD后生成的转换后的矩阵非常类似于我们前面的案例中的结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; round(sqrt(<span class="number">2</span>) * s$u , <span class="number">3</span>)</div><div class="line">       [,<span class="number">1</span>]   [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,] -<span class="number">0.982</span> -<span class="number">1.017</span></div><div class="line">[<span class="number">2</span>,] -<span class="number">1.017</span>  <span class="number">0.982</span></div></pre></td></tr></table></figure>
<p>当我们旋转后，绘制成的图形称为主成分(principal coimponent)：这里只绘制出了第一个主成分和第二个主成分。如果我们想要从SVD中获取主成分，只需要旋转后的$\mathbf{U}^\top\mathbf{Y}$ 即可：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PC1 = s$d[<span class="number">1</span>]*s$v[,<span class="number">1</span>]</div><div class="line">PC2 = s$d[<span class="number">2</span>]*s$v[,<span class="number">2</span>]</div><div class="line">plot(PC1,PC2,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173315.jpeg" alt=""></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>使用SVD的用途并不十分明显，我们可以看一些案例。在这个案例中，我们将会极大地降低$V$的组倒数，并且仍然能够构建$Y$。</p>
<p>现在我们来对基因表达谱进行SVD的计算，我们可以只使用表达谱中的100个基因的子集，这样计算会快一点，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tissuesGeneExpression)</div><div class="line">data(tissuesGeneExpression)</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">ind &lt;- sample(nrow(e),<span class="number">500</span>)</div><div class="line">Y &lt;- t(apply(e[ind,],<span class="number">1</span>,scale)) <span class="comment">#standardize data for illustration</span></div></pre></td></tr></table></figure>
<p>使用<code>svd()</code>函数可以返回3个矩阵（D矩阵仅返回对角线元素），如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s &lt;- svd(Y)</div><div class="line">U &lt;- s$u</div><div class="line">V &lt;- s$v</div><div class="line">D &lt;- diag(s$d) <span class="comment">##turn it into a matrix</span></div></pre></td></tr></table></figure>
<p>我们首选要注意到，我们可以重构$y$：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Yhat &lt;- U %*% D %*% t(V)</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>如果我们看一下$\mathbf{UD}$的平方和，我们会看到最后几个非常接近于0（也许我们会有一些重复的列）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909173946.jpeg" alt=""></p>
<p>这意味着$V$的最后一列对于$Y$的重建非常小。为了说明这一点，我们可以考虑$V$最后一项为0的这种极端情况。在这个案例中，$V$的最后一列根本用不到。由于SVD的这种创建方式，$V$的列对$Y$的重建影响越来越小。我们通常认为这种描述为“解释了较少的变异”。这就意味着，对于一个大型矩阵，当你到达最后一列时，可能已经没有太多需要“解释”的内容了。例如，当我们把最后4列删除，看一下计算结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- ncol(U)-<span class="number">4</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">max(abs(resid))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; max(abs(resid))</div><div class="line">[<span class="number">1</span>] <span class="number">3.552714e-14</span></div></pre></td></tr></table></figure>
<p>最大的残差基本上就等于0了，就意味着<code>Yhat</code>实际上是与<code>Y</code>一样，但是，我们至少需要4个维度来传输信息。</p>
<p>通过查看$d$，我们可以看到，在这个特定的数据集中，我们能得到一个很好的近似值，它只保留了94列。在下面的图形中，我们可以看到每列能解释的变异程度是多少：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(s$d^<span class="number">2</span>/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909174959.jpeg" alt=""></p>
<p>还可以看一下累积曲线，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plot(cumsum(s$d^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)*<span class="number">100</span>,ylab=<span class="string">"Percent variability explained"</span>,ylim=c(<span class="number">0</span>,\</div><div class="line"><span class="number">100</span>),type=<span class="string">"l"</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175047.jpeg" alt=""></p>
<p>虽然刚开始的时候，我们的数据是189维，但是我们可以使用95维来近似表示$Y$，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">k &lt;- <span class="number">95</span> <span class="comment">##out a possible 189</span></div><div class="line">Yhat &lt;- U[,<span class="number">1</span>:k] %*% D[<span class="number">1</span>:k,<span class="number">1</span>:k] %*% t(V[,<span class="number">1</span>:k])</div><div class="line">resid &lt;- Y - Yhat</div><div class="line">boxplot(resid,ylim=quantile(Y,c(<span class="number">0.01</span>,<span class="number">0.99</span>)),range=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190909175150.jpeg" alt=""></p>
<p>因此， 我们只使用了一半的维度就保留了原始数据中的大部分的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var(as.vector(resid))/var(as.vector(Y))</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; var(as.vector(resid))/var(as.vector(Y))</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>这个计算结果说明，我们使用了降维后的数据解释了原始95%的变异，我们需要注意的是，我们是通过$D$来计算的这个比例，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">1</span>-sum(s$d[<span class="number">1</span>:k]^<span class="number">2</span>)/sum(s$d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.04076899</span></div></pre></td></tr></table></figure>
<p>因此，$D$中的元素可以告诉我们每个PC在解释变异方面所贡献的程度大小。</p>
<h3 id="高度相关数据"><a href="#高度相关数据" class="headerlink" title="高度相关数据"></a>高度相关数据</h3><p>为了辅助理解SVD是如何工作的，我们使用两组高度相关的列来构建一个数据集，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">2</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- cbind(x,x)+e</div><div class="line">cor(Y)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; cor(Y)</div><div class="line">          x         x</div><div class="line">x <span class="number">1.0000000</span> <span class="number">0.9998873</span></div><div class="line">x <span class="number">0.9998873</span> <span class="number">1.0000000</span></div></pre></td></tr></table></figure>
<p>在这个案例中，第2列添加了很少的“信息”，因此所有的<code>Y[,1]-Y[,2]</code>都接近于0。使用<code>rowMeans(Y)</code>计算更加有效，这是因为<code>Y[,1]-rowMeans(Y)</code>和<code>Y[,2]-rowMeans(Y)</code>更接近于0。<code>rowMenas(Y)</code>最终生成的结果在$U$的第1列中。SVD的计算结果表明，仅使用第1列就能解释大多数的变异：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; d &lt;- svd(Y)$d</div><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999441</span></div></pre></td></tr></table></figure>
<p>在这个案例中，许多列的数据高度相关，我们可以进行更大程度的降维操作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">m &lt;- <span class="number">100</span></div><div class="line">n &lt;- <span class="number">25</span></div><div class="line">x &lt;- rnorm(m)</div><div class="line">e &lt;- rnorm(n*m,<span class="number">0</span>,<span class="number">0.01</span>)</div><div class="line">Y &lt;- replicate(n,x)+e</div><div class="line">d &lt;- svd(Y)$d</div><div class="line">d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; d[<span class="number">1</span>]^<span class="number">2</span>/sum(d^<span class="number">2</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">0.9999065</span></div></pre></td></tr></table></figure>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>P338</p>
<h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>原始Rmarkdown文档参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/projections.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>前面我们已经详细地描述了降维的概念，以及SVD和主成分分析的内容，现在我们来谈一下它们背后的数学原理。我们先从投影(projection)开始讲起。投影是一个线性代数的概念，它能帮助我们理解许多关于高通量数据的许多数学操作。如果想要了解更多相关的知识，可以找本线性代数的书来看一下有关投影的内容。在这一部分里，我们会提供一个快速的回顾，然后提供一些数据分析的相关案例。</p>
<p>作为回顾，我们需要注意的是，投影就是点与其子空间之间的距离，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910145026.png" alt=""></p>
<p>在上图中，顶部的点指向空间中的一点。在上图的这个卡通图中，空间是二维的，但是我们可以更加抽象地思考一下。这个空间由笛卡尔平面表示，小人站的这条线是点的一个子空间。将点投影到这个子空间上所对应的位置，就是这个子空间上这个位置距离原点最近的点。几何学告诉我们，我们可以通过从点到子空间一条垂线（虚线）来找到子空间上的这点。小人站在这个子空间上，这个人从原点走到投影点的位置时，就是这个点投影到子空间后的坐标。</p>
<p>为了扩展投影的概念，我们可以使用标准矩阵线性符号来说明这个点， $\vec{y} \in \mathbb{R}^N$是一个N维空间的点，$L \subset \mathbb{R}^N$是一个更小的子空间。</p>
<h3 id="案例：当N-2"><a href="#案例：当N-2" class="headerlink" title="案例：当N=2"></a>案例：当N=2</h3><p>先看一个案例，$Y = \begin{pmatrix} 2 \\ 3\end{pmatrix}$，我们可以画出这个向量的图形：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar (<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">plot(c(<span class="number">0</span>,<span class="number">4</span>),c(<span class="number">0</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910151328.jpeg" alt=""></p>
<p>我们可以马上定义一个坐标系统，将这个向量投影到空间中：$\begin{pmatrix} 1\\ 0\end{pmatrix}$ （x轴）和 $\begin{pmatrix} 0\\ 1\end{pmatrix}$ （y轴）。 $Y$ 向子空间的投影可以通过点2和3分别进行定义：</p>
<script type="math/tex; mode=display">
\begin{align*}
Y &= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&=2  \begin{pmatrix} 1\\ 0\end{pmatrix} + 3 \begin{pmatrix} 0\\ 1\end{pmatrix} 
\end{align*}</script><p>我们可以说 $2$ 和$3$是向量$Y$的坐标，$\begin{pmatrix} 1\\ 0\end{pmatrix} \mbox{and} \begin{pmatrix} 0\\1 \end{pmatrix}$ 是它的基。</p>
<p>现在我们定义一个新的子空间。红线（后面我们会画出这个图形）是一个子集(subset)$L$，它由满足 $c \vec{v}$ with $\vec{v}=\begin{pmatrix} 2&amp; 1\end{pmatrix}^\top$的点构成。那么 $\vec{y}$ 在$L$上的投影就是$L$上最接近于 $\vec{y}$ 的点。因此我们需要找一个向量$c$，它是位于 $\vec{y}$ 和$c\vec{v}=(2c,c)$之间最小的距离。从线性代数的知识我们可知，这些点之间的距离正交于空间：</p>
<script type="math/tex; mode=display">
(\vec{y}-\hat{c}\vec{v}) \cdot \vec{v} = 0</script><p>上面公式也可以写为：</p>
<script type="math/tex; mode=display">
\vec{y}\cdot\vec{v} - \hat{c}\vec{v}\cdot\vec{v} =  0</script><p>即：</p>
<script type="math/tex; mode=display">
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}</script><script type="math/tex; mode=display">\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}</script><p>这里我们使用点号 $\cdot$ 来表示点积(dot product): $\,\, \vec{x} \cdot \vec{y} = x_1 y_1+\dots x_n y_n$.</p>
<p>下面我们使用R来演示一下上面的案例：</p>
<figure class="highlight plain"><figcaption><span>projection, fig.cap</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mypar(1,1)</div><div class="line">plot(c(0,4),c(0,4),xlab=&quot;Dimension 1&quot;,ylab=&quot;Dimension 2&quot;,type=&quot;n&quot;)</div><div class="line">arrows(0,0,2,3,lwd=3)</div><div class="line">abline(0,0.5,col=&quot;red&quot;,lwd=3) #if x=2c and y=c then slope is 0.5 (y=0.5x)</div><div class="line">text(2,3,&quot; Y&quot;,pos=4,cex=3)</div><div class="line">y=c(2,3)</div><div class="line">x=c(2,1)</div><div class="line">cc = crossprod(x,y)/crossprod(x)</div><div class="line">segments(x[1]*cc,x[2]*cc,y[1],y[2],lty=2)</div><div class="line">text(x[1]*cc,x[2]*cc,expression(hat(Y)),pos=4,cex=3)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910153202.jpeg" alt=""></p>
<p>我们需要注意的是，如果 $\vec{v}$ 满足 $\vec{v}\cdot \vec{v}=1$, 那么$\hat{c}$ 就是 $\vec{y} \cdot \vec{v}$ ，空间 $L$并没有发生改变，这处简化担任就是我们喜欢正交矩阵的一个原因。</p>
<h3 id="案例：样本均值就是投影"><a href="#案例：样本均值就是投影" class="headerlink" title="案例：样本均值就是投影"></a>案例：样本均值就是投影</h3><p>设 $\vec{y} \in \mathbb{R}^N$ ，$L \subset \mathbb{R}^N$ 被以下向量张成： </p>
<script type="math/tex; mode=display">
\vec{v}=\begin{pmatrix} 1\\ \vdots \\  1\end{pmatrix};
L = \{ c \vec{v}; c \in \mathbb{R}\}</script><p>在这个空间里，向量的分量(components）都是相同的数目，因此我们可以把这个空间看作为常数：在投影中，每个维度都是相同的值。那么$c$如何才能使得 $c\vec{v}$ 与 $\vec{y}$ 之间的距离最小呢？</p>
<p>当我们谈到这个问题时，我们会使用前面的二维图形。我们可以简单地抽象将$\vec{y}$视为N维空间上的一个点，将$L$视为一个更小数目的子空间，在这个案例中就是$c$。</p>
<p>回到我们的问题，我们知道，投影就是：</p>
<script type="math/tex; mode=display">\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}}</script><p>在这个案例中它就是平均值：</p>
<script type="math/tex; mode=display">
\hat{c} = \frac{\vec{y}\cdot\vec{v}}
{\vec{v}\cdot\vec{v}} = \frac{\sum_{i=1}^N Y_i}{\sum_{i=1}^N 1} = \bar{Y}</script><p>在这个案例中，它也非常容易使用微积分进行计算：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial c}\sum_{i=1}^N (Y_i - c)^2 = 0 \implies 2 \sum_{i=1}^N (Y_i - \hat{c}) = 0 \implies</script><script type="math/tex; mode=display">
N c = \sum_{i=1}^N Y_i \implies \hat{c}=\bar{Y
}</script><h3 id="案例：回归也是一种投影"><a href="#案例：回归也是一种投影" class="headerlink" title="案例：回归也是一种投影"></a>案例：回归也是一种投影</h3><p>现在来看一下略微复杂的案例。简单线性回归也能用投影来解释。我们的数据 $\mathbf{Y}$（这里我们不再使用$\vec{y}$符号）是一个N维向量，我们使用一个线性方程$\beta_0 + \beta_1 X_i$来预测$Y_i$ 。此时我要找到能够使$Y$和由以下向量定义的空间的最小距离时的 $\beta_0$ 和 $\beta_1$ ，其中：</p>
<script type="math/tex; mode=display">
\vec{v}_0=
\begin{pmatrix}
1\\
1\\
\vdots \\
1\\
\end{pmatrix} 
\mbox{ and }
\vec{v}_1=
\begin{pmatrix}
X_{1}\\
X_{2}\\
\vdots \\
X_{N}\\
\end{pmatrix}</script><p>我们的 $N\times 2$ 矩阵 $\mathbf{X}$ 是 $[ \vec{v}_0 \,\, \vec{v}_1]$ ，$L$中的任何点都可以被写为 $X\vec{\beta}$. </p>
<p>正交投影的多维形式的方程为：</p>
<script type="math/tex; mode=display">
X^\top (\vec{y}-X\vec{\beta}) = 0</script><p>我们在之前看到过种形式：</p>
<script type="math/tex; mode=display">
X^\top X \hat{\beta}=  X^\top \vec{y}</script><script type="math/tex; mode=display">
\hat{\beta}= (X^\top X)^{-1}X^\top \vec{y}</script><p>它向$L$的投影就是：</p>
<script type="math/tex; mode=display">
X (X^\top X)^{-1}X^\top \vec{y}</script><h2 id="旋转-1"><a href="#旋转-1" class="headerlink" title="旋转"></a>旋转</h2><p>相关的Rmarkdown参见作者的<a href="https://github.com/genomicsclass/labs/blob/master/highdim/rotations.Rmd" target="_blank" rel="external">Github</a>。</p>
<p>与投影相关的一个最常见的应用就是坐标旋转(coordinate rotations)。在数据分析中，简单的旋转可以很好地对数据进行可视化和解释。我们将会介绍旋转背后的数学原理，并且给出一些简单的数据分析案例。</p>
<p>前面我们使用了下面的例子：</p>
<script type="math/tex; mode=display">
Y = \begin{pmatrix} 2 \\ 
3 
\end{pmatrix} 
= 
2  
\begin{pmatrix} 1\\
0 
\end{pmatrix} + 
3 
\begin{pmatrix} 0\\ 
1 
\end{pmatrix}</script><p>我们注意到，$Y$的坐标是$(2,3)$，现在我们使用如下的代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">segments(<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">segments(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910165242.jpeg" alt=""></p>
<p>但是，我们可以用其它的一些线性组合来表示点$(2,3)$：</p>
<script type="math/tex; mode=display">
\begin{align*}
Y &= \begin{pmatrix} 2 \\ 3\end{pmatrix} \\
&= 2.5 \begin{pmatrix} 1\\ 1\end{pmatrix} + -1 \begin{pmatrix} \phantom{-}0.5\\ -0.5\end{pmatrix} 
\end{align*}</script><p>新的坐标就是：</p>
<script type="math/tex; mode=display">
Z = \begin{pmatrix} 2.5 \\ -1 \end{pmatrix}</script><p>从图形上我们可以看出来，这个坐标就是我们由新的基定义的空间的投影</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">plot(c(-<span class="number">2</span>,<span class="number">4</span>),c(-<span class="number">2</span>,<span class="number">4</span>),xlab=<span class="string">"Dimension 1"</span>,ylab=<span class="string">"Dimension 2"</span>,type=<span class="string">"n"</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,bty=<span class="string">"n"</span>)</div><div class="line">text(rep(<span class="number">0</span>,<span class="number">6</span>),c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">2</span>)</div><div class="line">text(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>)),rep(<span class="number">0</span>,<span class="number">6</span>),as.character(c(c(-<span class="number">2</span>,-<span class="number">1</span>),c(<span class="number">1</span>:<span class="number">4</span>))),pos=<span class="number">1</span>)</div><div class="line">abline(v=<span class="number">0</span>,h=<span class="number">0</span>)</div><div class="line">abline(<span class="number">0</span>,<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">abline(<span class="number">0</span>,-<span class="number">1</span>,col=<span class="string">"red"</span>)</div><div class="line">arrows(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,lwd=<span class="number">3</span>)</div><div class="line">y=c(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">x1=c(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">##new basis</span></div><div class="line">x2=c(<span class="number">0.5</span>,-<span class="number">0.5</span>)<span class="comment">##new basis</span></div><div class="line">c1 = crossprod(x1,y)/crossprod(x1)</div><div class="line">c2 = crossprod(x2,y)/crossprod(x2)</div><div class="line">segments(x1[<span class="number">1</span>]*c1,x1[<span class="number">2</span>]*c1,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">segments(x2[<span class="number">1</span>]*c2,x2[<span class="number">2</span>]*c2,y[<span class="number">1</span>],y[<span class="number">2</span>],lty=<span class="number">2</span>)</div><div class="line">text(<span class="number">2</span>,<span class="number">3</span>,<span class="string">" Y"</span>,pos=<span class="number">4</span>,cex=<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233102.jpeg" alt=""></p>
<p>我们可以使用矩阵乘法在表示$(2,3)$的这两个坐标中进行转换：</p>
<script type="math/tex; mode=display">
Y =   AZ\\</script><script type="math/tex; mode=display">
 A^{-1} Y =  Z\\</script><script type="math/tex; mode=display">
A= \begin{pmatrix} 1& \phantom{-}0.5\\ 1 & -0.5\end{pmatrix} \implies 
A^{-1}= \begin{pmatrix} 0.5& 0.5 \\ 1 &-1\end{pmatrix}</script><p>其中，$Z$和$Y$表示了相同的信息，但是它们位于不同的坐标系中。</p>
<h3 id="案例：双胞胎身高"><a href="#案例：双胞胎身高" class="headerlink" title="案例：双胞胎身高"></a>案例：双胞胎身高</h3><p>我们先来看100个二维数据点$Y$，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(MASS)</div><div class="line">n = <span class="number">100</span></div><div class="line">mypar()</div><div class="line">set.seed(<span class="number">1</span>)</div><div class="line">y=t(mvrnorm(n,c(<span class="number">0</span>,<span class="number">0</span>),matrix(c(<span class="number">1</span>,<span class="number">0.95</span>,<span class="number">0.95</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)))</div><div class="line">plot(y[<span class="number">1</span>,],y[<span class="number">2</span>,],xlab=<span class="string">"Twin 1 (standardized height)"</span>,ylab=<span class="string">"Twin 2 (standardized height)"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233353.jpeg" alt=""></p>
<p>这里就使用了旋转：$Z = A^{-1} Y$，图形如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A = matrix(c(<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>,-<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">z = A%*%y</div><div class="line">mypar()</div><div class="line">plot(z[<span class="number">1</span>,],z[<span class="number">2</span>,],xlab=<span class="string">"Average"</span>,ylab=<span class="string">"Difference"</span>,xlim=c(-<span class="number">3</span>,<span class="number">3</span>),ylim=c(-<span class="number">3</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190910233448.jpeg" alt=""></p>
<p>我们在这里进行的操作就是对数据进行旋转，从而使行新的坐标系$Z$的第一维是平均身高（就是相当于x轴），崦第二维则是两个双胞胎身高的差值（y轴）。</p>
<p>我们已经使用了奇异值分解计算主成分。有时候将SVD视为应动力非常有用，例如 $\mathbf{U}^\top \mathbf{Y}$ 就会构建出一个新的坐标系 $\mathbf{DV}^\top$ ，在这个新的坐标系中，它们的维度按照维度能够解释变异的程序进行排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2019/08/19/Data Analysis for the life sciences/DALS019_StatisticalModels2_Beyes_Hierarchical/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/Data Analysis for the life sciences/DALS019_StatisticalModels2_Beyes_Hierarchical/" itemprop="url">DALS019-统计模型2-贝叶斯分布与层次分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T12:00:00+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Analysis-for-the-life-sciences/" itemprop="url" rel="index">
                    <span itemprop="name">Data Analysis for the life sciences</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,732
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一部分是《Data Analysis for the life sciences》的第7章统计模型的第2小节，这一部分的主要内容涉及贝叶斯统计的一些原理。相应的R markdown文档可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/modeling/bayes.Rmd" target="_blank" rel="external">Github</a>，另外，如果想补充一些贝叶斯的相关知识，可以参考这本书《统计学关我什么事：生活中的极简统计学》，这是一本有关贝叶斯统计的科普书，公式不多。</p>
<h2 id="贝叶斯统计"><a href="#贝叶斯统计" class="headerlink" title="贝叶斯统计"></a>贝叶斯统计</h2><p>高通量数据的一个明显特点就是，虽然我们最终会报道一些特定的基因，但是我们还会观察到许多相关的结果。例如，我们检测会数千个基因或者是代表了蛋白结合位点的数千个峰图，或者是一些CpGs的甲基化水平。但是，我们这里使用的多数统计推断方法都是独立地处理每个特征值，并且几乎忽略了来自其它特征的数据。在这一部分里，我们将会了解到，如何通过对特征值的联合建模来进行统计。这里方法中使用最为广泛的就是层次模型(hierachical models)，我们会在后面的贝叶斯统计中进行解释。</p>
<h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><p>先来看一个案例，如果我们有一种检测手段来检测囊性纤维化(cystic fibrosis)。假设这个检测手段的精确程度为99%，我们可以使用下面的公式来表示：</p>
<script type="math/tex; mode=display">
\mbox{Prob}(+ \mid D=1)=0.99, \mbox{Prob}(- \mid D=0)=0.99</script><p>其中，$+$表示阳性结果，$D$表示检测的结果，其中$1$表示得病，，$0$表示不得病。</p>
<p>现在我们随机选择一个人进行检测，结果如果是阳性，那么这个人患病的概率是多大？也就是说要计算$\mbox{Prb}(D=1|+)$的结果。囊性纤维化的发病率是每1/3900，也就是说，$\mbox{Prob}(D=1|+)=0.0025$，为了计算出这个人患病的概率，我们就会使用到贝叶斯定理，贝叶斯定理公式如下所示：</p>
<script type="math/tex; mode=display">
\mbox{Pr}(A \mid B)  =  \frac{\mbox{Pr}(B \mid A)\mbox{Pr}(A)}{\mbox{Pr}(B)}</script><p>这个公式就可以应用到我们的案例中，如下所示：</p>
<script type="math/tex; mode=display">
\begin{align*}
\mbox{Prob}(D=1 \mid +) & =  \frac{ P(+ \mid D=1) \cdot P(D=1)} {\mbox{Prob}(+)} \\
& =  \frac{\mbox{Prob}(+ \mid D=1)\cdot P(D=1)} {\mbox{Prob}(+ \mid D=1) \cdot P(D=1) + \mbox{Prob}(+ \mid D=0) \mbox{Prob}( D=0)} 
\end{align*}</script><p>换成实际数字，则如下所示：</p>
<script type="math/tex; mode=display">
\frac{0.99 \cdot 0.00025}{0.99 \cdot 0.00025 + 0.01 \cdot (.99975)}  =  0.02</script><p>也就是说，虽然这种检测手段有99%的精度，但是一个人的检测结果如果是阳性，那么这个人得病的概率只有0.02。这似乎有点反直觉。其原因就是，我们必须要考虑，当我们随机选择一个人时，这个人患上这种疾病时非常罕见的可能性。为了说明这一个，我们随便使用Monte Carlo模拟来计算一下。</p>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>下面的模拟旨在帮助你能够以可视化的形式来理解贝叶斯定理。我们首选从一个总体中随机选择1500人，其中患病的概率是5%，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">3</span>)</div><div class="line">prev &lt;- <span class="number">1</span>/<span class="number">20</span></div><div class="line"><span class="comment">##Later, we are arranging 1000 people in 80 rows and 20 columns</span></div><div class="line">M &lt;- <span class="number">50</span> ; N &lt;- <span class="number">30</span></div><div class="line"><span class="comment">##do they have the disease?</span></div><div class="line">d&lt;-rbinom(N*M,<span class="number">1</span>,p=prev)</div></pre></td></tr></table></figure>
<p>现在进行一项检测，这个检测的准确率是90%，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">accuracy &lt;- <span class="number">0.9</span></div><div class="line">test &lt;- rep(<span class="literal">NA</span>,N*M)</div><div class="line"><span class="comment">##do controls test positive?</span></div><div class="line">test[d==<span class="number">1</span>] &lt;- rbinom(sum(d==<span class="number">1</span>), <span class="number">1</span>, p=accuracy)</div><div class="line"><span class="comment">##do cases test positive?</span></div><div class="line">test[d==<span class="number">0</span>] &lt;- rbinom(sum(d==<span class="number">0</span>), <span class="number">1</span>, p=<span class="number">1</span>-accuracy)</div></pre></td></tr></table></figure>
<p>由于没有患病的人数要远远超过患病的人数，即使存在着极低的假阳性率，那么在检测为阳性的结果中，不患病人的也要多于患病的人，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">cols &lt;- c(<span class="string">"grey"</span>,<span class="string">"red"</span>)</div><div class="line">people &lt;- expand.grid(<span class="number">1</span>:M,N:<span class="number">1</span>)</div><div class="line">allcols &lt;- cols[d+<span class="number">1</span>] <span class="comment">##Cases will be red</span></div><div class="line">positivecols &lt;- allcols</div><div class="line">positivecols[test==<span class="number">0</span>] &lt;- <span class="literal">NA</span> <span class="comment">##remove non-positives</span></div><div class="line">negativecols &lt;- allcols</div><div class="line">negativecols[test==<span class="number">1</span>] &lt;- <span class="literal">NA</span> <span class="comment">##remove non-positives</span></div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar()</div><div class="line">layout(matrix(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>),<span class="number">2</span>,<span class="number">2</span>),width=c(<span class="number">0.35</span>,<span class="number">0.65</span>))</div><div class="line"><span class="comment">###plot of all people</span></div><div class="line">plot(people,col=allcols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste0(<span class="string">"Population: "</span>,round(mean(d)*<span class="number">100</span>),<span class="string">"% are red"</span>))</div><div class="line">plot(people,col=positivecols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste(<span class="string">"Tested Positive:"</span>,round(mean(d[test==<span class="number">1</span>])*<span class="number">100</span>),<span class="string">"% are red"</span>))</div><div class="line">plot(people,col=negativecols,pch=<span class="number">16</span>,xaxt=<span class="string">"n"</span>,yaxt=<span class="string">"n"</span>,xlab=<span class="string">""</span>,ylab=<span class="string">""</span>,</div><div class="line">     main=paste(<span class="string">"Tested Negative:"</span>,round(mean(d[test==<span class="number">0</span>])*<span class="number">100</span>,<span class="number">1</span>),<span class="string">"% are red"</span>))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908153222.jpeg" alt=""></p>
<p>现在解释一下上面的图：</p>
<p>顶图：红点表示患者。每个人接受检测的话，有90%的可能性结果是准确的。即$\mbox{Pr}(D=1)$；</p>
<p>下左图：检测结果为阳性（无论结果对不对，这里面含有真阳性与假阳性）的人，即$\mbox{Pr}(D=1|+)$</p>
<p>下右图：检测结果为阴性的人，即$\mbox{Pr}(D=0|+)$</p>
<h3 id="贝叶斯的实际运用"><a href="#贝叶斯的实际运用" class="headerlink" title="贝叶斯的实际运用"></a>贝叶斯的实际运用</h3><p>José Iglesias是一名职业棒球运行员，在2013年4月份，他开始了职业生成，他表表现得很好，成绩如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Month</th>
<th>At Bats</th>
<th>H</th>
<th>AVG</th>
</tr>
</thead>
<tbody>
<tr>
<td>April</td>
<td>20</td>
<td>9</td>
<td>.450</td>
</tr>
</tbody>
</table>
</div>
<p>平均击球率(battingaverage, AVG)统计是一种检测成功的方式。粗略地说，这个指标是告诉我们击球时的成功情况。<code>AVG=0.450</code>就表明，这个运动员在他击球的时间内（对应上面的<code>At Bats</code>）成功了45%，这是一个非常高的水平。为什么水平高呢，因为自1941年Ted Williams的<code>AVG=0.400</code>以来，还没有人能超过这个水平。为了说明层次模型的强大功能，我们将会在后面对Jose的数据进行预测。</p>
<p>在本书的前面部分到此为止，我们所到到的统计学技术可以被称为频率学派技术(frequentist techniques)，使用这种知识做出的结论就是能计算出一个置信区间。我们可以把击打(hitting)这个事件看作是一个二元结果，其成功的概论为$p$。因此，如果成功率是0.450的话，那么击球次数是20次时，标准误为：</p>
<script type="math/tex; mode=display">
\sqrt{\frac{.450 (1-.450)}{20}}=.111</script><p>也就是说，我们计算出的置信区间为<code>.450-.222</code> to <code>.450+.222</code>或<code>.228</code> to <code>.672</code>。</p>
<p>使用这种手段进行预测存在着两个问题。第一，实际用处不大。第二，成功率在0.450之间波动，也就是说这个人打破了Ted William的纪录。如果你自己关注棒球运动的话，打破Ted William纪录这种描述似乎是有问题，这是因为你隐含地使用了一个层次模型，这个模型会影响后面几年棒球的信息。在这里，我们对这种直觉进行量化。</p>
<p>首选，我们来研究一下前三个赛季里所有超过500次击打(at bats)的运动员的击球率的分布情况：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">tmpfile &lt;- tempfile()</div><div class="line">tmpdir &lt;- tempdir()</div><div class="line">download.file(<span class="string">"http://seanlahman.com/files/database/lahman-csv_2014-02-14.zip"</span>,tmpfile)</div><div class="line"><span class="comment">##this shows us files</span></div><div class="line">filenames &lt;- unzip(tmpfile,list=<span class="literal">TRUE</span>)</div><div class="line">players &lt;- read.csv(unzip(tmpfile,files=<span class="string">"Batting.csv"</span>,exdir=tmpdir),as.is=<span class="literal">TRUE</span>)</div><div class="line">unlink(tmpdir)</div><div class="line">file.remove(tmpfile)</div><div class="line"></div><div class="line"><span class="keyword">library</span>(dplyr)</div><div class="line"><span class="keyword">library</span>(rafalib)</div><div class="line">mypar(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line"><span class="keyword">for</span>(y <span class="keyword">in</span> <span class="number">2010</span>:<span class="number">2012</span>)&#123;</div><div class="line">  dat &lt;- filter(players,yearID==y) %&gt;% mutate(AVG=H/AB) %&gt;% filter(AB&gt;<span class="number">500</span>)</div><div class="line">  hist(dat$AVG*<span class="number">1000</span>,xlab=<span class="string">"AVG"</span>,freq=<span class="literal">FALSE</span>,main=y,xlim=c(<span class="number">200</span>,<span class="number">360</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908211314.jpeg" alt=""></p>
<p>我们注意到，普通运行员的AVG为0.275，总体运动员的标准差为0.027。所以，我们看到，0.45这个数字与它们假设偏离非常大，因为这个数字离平均值的差距超过了6个标准差。Jose的这个数字是由于运气，还是说他确实是过去50年来最好的运动员？或者是这两者的结合？但是，他有多幸运，以及运动天赋有多高？如果我们确信他是由于运气出现的这个数字，我们应该把他送到相信他确实是0.45这个水平的球队里，并且有可能高估了他的潜力。</p>
<h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a><strong>层次模型</strong></h3><p>层次模型为我们提供了如何观察到0.45的这个数字的数学描述。首先，我们会随机选择一个内在能力为$\theta$运动员，然后，我们看到成功概率为$\theta$的20个随机结果（这一段不太懂，原文为：The hierarchical model provides a mathematical description of how we came to see the observation of .450. First, we pick a player at random with an intrinsic ability summarized by, for example, $\theta$, then we see 20 random outcomes with success probability $\theta$.），其中：</p>
<script type="math/tex; mode=display">
\begin{align*}
\theta &\sim N(\mu, \tau^2) \mbox{ describes randomness in picking a player}\\
Y \mid \theta &\sim N(\theta, \sigma^2) \mbox{ describes randomness in the performance of this particular player}
\end{align*}</script><p>我们要注意2个层次（这就是为什么要称为层次分析的原因）：</p>
<ol>
<li>运动员与运动员之间的变异；</li>
<li>击球时，运气因素导致的变异。</li>
</ol>
<p>在贝叶斯框架中，第一个水平称为先验分布(prior distribution)，第二个水平称为采样分布(sampling distribution)。</p>
<p>现在我们使用贝叶斯模型来计算Jose的数据。假设我们想预测构成他真实击球平均水平$\theta$的内在能力的话。使用层次模型就按下面的方法表示：</p>
<script type="math/tex; mode=display">
\begin{align*}
\theta &\sim N(.275, .027^2) \\
Y \mid \theta &\sim N(\theta, .111^2) 
\end{align*}</script><p>我们现在就可以计算出一个后验分布(posterior distribution)来描述我们对$\theta$的预测。这里我们可以使用贝叶斯规则的连续计算方法推导后验概率，后验概率是对给定观测数据参数$\theta$的分布：</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{ \theta \mid Y} (\theta\mid Y) &=
\frac{f_{Y\mid \theta}(Y\mid \theta) f_{\theta}(\theta)
}{f_Y(Y)}\\
&= \frac{f_{Y\mid \theta}(Y\mid \theta) f_{\theta}(\theta)}
{\int_{\theta}f_{Y\mid \theta}(Y\mid \theta)f_{\theta}(\theta)}
\end{align*}</script><p>我们主要是对能够使后验概率$f_{\theta\mid Y}(\theta\mid Y)$的值最大的$\theta$感兴趣。在我们的案例中，我们可以看出后验概率服从正态分布，我们能计算出均值$\mbox{E}(\theta\mid y)$，方差$\mbox{var}(\theta\mid y)$，尤其，我们可以计算出这个分布的均值服从以下分布：</p>
<script type="math/tex; mode=display">
\begin{align*}
\mbox{E}(\theta\mid y) &= B \mu + (1-B) Y\\
&= \mu + (1-B)(Y-\mu)\\
B &= \frac{\sigma^2}{\sigma^2+\tau^2}
\end{align*}</script><p>这是一个总体均值$\mu$和观测数据$Y$的加权均值。其权重取决于总体$\tau$的SD和我们观测数据$\sigma$的SD。这个加权均值有时候也会被称为<code>shrinking</code>，因为它缩小(shrink)了对先验均值的估计，在Joes Iglesias的数据中，结果如下所示：</p>
<script type="math/tex; mode=display">
\begin{align*}
\mbox{E}(\theta \mid Y=.450) &= B \times .275 + (1 - B) \times .450 \\
&= .275 + (1 - B)(.450 - .275) \\
B &=\frac{.111^2}{.111^2 + .027^2} = 0.944\\
\mbox{E}(\theta \mid Y=450) &\approx .285
\end{align*}</script><p>方差如下所示：</p>
<script type="math/tex; mode=display">
\mbox{var}(\theta\mid y) = \frac{1}{1/\sigma^2+1/\tau^2}
= \frac{1}{1/.111^2 + 1/.027^2} = 0.00069</script><p>标准差因此是0.026。我们开始时，使用了传统频率学派的思路计算出的95%置信区间忽略了来自于其他运动员的数据，因此会单纯地认为Joes的数据是0.0450 ± 0.220。我们随后使用了贝叶斯方法，整合了来源于其他运动员的数据，以及前几年的数据，计算出了后验概率。这种计算思路实际上就是经验贝叶斯方法，因此我们使用了数据先构建了先验知识。从后验结果中我们可以知道，通过报告一个以均值为中心的区间来报告所谓的95%的可信区间，其发生的概率为95%，在这个案例中，其结果是0.285 ± 0.052。原文：From the posterior we can report what is called a 95% credible interval by reporting a region, centered at the mean, with a 95% chance of occurring. In our case, this turns out to be: 0.285 ± 0.052.</p>
<p>贝叶斯可信区间表明，如果其他的球队发现了0.45这个数字，我们应该考虑到Joses可能转会到其他球队，因为我们预测到了Jose的水平高于平均不水平。有意思的是，Red Sox在7月份的时候将Jose转会到了Detroit Tigers队。这里是Jose在接下来的5个月内的击球率：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Month</th>
<th>At Bat</th>
<th>Hits</th>
<th>AVG</th>
</tr>
</thead>
<tbody>
<tr>
<td>April</td>
<td>20</td>
<td>9</td>
<td>.450</td>
</tr>
<tr>
<td>May</td>
<td>26</td>
<td>11</td>
<td>.423</td>
</tr>
<tr>
<td>June</td>
<td>86</td>
<td>34</td>
<td>.395</td>
</tr>
<tr>
<td>July</td>
<td>83</td>
<td>17</td>
<td>.205</td>
</tr>
<tr>
<td>August</td>
<td>85</td>
<td>25</td>
<td>.294</td>
</tr>
<tr>
<td>September</td>
<td>50</td>
<td>10</td>
<td>.200</td>
</tr>
<tr>
<td>Total w/o April</td>
<td>330</td>
<td>97</td>
<td>.293</td>
</tr>
</tbody>
</table>
</div>
<p>虽然这两个区间都包括了最终的击球平均值，但是贝叶斯可信区间提供了更精确的预测，尤其是，这种方法预测到Jose在本赛季的剩余时间里表现不佳。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>P308</p>
<h2 id="层次模型-1"><a href="#层次模型-1" class="headerlink" title="层次模型"></a>层次模型</h2><p>有关层次模型的内容可以参考作者的<a href="https://github.com/genomicsclass/labs/tree/master/modeling/hierarchical_models.Rmd" target="_blank" rel="external">Github</a>。</p>
<p> 在这一部分里，我们会使用数据理论来描述在高通量数据分析中常用的方法。常规的思路就是构建一个两层的层次模型。一层用于描述样本/实验单元之间的变异，另外一层用于描述特征值之间的变异。这种分析方法类似于我们前面讲的棒球案例，即第一层用于描述不同运动员之间的变异，第二层用于描述一个运动员成功的随机性。我们这里𢪮的所有模型与方法都考虑了第一个变异水平，例如构建t检验的醋。第二个水平允许我们通过从所有的特征值里“借用(borrow)”信息用于对特征值进行统计推断，从而提供检验效能。</p>
<p>现在我们来看一个在基因表达数据中使用最为广泛的统计学方法。这个统计学方就是由<code>limma</code>Bioconductor包提供的。这个方法已经被用于改造分析RNAseq数据，例如edgeR<a href="https://www.ncbi.nlm.nih.gov/pubmed/19910308" target="_blank" rel="external">《edgeR: a Bioconductor package for differential expression analysis of digital gene expression data.》</a>和DESeq2<a href="https://www.ncbi.nlm.nih.gov/pubmed/25516281" target="_blank" rel="external">《Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2》</a>。这两个包提供了t检验的替代方案，它们通过对方差进行建模从而极大地改善了统计功效。然而在棒球案例中，我们是对均值进行了建模，这是与那两种方法建模的不同之处。对方差建模需要更深的数学知识，但是思路是一样的。我们以一个案例来说明一下这种方法。</p>
<p>下图是一个火山图，它显示了使用t检验来分析数据的结果，显示了效应大小(effect size)和p值，其中使用了6个重复样本（对照组3个，干预组3个），其中有16个基因是人为设定的差异基因。只有这16个基因的备选假设为真，在火山图上它们标记为蓝色，代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(SpikeInSubset) <span class="comment">##Available from Bioconductor</span></div><div class="line">data(rma95)</div><div class="line"><span class="keyword">library</span>(genefilter)</div><div class="line">fac &lt;- factor(rep(<span class="number">1</span>:<span class="number">2</span>,each=<span class="number">3</span>))</div><div class="line">tt &lt;- rowttests(exprs(rma95),fac)</div><div class="line">smallp &lt;- with(tt, p.value &lt; <span class="number">.01</span>)</div><div class="line">spike &lt;- rownames(rma95) %<span class="keyword">in</span>% colnames(pData(rma95))</div><div class="line">cols &lt;- ifelse(spike,<span class="string">"dodgerblue"</span>,ifelse(smallp,<span class="string">"red"</span>,<span class="string">"black"</span>))</div><div class="line">with(tt, plot(-dm, -log10(p.value), cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">xlim=c(-<span class="number">1</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">4.5</span>),</div><div class="line">xlab=<span class="string">"difference in means"</span>,</div><div class="line">col=cols))</div><div class="line">abline(h=<span class="number">2</span>,v=c(-<span class="number">.2</span>,<span class="number">.2</span>), lty=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908225643.jpeg" alt=""></p>
<p>上图是使用t检验计算了两组样本的差异基因，其中Spiked-in基因使用蓝色。剩下的基因中，p小于的用红色标明。</p>
<p>在上面的火山图中，我们将y轴的截止值(cut-off)设为了4.5，但是有一个蓝点的p值小于$10^{-6}$。但是，从这张图中我们会发现2点怪异之处。第一，按照5% FDR的标准，只有一个阳性结果是显著的，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum( p.adjust(tt$p.value,method = <span class="string">"BH"</span>)[spike] &lt; <span class="number">0.05</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; sum( p.adjust(tt$p.value,method = <span class="string">"BH"</span>)[spike] &lt; <span class="number">0.05</span>)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div></pre></td></tr></table></figure>
<p>这个结果与每组3个样本的低统计效能有关。第二，如果我们忽略掉统计推断，仅仅是基于t检验统计量的大小简单地对这些基因进行排序，那么我们会在任何大于1的排序列表中得到很多假阳性结果。例如，按照t检验统计量进行排序，位列前10名的基因中，有6个都是假阳性，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table( top50=rank(tt$p.value)&lt;= <span class="number">10</span>, spike) <span class="comment">#t-stat and p-val rank is the same</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table( top50=rank(tt$p.value)&lt;= <span class="number">10</span>, spike) <span class="comment">#t-stat and p-val rank is the same</span></div><div class="line">       spike</div><div class="line">top50   <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line">  <span class="literal">FALSE</span> <span class="number">12604</span>    <span class="number">12</span></div><div class="line">  <span class="literal">TRUE</span>      <span class="number">6</span>     <span class="number">4</span></div></pre></td></tr></table></figure>
<p>在火山图中，我们注意到，大多数基因的效能大小都非常小，这说明，估计的标准误非常小，我们可以通过画图的手段来看一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tt$s &lt;- apply(exprs(rma95), <span class="number">1</span>, <span class="keyword">function</span>(row)</div><div class="line">  sqrt(<span class="number">.5</span> * (var(row[<span class="number">1</span>:<span class="number">3</span>]) + var(row[<span class="number">4</span>:<span class="number">6</span>]) ) ) )</div><div class="line">with(tt, plot(s, -log10(p.value), cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">              log=<span class="string">"x"</span>,xlab=<span class="string">"estimate of standard deviation"</span>,</div><div class="line">              col=cols))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908230650.jpeg" alt=""></p>
<p>在这里我们就可以看到层次模型的用处了。如果我们假设这些变异的分布在所有基因中，然后我们通过分布来“调整”那些“太小”估计值，就可以改善我们的计算结果。在本书的前面部分中，我们提到F分布与观测到的方差分布近似，即：</p>
<script type="math/tex; mode=display">
s^2 \sim s_0^2 F_{d,d_0}</script><p>因为我们有数千个数据点，我们实际上可以检验一下这个假设，并且估计出参数$s_{0}$和$d_{0}$。这种估计方法指的就是经验贝叶斯统计，因为我们使用现有的数据（经验）就可以构建先验分布（贝叶斯方法）。</p>
<p>现在我们将前面的棒球案例应用到标准误的估计中。像以前一样，我们已经有了每个基因的观测值$s_{g}$，这是一个采样分布，用它来作为先验分布。我们因此可以计算出方差$\sigma_{g}^2$的后来又做分布，并且获得一个后验均值，细节可以参考文献<a href="https://www.ncbi.nlm.nih.gov/pubmed/16646809" target="_blank" rel="external">《Linear models and empirical bayes methods for assessing differential expression in microarray experiments.》</a>，均值如下所示：</p>
<script type="math/tex; mode=display">
\mathrm{E}\left[\sigma_{g}^{2} | s_{g}\right]=\frac{d_{0} s_{0}^{2}+d s_{g}^{2}}{d_{0}+d}</script><p>与棒球案例一样，后验均值会降低我们观测到的方差$s_{g}^2$偏向于全局方差$s_{0}^2$，其权重取决于样本大小，以及含有自由度$d$的样本数目，在这个案例中，就是取决于通过$d_{0}$的先验分布形状。（原文：AAs in the baseball example, the posterior mean _shrinks_ the observed variance $s_g^2$ towards the global variance $s_0^2$ and the weights depend on the sample size through the degrees of freedom $d$ and, in this case, the shape of the prior distribution through $d_0$. ）</p>
<p>在上面的图形中，我们可以看到40个基因的方差估计是如何缩小(shrink)的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">fit &lt;- lmFit(rma95, model.matrix(~ fac))</div><div class="line">ebfit &lt;- ebayes(fit)</div><div class="line">n &lt;- <span class="number">40</span></div><div class="line">qs &lt;- seq(from=<span class="number">0</span>,to=<span class="number">.2</span>,length=n)</div><div class="line">idx &lt;- sapply(seq_len(n),<span class="keyword">function</span>(i) which(as.integer(cut(tt$s^<span class="number">2</span>,qs)) == i)[<span class="number">1</span>])</div><div class="line">idx &lt;- idx[!is.na(idx)]</div><div class="line">par(mar=c(<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>))</div><div class="line">plot(<span class="number">1</span>,<span class="number">1</span>,xlim=c(<span class="number">0</span>,<span class="number">.21</span>),ylim=c(<span class="number">0</span>,<span class="number">1</span>),type=<span class="string">"n"</span>,</div><div class="line">     xlab=<span class="string">"variance estimates"</span>,ylab=<span class="string">""</span>,yaxt=<span class="string">"n"</span>)</div><div class="line">axis(<span class="number">2</span>,at=c(<span class="number">.1</span>,<span class="number">.9</span>),c(<span class="string">"before"</span>,<span class="string">"after"</span>),las=<span class="number">2</span>)</div><div class="line">segments((tt$s^<span class="number">2</span>)[idx],rep(<span class="number">.1</span>,n),</div><div class="line">         ebfit$s2.post[idx],rep(<span class="number">.9</span>,n))</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908232355.jpeg" alt=""></p>
<p>上图显示的就是估计值如何向先验期望缩小的，40个基因包括了我们选择值的整个范围。</p>
<p>这种调整的一个重要方面就是使那些样本标准差接近于0的基因的样本偏差不再接近于0（向$s_{0}$收缩）。我们现在就创建一个t检验的统计模型，用于替代使用这个后验均值或“收缩“(shrunken)后的方差估计值。我们称这种t检验模型为适度t检验（moderated t-test）。当我们使用适应t检验后从火山图上就能明显地看到其改进之处：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(limma)</div><div class="line">fit &lt;- lmFit(rma95, model.matrix(~ fac))</div><div class="line">ebfit &lt;- ebayes(fit)</div><div class="line">limmares &lt;- data.frame(dm=coef(fit)[,<span class="string">"fac2"</span>], p.value=ebfit$p.value[,<span class="string">"fac2"</span>])</div><div class="line">with(limmares, plot(dm, -log10(p.value),cex=<span class="number">.8</span>, pch=<span class="number">16</span>,</div><div class="line">                    col=cols,xlab=<span class="string">"difference in means"</span>,</div><div class="line">                    xlim=c(-<span class="number">1</span>,<span class="number">1</span>), ylim=c(<span class="number">0</span>,<span class="number">5</span>)))</div><div class="line">abline(h=<span class="number">2</span>,v=c(-<span class="number">.2</span>,<span class="number">.2</span>), lty=<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190908233029.jpeg" alt=""></p>
<p>这个火山图显示的就是使用适度t检验比较两组的差异基因结果。Spiked-in基因用蓝色进行了标注。剩下的基因中，p值小于的用红色标注。</p>
<p>现在我们来看一下排列前10的基因中假阳性的数目，这个数目就降为了2，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table( top50=rank(limmares$p.value)&lt;= <span class="number">10</span>, spike)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; table( top50=rank(limmares$p.value)&lt;= <span class="number">10</span>, spike)</div><div class="line">       spike</div><div class="line">top50   <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line">  <span class="literal">FALSE</span> <span class="number">12608</span>     <span class="number">8</span></div><div class="line">  <span class="literal">TRUE</span>      <span class="number">2</span>     <span class="number">8</span></div></pre></td></tr></table></figure>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>P315</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">249</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共981.6k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
