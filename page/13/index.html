<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/13/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/13/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/29/Linux/Linux-shell01-基础笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/Linux/Linux-shell01-基础笔记/" itemprop="url">Shell学习笔记（1）——shell脚本基础笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T12:10:54+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,088
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记的参考资料是（<a href="https://item.jd.com/12010266.html" target="_blank" rel="external">《Linux命令行与shell脚本编程大全》</a>（第3版），外加百度辅助，本篇笔记主要内容是Shell脚本的一些基本知识。</p>
<p>使用命令行的一大特点就是能够写脚本，可以将一些命令写到一个脚本中，自动运行。而在Linux的命令行中，一次基本上只能运行一个或几个命令，就像下面的这样，它可以运行两个命令，只是要用分号隔开。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ date;who</div><div class="line">Fri Apr 27 15:56:32 CST 2018</div><div class="line">biotest  tty7         2018-04-27 11:24 (:0)</div></pre></td></tr></table></figure>
<p>这两个命令其实也可以视为一个非常简单的脚本，虽然它只有两个命令，作用就是显示今天的日期以及当前登录到系统中的用户。</p>
<h2 id="创建shell脚本文件">创建shell脚本文件</h2>
<p>如果要将shell命令放到文本文件中，就需要一个文本编辑器，Linux中常用的是vim，写好的脚本文件如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">date;who</div><div class="line"><span class="meta">#</span> this is comments</div></pre></td></tr></table></figure>
<p>将脚本文件保存，命令为test.sh。</p>
<p>现在解释一下这个脚本：</p>
<p>第1行：写入的是<code>#!/bin/bash</code>，#号是用于注释的，shell并不会处理注释，注释只是起到说明的作用，但第1行是个例外，#!的意思是要告诉shell要到哪个shell来运行，这里指定的是bash。</p>
<p>第2行：在第1行中指定了运行脚本的shell后，就可以输入命令了，输入一个命令后，回车，再输入另外一个命令，或者是用分号隔开两个命令。</p>
<p>命令结束后，输入脚本，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ test.sh</div><div class="line">test.sh: command not found</div></pre></td></tr></table></figure>
<p>这是因为，shell是通过PATH环境变量来查找命令的，现在test.sh这个脚本文件并不在环境变量PATH中，因此如果要运行这个脚本，只有2种方法：</p>
<p>第一，将shell脚本文件所在的目录添加到PATH环境中；</p>
<p>第二，使用绝对或相对路径引用shell脚本文件。</p>
<p>现在使用第二种方法，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$</div></pre></td></tr></table></figure>
<p>发现没有反应，此时输入<code>bash test</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/test/testfile$ bash test</div><div class="line">Fri Apr 27 16:19:14 CST 2018</div><div class="line">biotest  tty7         2018-04-27 11:24 (:0)</div></pre></td></tr></table></figure>
<p>test是一个脚本文件，通过<code>ls -lF</code>命令查看发现，test不是一个可执行程序，因此运行这个脚本，需要使用bash test，如果要将它设为可执行文件，则如下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls -lF test</div><div class="line">-rw-rw-r-- 1 biotest biotest 42 Apr 27 01:28 test</div><div class="line">biotest@ubuntu:~$ chmod u+x test</div><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$ ./test</div><div class="line">Fri Apr 27 01:29:38 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure>
<p>此时输入的是相对路径<code>./test</code>，如果要直接运行，则需要将test添加到环境变量中去，如下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ./test</div><div class="line">Fri Apr 27 01:36:50 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">biotest@ubuntu:~$ pwd</div><div class="line">/home/biotest</div><div class="line">biotest@ubuntu:~$ echo 'export PATH=$PATH:/home/biotest/'&gt;&gt;~/.bashrc</div><div class="line">biotest@ubuntu:~$ source ~/.bashrc</div><div class="line">biotest@ubuntu:~$ test</div><div class="line">biotest@ubuntu:~$ mv test test.sh</div><div class="line">biotest@ubuntu:~$ test.sh</div><div class="line">Fri Apr 27 01:37:57 PDT 2018</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure>
<p>添加到环境变量用到了<code>echo 'export PATH=$PATH:/home/biotest/'&gt;&gt;~/.bashrc</code>命令，此外，还有一点，test是用shell写的，原来没有后缀名，输入后无法运行，当添加上上了<code>.sh</code>后，可以正常运行，原理现在还不清楚，懂了再写。</p>
<h2 id="显示消息">显示消息</h2>
<p>多数shell都会产生自己的输出，这些输出会显示脚本所运行的控制台显示器上。很多时候，在自己写脚本时，要添加自己的文本消息来告诉脚本用户正在做什么，需要echo命令，如果在echo命令后面加上一个字符串，就会显示出这个文本字符串，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo This is a test</div><div class="line">This is a test</div><div class="line">biotest@ubuntu:~$ echo "This is a test to see if you're paying attention"</div><div class="line">This is a test to see if you're paying attention</div><div class="line">biotest@ubuntu:~$ ^C</div><div class="line">biotest@ubuntu:~$ echo 'Rich says "scripting is easy".'</div><div class="line">Rich says "scripting is easy".</div></pre></td></tr></table></figure>
<p>从中可以发现：第一，常规情况下字符串并不需要使用引号；第二，如果要使用引号，字符串中间的引号不能与字符串两端的引号重复（即字符串中使用单引号，整个字符串就使用双引号，反之亦然）。</p>
<p>再看一案例，新建一个文件，命名为test1，输入以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> This script displays the date and who's logged on </div><div class="line">echo The time and date are:</div><div class="line">date</div><div class="line">echo "Let's see who's logged into the system:"</div><div class="line">who</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test1</div><div class="line">The time and date are:</div><div class="line">Fri Apr 27 03:01:29 PDT 2018</div><div class="line">Let&apos;s see who&apos;s logged into the system:</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div></pre></td></tr></table></figure></p>
<h2 id="使用变量">使用变量</h2>
<p>环境变量是常见的变量之一，在shell脚本中，也能使用环境变量，只需要在环境㸄前加上美元符号（$）即可，下面的脚本中就使用了一些环境变量，如下所示： <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> display user information from the system.</div><div class="line">echo "User info for userid: $USER"</div><div class="line">echo UID:$UID</div><div class="line">echo HOME: $HOME</div></pre></td></tr></table></figure></p>
<p>运行后结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test2</div><div class="line">User info for userid: biotest</div><div class="line">UID:1000</div><div class="line">HOME: /home/biotest</div></pre></td></tr></table></figure>
<p>如果在字符串中使用美元符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo "The cost of the item is $15"</div><div class="line">The cost of the item is 5</div></pre></td></tr></table></figure>
<p>这里面的美元符号就不会显示，如果要显示的话，需要添加转义字符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo "The cost of the item is \$15"</div><div class="line">The cost of the item is $15</div></pre></td></tr></table></figure>
<h2 id="用户变量">用户变量</h2>
<p>用户变量是用户自己定义的一些变量，这些常见的编程语言中的变量大同小异，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing vairbales</div><div class="line">days=10</div><div class="line">guest="Test"</div><div class="line">echo "$guest checked in $days days ago"</div><div class="line">days=5</div><div class="line">guest="Test01"</div><div class="line">echo "$guest checked in $days days ago"</div></pre></td></tr></table></figure>
<p>运行后结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test3</div><div class="line">Test checked in 10 days ago</div><div class="line">Test01 checked in 5 days ago</div></pre></td></tr></table></figure>
<h3 id="有关美元符号与赋值的另一案例">有关美元符号与赋值的另一案例</h3>
<p>如果引用变量不使用美元符号，会将引用的某个变量名称识别为字符串，看下面的案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> assigning a variable value to another variable</div><div class="line"></div><div class="line">value1=10</div><div class="line">value2=$value1</div><div class="line">echo The resulting value is $value2</div><div class="line">value3=value1</div><div class="line">echo The resulting value is $value3</div></pre></td></tr></table></figure>
<p>结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test4</div><div class="line">The resulting value is 10</div><div class="line">The resulting value is value1</div></pre></td></tr></table></figure></p>
<p>从结果可以看出来，当value2=$value1时，就把变量value1的值10赋值给了value2，当使用value3=value1时，由于没加美元符号，就把value1这个字符串赋值给了value3。</p>
<h2 id="命令替换">命令替换</h2>
<p>shell脚本有一个重要的功能就是从命令输出中提取信息，并将值赋给某个变量。有2种方法可以将命令输出赋值给某个变量：</p>
<p>第一：使用反引号（`）； 第二：使用<code>$()</code>格式。 使用这两种方法可以使shell命令的输出赋值给变量，具体用法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">testing=`date`</div><div class="line"># 或者是</div><div class="line">testing=$(date)</div></pre></td></tr></table></figure>
<p>具体的案例如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">testing=$(date)</div><div class="line">echo &quot;The date and time are: &quot; $testing</div></pre></td></tr></table></figure></p>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test5</div><div class="line">The date and time are:  Fri Apr 27 07:10:16 PDT 2018</div></pre></td></tr></table></figure>
<p>第二案例： 以下的案例就是就是通过命令替换获得当前日期，并用它来生成唯一文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># copy the /usr/bin directory listing to a log file</div><div class="line">today=$(date +%y%m%d) </div><div class="line"># there is a blank between +%y%m%d</div><div class="line">ls /usr/bin -al &gt; log.$today</div></pre></td></tr></table></figure>
<p>运行后没有输出信息，但是它会在当前目录下生成一个log文件，名称就是log加上今天的日期（今天是2018年4月27日），则这个文件名称就是log.180427。代码的运行原理是，date命令得到当前日期，经格式化后，赋值给today。关于日期的格式化，可以看下面的案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date</div><div class="line">Fri Apr 27 07:21:17 PDT 2018</div><div class="line">biotest@ubuntu:~$ date +%y%m%d</div><div class="line">180427</div></pre></td></tr></table></figure>
<h2 id="重定向输入和输出">重定向输入和输出</h2>
<p>有时候我们会遇到这样的场景，我想把某个命令的输出结果保存到某个文件中，这个文件我可以用于查看，或者是经后来的命令处理。这就用到了重定向，重定向可以用于输入，也可以用于输出。</p>
<h3 id="输出重定向">输出重定向</h3>
<p>最基本的重定向就是将命令的输出发送到一个文件中，bash shell中使用大于号（&gt;）来完成，格式为<code>command &gt; outputfile</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date &gt; test7</div><div class="line">biotest@ubuntu:~$ ls -l test7</div><div class="line">-rw-rw-r-- 1 biotest biotest 29 Apr 27 07:25 test7</div><div class="line">biotest@ubuntu:~$ less test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">Fri Apr 27 07:25:44 PDT 2018</div><div class="line">biotest@ubuntu:~$ who &gt; test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">biotest@ubuntu:~$ date &gt;&gt; test7</div><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">Fri Apr 27 07:28:58 PDT 2018</div></pre></td></tr></table></figure>
<p>使用重定向文件创建了一个文件test7，将date命令的输出结果重定向了到了test7中，如果这个文件存在，则重定向的数据会覆盖原来的数据，如果不想覆盖，只是追加，可以使用双大于号。</p>
<h3 id="输入重定向">输入重定向</h3>
<h4 id="常规的输入重定向">常规的输入重定向</h4>
<p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令。 输入重定向符号是小于号（&lt;），格式为<code>command &lt; inputfile</code>。 如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ cat test7</div><div class="line">biotest  tty7         2018-03-24 03:28 (:0)</div><div class="line">Fri Apr 27 07:28:58 PDT 2018</div><div class="line">biotest@ubuntu:~$ wc &lt; test7</div><div class="line"> 2 11 73</div></pre></td></tr></table></figure></p>
<p>在这个案例中，将test7的内容输入到wc命令中，wc命令可以对数据中的文本进行计数（wc的全称为words count），wc的默认输出有3个值，从左到右分别为： ①文本的行数；②文本的词数；③文本的字节数，在前面的案例中，结果就是2行，11个单词，73个字节。</p>
<h4 id="内联输入重定向">内联输入重定向</h4>
<p>内联输入重定向的英文是inline input redirection，这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致，格式为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">command &lt;&lt; marker </div><div class="line">data </div><div class="line">marker</div></pre></td></tr></table></figure></p>
<p>maker是数据的开始，也是结果，data是位于maker之间的文本文件，看一个案例： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ wc &lt;&lt; EOF</div><div class="line">&gt; test string 1</div><div class="line">&gt; test string 2</div><div class="line">&gt; test string 3</div><div class="line">&gt; EOF</div><div class="line"> 3  9 42</div></pre></td></tr></table></figure></p>
<p>当输入wc &lt;&lt; EOF时，命令行会自动变成大于号，接着输入内容，输入完毕后，再输入EOF表示结束，此时命令开始运行，结果为3，9， 42.</p>
<h2 id="管道">管道</h2>
<p>管道的使用场景为，将命令A的输出结果导入到命令B，使A的结果成为B的输入。其实这样可以通过重定向实现，但是太麻烦，管道就是出于此目的而设计的。</p>
<p>举个例子：统计当前的文件数有多少个。</p>
<p>先看一下重定向是如何实现的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls &gt; filename</div><div class="line">biotest@ubuntu:~$ cat filename</div><div class="line">Desktop</div><div class="line">Documents</div><div class="line">Downloads</div><div class="line">examples.desktop</div><div class="line">filename</div><div class="line">log.</div><div class="line">log.180427</div><div class="line">miniconda2</div><div class="line">Miniconda2-latest-Linux-x86_64.sh</div><div class="line">Music</div><div class="line">Pictures</div><div class="line">Public</div><div class="line">Templates</div><div class="line">test1</div><div class="line">test2</div><div class="line">test3</div><div class="line">test4</div><div class="line">test5</div><div class="line">test6</div><div class="line">test7</div><div class="line">test8</div><div class="line">test.sh</div><div class="line">Videos</div><div class="line">biotest@ubuntu:~$ wc filename</div><div class="line"> 23  23 210 filename</div></pre></td></tr></table></figure></p>
<p>使用重定向就是，先用ls列出当前的文件名，重定向到filename文件，然后使用wc命令来统计。</p>
<p>再看一下管道命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls|wc</div><div class="line">     23      23     210</div><div class="line">biotest@ubuntu:~$</div></pre></td></tr></table></figure></p>
<p>管道命令通过一条竖线，将ls的结果导入到wc中。</p>
<h2 id="退出脚本">退出脚本</h2>
<p>shell中运行的每个命令都是使用退出状态码（exit status）告诉shell它已经运行完毕，退出状态码是一个0~255的号数值，在命令结束运行时，由命令传给shell。</p>
<h3 id="查看退出状态码">查看退出状态码</h3>
<p>Linux提供了一个专门的变量<code>$?</code> 来保存上个已执行命令的退出状态码。对于需要进行检查的 命令，必须在其运行完毕后立刻查看或使用 $? 变量。它的值会变成由shell所执行的最后一条命令的退出状态码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ date</div><div class="line">Fri Apr 27 07:52:45 PDT 2018</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">0</div></pre></td></tr></table></figure>
<p>通常一个成功结束的命令的退出状态码是0，如果命令结束时有错误，这个代码就是一个正整数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ asd</div><div class="line">No command &apos;asd&apos; found, but there are 22 similar ones</div><div class="line">asd: command not found</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">127</div></pre></td></tr></table></figure>
<h3 id="exit命令">exit命令</h3>
<p>exit 命令允许你在脚本结束时指定一个退出状态码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># testing the exit status</div><div class="line">var1=10</div><div class="line">var2=30</div><div class="line">var3=$[$var1 + $var2]</div><div class="line">echo The answer is $var3</div><div class="line">exit 5</div></pre></td></tr></table></figure>
<p>运行后，结果如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ bash test9</div><div class="line">The answer is 40</div><div class="line">biotest@ubuntu:~$ echo $?</div><div class="line">5</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/28/Linux/Linux环境变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/Linux/Linux环境变量/" itemprop="url">Linux环境变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-28T12:10:54+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,588
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是shell">1. 什么是shell？</h3>
<p>答：在计算机科学中，Shell俗称壳（用来区别于核，核是指“内核”），Shell是指“提供使用者使用界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。</p>
<p>在很多并不正式的场合，这两个名词表达的意思相同，即命令解释器。但从严格的意义上讲，命令行是指供用户输入命令的界面，其本身只是接受输入，然后把命令传递给命令解释器，后者就是Shell，从本质上讲，Shell是一个程序，它在用户和操作系统之间提供了一个面向行的可交互接口，用户在命令行中输入命令，运行在后台的Shell把命令转换成指令代码发送给操作系统。Shell并非只有命令行这一种形式，例如GNOME、KDE等图形界面也是Shell，不过它们是GUI Shell，都是为了解决人机交互的问题。</p>
<p>目前在Linux环境下有几种不同类型的Shell，常用的有Bourne Again Shell（BASH）、TCSH Shell、Z-Shell。不同的Shell提供不同的语法和特性。</p>
<p>例如在Ubuntu中，可以在<code>etc/passwd</code>文件中查看到自己的默认shell程序，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ cat /etc/passwd |grep biotest</div><div class="line">biotest:x:1000:1000:UBUNTU,,,:/home/biotest:/bin/bash</div></pre></td></tr></table></figure>
<p>由上述结果可知，biotest用户所用到shell是bash。bash shell程序位于/bin目录内，从长列表中可以看出<code>/bin/bash</code>是一个可执行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ ls -lF /bin/bash</div><div class="line">-rwxr-xr-x 1 root root 1037528 May 16  2017 /bin/bash*</div></pre></td></tr></table></figure>
<p>注：在Linux系统中，当使用ls，添加了-F参数时，会在每个输出项后追加文件的类型标识符，具体含义为：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；</p>
<h3 id="什么是bash">2. 什么是bash？</h3>
<p>答：bash相当于shell中的某个，shell的范围更广。bash的全称是Bourne again / born again。</p>
<h3 id="什么是环境变量">3. 什么是环境变量？</h3>
<p>答：shell 在 shell 会话中保存着大量信息。这些信息被称为 (shell 的) 环境。 程序获取环境中的数据（即环境变量）来了解本机的配置。虽然大多数程序用配置文件来存储程序设置， 一些程序会根据环境变量来调整他们的行为。Linux是一个多用户的操作系统。每个用户登录系统后，都会有一个专用的运行环境。 通常每个用户默认的环境都是相同的，这个默认环境实际上就是一组环境变量的定义。 环境变量是全局的，设置好的环境变量可以被所有当前用户所运行的程序所使用。 用户可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。在bash shell中，环境变量分为两类，分别为全局变量，局部变量。</p>
<p>shell 在环境中存储了两种基本类型的数据，虽然 bash 几乎无法分辨这些数据的类型。 它们是环境变量和 shell 变量。Shell 变量是 bash 存放的少量数据。剩下的都是 环境变量。除了变量，shell 也存储了一些可编程的数据，即别名和 shell 函数。</p>
<h3 id="如何查看环境变量">4. 如何查看环境变量？</h3>
<p>答：<code>printenv</code>可以显示全局变量，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/f429H66haH.png?imageslim" alt="mark"> 上述的内容是环境变量及其数值列表，环境变量通常是大写字母，这主要是为了与用户的变量进行区分，例如我们可以看到USER=biotest这行代码，就表示当前的用户是biotest，用<code>printenv</code>命令也可以查看当前用户，如下所示：</p>
<blockquote>
<p>biotest@ubuntu:~$ printenv USER biotest</p>
</blockquote>
<h4 id="通过echo来查看变量的值如下所示">通过echo来查看变量的值，如下所示：</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo $HOME</div><div class="line">/home/biotest</div><div class="line">biotest@ubuntu:~/miniconda2/opt$ echo $PWD # PWD是显示当前目录</div><div class="line">/home/biotest/miniconda2/opt</div></pre></td></tr></table></figure>
<h4 id="的作用">$的作用</h4>
<p>在echo命令中，在变量名前加上<code>$</code>就能显示当前变量的值，它也能让变量作为命令行参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/miniconda2/opt$ ls $HOME</div><div class="line">biosoft    Downloads         Miniconda2-latest-Linux-x86_64.sh  Public     Videos</div><div class="line">Desktop    examples.desktop  Music                              Templates</div><div class="line">Documents  miniconda2        Pictures                           test</div></pre></td></tr></table></figure>
<h4 id="设置局部用户定义变量">设置局部用户定义变量</h4>
<p>一旦启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变量了。可以通过等号给环境变量赋值，值可以是数值或字符串，需要注意的是，在shell中，变量名，等号和值之间没有空格，否则会出错，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/miniconda2/opt$ echo $mywords</div><div class="line"></div><div class="line">biotest@ubuntu:~/miniconda2/opt$ mywords=hello</div><div class="line">biotest@ubuntu:~/miniconda2/opt$ echo $mywords</div><div class="line">hello</div></pre></td></tr></table></figure>
<p>如果要给变量赋值一个含有空格的字符串，必须要加上单绰号来界定字符串的首和尾，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/miniconda2/opt$ mywords=Hello linux</div><div class="line">linux: command not found</div><div class="line">biotest@ubuntu:~/miniconda2/opt$ mywords="Hello linux"</div><div class="line">biotest@ubuntu:~/miniconda2/opt$ echo $mywords</div><div class="line">Hello linux</div></pre></td></tr></table></figure>
<p>设置了局部变量后，就能在shell进程的任何地方使用它了，但是，如果生成了另外一个shell，在它的子shell中就无法使用。类似地，如果在子进程中设置了一个局部变量，一旦退出了子进程，那个局部环境变量就无法使用。</p>
<h4 id="设置全局环境变量">设置全局环境变量</h4>
<p>在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。，这个过程是通过<code>export</code>命令实现的，变量名前面不加<code>$</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ my_words="I love Linux"</div><div class="line">biotest@ubuntu:~$ export my_words</div><div class="line">biotest@ubuntu:~$ echo $mywords</div><div class="line">Hello linux</div><div class="line">biotest@ubuntu:~$ bash</div><div class="line">bbiotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div></pre></td></tr></table></figure>
<p>在定义了my_words变量后，用bash命令启动了一个子shell，在空上子shell中能够显示变量my_words的值，这是因为export命令将其设为了全局变量。</p>
<p>修改子shell中全局环境变量的值并不会影响你shell中该变量的值，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div><div class="line">biotest@ubuntu:~$ bash</div><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div><div class="line">biotest@ubuntu:~$ my_words="I love Ubuntu"</div><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Ubuntu</div><div class="line">biotest@ubuntu:~$ exit</div><div class="line">exit</div><div class="line">biotest@ubuntu:~$ exit</div><div class="line">exit</div><div class="line">biotest@ubuntu:~$ ps</div><div class="line">   PID TTY          TIME CMD</div><div class="line"> 20142 pts/4    00:00:00 bash</div><div class="line"> 20318 pts/4    00:00:00 ps</div><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div></pre></td></tr></table></figure>
<p>子shell也无法通export命令改变父shell中全局变量的值。</p>
<h4 id="删除环境变量">删除环境变量</h4>
<p>删除环境变量使用<code>unset</code>命令，前面不加<code>$</code>符号，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line">I love Linux</div><div class="line">biotest@ubuntu:~$ unset my_words</div><div class="line">biotest@ubuntu:~$ echo $my_words</div><div class="line"></div><div class="line">biotest@ubuntu:~$</div></pre></td></tr></table></figure>
<p>在涉及变量名时，什么时候使用<code>$</code>，什么时候不使用<code>$</code>，只需要这样记忆：要具体地查看变量的值时，就需要<code>$</code>符号，如果不需要查看变量的值，只针对变量本身操作，就不使用<code>$</code>符号。</p>
<h3 id="setprintenv都可以查看系统变量它们有什么区别">5. setprintenv都可以查看系统变量，它们有什么区别？</h3>
<p>答：（1）通过<code>set</code>可以设置shell选项，如果只输入set而不加任何参数，它就会显示shell 变量，环境变量，和定义的 shell 函数，此时与printenv命令类似，与 printenv 命令不同的是，set 命令的输出很友好地按照首字母顺序排列，如下所示：</p>
<p><img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/Hc4BKfI9eL.png?imageslim" alt="mark"> 如上图所示，当使用没有带选项和参数的 set 命令时，shell 变量，环境变量，和定义的 shell 函数都会被显示。不同于 printenv 命令，set 命令的输出很友好地按照首字母顺序排列。 （2）set命令显示当前shell的变量，包括当前用户的变量；printenv（输入env也可以）命令只显示当前用户的变量。每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，但shell自己的变量不同shell是不同的，比如BASH_ARGC， BASH等，这些变量只有set才会显示，是bash特有的。</p>
<h3 id="环境变量存放在哪个地方">6. 环境变量存放在哪个地方？</h3>
<p>答：当你进入系统的时候，linux 就会为你读入系统的环境变量，这些环境变量存放在什么地方，那就是环境变量的文件中。Linux 中有很多记载环境变量的文件，它们被系统读入是按照一定的顺序的，这些文件包括以下部分：</p>
<h4 id="etcprofile">6.1 <code>/etc/profile</code>：</h4>
<p>此文件是bash shell默认的主启动文件，只要登录了Linux，bash就会执行/etc/profile启动文件中的命令，该文件存储的是整个系统的环境变量，它为每个用户设置环境信息，这个文件只有root才能修改。当用户第一次登录时，该文件被执行。并从/etc/profile.d目录的配置文件中搜集shell 的设置。这个文件，是任何用户登陆操作系统以后都会读取的文件（如果用户的shell 是csh 、tcsh 、zsh ，则不会读取此文件），用于获取系统的环境变量，只在登陆的时候读取一次。</p>
<h4 id="etcbashrc">6.2<code>/etc/bashrc</code>：</h4>
<p>在执行完/etc/profile 内容之后，如果用户的Shell运行的是bash ，那么接着就会执行此文件。另外，当每次一个新的bash shell 被打开时, 该文件被读取。每个使用bash的用户在登陆以后执行完/etc/profile 中内容以后都会执行此文件，在新开一个bash 的时候也会执行此文件。因此，如果你想让每个使用bash 的用户每新开一个bash 和每次登陆都执行某些操作，或者给他们定义一些新的环境变量，就可以在这个里面设置。 注：<code>/etc/profile</code>，<code>/etc/bashrc</code> 是系统全局环境变量设定</p>
<h4 id="home.bashrc">6.3<code>$HOME/.bashrc</code>：</h4>
<p>该文件包含专用于单个人的bash shell 的bash 信息，当登录时以及每次打开一个新的shell 时, 该该文件被读取。 单个用户此文件的修改会影响到他以后的每一次登陆系统和每一次新开一个bash 。因此，可以在这里设置单个用户的特殊的环境变量或者特殊的操作，那么每次它新登陆系统或者新开一个bash ，都会去获取相应的特殊的环境变量和特殊操作。</p>
<h4 id="home.bash_profile">6.4<code>$HOME/.bash_profile</code>：</h4>
<p>每个用户都可使用该文件输入专用于自己使用的shell 信息。当用户登录时，该文件仅仅执行一次，默认情况下，它设置一些环境变量，执行用户的.bashrc 文件。单个用户此文件的修改只会影响到他以后的每一次登陆系统。因此，可以在这里设置单个用户的特殊的环境变量或者特殊的操作，那么它在每次登陆的时候都会去获取这些新的环境变量或者做某些特殊的操作，但是仅仅在登陆时。 <code>~/.bashrc</code>和<code>~/.bash_profile</code>都只对当前的用户永久生效，也就是说假如用户A设置了些类环境变量，这个环境变量只有A才能使用，而对于其他的B，C，D等用户来说，这个变量是不存在的。在根目录下，通过<code>ls -a</code>可以查看这两个文件，正常情况下，这两个文件是隐藏的。</p>
<h4 id="home.bash_logout">6.5<code>$HOME/.bash_logout</code>：</h4>
<p>当每次退出系统( 退出bash shell) 时, 执行该文件。</p>
<h3 id="bashrc和.bash_profile的区别是什么">7. <code>~/.bashrc</code>和<code>~/.bash_profile</code>的区别是什么？</h3>
<p>答：原则上来说，设置自己的环境变量时，在这两个文件中任意选一个即可，它们的区别在于：<code>~/.bash_profile</code>是交互式login方式进入bash shell运行而<code>~/ .bashrc</code>是交互式non-login方式进入bash shell运行。二者设置大致相同。通俗点说，就是<code>.bash_profile</code>文件只会在用户登录的时候读取一次，而<code>.bashrc</code>在每次打开终端进行一次新的会话时都会读取。</p>
<h4 id="登录-shell-会读取一个或多个启动文件的总结">登录 shell 会读取一个或多个启动文件的总结:</h4>
<table style="width:85%;">
<colgroup>
<col width="27%">
<col width="56%">
</colgroup>
<thead>
<tr class="header">
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/etc/profile</td>
<td>应用于所有用户的全局配置脚本。</td>
</tr>
<tr class="even">
<td>$HOME/.bash_profile</td>
<td>用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td>
</tr>
<tr class="odd">
<td>$HOME/.bash_login</td>
<td>如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。</td>
</tr>
<tr class="even">
<td>$HOME/.profile</td>
<td>如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。</td>
</tr>
</tbody>
</table>
<p>非登录 shell 会话会读取以下启动文件：</p>
<table>
<thead>
<tr class="header">
<th>文件</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/etc/bash.bashrc</td>
<td>应用于所有用户的全局配置文件。</td>
</tr>
<tr class="even">
<td>~/.bashrc</td>
<td>用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。</td>
</tr>
</tbody>
</table>
<p>在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。</p>
<h3 id="如何查看某个变量的内容">8. 如何查看某个变量的内容？</h3>
<p>答：如果只查看某个变量的内容，用echo，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/EEDi017BBh.png?imageslim" alt="mark"></p>
<h3 id="什么是临时有效的环境变量">9. 什么是临时有效的环境变量？</h3>
<p>答：临时有效的环境变量就是只对当前的shell有效，当我们退出登录或者关闭终端再打开时，这个环境变量就会消失，它是临时的，设置方法是直接使用<code>export</code>命令来添加，如下所示：</p>
<blockquote>
<p>biotest@ubuntu:~$ export Words=“Hello, world!” biotest@ubuntu:~$ echo $Words Hello, world! biotest@ubuntu:~</p>
</blockquote>
<h3 id="如何查看地自定义的别名">10. 如何查看地自定义的别名？</h3>
<p>答：通过set或printenv无法查看通过alias命名的别名，此时需要通过alias来查看，如下所示：</p>
<blockquote>
<p>alias egrep=‘egrep –color=auto’ alias fgrep=‘fgrep –color=auto’ alias grep=‘grep –color=auto’ alias l=‘ls -CF’ alias la=‘ls -A’ alias ll=‘ls -alF’ alias ls=‘ls –color=auto’</p>
</blockquote>
<h3 id="shell中的一些大写字母是什么意思">11. Shell中的一些大写字母是什么意思？</h3>
<p>答：这些大写字母表示一些特殊的环境变量，如下所示：</p>
<table style="width:68%;">
<colgroup>
<col width="11%">
<col width="56%">
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DISPLAY</td>
<td>如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 “:0”， 意思是由 X 产生的第一个显示器。</td>
</tr>
<tr class="even">
<td>EDITOR</td>
<td>文本编辑器的名字。</td>
</tr>
<tr class="odd">
<td>SHELL</td>
<td>shell 程序的名字。</td>
</tr>
<tr class="even">
<td>HOME</td>
<td>用户家目录。</td>
</tr>
<tr class="odd">
<td>LANG</td>
<td>定义了字符集以及语言编码方式。</td>
</tr>
<tr class="even">
<td>OLD_PWD</td>
<td>先前的工作目录。</td>
</tr>
<tr class="odd">
<td>PAGER</td>
<td>页输出程序的名字。这经常设置为/usr/bin/less。</td>
</tr>
<tr class="even">
<td>PATH</td>
<td>由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。</td>
</tr>
<tr class="odd">
<td>PS1</td>
<td>Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。</td>
</tr>
<tr class="even">
<td>PWD</td>
<td>当前工作目录。</td>
</tr>
<tr class="odd">
<td>TERM</td>
<td>终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。</td>
</tr>
<tr class="even">
<td>TZ</td>
<td>指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。</td>
</tr>
<tr class="odd">
<td>USER</td>
<td>你的用户名</td>
</tr>
</tbody>
</table>
<h3 id="设置环境变量常用的指令有哪些">12. 设置环境变量常用的指令有哪些?</h3>
<p>答:常用的命令有<code>echo</code>,<code>export</code>,<code>env</code>,<code>set</code>,<code>unset</code>，<code>readonly</code>等，如下所示：</p>
<h4 id="echo">(1)<code>echo</code></h4>
<p>查看某个环境变量．</p>
<h4 id="env">(２)<code>env</code></h4>
<p>查看所有环境变量</p>
<h4 id="set">(３)<code>set</code></h4>
<p>查看本地定义的所有shell变量．</p>
<h4 id="unset">(４)<code>unset</code></h4>
<p>删除一个环境变量，例如：</p>
<blockquote>
<p>biotest@ubuntu:~$ export Words=“Hello, world!” biotest@ubuntu:~$ echo $Words Hello, world! biotest@ubuntu:~$ unset Words biotest@ubuntu:~$ echo $Words biotest@ubuntu:~$</p>
</blockquote>
<h4 id="readonly">(5)<code>readonly</code></h4>
<p>设置只读环境变量．</p>
<h3 id="如何将某程序的目录添加到环境变量">13. 如何将某程序的目录添加到环境变量？</h3>
<p>答：当在shell中输入一个外部命令时,shell就会搜索系统来找到相应的程序,<code>PATH</code>这个环境变量就是定义用于命令和程序查找的目录,通过<code>echo $PATH</code>可以查看环境变量，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/H7kICbk6jf.png?imageslim" alt="mark"></p>
<p>在<code>PATH</code>变量中，可以看到许多由冒号（黄色方框标出的部分）分开的路径。每个冒号就是一个路径，这些搜索路径都是一些可以找到可执行程序的目录列表。当我们输入一个指令时，shell会先检查命令是否是内部命令，不是的话会再检查这个命令是否是一个应用程序。然后shell会试着从这些搜索路径，即PATH（上图中路径）中寻找这些应用程序。如果shell在这些路径目录里没有找到可执行文件。则会报错。若找到，shell内部命令或应用程序将被分解为系统调用并传给Linux内核。在某些时候,我们在Linux中安装了软件,如果没有把软件的可执行文件路径添加到PATH中去的话，要执行某个程序，就需要输入全路径，非常不方便，因此我们需要把软件的安装目录添加到PATH变量中。</p>
<h4 id="path环境变量的一个案例"><code>PATH</code>环境变量的一个案例</h4>
<ol style="list-style-type: decimal">
<li>创建一个可执行文件 在<code>/mnt/hgfs/biotest</code>这个目录下建立一个<code>test.py</code>文件，输入以下内容：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"></div><div class="line">print(<span class="string">"hello, world"</span>)</div></pre></td></tr></table></figure>
<p>保存，退出。 然后将这个文件权限修改为可执行，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x test.py</div></pre></td></tr></table></figure>
<ol start="2" style="list-style-type: decimal">
<li><p>测试相对路径与绝对路径调用 在当前目录下打开客户端，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:/mnt/hgfs/biotest$ ./test.py # 相对路径调用</div><div class="line">&gt;hello, world</div><div class="line">&gt;biotest@ubuntu:/mnt/hgfs/biotest$ </div><div class="line">&gt;biotest@ubuntu:/mnt/hgfs/biotest$ cd</div><div class="line">&gt;biotest@ubuntu:/mnt/hgfs/biotest/test.py # 绝对路径调用</div><div class="line">&gt;hello, world</div></pre></td></tr></table></figure></p></li>
<li><p>未添加到环境变量PATH时的情况 此时，<code>test.py</code>文件并没添加到<code>PATH</code>的环境变量中，因此直接输入<code>test.py</code>会出错，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:$ test.py</div><div class="line">&gt;test.py: command not found</div></pre></td></tr></table></figure></p></li>
<li><p>将文件的路径添加到环境变量PATH 通过设置PATH环境变量，直接用文件名调用：</p></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:$export PATH=$PATH:/mnt/hgfs/biotest</div><div class="line">&gt;biotest@ubuntu:$ test.py</div><div class="line">&gt;hello, world</div><div class="line">&gt;biotest@ubuntu:$</div></pre></td></tr></table></figure>
<p>注：在添加路径到环境变量时，用到了<code>export</code>，它的用法是<code>export PATH=$PATH:路径</code>，或<code>export $PATH=&quot;路径”</code></p>
<ol start="5" style="list-style-type: decimal">
<li>永久将文件路径添加到环境变量 此时，将这个客户端关闭，再打开，试着输入<code>test.py</code>，发现出错了，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:$ test.py</div><div class="line">&gt;test.py: command not found</div></pre></td></tr></table></figure></li>
</ol>
<p>因为在第4步中，<code>export PATH=$PATH:/mnt/hgfs/biotest</code>只是一种临时添加到环境变量的方法，如果要每次打开客户端时，都能直接执行<code>test.py</code>，则需要将目录添加到.bashrc文件中，步骤如下： 第一，输入<code>biotest@ubuntu:/$ vi ~/.bashrc</code>打开bashrc文件； 第二，移到bashrc文件的最末端，按<code>I</code>，切换到编辑模式，输入<code>export PATH=/mnt/hgfs/biotest:$PATH</code>，再按<code>Esc</code>键，输入<code>wq</code>，回车，退出； 第三，输入<code>source ~/.bashrc</code>，刷新文件，此时，再输入<code>test.py</code>，如下所示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;biotest@ubuntu:$ test.py</div><div class="line">&gt;hello, world</div></pre></td></tr></table></figure></p>
<p>把客户端关闭或者是重启电脑，再次输入<code>test.py</code>也能够执行，用<code>export</code>查看一下环境变量，如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/lfJc52FL4H.png?imageslim" alt="mark"> 可以发现，test.py所在的目录在环境变量中。</p>
<p>如果觉得打开<code>~/.bashrc</code>文件，添加环境变量太麻烦了，可以直接在命令行模式下面进行添加，现在将原来的那个test.py文件拷到另外一个目录（<code>~/Downloads</code>）下面，并把文件名字进行修改，改为<code>test2.py</code>，此时输入以下命令即可： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &apos;export PATH=$PATH:~/Downloads&apos;&gt;&gt;~/.bashrc &amp;&amp; source ~/.bashrc</div></pre></td></tr></table></figure></p>
<p>运行过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/Downloads$ ./test2.py #相对路径运行</div><div class="line">hello, world</div><div class="line">biotest@ubuntu:~/Downloads$ echo &apos;export PATH=$PATH:~/Downloads&apos;&gt;&gt;~/.bashrc &amp;&amp; source ~/.bashrc #将路径添加到环境变量，直接运行；；</div><div class="line">biotest@ubuntu:~/Downloads$ test2.py</div><div class="line">hello, world</div></pre></td></tr></table></figure>
<p>通过echo还可以添加alias，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;alias lh=&apos;ls -lh&apos;&quot; &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc</div></pre></td></tr></table></figure>
<p>运行过程如下所示： <img src="http://ortxpw68f.bkt.clouddn.com/professional/180421/0fJGD9KkA1.png?imageslim" alt="mark"></p>
<h3 id="什么是非交互式shell">什么是非交互式shell？</h3>
<p>答：在命令行中输入bash命令，这就是交互式shell，系统执行shell脚本时则是非交互式shell，不同的地方就在于非交互式shell没有命令行提示答。bash shell有一个环境变量即，<code>BASH_ENV</code>环境变量，当shell启动一个非交互式shell进程时，它会检查这个环境变量来查提要执行的启动文件，如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。这个环境㸄在默认情况下并没有设置，输入<code>printenv BASH_ENV</code>不会返回任何信息。如果BASH_ENV没有设置，shell脚本获取环境变量的过程是这样的：shell脚本是通过启动一个子shell来执行的，子shell可以继承父shell导出过的变量，举例来说，如果父shell是登录shell，在<code>etc/profile</code>、<code>/etc/profile.d/*.sh</code>和<code>$HOME/.bashrc</code>文件中设置并导出了变量，用于执行脚本的子shell就能够继池在这些变量。需要注意的是，父shell设置但并未导出的变量都是局部变量，子shell无法继承局部变量。</p>
<h3 id="什么是数组变量">什么是数组变量？</h3>
<p>答：环境变量有一个很有用的特性就是它们可以作为数组使用，数组是能够储存多个值的变量，这些值可以单独引用，也可以作为整个数组来引物，要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~$ mytest=(one two three four five)</div><div class="line">biotest@ubuntu:~$ echo $mytest</div><div class="line">one</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[2]&#125;</div><div class="line">three</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[0]&#125;</div><div class="line">one</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[*]&#125;</div><div class="line">one two three four five</div><div class="line">biotest@ubuntu:~$ unset mytest[2]</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[*]&#125;</div><div class="line">one two four five</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[3]&#125;</div><div class="line">four</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[*]&#125;</div><div class="line">one two four five</div><div class="line">biotest@ubuntu:~$ unset mytest</div><div class="line">biotest@ubuntu:~$ echo $&#123;mytest[*]&#125;</div></pre></td></tr></table></figure>
<p>从上面结果可以知道，数组变量有这样的特点：①如果只输入变量的名称，只返回第1个元素的值；②如果要显其余的变量的值，格式为<code>echo ${mytest[n]}</code>，其中n是元素的索引，它是从0开始的，如果要显示全部的内容，需要输入星号（*）；③如果要删除数组变量中间的某个元素，删除后，原变量的索引不变；④</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/18/Python/Python学习笔记（17）-文件_目录_eval/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/Python/Python学习笔记（17）-文件_目录_eval/" itemprop="url">Python学习笔记（17）-黑马教程-文件，目录与eval函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T12:00:00+08:00">
                2018-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,211
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文件的基本操作">文件的基本操作</h2>
<h3 id="操作文件的步骤">操作文件的步骤</h3>
<p>在计算机中要操作文件的套路非常固定，一共包含三个步骤：</p>
<ol style="list-style-type: decimal">
<li>打开文件；</li>
<li>读、写文件：<strong>读</strong>是指将文件内容读入内存；<strong>写</strong>将内存内容写入文件；</li>
<li>关闭文件。</li>
</ol>
<h3 id="操作文件的函数方法">操作文件的函数/方法</h3>
<p>在Python中要担任文件需要记住1个函数和3个方法，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>函数/方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>open</td>
<td>打开文件，并返回文件操作对象</td>
</tr>
<tr class="even">
<td>02</td>
<td>read</td>
<td>将文件内容读取到内存</td>
</tr>
<tr class="odd">
<td>03</td>
<td>write</td>
<td>将指定内容写入文件</td>
</tr>
<tr class="even">
<td>04</td>
<td>close</td>
<td>关闭文件</td>
</tr>
</tbody>
</table>
<p>其中<code>open</code>函数负责打开文件，并返回文件对象，而<code>read/write/close</code>这三个方法都需要通过<code>文件对象</code>来调用。</p>
<h2 id="read方法读取文件">read方法——读取文件</h2>
<ol style="list-style-type: decimal">
<li><code>open</code>函数的第一个参数是要打开的文件（文件名是区分大小写的），如果文件<strong>存在</strong>，返回<strong>文件操作对象</strong>，如果文件<strong>不存在</strong>，会<strong>抛出异常</strong>。</li>
<li><code>read</code>文件可以一次性读入并返回文件的所有内容。</li>
<li><code>close</code>方法负责关闭文件。如果<strong>忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问</strong>。因此，当我们<code>open()</code>文件后，就在最后面输入<code>close()</code>，对应起来，再写中间部分，这样会避免忘记关闭文件。</li>
</ol>
<p>需要注意的是，方法执行后，会把<strong>文件指针</strong>移动到<strong>文件的末尾</strong>。</p>
<p>现在来看一个案例，我们新建一个<code>README.txt</code>文件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello python!</div><div class="line">hello world!</div></pre></td></tr></table></figure>
<p>在同一个目录下新建一个python文件，命名为<code>hm_01_读取文件.py</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 打开文件</span></div><div class="line">file = open(<span class="string">"README"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 读取文件内容</span></div><div class="line">text = file.read()</div><div class="line">print(text)</div><div class="line"></div><div class="line"><span class="comment"># 3. 关闭文件</span></div><div class="line">file.close()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello python!</div><div class="line">hello world!</div></pre></td></tr></table></figure>
<h3 id="文件指针">文件指针</h3>
<p>文件指针会标记从哪个位置开始读取数据，第一次打开文件时，通常文件指针会指向文件的开始位置，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190609154525.png">

</div>
<p>当执行了<code>read</code>方法后，文件指标会移动到读取内容的末尾，默认情况下会移动到文件末尾，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190609154643.png">

</div>
<p>因此，当我们执行了一次<code>read</code>方法后，读取了所有内容，那么再次调用<code>read</code>方法，就无法获取内容，因此此时文件指标已经移到了文件的末尾。现在我们来验证一下，还是改造原来的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 打开文件</span></div><div class="line">file = open(<span class="string">"README.txt"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 读取文件内容</span></div><div class="line">text = file.read()</div><div class="line">print(text)</div><div class="line"></div><div class="line">print(<span class="string">"-"</span> * <span class="number">50</span>)</div><div class="line"></div><div class="line">text = file.read()</div><div class="line">print(text)</div><div class="line"></div><div class="line"><span class="comment"># 3. 关闭文件</span></div><div class="line">file.close()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hello, python!</div><div class="line">Hello, world!</div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，第二次调用<code>read</code>方法后，没有内容读取。我们还可以看一下读取文件内容的长度，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 打开文件</span></div><div class="line">file = open(<span class="string">"README.txt"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 读取文件内容</span></div><div class="line">text = file.read()</div><div class="line">print(text)</div><div class="line">print(len(text)) <span class="comment">#输出读取文件长度</span></div><div class="line"></div><div class="line">print(<span class="string">"-"</span> * <span class="number">50</span>)</div><div class="line"></div><div class="line">text = file.read()</div><div class="line">print(text)</div><div class="line">print(len(text))</div><div class="line"></div><div class="line"><span class="comment"># 3. 关闭文件</span></div><div class="line">file.close()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Hello, python!</div><div class="line">Hello, world!</div><div class="line"><span class="number">29</span></div><div class="line">--------------------------------------------------</div><div class="line"></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>
<p>从结果也可以发现，第二次读取的长度是0。</p>
<h2 id="打开文件的方式">打开文件的方式</h2>
<p><code>open</code>在默认的情况下是以只读的方式打开文件，并且返回文件对象，语法如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f = open(<span class="string">"文件名"</span>, <span class="string">"访问方式"</span>)</div></pre></td></tr></table></figure>
<table style="width:92%;">
<colgroup>
<col width="6%">
<col width="84%">
</colgroup>
<thead>
<tr class="header">
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr class="even">
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td>
</tr>
<tr class="odd">
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr class="even">
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr class="odd">
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="even">
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="odd">
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="even">
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr class="odd">
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr class="even">
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr class="odd">
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr class="even">
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
<h2 id="写入文件">写入文件</h2>
<p>现在我们向<code>README.txt</code>文件中写入<code>HELLO</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 打开文件</span></div><div class="line">file = open(<span class="string">"README.txt"</span>, <span class="string">"w"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 写入文件</span></div><div class="line">file.write(<span class="string">"HELLO"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 3. 关闭文件</span></div><div class="line">file.close()</div></pre></td></tr></table></figure>
<p>查看一下<code>README.txt</code>文件，我们使用了<code>w</code>参数来写入文件，如果原文件中有内容，那么就会覆盖，如果没有这个文件，就新建。</p>
<p>现在我们来看一下参数<code>a</code>，这个参数的功能在于以追加的方式写入文件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 打开文件</span></div><div class="line">file = open(<span class="string">"README.txt"</span>, <span class="string">"a"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 写入文件</span></div><div class="line">file.write(<span class="string">"123HELLO"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 3. 关闭文件</span></div><div class="line">file.close()</div></pre></td></tr></table></figure>
<p>现在我们打开文件<code>README.txt</code>，结果为<code>HELLO123HELLO</code>。如果分别在参数<code>r,w,a</code>的后面添加上<code>+</code>号，即<code>r+, w+, a+</code>，那么就会以<strong>读写</strong>的方式打开文件，这会造成频繁地移动文件指标，影响文件的读写效率，在开发中，更多的是采用<strong>只读</strong>或<strong>只写</strong>的方式来操作文件。</p>
<h2 id="按行读取文件内容">按行读取文件内容</h2>
<p><code>read</code>方法会默认把文件的<strong>所有内容一次性读取到内存</strong>，如果文件太大，对内存的占用会非常严重。此时我们可以使用<code>readline</code>方法。</p>
<h3 id="readline方法">readline方法</h3>
<p><code>readline</code>方法可以一次读取一行内容，方法执行后，会把<strong>文件指针</strong>移动到下一行，准备再次读取。因此我们在读取大文件时的代码通常是如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">file = open(<span class="string">"README.txt"</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    text = file.readline()</div><div class="line"></div><div class="line">    <span class="comment"># 判断是否读取到内容</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</div><div class="line">        <span class="keyword">break</span></div><div class="line"></div><div class="line">    print(text)</div><div class="line"></div><div class="line">file.close()</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Hello1</div><div class="line"></div><div class="line">Hello2</div><div class="line"></div><div class="line">Hello3</div></pre></td></tr></table></figure>
<h2 id="文件读写案例复制文件">文件读写案例——复制文件</h2>
<p>在这个案例中，使用代码的方式来实现文件的复制过程。如果我们要复制的源文件是一个小文件，那么我们就可以使用<code>read</code>方法直接把文件的内容全部读取下来，再写入到另外一个文件中，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 打开文件</span></div><div class="line">file_read = open(<span class="string">"README.txt"</span>)</div><div class="line">file_write = open(<span class="string">"README[复制]"</span>, <span class="string">"w"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 读、写</span></div><div class="line">text = file_read.read()</div><div class="line">file_write.write(text)</div><div class="line"></div><div class="line"><span class="comment"># 3. 关闭文件</span></div><div class="line">file_read.close()</div><div class="line">file_write.close()</div></pre></td></tr></table></figure>
<p>现在在同一个目录下出现了<code>README[复制].txt</code>这个文件，里面的内容与<code>README.txt</code>完全相同。</p>
<p>再看一个案例，这个是案例是复制大文件。</p>
<p>如果要复制大文件，就不能使用<code>read</code>方法，因为这会对内存造成很大的压力，因此可以使用<code>readline</code>方法。</p>
<p>现在我们在源文件<code>README.txt</code>中输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hello1</div><div class="line">Hello2</div><div class="line">Hello345</div></pre></td></tr></table></figure>
<p>运行复制大文件的代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. 打开文件</span></div><div class="line">file_read = open(<span class="string">"README.txt"</span>)</div><div class="line">file_write = open(<span class="string">"README[复制]"</span>, <span class="string">"w"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 读、写</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="comment"># 读取一行内容</span></div><div class="line">    text = file_read.readline()</div><div class="line"></div><div class="line">    <span class="comment"># 判断是否读取到内容</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</div><div class="line">        <span class="keyword">break</span></div><div class="line"></div><div class="line">    file_write.write(text)</div><div class="line"></div><div class="line"><span class="comment"># 3. 关闭文件</span></div><div class="line">file_read.close()</div><div class="line">file_write.close()</div></pre></td></tr></table></figure>
<p>运行后，打开复制好的文件，<code>README[复制]</code>，结果与源文件一样。</p>
<h2 id="文件目录的常用管理操作">文件/目录的常用管理操作</h2>
<p>在<strong>终端/浏览器</strong>中可以执行常规的<strong>文件/目录</strong>操作，例如创建、重命名、删除、改变路径、查看目录内容等，在python中，如果要实现上述功能，通常使用<code>os</code>模块。</p>
<p>Python中的目录操作有这些：</p>
<table style="width:92%;">
<colgroup>
<col width="6%">
<col width="84%">
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>方法及描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>os.access(path, mode)：检验权限模式</td>
</tr>
<tr class="even">
<td>2</td>
<td>os.chdir(path)：改变当前工作目录</td>
</tr>
<tr class="odd">
<td>3</td>
<td>os.chflags(path, flags)：设置路径的标记为数字标记。</td>
</tr>
<tr class="even">
<td>4</td>
<td>os.chmod(path, mode)：更改权限</td>
</tr>
<tr class="odd">
<td>5</td>
<td>os.chown(path, uid, gid)：更改文件所有者</td>
</tr>
<tr class="even">
<td>6</td>
<td>os.chroot(path)：改变当前进程的根目录</td>
</tr>
<tr class="odd">
<td>7</td>
<td>os.close(fd)：关闭文件描述符 fd</td>
</tr>
<tr class="even">
<td>8</td>
<td>os.closerange(fd_low, fd_high)：关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr class="odd">
<td>9</td>
<td>os.dup(fd)：复制文件描述符 fd</td>
</tr>
<tr class="even">
<td>10</td>
<td>os.dup2(fd, fd2)：将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr class="odd">
<td>11</td>
<td>os.fchdir(fd)：通过文件描述符改变当前工作目录</td>
</tr>
<tr class="even">
<td>12</td>
<td>os.fchmod(fd, mode)：改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr class="odd">
<td>13</td>
<td>os.fchown(fd, uid, gid)：修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr class="even">
<td>14</td>
<td>os.fdatasync(fd)：强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr class="odd">
<td>15</td>
<td>os.fdopen(fd[, mode[, bufsize]])：通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr class="even">
<td>16</td>
<td>os.fpathconf(fd, name)：返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr class="odd">
<td>17</td>
<td>os.fstat(fd)：返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr class="even">
<td>18</td>
<td>os.fstatvfs(fd)：返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td>
</tr>
<tr class="odd">
<td>19</td>
<td>os.fsync(fd)：强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr class="even">
<td>20</td>
<td>os.ftruncate(fd, length)：裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr class="odd">
<td>21</td>
<td>os.getcwd()：返回当前工作目录</td>
</tr>
<tr class="even">
<td>22</td>
<td>os.getcwdu()：返回一个当前工作目录的Unicode对象</td>
</tr>
<tr class="odd">
<td>23</td>
<td>os.isatty(fd)：如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr class="even">
<td>24</td>
<td>os.lchflags(path, flags)：设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr class="odd">
<td>25</td>
<td>os.lchmod(path, mode)：修改连接文件权限</td>
</tr>
<tr class="even">
<td>26</td>
<td>os.lchown(path, uid, gid)：更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr class="odd">
<td>27</td>
<td>os.link(src, dst)：创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr class="even">
<td>28</td>
<td>os.listdir(path)：返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr class="odd">
<td>29</td>
<td>os.lseek(fd, pos, how)：设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr class="even">
<td>30</td>
<td>os.lstat(path)：像stat(),但是没有软链接</td>
</tr>
<tr class="odd">
<td>31</td>
<td>os.major(device)：从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr class="even">
<td>32</td>
<td>os.makedev(major, minor)：以major和minor设备号组成一个原始设备号</td>
</tr>
<tr class="odd">
<td>33</td>
<td>os.makedirs(path[, mode])：递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr class="even">
<td>34</td>
<td>os.minor(device)：从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr class="odd">
<td>35</td>
<td>os.mkdir(path[, mode])：以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr class="even">
<td>36</td>
<td>os.mkfifo(path[, mode])：创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr class="odd">
<td>37</td>
<td>os.mknod(filename[, mode=0600, device])：创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr class="even">
<td>38</td>
<td>os.open(file, flags[, mode])：打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr class="odd">
<td>39</td>
<td>os.openpty()：打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr class="even">
<td>40</td>
<td>os.pathconf(path, name)：返回相关文件的系统配置信息。</td>
</tr>
<tr class="odd">
<td>41</td>
<td>os.pipe()：创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr class="even">
<td>42</td>
<td>os.popen(command[, mode[, bufsize]])：从一个 command 打开一个管道</td>
</tr>
<tr class="odd">
<td>43</td>
<td>os.read(fd, n)：从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr class="even">
<td>44</td>
<td>os.readlink(path)：返回软链接所指向的文件</td>
</tr>
<tr class="odd">
<td>45</td>
<td>os.remove(path)：删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr class="even">
<td>46</td>
<td>os.removedirs(path)：递归删除目录。</td>
</tr>
<tr class="odd">
<td>47</td>
<td>os.rename(src, dst)：重命名文件或目录，从 src 到 dst</td>
</tr>
<tr class="even">
<td>48</td>
<td>os.renames(old, new)：递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr class="odd">
<td>49</td>
<td>os.rmdir(path)：删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr class="even">
<td>50</td>
<td>os.stat(path)：获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr class="odd">
<td>51</td>
<td>os.stat_float_times([newvalue])：决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr class="even">
<td>52</td>
<td>os.statvfs(path)：获取指定路径的文件系统统计信息</td>
</tr>
<tr class="odd">
<td>53</td>
<td>os.symlink(src, dst)：创建一个软链接</td>
</tr>
<tr class="even">
<td>54</td>
<td>os.tcgetpgrp(fd)：返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr class="odd">
<td>55</td>
<td>os.tcsetpgrp(fd, pg)：设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr class="even">
<td>56</td>
<td>os.tempnam([dir[, prefix]])：Python3 中已删除。返回唯一的路径名用于创建临时文件。</td>
</tr>
<tr class="odd">
<td>57</td>
<td>os.tmpfile()：Python3 中已删除。返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
</tr>
<tr class="even">
<td>58</td>
<td>os.tmpnam()：Python3 中已删除。为创建一个临时文件返回一个唯一的路径</td>
</tr>
<tr class="odd">
<td>59</td>
<td>os.ttyname(fd)：返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr class="even">
<td>60</td>
<td>os.unlink(path)：删除文件路径</td>
</tr>
<tr class="odd">
<td>61</td>
<td>os.utime(path, times)：返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr class="even">
<td>62</td>
<td>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])：输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
</tr>
<tr class="odd">
<td>63</td>
<td>os.write(fd, str)：写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
</tbody>
</table>
<p>目录操作的函数太多，用到的时候再学习，下面只列出几个简单的案例：</p>
<h3 id="显示某文件夹下的所有文件名">显示某文件夹下的所有文件名</h3>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">C:\Users\<span class="number">20161111</span>&gt;type practice.py</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(<span class="string">'d:/Software'</span>):</div><div class="line">    print(filename)</div><div class="line">    </div><div class="line">C:\Users\<span class="number">20161111</span>&gt;python practice.py</div><div class="line">office_tools</div><div class="line">Professional_tools</div><div class="line">ProgramTool</div><div class="line">SnapGene <span class="number">3.2</span><span class="number">.1</span> Win</div><div class="line">system_enhance</div><div class="line">windows_iso</div><div class="line">谷歌批量翻译</div></pre></td></tr></table></figure>
<h3 id="创建某个目录">创建某个目录</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">"d:/Software/test"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</div><div class="line">C:\Users\<span class="number">20161111</span>&gt;d:</div><div class="line">D:\&gt;cd software</div><div class="line">D:\software&gt;dir</div><div class="line"> Volume <span class="keyword">in</span> drive D <span class="keyword">is</span> 新加卷</div><div class="line"> Volume Serial Number <span class="keyword">is</span> C0C6<span class="number">-2E4</span>F</div><div class="line"></div><div class="line"> Directory of D:\software</div><div class="line"></div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">24</span>  <span class="number">09</span>:<span class="number">33</span>    &lt;DIR&gt;          .</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">24</span>  <span class="number">09</span>:<span class="number">33</span>    &lt;DIR&gt;          ..</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span>  <span class="number">13</span>:<span class="number">46</span>    &lt;DIR&gt;          office_tools</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">21</span>  <span class="number">10</span>:<span class="number">30</span>    &lt;DIR&gt;          Professional_tools</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span>  <span class="number">13</span>:<span class="number">46</span>    &lt;DIR&gt;          ProgramTool</div><div class="line"><span class="number">2017</span>/<span class="number">11</span>/<span class="number">22</span>  <span class="number">20</span>:<span class="number">21</span>    &lt;DIR&gt;          SnapGene <span class="number">3.2</span><span class="number">.1</span> Win</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">13</span>  <span class="number">21</span>:<span class="number">38</span>    &lt;DIR&gt;          system_enhance</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">24</span>  <span class="number">09</span>:<span class="number">33</span>    &lt;DIR&gt;          test <span class="comment"># 刚刚创建的文件夹</span></div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">11</span>  <span class="number">00</span>:<span class="number">48</span>    &lt;DIR&gt;          windows_iso</div><div class="line"><span class="number">2017</span>/<span class="number">11</span>/<span class="number">02</span>  <span class="number">10</span>:<span class="number">52</span>    &lt;DIR&gt;          谷歌批量翻译</div><div class="line">               <span class="number">1</span> File(s)              <span class="number">0</span> bytes</div><div class="line">              <span class="number">10</span> Dir(s)  <span class="number">49</span>,<span class="number">307</span>,<span class="number">074</span>,<span class="number">560</span> bytes free</div></pre></td></tr></table></figure>
<h3 id="删除某个文件夹">删除某个文件夹</h3>
<p>命令<code>rmdir</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">'d:/Software/test'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</div><div class="line"></div><div class="line">D:\software&gt;dir</div><div class="line"> Volume <span class="keyword">in</span> drive D <span class="keyword">is</span> 新加卷</div><div class="line"> Volume Serial Number <span class="keyword">is</span> C0C6<span class="number">-2E4</span>F</div><div class="line"></div><div class="line"> Directory of D:\software</div><div class="line"></div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">25</span>  <span class="number">12</span>:<span class="number">40</span>    &lt;DIR&gt;          .</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">25</span>  <span class="number">12</span>:<span class="number">40</span>    &lt;DIR&gt;          ..</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span>  <span class="number">13</span>:<span class="number">46</span>    &lt;DIR&gt;          office_tools</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">21</span>  <span class="number">10</span>:<span class="number">30</span>    &lt;DIR&gt;          Professional_tools</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span>  <span class="number">13</span>:<span class="number">46</span>    &lt;DIR&gt;          ProgramTool</div><div class="line"><span class="number">2017</span>/<span class="number">11</span>/<span class="number">22</span>  <span class="number">20</span>:<span class="number">21</span>    &lt;DIR&gt;          SnapGene <span class="number">3.2</span><span class="number">.1</span> Win</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">13</span>  <span class="number">21</span>:<span class="number">38</span>    &lt;DIR&gt;          system_enhance</div><div class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">11</span>  <span class="number">00</span>:<span class="number">48</span>    &lt;DIR&gt;          windows_iso</div><div class="line"><span class="number">2017</span>/<span class="number">11</span>/<span class="number">02</span>  <span class="number">10</span>:<span class="number">52</span>    &lt;DIR&gt;          谷歌批量翻译</div><div class="line">               <span class="number">1</span> File(s)              <span class="number">0</span> bytes</div><div class="line">               <span class="number">9</span> Dir(s)  <span class="number">48</span>,<span class="number">131</span>,<span class="number">309</span>,<span class="number">568</span> bytes free</div></pre></td></tr></table></figure>
<p>把<code>D:\Software\test</code>这个文件夹删除了 。</p>
<h3 id="重命名某个文件">重命名某个文件</h3>
<p>如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">D:\netdisk\bioinfo.notes\Python\黑马教程笔记\<span class="number">13</span>_文件&gt;ipython</div><div class="line">Python <span class="number">3.6</span><span class="number">.3</span> |Anaconda, Inc.| (default, Oct <span class="number">15</span> <span class="number">2017</span>, <span class="number">03</span>:<span class="number">27</span>:<span class="number">45</span>) [MSC v<span class="number">.1900</span> <span class="number">64</span> bit (AMD64)]</div><div class="line">Type <span class="string">'copyright'</span>, <span class="string">'credits'</span> <span class="keyword">or</span> <span class="string">'license'</span> <span class="keyword">for</span> more information</div><div class="line">IPython <span class="number">6.2</span><span class="number">.1</span> -- An enhanced Interactive Python. Type <span class="string">'?'</span> <span class="keyword">for</span> help.</div><div class="line"></div><div class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> os</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: os.rename(<span class="string">"README.txt"</span>,<span class="string">"TEST.txt"</span>)</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: ls</div><div class="line"> Volume <span class="keyword">in</span> drive D <span class="keyword">is</span> 新加卷</div><div class="line"> Volume Serial Number <span class="keyword">is</span> C0C6<span class="number">-2E4</span>F</div><div class="line"></div><div class="line"> Directory of D:\netdisk\bioinfo.notes\Python\黑马教程笔记\<span class="number">13</span>_文件</div><div class="line"></div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">51</span>    &lt;DIR&gt;          .</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">51</span>    &lt;DIR&gt;          ..</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">46</span>    &lt;DIR&gt;          .idea</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">15</span>:<span class="number">39</span>               <span class="number">164</span> hm_01_读取文件.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">19</span>               <span class="number">229</span> hm_02_读取文件后文件指针会改变.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">25</span>               <span class="number">129</span> hm_03_写入文件</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">37</span>               <span class="number">177</span> hm_04_分行读取文件.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">41</span>               <span class="number">224</span> hm_05_复制文件.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">44</span>               <span class="number">347</span> hm_06_复制大文件.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">46</span>                <span class="number">24</span> README[复制]</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">45</span>                <span class="number">24</span> TEST.txt</div><div class="line">               <span class="number">8</span> File(s)          <span class="number">1</span>,<span class="number">318</span> bytes</div><div class="line">               <span class="number">3</span> Dir(s)  <span class="number">52</span>,<span class="number">836</span>,<span class="number">925</span>,<span class="number">440</span> bytes free</div></pre></td></tr></table></figure>
<h3 id="显示当前目录内的所有文件">显示当前目录内的所有文件</h3>
<p>使用<code>os</code>模块下的<code>listdir</code>命令，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: os.listdir(<span class="string">"."</span>)</div><div class="line">Out[<span class="number">4</span>]:</div><div class="line">[<span class="string">'.idea'</span>,</div><div class="line"> <span class="string">'hm_01_读取文件.py'</span>,</div><div class="line"> <span class="string">'hm_02_读取文件后文件指针会改变.py'</span>,</div><div class="line"> <span class="string">'hm_03_写入文件'</span>,</div><div class="line"> <span class="string">'hm_04_分行读取文件.py'</span>,</div><div class="line"> <span class="string">'hm_05_复制文件.py'</span>,</div><div class="line"> <span class="string">'hm_06_复制大文件.py'</span>,</div><div class="line"> <span class="string">'README[复制]'</span>,</div><div class="line"> <span class="string">'TEST.txt'</span>]</div></pre></td></tr></table></figure>
<h3 id="判断文件是目录还是文件">判断文件是目录还是文件</h3>
<p>使用<code>os</code>模块中的<code>path.isdir</code>命令，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">5</span>]: os.path.isdir(<span class="string">"TEST.txt"</span>)</div><div class="line">Out[<span class="number">5</span>]: <span class="keyword">False</span></div><div class="line"></div><div class="line">In [<span class="number">6</span>]: os.path.isdir(<span class="string">".idea"</span>)</div><div class="line">Out[<span class="number">6</span>]: <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h2 id="eval函数">eval函数</h2>
<p><code>eval()</code>函数可以接受一个字符串，将其当成有效的表达式来求值，并返回计算结果，来看一下面代码的运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="comment"># 基本的数学计算</span></div><div class="line"></div><div class="line">In [<span class="number">2</span>]: eval(<span class="string">"1 + 1"</span>)</div><div class="line">Out[<span class="number">2</span>]: <span class="number">2</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: <span class="comment"># 字符串重复</span></div><div class="line"></div><div class="line">In [<span class="number">4</span>]: eval(<span class="string">"'*' * 10"</span>)</div><div class="line">Out[<span class="number">4</span>]: <span class="string">'**********'</span></div><div class="line"></div><div class="line">In [<span class="number">5</span>]: <span class="comment"># 将字符串转换成列表</span></div><div class="line"></div><div class="line">In [<span class="number">6</span>]: type(eval(<span class="string">"[1, 2, 3, 4, 5]"</span>))</div><div class="line">Out[<span class="number">6</span>]: list</div><div class="line"></div><div class="line">In [<span class="number">7</span>]: <span class="comment"># 将字符串转换成字典</span></div><div class="line"></div><div class="line">In [<span class="number">8</span>]: type(eval(<span class="string">"&#123;'name':'xiaoming', 'age':18&#125;"</span>))</div><div class="line">Out[<span class="number">8</span>]: dict</div></pre></td></tr></table></figure>
<h3 id="eval案例计算器">eval案例——计算器</h3>
<p>需求如下：</p>
<ol style="list-style-type: decimal">
<li>提示用户输入一个加减乘除混合运行；</li>
<li>返回过计算结果。</li>
</ol>
<p>代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">input_str = input(<span class="string">"请输入算术题:  "</span>)</div><div class="line"></div><div class="line">print(eval(input_str))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入算术题:  (<span class="number">5</span>+<span class="number">4</span>)*<span class="number">5</span></div><div class="line"><span class="number">45</span></div></pre></td></tr></table></figure>
<h3 id="不要滥用eval">不要滥用eval</h3>
<p>在开发过程中，不要使用<code>eval</code>来直接转换<code>input</code>结果，现在我们来看一下为什么不要这么做。</p>
<p>我们先来看一下这行代码（由于本人是在windows环境下运行的，因此使用的是<code>dir</code>命令，它等于同Linux环境下的<code>ls</code>命令，这一点与视频中的不一样）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__import__(<span class="string">'os'</span>).system(<span class="string">'dir'</span>)</div></pre></td></tr></table></figure>
<p>上面的这行代码等于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">os.system(<span class="string">"终端命令"</span>)</div></pre></td></tr></table></figure>
<p>如果执行成功，返回0，执行失败，返回错误信息。现在还看上面的计算器案例，运行后，如果我们输入的内容是<code>__import__('os').system('dir')</code>，我们看一下计算的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">C:\Anaconda3\python.exe D:/netdisk/bioinfo.notes/Python/黑马教程笔记/<span class="number">13</span>_文件/hm_08_eval计算器.py</div><div class="line">请输入算术题:  __import__(<span class="string">'os'</span>).system(<span class="string">'dir'</span>)</div><div class="line"> 驱动器 D 中的卷是 新加卷</div><div class="line"> 卷的序列号是 C0C6<span class="number">-2E4</span>F</div><div class="line"></div><div class="line"> D:\netdisk\bioinfo.notes\Python\黑马教程笔记\<span class="number">13</span>_文件 的目录</div><div class="line"></div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">19</span>:<span class="number">54</span>    &lt;DIR&gt;          .</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">19</span>:<span class="number">54</span>    &lt;DIR&gt;          ..</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">19</span>:<span class="number">57</span>    &lt;DIR&gt;          .idea</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">15</span>:<span class="number">39</span>               <span class="number">164</span> hm_01_读取文件.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">19</span>               <span class="number">229</span> hm_02_读取文件后文件指针会改变.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">25</span>               <span class="number">129</span> hm_03_写入文件</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">37</span>               <span class="number">177</span> hm_04_分行读取文件.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">41</span>               <span class="number">224</span> hm_05_复制文件.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">44</span>               <span class="number">347</span> hm_06_复制大文件.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">19</span>:<span class="number">54</span>                <span class="number">68</span> hm_08_eval计算器.py</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">46</span>                <span class="number">24</span> README[复制]</div><div class="line"><span class="number">2019</span>/<span class="number">06</span>/<span class="number">09</span>  <span class="number">16</span>:<span class="number">45</span>                <span class="number">24</span> TEST.txt</div><div class="line">               <span class="number">9</span> 个文件          <span class="number">1</span>,<span class="number">386</span> 字节</div><div class="line">               <span class="number">3</span> 个目录 <span class="number">52</span>,<span class="number">828</span>,<span class="number">184</span>,<span class="number">576</span> 可用字节</div></pre></td></tr></table></figure>
<p>现在我们再换一个命令输入，输入<code>__import__('os').system('cd.&gt;a.txt')</code>，结果就会在同一个目录下创建了一个名为<code>a.txt</code>的文本文件。</p>
<p>现在我们再换一个命令，输入<code>__import__('os').system('del a.txt')</code>，此时就会把刚刚创建的那个<code>a.txt</code>文件删除。</p>
<p>此时我们应该就明白了，使用<code>eval()</code>函数直接转换<code>input</code>的结果了，如果用户使用这个函数直接调用<code>os</code>模块中的命令，就会执行任何终端命令，一旦操作出现失误，会造成严重的后果。</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>黑马Python教程之面向对象</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/17/Python/Python学习笔记（16）-模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/Python/Python学习笔记（16）-模块/" itemprop="url">Python学习笔记（16）-黑马教程-模块与包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T12:00:00+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,003
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模块概念">模块概念</h2>
<ul>
<li><p>Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句；</p></li>
<li><p>模块名同样也是一个标识符，需要符合标识符的命名规则；</p></li>
<li><p>在模块中定义的全局变量、函数、类都是提供给外界直接使用的工具；</p></li>
<li><p>模块就好比工具包，要想使用这个工具包中的工具，就需要先导入这个模块。</p></li>
</ul>
<h2 id="模块的导入">模块的导入</h2>
<p>模块的导入要用到<code>import</code>命令，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> 模块名<span class="number">1</span></div><div class="line"><span class="keyword">import</span> 模块名<span class="number">2</span></div></pre></td></tr></table></figure>
<p>当模块导入后，通过<code>模块名.</code>就可以使用模块提供的工具，例如全局变量、函数和类。</p>
<h3 id="模块导入案例">模块导入案例</h3>
<p>现在我们演示一下如何导入模块，我们现在先同一个文件夹下创建2个模块，分别为<code>hm_01_测试模块1.py</code>和<code>hm_01_测试模块1.py</code>，再新建一个python文件，<code>hm_03_import导入模块.py</code>。</p>
<p>这2个模块文件分别如下所示：</p>
<p><code>hm_01_测试模块1.py</code>代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 全局变量</span></div><div class="line">title = <span class="string">"模块1"</span></div><div class="line"></div><div class="line"><span class="comment"># 函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"我是 %s"</span> % title)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p><code>hm_02_测试模块2.py</code>代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 全局变量</span></div><div class="line">title = <span class="string">"模块2"</span></div><div class="line"></div><div class="line"><span class="comment"># 函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"我是 %s"</span> % title)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>现在创建导入模块的文件，即<code>hm_03_import导入模块.py</code>文件，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hm_01_测试模块<span class="number">1</span></div><div class="line"><span class="keyword">import</span> hm_02_测试模块<span class="number">2</span></div><div class="line"></div><div class="line">hm_01_测试模块<span class="number">1.</span>say_hello()</div><div class="line">hm_02_测试模块<span class="number">2.</span>say_hello()</div><div class="line"></div><div class="line">dog = hm_01_测试模块<span class="number">1.</span>Dog()</div><div class="line">print(dog)</div><div class="line"></div><div class="line">cat = hm_02_测试模块<span class="number">2.</span>Cat()</div><div class="line">print(cat)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">我是 模块<span class="number">1</span></div><div class="line">我是 模块<span class="number">2</span></div><div class="line">&lt;hm_01_测试模块<span class="number">1.</span>Dog object at <span class="number">0x0000021F03B475F8</span>&gt;</div><div class="line">&lt;hm_02_测试模块<span class="number">2.</span>Cat object at <span class="number">0x0000021F03B47668</span>&gt;</div></pre></td></tr></table></figure>
<h3 id="使用as指定模块的别名">使用as指定模块的别名</h3>
<p>如果一个模块的名字太长，可以使用<code>as</code>指定模块的名称，以方便在代码中的使用，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> 模块名<span class="number">1</span> <span class="keyword">as</span> 模块名</div></pre></td></tr></table></figure>
<p>需要注意的是，给模块取别名的时候，要使用大驼峰命名法，还是以前面的案例为例说明一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hm_01_测试模块<span class="number">1</span> <span class="keyword">as</span> DogModule <span class="comment"># 将hm_01_测试模块1重命名为DogModule</span></div><div class="line"><span class="keyword">import</span> hm_02_测试模块<span class="number">2</span> <span class="keyword">as</span> CatModule</div><div class="line"></div><div class="line">DogModule.say_hello()</div><div class="line">CatModule.say_hello()</div><div class="line"></div><div class="line">dog = DogModule.Dog()</div><div class="line">print(dog)</div><div class="line"></div><div class="line">cat = CatModule.Cat()</div><div class="line">print(cat)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">我是 模块<span class="number">1</span></div><div class="line">我是 模块<span class="number">2</span></div><div class="line">&lt;hm_01_测试模块<span class="number">1.</span>Dog object at <span class="number">0x0000026D1FFF85F8</span>&gt;</div><div class="line">&lt;hm_02_测试模块<span class="number">2.</span>Cat object at <span class="number">0x0000026D1FFF8668</span>&gt;</div></pre></td></tr></table></figure>
<p>需要注意的是，输出的结果中，模块名称还是原来的名称，例如<code>hm_01_测试模块1</code>。</p>
<h3 id="导入模块中的部分工具">导入模块中的部分工具</h3>
<p>当我们遇到一种情况，也就是说，只想导入某一模块中的一部分东西，不想全部导入的情况。此时就需要使用<code>from...import</code>这种方式。</p>
<p>前面提到的<code>import 模块名</code>这种方式是<strong>一次性</strong>把模块中的所有工具全部导入，并且通过<code>模块名/别名</code>来访问。现在提到的这个<code>from...import</code>的使用语法如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 从模块中导入某一工具</span></div><div class="line"><span class="keyword">from</span> 模块名<span class="number">1</span> <span class="keyword">import</span> 工具名</div></pre></td></tr></table></figure>
<p>在这种情况下，当我们导入某个模块的部分工具后，不需要通过<code>模块名.部分工具</code>来访问，可以直接使用。</p>
<p>现在还是看前面的案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> hm_01_测试模块<span class="number">1</span> <span class="keyword">import</span> Dog</div><div class="line"><span class="keyword">from</span> hm_02_测试模块<span class="number">2</span> <span class="keyword">import</span> say_hello</div><div class="line"></div><div class="line">say_hello()</div><div class="line">wangcai = Dog()</div><div class="line">print(wangcai)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">我是 模块<span class="number">2</span></div><div class="line">&lt;hm_01_测试模块<span class="number">1.</span>Dog object at <span class="number">0x0000026122974F98</span>&gt;</div></pre></td></tr></table></figure>
<p>但是，有一种情况需要注意，如果两个模块存在<strong>同名的函数</strong>，<strong>最后导入的函数</strong>会覆盖<strong>先前导入的函数</strong>，因此一旦出现这种情况，最好使用<code>as</code>经其中的一个取一个别名，现在看案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> hm_01_测试模块<span class="number">1</span> <span class="keyword">import</span> say_hello</div><div class="line"><span class="keyword">from</span> hm_02_测试模块<span class="number">2</span> <span class="keyword">import</span> say_hello</div><div class="line"></div><div class="line">say_hello()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我是 模块<span class="number">2</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以看出来，<code>hm_02_测试模块2</code>中的<code>say_hello</code>函数覆盖了<code>hm_01_测试模块1</code>中的<code>say_hello</code>函数。</p>
<p>现在我们改变一下顺序，先导入<code>hm_02_测试模块2</code>，再导入<code>hm_01_测试模块1</code>，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># from hm_01_测试模块1 import say_hello</span></div><div class="line"><span class="keyword">from</span> hm_02_测试模块<span class="number">2</span> <span class="keyword">import</span> say_hello</div><div class="line"><span class="keyword">from</span> hm_01_测试模块<span class="number">1</span> <span class="keyword">import</span> say_hello</div><div class="line"></div><div class="line">say_hello()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我是 模块<span class="number">1</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以看出来，<code>hm_01_测试模块1</code>中的<code>say_hello</code>函数覆盖了<code>hm_02_测试模块2</code>中的<code>say_hello</code>函数。</p>
<p>为了避免这种情况，就需要将另外一个函数通过<code>as</code>来指为别名，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># from hm_01_测试模块1 import say_hello</span></div><div class="line"><span class="keyword">from</span> hm_02_测试模块<span class="number">2</span> <span class="keyword">import</span> say_hello <span class="keyword">as</span> module2_say_hello</div><div class="line"><span class="keyword">from</span> hm_01_测试模块<span class="number">1</span> <span class="keyword">import</span> say_hello</div><div class="line"></div><div class="line">say_hello()</div><div class="line">module2_say_hello()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">我是 模块<span class="number">1</span></div><div class="line">我是 模块<span class="number">2</span></div></pre></td></tr></table></figure>
<p>这样就避免了同名函数的覆盖问题。</p>
<h3 id="导入模块的所有内容">导入模块的所有内容</h3>
<p>如果我们使用<code>from...import *</code>时，就可以导入某个模块的所有内容。这与前面的<code>import 模块名</code>的区别就在，<code>import 模块名</code>导入后，需要通过<code>模块名.函数/类</code>才能访问某个函数，而使用<code>from...import *</code>则是直接访问即可，不用加<code>模块名.</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> hm_01_测试模块<span class="number">1</span> <span class="keyword">import</span> *</div><div class="line"></div><div class="line">print(title)</div><div class="line">say_hello()</div><div class="line"></div><div class="line">wangcai = Dog()</div><div class="line">print(wangcai)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">模块<span class="number">1</span></div><div class="line">我是 模块<span class="number">1</span></div><div class="line">&lt;hm_01_测试模块<span class="number">1.</span>Dog object at <span class="number">0x000001ACD3C14F98</span>&gt;</div></pre></td></tr></table></figure>
<p>但是这种方法不建议使用，因为一旦出现函数重名，就会出问题。</p>
<h2 id="模块的搜索顺序">模块的搜索顺序</h2>
<p>当Python解释器导入一个模块时，它会遵循一定的规则来搜索相应的导入顺序：</p>
<ol style="list-style-type: decimal">
<li>搜索<strong>当前目录</strong>指模块名的文件，如果有就直接导入；</li>
<li>如果没有，再搜索<strong>系统目录</strong>。</li>
</ol>
<p>在Python中，每一个模块都有一个内置属性<code>__file__</code>可以查看模块的<strong>完整路径</strong>。</p>
<p>当我们在实际开发时，给文件取名时，<strong>不要和系统的模块文件重名</strong>。</p>
<p>来看一个案例，这个代码文件我们命名为<code>hm_08_模块的搜索顺序.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="comment"># 生成一个 0 ~ 10的数字</span></div><div class="line">rand = random.randint(<span class="number">0</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">print(rand)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>当我们运行上面的代码时，<code>Python解释器</code>会加载系统目录中下的<code>random.py</code>模块。如果我们在当前目录下也有一个<code>random.py</code>文件，那么上面的代码就不会运行，此时我们在这个文件的同一个目录下新建一个<code>random.py</code>文件，输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"Hello, python"</span>)</div></pre></td></tr></table></figure>
<p>现在这个文件夹下的所有文件如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190608155733.png">

</div>
<p>再次运行前面的那个代码，也就是<code>hm_08_模块的搜索顺序.py</code>文件，就出现了错误，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Hello, python</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:\netdisk\bioinfo.notes\Python\黑马教程笔记\模块\hm_08_模块的搜索顺序.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    rand = random.randint(<span class="number">0</span>, <span class="number">10</span>)</div><div class="line">AttributeError: module <span class="string">'random'</span> has no attribute <span class="string">'randint'</span></div></pre></td></tr></table></figure>
<p>错误信息显示，<code>random.py</code>这个模块不含有<code>randint</code>函数。这是因为当前目录下已经有了<code>random.py</code>这个文件，Python解释器就不再导入系统目录中的<code>random.py</code>这个模块。</p>
<p>这里还需要注意的是，当我们导入了<code>random.py</code>这个模块时，它的内容<code>Hello, python</code>也被显示了出来，这个后面我们会再次提到，这里先放下。</p>
<p>现在我们来查看一下这个<code>random.py</code>到底是哪个，就用到了<code>__file__</code>这个属性，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">print(random.__file__)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, python</div><div class="line">D:\netdisk\bioinfo.notes\Python\黑马教程笔记\模块\random.py</div></pre></td></tr></table></figure>
<p>从结果我们可以看出来，这个<code>random.py</code>文件来源于<code>D:\netdisk\bioinfo.notes\Python\黑马教程笔记\模块\</code>这个目录。</p>
<p>现在我们把当前目录的<code>random.py</code>这个文件删除，再运行代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Anaconda3\lib\random.py</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，现在<code>random.py</code>这个文件来源于<code>C:\Anaconda3\lib\random.py</code>这个目录。</p>
<h2 id="模块的开发原则">模块的开发原则</h2>
<p>一个独立的Python文件就是一个模块，因此每一个我们写的Python文件都应该是可以被导入的。在实际工作中，当我们每开发一个Python时，它都可以被导入，这样就会极大地提高工作效率。</p>
<p>当一个Python被当作模块被导入时，这个Python文件中<strong>所有没有任何缩进的代码都会被执行一遍</strong>。现在我们来说明一下这句话是什么意思。</p>
<p>现在我们在一个目录中新建一个文件，命名为<code>hm_09_name模块.py</code>，输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"小明开发的模块"</span>)</div></pre></td></tr></table></figure>
<p>在同一个目录中再新建一个文件，命名为<code>hm_10_name测试导入.py</code>，输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hm_09_name模块</div><div class="line"></div><div class="line">print(<span class="string">"-"</span> * <span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>现在我们运行<code>hm_10_name测试导入.py</code>文件，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">小明开发的模块</div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>从结果中我们可以知道以下信息：</p>
<ol style="list-style-type: decimal">
<li><code>hm_10_name测试导入.py</code>文件导入了<code>hm_09_name模块.py</code>这个模块后，<code>hm_09_name模块.py</code>中的代码<code>print(&quot;小明开发的模块&quot;)</code>就自动执行了；</li>
<li>根据我们前面提到的内容，也就是“当一个Python被当作模块被导入时，这个Python文件中<strong>所有没有任何缩进的代码都会被执行一遍</strong>”这句话，因为在<code>hm_09_name模块.py</code>中，<code>print(&quot;小明开发的模块&quot;)</code>这句话前面是没有空格的，它就被自动执行了，现在我们改变一下代码，如下所示：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"你好，我是Say hello函数"</span>)</div><div class="line"></div><div class="line"></div><div class="line">print(<span class="string">"小明开发的模块"</span>)</div><div class="line">say_hello()</div></pre></td></tr></table></figure>
<p>再次运行<code>hm_10_name测试导入.py</code>文件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">小明开发的模块</div><div class="line">你好，我是Say hello函数</div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>从结果中我们还可以发现，<code>say_hello()</code>这个函数前面也是没有空格的，也被自动执行了。但是，我们想要的最终结果中时，不想让它执行，这就涉及到Python的<code>__name__</code>属性。</p>
<h3 id="name__属性"><code>__name__</code>属性</h3>
<p><code>__name__</code>是Python的一个内置属性，记录着一个字符串，如果<strong>一个Python是被其他文件导入的</strong>，<code>__name__</code>就是模块名，如果是<strong>当前执行的程序</strong>，<code>__name__</code>就是<code>__main__</code>。</p>
<p>现在看一下前面的案例，解释一下上面的这段话是什么意思。</p>
<p>在<code>hm_09_name模块.py</code>中输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"你好，我是Say hello函数"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 如果直接执行这个模块，那么__name__就是_main__</span></div><div class="line">print(__name__)</div><div class="line">print(<span class="string">"小明开发的模块"</span>)</div><div class="line">say_hello()</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__main__</div><div class="line">小明开发的模块</div><div class="line">你好，我是Say hello函数</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，<code>hm_09_name模块.py</code>这个模块中的<code>print(__name__)</code>输出的结果是<code>__main__</code>。</p>
<p>现在我们执行<code>hm_10_name测试导入.py</code>这个文件，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hm_09_name模块</div><div class="line">小明开发的模块</div><div class="line">你好，我是Say hello函数</div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，执行<code>hm_10_name测试导入.py</code>这个文件，<code>print(__name__)</code>输出的结果是<code>hm_09_name模块</code>。</p>
<p>从上面的结果我们就可以知道了前面那段话的意思：</p>
<blockquote>
<p><code>__name__</code>是Python的一个内置属性，记录着一个字符串，如果一个Python是被其他文件导入的，<code>__name__</code>就是模块名，如果是<strong>当前执行的程序</strong>，<code>__name__</code>就是<code>__main__</code>。</p>
</blockquote>
<p>那么如果我们想要这样的一个目的：怎么样才能做到，模块测试的代码（也就是<code>print(&quot;小明开发的模块&quot;)</code>和<code>say_hello()</code>这两句代码）只有在执行模块时才会被运行？</p>
<p>那么我们就需要先判断<code>__name__</code>这个属性内容，如果<code>__name__</code>的内容是<code>__main__</code>，就说明我们当前在执行这个模块。因此我们可以在<code>hm_09_name模块.py</code>中添加一个段if语句来判断<code>__name__</code>内容，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"你好，我是Say hello函数"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    print(__name__)</div><div class="line">    print(<span class="string">"小明开发的模块"</span>)</div><div class="line">    say_hello()</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__main__</div><div class="line">小明开发的模块</div><div class="line">你好，我是Say hello函数</div></pre></td></tr></table></figure>
<p>现在我们再切换到<code>hm_10_name测试导入.py</code>中，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hm_09_name模块</div><div class="line"></div><div class="line">print(<span class="string">"-"</span> * <span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>代码运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>现在<code>hm_10_name测试导入.py</code>就不再运行原来的些内容了。原来的运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hm_09_name模块</div><div class="line">小明开发的模块</div><div class="line">你好，我是Say hello函数</div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>对比一下两者的运行结果，就明白了。这里我们再说一下，如果在网络上查找一些Python原代码文件，有的时候会看到以下这样的格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 导入模块</span></div><div class="line"><span class="comment"># 定义全局变量</span></div><div class="line"><span class="comment"># 定义类</span></div><div class="line"><span class="comment"># 定义函数</span></div><div class="line"></div><div class="line"><span class="comment"># 在代码的最下文</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="comment"># 根据 __name__判断是否执行下方代码</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>如果出现了这样格式的代码，就说明了这样的代码不仅能够作为一个独立文件进行测试，还可以被当作模块导入其它的文件中。</p>
<h2 id="包">包</h2>
<h3 id="包的概念">包的概念</h3>
<p>包是一个包含多个模块的特殊目录，在这个目录下有一个特殊的文件，命名为<code>__init__.py</code>，包的命名方式和变量一致，通常是<code>小写字母_xxxx</code>。</p>
<p>使用包的好处就是，可以通过<code>import包名</code>这样的方式一次性导入包中<strong>所有的模块</strong>。</p>
<h3 id="案例使用">案例使用</h3>
<p>现在来演示一下包，需求如下：</p>
<ol style="list-style-type: decimal">
<li>新建一个<code>hm_message</code>的包；</li>
<li>在目录下，新建两个文件<code>send_message</code>和<code>receive_message</code>；</li>
<li>在<code>send_message</code>文件中定义一个<code>send</code>函数；</li>
<li>在<code>receive_message</code>文件中定义一个<code>receive</code>函数；</li>
<li>在外部直接导入<code>hm_message</code>包。</li>
</ol>
<h4 id="第一步新建一个包目录">第一步：新建一个包目录</h4>
<p>在PyCharm中单右键，新建一个<code>Directory</code>，命名为<code>hm_message</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190609135109.png">

</div>
<p>新建后的包如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190609135218.png">

</div>
<h4 id="第二步在包中新建一个__init__.py文件">第二步：在包中新建一个<code>__init__.py</code>文件</h4>
<p>包中必须要包含一个<code>__init__.py</code>文件，因此要在包这个目录上单击右键，新建一个python文件，取名为<code>__init__.py</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190609135425.png">

</div>
<p>现在我们已经创建了一个包的基本结构。现在删除这个包，看另外一种创建包的方式。那就是右键，新建<code>Python Package</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190609135621.png">

</div>
<p>这样的话，PyCharm就能自动创建一个<code>__init__.py</code>文件。</p>
<h4 id="第三步创建相应的python文件">第三步：创建相应的Python文件</h4>
<p>由于我们在需求中提到以下内容：</p>
<ol style="list-style-type: decimal">
<li>新建一个<code>hm_message</code>的包；</li>
<li>在目录下，新建两个文件<code>send_message</code>和<code>receive_message</code>；</li>
<li>在<code>send_message</code>文件中定义一个<code>send</code>函数；</li>
<li>在<code>receive_message</code>文件中定义一个<code>receive</code>函数；</li>
<li>在外部直接导入<code>hm_message</code>包。</li>
</ol>
<p>现在新建<code>send_message.py</code>文件与<code>receive_message.py</code>文件，现在在<code>send_message.py</code>文件中输入以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(text)</span>:</span></div><div class="line">    print(<span class="string">"正在发达 %s..."</span> % text)</div></pre></td></tr></table></figure>
<p>这样我们就在<code>send_message.py</code>文件中就定义了<code>send()</code>这个函数。</p>
<p>现在在<code>receive_message.py</code>文件中输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"这是来自于 10xxx的 短信"</span></div></pre></td></tr></table></figure>
<p>这样我们就在<code>receive_message.py</code>中创建了<code>receive()</code>这个函数。</p>
<h4 id="第四步写入__init__.py文件">第四步：写入<code>__init__.py</code>文件</h4>
<p>如果想让上述的包<code>hm_message</code>能够顺利地被其他文件所调用，那么我们还需要更改一下<code>__init__.py</code>文件，输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> . <span class="keyword">import</span> send_message</div><div class="line"><span class="keyword">from</span> . <span class="keyword">import</span> receive_message</div></pre></td></tr></table></figure>
<p>这个代码表示在<code>__init__.py</code>中导入<code>send_message.py</code>和<code>receive_message.py</code>文件。</p>
<p>现在我们新建一个Python文件，命名为<code>hm_11_导入包.py</code>，导入这个包试一下，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hm_message</div><div class="line"></div><div class="line">hm_message.send_message.send(<span class="string">"Hello"</span>)</div><div class="line">txt = hm_message.receive_message.receive()</div><div class="line">print(txt)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">正在发达 Hello...</div><div class="line">这是来自于 <span class="number">10</span>xxx的 短信</div></pre></td></tr></table></figure>
<p>上述过程就是创建一个包，并且调用的过程，需要注意的就是包(package)中<code>__init__.py</code>文件的书写。</p>
<h2 id="发布模块">发布模块</h2>
<p>如果希望自己开发的模块分享给其他的人，那么就需要按以下步骤操作即可。</p>
<h3 id="制作发布压缩包的步骤">制作发布压缩包的步骤</h3>
<p>现在我们把前面的那个包<code>hm_message</code>制作成一个可以分享的压缩包。</p>
<p>我们先新建一个<code>New Project</code>，命名为<code>12_发布模块</code>，现在把原来的那个包文件复制到这个目录中去，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190609142314.png">

</div>
<h4 id="第一步制作setup.py文件">第一步：制作setup.py文件</h4>
<p>新建一个<code>setup.py</code>文件，这个文件的内容非常固定，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</div><div class="line"></div><div class="line">setup(name=<span class="string">"hm_message"</span>,  <span class="comment"># 包名</span></div><div class="line">      version=<span class="string">"1.0"</span>,  <span class="comment"># 版本</span></div><div class="line">      description=<span class="string">"itheima's 发送和接收消息模块"</span>,  <span class="comment"># 描述信息</span></div><div class="line">      long_description=<span class="string">"完整的发送和接收消息模块"</span>,  <span class="comment"># 完整描述信息</span></div><div class="line">      author=<span class="string">"itheima"</span>,  <span class="comment"># 作者</span></div><div class="line">      author_email=<span class="string">"itheima@itheima.com"</span>,  <span class="comment"># 作者邮箱</span></div><div class="line">      url=<span class="string">"www.itheima.com"</span>,  <span class="comment"># 主页</span></div><div class="line">      py_modules=[<span class="string">"hm_message.send_message"</span>,</div><div class="line">                  <span class="string">"hm_message.receive_message"</span>])</div></pre></td></tr></table></figure>
<p><code>setup()</code>这个函数接收的参数是多值字典参数，即<code>**attrs</code>。`</p>
<p><code>setup（）</code>中有包的名称，版本，作者等等信息。最后一行是<code>py_modules</code>信息，这是一个列表，列表里面是这个包的不同模块名称。</p>
<h4 id="第二步构建模块">第二步：构建模块</h4>
<p>现在通过命令行进入模块所在的目录，输入<code>python setup.py build</code>，运行后的结果如下所示：</p>
<p>注意：这是在Windows下的cmd命令行运行的，不是在Linux环境下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">D:\netdisk\bioinfo.notes\Python\黑马教程笔记\12_发布模块&gt;python setup.py build</div><div class="line">running build</div><div class="line">running build_py</div><div class="line">creating build</div><div class="line">creating build\lib</div><div class="line">creating build\lib\hm_message</div><div class="line">copying hm_message\__init__.py -&gt; build\lib\hm_message</div><div class="line">copying hm_message\send_message.py -&gt; build\lib\hm_message</div><div class="line">copying hm_message\receive_message.py -&gt; build\lib\hm_message</div></pre></td></tr></table></figure>
<p>输入<code>tree</code>命名，查看文件目录，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">D:\netdisk\bioinfo.notes\Python\黑马教程笔记\<span class="number">12</span>_发布模块&gt;tree</div><div class="line">Folder PATH listing <span class="keyword">for</span> volume 新加卷</div><div class="line">Volume serial number <span class="keyword">is</span> C0C6<span class="number">-2E4</span>F</div><div class="line">D:.</div><div class="line">├───.idea</div><div class="line">│   └───dictionaries</div><div class="line">├───build</div><div class="line">│   └───lib</div><div class="line">│       └───hm_message</div><div class="line">└───hm_message</div><div class="line">    └───__pycache__</div></pre></td></tr></table></figure>
<h4 id="第三步生成发布压缩包">第三步：生成发布压缩包</h4>
<p>执行<code>python setup.py sdist</code>命名，回车，所示信息如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">D:\netdisk\bioinfo.notes\Python\黑马教程笔记\<span class="number">12</span>_发布模块&gt;python setup.py sdist</div><div class="line">running sdist</div><div class="line">running check</div><div class="line">warning: sdist: manifest template <span class="string">'MANIFEST.in'</span> does <span class="keyword">not</span> exist (using default file list)</div><div class="line"></div><div class="line">warning: sdist: standard file <span class="keyword">not</span> found: should have one of README, README.txt</div><div class="line"></div><div class="line">writing manifest file <span class="string">'MANIFEST'</span></div><div class="line">creating hm_message<span class="number">-1.0</span></div><div class="line">creating hm_message<span class="number">-1.0</span>\hm_message</div><div class="line">making hard links <span class="keyword">in</span> hm_message<span class="number">-1.0</span>...</div><div class="line">hard linking setup.py -&gt; hm_message-1.0</div><div class="line">hard linking hm_message\__init__.py -&gt; hm_message-1.0\hm_message</div><div class="line">hard linking hm_message\receive_message.py -&gt; hm_message-1.0\hm_message</div><div class="line">hard linking hm_message\send_message.py -&gt; hm_message-1.0\hm_message</div><div class="line">creating dist</div><div class="line">Creating tar archive</div><div class="line">removing <span class="string">'hm_message-1.0'</span> (<span class="keyword">and</span> everything under it)</div></pre></td></tr></table></figure>
<p>输入<code>tree</code>命名，再次查看目录信息，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">D:\netdisk\bioinfo.notes\Python\黑马教程笔记\<span class="number">12</span>_发布模块&gt;tree</div><div class="line">Folder PATH listing <span class="keyword">for</span> volume 新加卷</div><div class="line">Volume serial number <span class="keyword">is</span> C0C6<span class="number">-2E4</span>F</div><div class="line">D:.</div><div class="line">├───.idea</div><div class="line">│   └───dictionaries</div><div class="line">├───build</div><div class="line">│   └───lib</div><div class="line">│       └───hm_message</div><div class="line">├───dist</div><div class="line">└───hm_message</div><div class="line">    └───__pycache__</div></pre></td></tr></table></figure>
<p>可以发现，又出现了一个<code>dist</code>目录，输入<code>tree /f</code>命令查看整个目录下的内容，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">D:\netdisk\bioinfo.notes\Python\黑马教程笔记\<span class="number">12</span>_发布模块&gt;tree /f</div><div class="line">Folder PATH listing <span class="keyword">for</span> volume 新加卷</div><div class="line">Volume serial number <span class="keyword">is</span> <span class="number">000001E9</span> C0C6:<span class="number">2E4</span>F</div><div class="line">D:.</div><div class="line">│   MANIFEST</div><div class="line">│   setup.py</div><div class="line">│</div><div class="line">├───.idea</div><div class="line">│   │   <span class="number">12</span>_发布模块.iml</div><div class="line">│   │   misc.xml</div><div class="line">│   │   modules.xml</div><div class="line">│   │   workspace.xml</div><div class="line">│   │</div><div class="line">│   └───dictionaries</div><div class="line">│           <span class="number">20161111.</span>xml</div><div class="line">│</div><div class="line">├───build</div><div class="line">│   └───lib</div><div class="line">│       └───hm_message</div><div class="line">│               receive_message.py</div><div class="line">│               send_message.py</div><div class="line">│               __init__.py</div><div class="line">│</div><div class="line">├───dist</div><div class="line">│       hm_message<span class="number">-1.0</span>.tar.gz</div><div class="line">│</div><div class="line">└───hm_message</div><div class="line">    │   receive_message.py</div><div class="line">    │   send_message.py</div><div class="line">    │   __init__.py</div><div class="line">    │</div><div class="line">    └───__pycache__</div><div class="line">            receive_message.cpython<span class="number">-36.</span>pyc</div><div class="line">            send_message.cpython<span class="number">-36.</span>pyc</div><div class="line">            __init__.cpython<span class="number">-36.</span>pyc</div></pre></td></tr></table></figure>
<p>我们可以发现，dist目录下面有一个压缩文件，也就是<code>hm_message-1.0.tar.gz</code>，至此，发布包的任务完成。</p>
<h3 id="安装模块">安装模块</h3>
<p>视频中的安装过程是在Linux环境下的，下面只输入安装包的命令，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cp <span class="number">12</span>_发布模块/dist/*. <span class="comment"># 复制dist目录下所有的压缩文件到当前目录</span></div><div class="line">tar zxvf hm_message<span class="number">-1.0</span>.tar.gz <span class="comment"># 解压</span></div><div class="line"><span class="comment"># 解压后的文件中有一个PKG-INFO文件，这个文件里面记录了Python包的一些信息，其实就是package-information的缩写</span></div><div class="line">sudo python setup.py install <span class="comment"># 安装模块</span></div><div class="line"><span class="comment"># 这一步的包会被安装的python的系统目录</span></div></pre></td></tr></table></figure>
<h3 id="卸载模块">卸载模块</h3>
<p>进入模块所在的目录，使用<code>rm</code>删除即可。</p>
<p>这个时候，如果要查看这个模块所有的上当，就需要查看一下<code>__file__</code>文件即可。</p>
<h3 id="pip安装第三方模块">pip安装第三方模块</h3>
<p>第三方椟通常是指由知名的第三方团队开发的并且被程序员广泛使用的Python包/模块。例如pygame就是一套非常成熟的游戏开发模块。</p>
<p>pip是一个通过的Python包管理工作，它提供到了对Python包的查找、下载、安装、卸载等功能。</p>
<h4 id="pip安装和卸载命令如下">pip安装和卸载命令如下：</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ubuntu环境</span></div><div class="line"><span class="comment"># 安装python3环境的pip</span></div><div class="line">sudo pip3 install pygame</div><div class="line"></div><div class="line"><span class="comment">#卸载pip</span></div><div class="line">sudo pip3 uninstall pygame</div><div class="line"></div><div class="line"><span class="comment"># Linux环境安装ipython</span></div><div class="line">sudo apt install ipython3</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/16/Python/Python学习笔记（15）-异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/Python/Python学习笔记（15）-异常/" itemprop="url">Python学习笔记（15）-黑马教程-异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T12:00:00+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,682
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="异常的概念">异常的概念</h2>
<p>程序在运行时，如果<code>Python解释器</code>遇到了一个错误，Python解释器就会停止程序的执行，并且提示一些错误信息，这就是<strong>异常</strong>。</p>
<p>程序停止执行并提示错误信息的这个动作我们称之为<strong>抛出异常</strong>。</p>
<p>现在我们来了解一下Python为什么会抛出异常，看一个简单的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">6</span>]: num = int(input(<span class="string">"请输入一个数字  "</span>))</div><div class="line">请输入一个数字  a</div><div class="line">---------------------------------------------------------------------------</div><div class="line">ValueError                                Traceback (most recent call last)</div><div class="line">&lt;ipython-input<span class="number">-6</span>-f1f596245a67&gt; <span class="keyword">in</span> &lt;module&gt;()</div><div class="line">----&gt; 1 num = int(input("请输入一个数字  "))</div><div class="line"></div><div class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'a'</span></div></pre></td></tr></table></figure>
<p>在这个案例中，我们先输入了一段代码，用于接收用户输入的整数，即<code>num = int(input(&quot;请输入一个数字  &quot;))</code>，但是当我们输入了一个<code>a</code>后，Python的解释器就报错了，并且解释器提示，输入的这个<code>a</code>无法用于<code>int()</code>函数，它只支持10进行的转换，这就是抛出异常。这说明，即使我们输入的是一段在语法上正确的代码，但是它在执行上还有可能报错的，因为我们无法判断用户在输入内容上，用户输入的是一个数字还是字母。</p>
<p>因此当我们面临类似的情况时，我们就需要处理这种特殊情况，我们看一下示意图：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190607220308.png">

</div>
<p>从示意图上我们可以知道，当程序遇到错误时，会抛出异常，这个异常就是我们在设计程序时需要考虑到的情况，这种情况是抛给最初设计程序的程序员的，程序员会针对这种情况输出一定的反馈信息，例如，我们设计程序时，如果有输入性别的选项，有人输入了一个数字，那么就是错误的，程序需要针对这种情况提前设计相应的反馈信息。</p>
<h2 id="捕获异常语法">捕获异常语法</h2>
<p>在程序开发中，如果对某些代码执行不能确定是否正确，可以增加<code>try</code>来捕获异常，捕获异常最简单的语法格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    尝试执行的代码</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    出现错误的处理</div></pre></td></tr></table></figure>
<p>这里解释一下：<code>try</code>是指下方编写要尝试执行的代码，也就是那些<strong>不确定是否能够正常执行的代码</strong>。<code>except</code>指的是，<code>try</code>下方执行失败后，需要执行哪些代码。</p>
<h3 id="捕获异常的案例">捕获异常的案例</h3>
<p>现在还是看前面的那个案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">num = int(input(<span class="string">"请输入一个整数： "</span>))</div></pre></td></tr></table></figure>
<p>现在我们输入一个<code>4</code>，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请输入一个整数： <span class="number">4</span></div></pre></td></tr></table></figure>
<p>这种情况下，程序运行是正常的，现在我们输入一个<code>a</code>，程序运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">请输入一个整数： a</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_01_简单的异常捕获.py"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    num = int(input(<span class="string">"请输入一个整数： "</span>))</div><div class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'a'</span></div></pre></td></tr></table></figure>
<p>程序运行出错。</p>
<p>上面还是原来的内容，现在我们使用<code>try...except...</code>语法实现一下类似的功能，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    num = int(input(<span class="string">"请输入一个整数： "</span>))</div><div class="line"></div><div class="line"><span class="keyword">except</span>:</div><div class="line">    print(<span class="string">"请输入正确的整数： "</span>)</div><div class="line"></div><div class="line">print(<span class="string">"-"</span> *<span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>现在我们输入一个<code>4</code>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入一个整数： <span class="number">4</span></div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>现在我们输入一个<code>a</code>，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">请输入一个整数： a</div><div class="line">请输入正确的整数： </div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>现在我们发现了，<code>except</code>下面的代码得到了执行。并且两种情况下，最后一行代码，也就是<code>print(&quot;-&quot; * 50)</code>的执行不受影响。</p>
<h2 id="错误类型的捕获">错误类型的捕获</h2>
<p>在程序执行时，可能遇到<strong>不同类型的异常</strong>，并且需要<strong>针对不同类型的异常，做出不同的响应</strong>，这个时候就需要捕获错误类型了，这种情况下的语法格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 尝试执行的代码</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</div><div class="line">    <span class="comment"># 针对错误类型1，对应的代码处理</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="keyword">except</span> (错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</div><div class="line">    <span class="comment"># 针对错误类型2和3，对应的代码处理</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</div><div class="line">    print(<span class="string">"未知错误 %s"</span> % result)</div></pre></td></tr></table></figure>
<p>当<code>Python</code>解释器抛出异常时，最后一行错误信息的第一个单词，就是错误类型。</p>
<h3 id="异常类型捕获案例">异常类型捕获案例</h3>
<p>我们还以前面的让用户输入整数的案例为例说明一下：</p>
<p>这个程序的需求为：①提示用户输入一个整数；②使用<code>8</code>这个整数除以刚刚用户输入的整数并输出，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 提示用户输入一个整数</span></div><div class="line">num = int(input(<span class="string">"输入一个整数： "</span>))</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 使用 8 除以用户输入的整数并输入</span></div><div class="line">result = <span class="number">8</span>/num</div><div class="line">print(result)</div></pre></td></tr></table></figure>
<p>现在我们输入一个<code>10</code>，看一下运行结果，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入一个整数： <span class="number">10</span></div><div class="line"><span class="number">0.8</span></div></pre></td></tr></table></figure>
<p>现在我们再输入一个字母<code>a</code>，我们看一下结果，结果会出错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入一个整数： a</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_02_捕获错误类型.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    num = int(input(<span class="string">"输入一个整数： "</span>))</div><div class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'a'</span></div></pre></td></tr></table></figure>
<p>但是，这个程序还有可能在<code>num</code>这个地方出错，因为如果用户输入的是一个<code>0</code>，那么<code>result = 8 / num</code>中除数就是0了，没有意义，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入一个整数： <span class="number">0</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_02_捕获错误类型.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    result = <span class="number">8</span>/num</div><div class="line">ZeroDivisionError: division by zero</div></pre></td></tr></table></figure>
<p>因此针对上面的这些情况，我们都要考虑到这些异常的具体情况，针对每一种具体情况来进行设计。</p>
<p>现在我们还需要了解一点就是，我们如何知道错误类型，前面我们提到，当Python解释器抛出异常时，最后一行错误信息的第一个单词，就是错误类型，现在我们具体的来看一下：</p>
<p>前面的2种错误的第一个单词分别是<code>ValueError</code>和<code>ZeroDivisionError</code>，这就是错误类型，现在我们将这个错误类型添加到代码中，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 提示用户输入一个整数</span></div><div class="line">    num = int(input(<span class="string">"输入一个整数： "</span>))</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 使用 8 除以用户输入的整数并输入</span></div><div class="line">    result = <span class="number">8</span>/num</div><div class="line">    print(result)</div><div class="line"></div><div class="line"><span class="keyword">except</span> ZeroDivisionError:</div><div class="line">    print(<span class="string">"除0错误"</span>)</div></pre></td></tr></table></figure>
<p>运行代码，我们输入一个<code>0</code>，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入一个整数： <span class="number">0</span></div><div class="line">除<span class="number">0</span>错误</div></pre></td></tr></table></figure>
<p>当我们添加了这些代码后，Python解释器就会抛出异常了。</p>
<p>现在我们再来设计针对输入字母这种情况，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 提示用户输入一个整数</span></div><div class="line">    num = int(input(<span class="string">"输入一个整数： "</span>))</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 使用 8 除以用户输入的整数并输入</span></div><div class="line">    result = <span class="number">8</span>/num</div><div class="line">    print(result)</div><div class="line"></div><div class="line"><span class="keyword">except</span> ZeroDivisionError:</div><div class="line">    print(<span class="string">"除0错误"</span>)</div><div class="line"></div><div class="line"><span class="keyword">except</span> ValueError:</div><div class="line">    print(<span class="string">"输入的不是整数"</span>)</div></pre></td></tr></table></figure>
<p>现在我们运行代码，输入一个字母<code>a</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入一个整数： a</div><div class="line">输入的不是整数</div></pre></td></tr></table></figure>
<p>这个案例说明了针对不止一种错误类型的处理方式。</p>
<h3 id="捕获未知错误">捕获未知错误</h3>
<p>在开发中，我们要预判到所有可能出现的错误有一定难度。如果希望程序无论出现任何错误，都<strong>不会因为Python解释器抛出异常而被终止</strong>，我们可能再增加一个except，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</div><div class="line">    print(<span class="string">"未知错误 %s"</span> % result)</div></pre></td></tr></table></figure>
<p>现在我们把前面的案例中的那个除数为0的错误删除，使用这种未知错误来写一下，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 提示用户输入一个整数</span></div><div class="line">    num = int(input(<span class="string">"输入一个整数： "</span>))</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 使用 8 除以用户输入的整数并输入</span></div><div class="line">    result = <span class="number">8</span>/num</div><div class="line">    print(result)</div><div class="line"></div><div class="line"><span class="keyword">except</span> ValueError:</div><div class="line">    print(<span class="string">"输入的不是整数"</span>)</div><div class="line"></div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</div><div class="line">    print(<span class="string">"未知错误 %s"</span> % result)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入一个整数： <span class="number">0</span></div><div class="line">未知错误 division by zero</div></pre></td></tr></table></figure>
<p>因此，在捕获异常时，最好在最后加上这么这么一句，即<code>except Exception as result:</code>，其中<code>Exception</code>是Python是有关错误的一个类。</p>
<h2 id="异常捕获的完整语法">异常捕获的完整语法</h2>
<p>在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 尝试执行的代码</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</div><div class="line">    <span class="comment"># 针对错误类型1，对应的代码处理</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="keyword">except</span> 错误类型<span class="number">2</span>:</div><div class="line">    <span class="comment"># 针对错误类型2，对应的代码处理</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="keyword">except</span> (错误类型<span class="number">3</span>，错误类型<span class="number">4</span>):</div><div class="line">    <span class="comment"># 针对错误类型3和4，对应的代码处理</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</div><div class="line">    <span class="comment"># 打印错误信息</span></div><div class="line">    print(result)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="comment"># 没有异常才会执行的代码</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="comment"># 无论是否有异常，都会执行的代码</span></div><div class="line">    print(<span class="string">"无论是否有异常，都会执行的代码"</span>)</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>else</code>只有在没有异常时才会执行的代码；</li>
<li><code>finally</code>无论是否有异常，都会执行的代码。</li>
</ul>
<p>现在我们求救一下前面案例的<strong>完整捕获异常</strong>，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 提示用户输入一个整数</span></div><div class="line">    num = int(input(<span class="string">"输入一个整数： "</span>))</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># 使用 8 除以用户输入的整数并输入</span></div><div class="line">    result = <span class="number">8</span>/num</div><div class="line">    print(result)</div><div class="line"></div><div class="line"><span class="keyword">except</span> ValueError:</div><div class="line">    print(<span class="string">"输入的不是整数"</span>)</div><div class="line"></div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</div><div class="line">    print(<span class="string">"未知错误 %s"</span> % result)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">"尝试成功"</span>)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    print(<span class="string">"无论是否出现错误，都会执行的代码"</span>)</div><div class="line"></div><div class="line">print(<span class="string">"-"</span> * <span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>现在我们输入数字<code>1</code>，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入一个整数： <span class="number">1</span></div><div class="line"><span class="number">8.0</span></div><div class="line">尝试成功</div><div class="line">无论是否出现错误，都会执行的代码</div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，在没有错误出现的情况下，<code>else</code>与<code>finally</code>下面的代码都得到了执行。</p>
<p>现在我们输入数字<code>0</code>，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">输入一个整数： <span class="number">0</span></div><div class="line">未知错误 division by zero</div><div class="line">无论是否出现错误，都会执行的代码</div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，在出现错误出现的情况下，<code>else</code>下面的代码<strong>不执行</strong>，直接输出异常情况下的错误信息，并且<code>finally</code>下面的代码也得到了执行，因为<code>finally</code>下面的代码无论什么情况下都会执行，并且最后一行的代码<code>print(&quot;-&quot; * 50)</code>也得到了执行，因为抛出异常的完整代码部分就是从<code>try</code>开始，到<code>finally</code>结束，之后的代码就都正常执行了。</p>
<h2 id="异常的传递">异常的传递</h2>
<p>异常的传递是指，当<strong>函数/方法</strong>执行出现异常时，会将异常传递给函数/方法的调用一方，此时程序还不会被终止，如果传递到主程序，仍然没有异常处理，这个时候，程序才会被终止。</p>
<p>现在我们来验证一下异常的传递，先来看一下需求：</p>
<ol style="list-style-type: decimal">
<li>定义函数<code>demo1()</code>，提示用户输入一个整数并且返回；</li>
<li>定义函数<code>demo2()</code>，调用<code>demo1()</code>；</li>
<li>在主程序中调用<code>demo2()</code>。</li>
</ol>
<p>完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> int(input(<span class="string">"输入整数： "</span>))</div><div class="line"></div><div class="line">print(demo1())</div></pre></td></tr></table></figure>
<p>运行程序，我们输入一个<code>1</code>，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入整数： <span class="number">1</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>程序运行正常。现在我们输入一个字母<code>a</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入整数： a</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_05_异常的传递.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    print(demo1())</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_05_异常的传递.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> demo1</div><div class="line">    <span class="keyword">return</span> int(input(<span class="string">"输入整数： "</span>))</div><div class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'a'</span></div></pre></td></tr></table></figure>
<p>程序报错，最下面的错误信息是<code>ValueError: invalid literal for int() with base 10: 'a'</code>，这是说明，输入的字母无法被<code>int()</code>函数识别。</p>
<p>我们再往上看，有<code>line 2, in demo1 return int(input(&quot;输入整数： &quot;))</code>字样，也就是说错误出现在了第2行，第2行在转换整数的时候出现了问题。但是，第2行代码出现问题的时候，会把异常交给第4行，也就是解释器出现的这个信息<code>line 4, in &lt;module&gt;     print(demo1())</code>。第4行代码是主程序，也就是<code>print(demo1())</code>，它是在调用第2行的函数，第2行代码本身是不做异常处理的，主程序中没有做异常处理，因此程序就终止了。</p>
<p>现在我们再改造一下原代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> int(input(<span class="string">"输入整数： "</span>))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> demo1()</div><div class="line"></div><div class="line"></div><div class="line">print(demo1())</div></pre></td></tr></table></figure>
<p>现在我们再输入一个字母<code>a</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">输入整数： a</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_05_异常的传递.py"</span>, line <span class="number">9</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    print(demo2())</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_05_异常的传递.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> demo2</div><div class="line">    <span class="keyword">return</span> demo1()</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_05_异常的传递.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> demo1</div><div class="line">    <span class="keyword">return</span> int(input(<span class="string">"输入整数： "</span>))</div><div class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'a'</span></div></pre></td></tr></table></figure>
<p>从错误信息中我们可以知道这些信息：</p>
<ol style="list-style-type: decimal">
<li>出错的代码还是第2行，提示demo1函数出现的问题；</li>
<li>错误信息往上，我们发现了第2行代码出错时，会把错误传递给第6行，因为第6行中的demo2()函数调用了demo1()函数，继续提示demo2出现了问题，但此时我们并没有在demo2内部针对异常进行处理，此时继续向上传递，传递到了第9行；</li>
<li>第9行传递到了主程序，也就是<code>print(deom2())</code>。</li>
</ol>
<p>从上面的结果我们可以知道，一旦出现异常，异常会一级一级向上传递，一直到主程序，直到主程序终止运行。</p>
<p>如果我们在实际设计程序中，如果在每一个函数中都设计异常处理，这样代码量会非常大，不现实。因此我们可以利用异常的传递性，可以在主程序中捕获异常即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> int(input(<span class="string">"输入整数： "</span>))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> demo1()</div><div class="line"></div><div class="line"><span class="comment"># 利用异常的传递性，在主程序捕获异常</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    print(demo2())</div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</div><div class="line">    print(<span class="string">"未知3错误 %s"</span> % result)</div></pre></td></tr></table></figure>
<p>现在运行程序，输入一个字母<code>a</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入整数： a</div><div class="line">未知错误 invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'a'</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，我们只在主程序中添加了异常捕获，就不用在每个函数中对异常进行捕获了。</p>
<p>现在总结一下，利用异常的传递性在开发程序中的好处：可以将精力放在函数的代码逻辑上，不用花太多精力放在异常捕获上，只要函数开发完成，就可以在主程序中添加异常捕获。</p>
<h2 id="抛出异常">抛出异常</h2>
<p>在开发中，除了代码执行出错，Python解释会自己抛出异常之外。我们还可以根据应用程序特有的功能来主动抛出异常，现在我们来看一个案例。</p>
<p>例如我们要添加一个用户登录模块，里面有一个函数，这个函数的功能是：提示用户输入密码，如果长度少于8，那么就抛出异常，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190607233243.png">

</div>
<p>这里需要注意的是，当前这个函数<strong>只负责</strong>提示用户输入密码，如果密码长度不正确，需要其他的函数进行额外处理。</p>
<h3 id="抛出异常-1">抛出异常</h3>
<p>Python中提供了一个<code>Exception</code>异常类。在开发时，如果满足特定功能需求时，希望抛出异常，可以做两件事情：</p>
<ol style="list-style-type: decimal">
<li>创建一个<code>Exception</code>的<strong>对象</strong>；</li>
<li>使用<code>raise</code>关键字抛出<strong>异常对象</strong>。</li>
</ol>
<p>我们来看一下前面案例的需求：</p>
<ol style="list-style-type: decimal">
<li>定义<code>input_password</code>函数，提示用户输入密码；</li>
<li>如果用户输入长度小于8，抛出异常；</li>
<li>如果用户输入长度大于等于8，返回输入的密码。</li>
</ol>
<p>现在来看一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_password</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 1. 提示用户输入密码</span></div><div class="line">    pwd = input(<span class="string">"请输入密码： "</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 2. 判断密码长度 &gt;= 8， 返回用户输入的密码</span></div><div class="line">    <span class="keyword">if</span> len(pwd) &gt;= <span class="number">8</span>:</div><div class="line">        <span class="keyword">return</span> pwd</div><div class="line"></div><div class="line">    <span class="comment"># 3. 如果密码 &lt; 8，主动抛出异常</span></div><div class="line">    print(<span class="string">"主动抛出异常"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 提示用户输入密码</span></div><div class="line">print(input_password())</div></pre></td></tr></table></figure>
<p>现在运行代码，我们输入12345678，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入密码： <span class="number">123456789</span></div><div class="line"><span class="number">123456789</span></div></pre></td></tr></table></figure>
<p>现在我们输入123，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">请输入密码： <span class="number">123</span></div><div class="line">主动抛出异常</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，输出了异常，并且还有一个<code>None</code>，这里为什么会输出<code>None</code>呢，这是因为在代码中，抛出异常时，并没有任何返回，所以就返回了<code>None</code>。</p>
<p>现在再更改一下代码，需要创建一个<code>Exception</code>类对象，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_password</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 1. 提示用户输入密码</span></div><div class="line">    pwd = input(<span class="string">"请输入密码： "</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 2. 判断密码长度 &gt;= 8， 返回用户输入的密码</span></div><div class="line">    <span class="keyword">if</span> len(pwd) &gt;= <span class="number">8</span>:</div><div class="line">        <span class="keyword">return</span> pwd</div><div class="line"></div><div class="line">    <span class="comment"># 3. 如果密码 &lt; 8，主动抛出异常</span></div><div class="line">    print(<span class="string">"主动抛出异常"</span>)</div><div class="line">    <span class="comment"># 第一步：创建异常对象</span></div><div class="line">    ex = Exception(<span class="string">"密码长度不够"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 第二步：主动抛出异常</span></div><div class="line">    <span class="keyword">raise</span> ex</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 提示用户输入密码</span></div><div class="line">print(input_password())</div></pre></td></tr></table></figure>
<p>运行结果，我们输入123，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">请输入密码： <span class="number">123</span></div><div class="line">主动抛出异常</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_06_抛出异常.py"</span>, line <span class="number">21</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    print(input_password())</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/异常/hm_06_抛出异常.py"</span>, line <span class="number">16</span>, <span class="keyword">in</span> input_password</div><div class="line">    <span class="keyword">raise</span> ex</div><div class="line">Exception: 密码长度不够</div></pre></td></tr></table></figure>
<p>从结果我们可以看出现，程序出错的代码在第16行，也就是<code>raise ex</code>这一句。根据异常的传递性，继续向上看，异常传递到第22行，也就是<code>print(input_password())</code>这一句，此时我们使用try来改一下这句，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_password</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 1. 提示用户输入密码</span></div><div class="line">    pwd = input(<span class="string">"请输入密码： "</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 2. 判断密码长度 &gt;= 8， 返回用户输入的密码</span></div><div class="line">    <span class="keyword">if</span> len(pwd) &gt;= <span class="number">8</span>:</div><div class="line">        <span class="keyword">return</span> pwd</div><div class="line"></div><div class="line">    <span class="comment"># 3. 如果密码 &lt; 8，主动抛出异常</span></div><div class="line">    print(<span class="string">"主动抛出异常"</span>)</div><div class="line">    <span class="comment"># 第一步：创建异常对象-可以使用错误信息字符串作为参数</span></div><div class="line">    ex = Exception(<span class="string">"密码长度不够"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 第二步：主动抛出异常</span></div><div class="line">    <span class="keyword">raise</span> ex</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 提示用户输入密码</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    print(input_password())</div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</div><div class="line">    print(result)</div></pre></td></tr></table></figure>
<p>继续运行，还是输入123，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">请输入密码： <span class="number">123</span></div><div class="line">主动抛出异常</div><div class="line">密码长度不够</div></pre></td></tr></table></figure>
<p>这一次我们就可以发现，运行正常。</p>
<p>在这个案例中我们其实就发现了，我们写了<code>Exception</code>这个类的对象，程序最终输出的结果就是我们定义的那个对象，即<code>ex = Exception(&quot;密码长度不够&quot;)</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/15/Python/Python学习笔记（14）-面向对象之多态和类属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/Python/Python学习笔记（14）-面向对象之多态和类属性/" itemprop="url">Python学习笔记（14）-黑马教程-面向对象之多态和类属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T12:00:00+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,620
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多态">多态</h2>
<h3 id="前言">前言</h3>
<p>面向对象的三大特征分别是：封装，继承，多态，如下所示：</p>
<ol style="list-style-type: decimal">
<li><p>封装是根据需求将属性和方法封装到一个抽象的类中</p></li>
<li><p>继承则能够实现代码的重用，相同的代码不需要重复编写；</p></li>
<li><p>多态：不同的子类对象调用相同的父类方法，产生不同的执行结果，多态的思路：</p></li>
</ol>
<ul>
<li>多态可以增加代码的灵活度</li>
<li>以继承和重写父类方法为前提</li>
<li>是调用方法的技巧，不会影响到类的内部设计</li>
</ul>
<p>示意图如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190523153900.png">

</div>
<p>在这个示意图中，假设我们定义了一个人类，然后从人类中派生出了程序员类与设计师类，而程序员类的工作产出了代码，设计师的工作产生了设计图，这两个类都有一个共同的父类，即人类，但他们的产出则不同。</p>
<p>在设计代码时，通常是先封装，有了封装后，等到代码比较复杂时，我们就会用到继承，产生各种子类，有些子类会继承自相同的父类，这就是多态，代码的灵活度就会增强。</p>
<h2 id="多态polymorphism">多态(Polymorphism)</h2>
<p>书中原文说的多态是指：术语多态（polymorphism）源自希腊语，意思是“有多种形态”。这大致意味着即便你不知道变量指向的是哪种对象，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异。</p>
<p>书中列举了几个案例，例如当你收到一个对象时，却根本不知道它是如何实现的，它就有可能是众多“多态”中的任何一种，例如当设计一个购物系统中，有一项功能是获取某个物品的价格，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>object.get_price()</div><div class="line"><span class="number">2.5</span></div></pre></td></tr></table></figure>
<p>像这样与对象属性相关联的函数称为方法，在常规的Python对象，例如字符串、列表或字典中也会见到这样的方法，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span>.count(<span class="string">'a'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>].count(<span class="string">'a'</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>就像上面的案例，如果有一个变量x，你需要知道它是字符串，还是列表，就能调用方法count，你只需要向这个方法提供一个字符作为参数，它就能正常运行，这就是多态的表现之一。下面再来做一个实验，标准库模块random包含一个名为choice的函数，它会从序列中随机选择一个元素，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> choice</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = choice([<span class="string">'Hello world!'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'e'</span>,<span class="string">'e'</span>,<span class="number">4</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x</div><div class="line"><span class="string">'Hello world!'</span></div></pre></td></tr></table></figure>
<p>x可能包含字符串`Hello, world!‘，也可能包含列表[1,2,‘e’,‘e’,4]，具体是哪一个，我们并不需要关心，我们只关心x包含多个e，而不管x是字符串还是列表，此时我们再调用count方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.count(<span class="string">'e'</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>从结果来看，x包括的应该是字符串（其实前面也显示了这个结果），但关键在于你无需执行相关的检查，只要x有一个名为count的方法，它将单个字符作为参数并返回一个整数就行。</p>
<h3 id="多态形式的多样性">多态形式的多样性</h3>
<p>每当无需知道对象是什么样时，就能对其进行操作时，就是多态在起作用。这不仅仅适用于方法，内置运算符和函数都大量使用了多态，可以看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Fish'</span> + <span class="string">'License'</span></div><div class="line"><span class="string">'FishLicense'</span></div></pre></td></tr></table></figure>
<p>上面的案例说明，<code>+</code>运算符即可以用于整数的加法，还可以用于字符串的连接，这就是多态的体现。</p>
<p>再看一个案例，如果要编写一个函数，通过打印一条消息来指出对象的长度，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_message</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">"The length of "</span>,repr(x), <span class="string">"is"</span>, len(x))</div><div class="line"></div><div class="line"></div><div class="line">length_message(<span class="string">'Fonrd'</span>)</div><div class="line">length_message([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>length_message(<span class="string">'Fonrd'</span>)</div><div class="line">The length of  <span class="string">'Fonrd'</span> <span class="keyword">is</span> <span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>length_message([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">The length of  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">is</span></div></pre></td></tr></table></figure>
<p>可以看出来，无论对象是列表，还是字符串，此函数都能运行。当使用多有态的函数和运算符时，多态都将发挥作用，事实上，要破坏多态，唯一的办法就是使用诸如type，issubclass等函数显式地执行类型检查，但你应尽可能避免以这种方式破坏多态。</p>
<h3 id="多态的案例">多态的案例</h3>
<p>现在我们来看一个案例需求：</p>
<ol style="list-style-type: decimal">
<li>我们需要定义3个类，分别是人类(Person)，狗类(Dog)，哮天犬类(XiaoTianQuan)类；</li>
<li>狗类(Dog)中封装一个玩耍的方法(game)；</li>
<li>定义一个哮天犬类(XiaoTianQuan)类，这个类继承自(Dog)，但是这个类中的game方法需要进行修改，例如普通玩耍变成飞到天上玩耍；</li>
<li>定义一个人类(Person)，在这个类中，让人(Person)与狗类(Dog)玩耍(game)，示意图如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190523154717.png">

</div>
<p>代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 蹦蹦跳跳的玩耍..."</span> % self.name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianQuan</span><span class="params">(Dog)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 飞到天上去玩耍..."</span>% self.name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game_with_dog</span><span class="params">(self,dog)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"%s 和 %s 快乐地玩耍..."</span>% (self.name, dog.name))</div><div class="line"></div><div class="line">        <span class="comment"># 让狗玩耍</span></div><div class="line">        dog.game()</div><div class="line"></div><div class="line"><span class="comment"># 1. 创建狗对象</span></div><div class="line">wangcai = Dog(<span class="string">"旺财"</span>)</div><div class="line"><span class="comment"># 创建普通的狗对象</span></div><div class="line"></div><div class="line">feitianwangcai = XiaoTianQuan(<span class="string">"飞天旺财"</span>)</div><div class="line"><span class="comment"># 创建哮天犬类的对象</span></div><div class="line"></div><div class="line"><span class="comment"># 2. 创建一个小明对象</span></div><div class="line">xiaoming = Person(<span class="string">"小明"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 3. 让小明调用和狗玩的方法</span></div><div class="line">xiaoming.game_with_dog(wangcai)</div><div class="line">xiaoming.game_with_dog(feitianwangcai)</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">小明 和 旺财 快乐地玩耍...</div><div class="line">旺财 蹦蹦跳跳的玩耍...</div><div class="line">小明 和 飞天旺财 快乐地玩耍...</div><div class="line">飞天旺财 飞到天上去玩耍...</div></pre></td></tr></table></figure>
<p>从结果可以看出来，不同的狗，(Dog)与(XiaoTianQuan)调用相的方法时，产生的结果不一样。</p>
<h3 id="实例">实例</h3>
<p>面向对象开发步骤如下：</p>
<ol style="list-style-type: decimal">
<li>使用面向对象开发，第1步是设计<strong>类</strong>；</li>
<li>使用<code>类名()</code>创建对象，<strong>创建对象</strong>的动作有两步：①在内存中为对象分配空间；②调用初始化方法<code>__init__</code>为对象初始化；</li>
<li>对象创建后，<strong>内存</strong>中就有一个对象的实实在在的存在，这个存在就是<strong>实例</strong>。</li>
</ol>
<p>因此，通常也会有以下这种叫法：</p>
<ol style="list-style-type: decimal">
<li>创建出来的对象叫做<strong>类</strong>的<strong>实例</strong>；</li>
<li>创建对象的动作叫做<strong>实例化</strong>；</li>
<li>对象的属性叫做<strong>实例属性</strong>；</li>
<li>对象调用的方法叫做<strong>实例方法</strong>。</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190524142813.png">

</div>
<p>在程序执行时：</p>
<ol style="list-style-type: decimal">
<li>对象各自拥有自己的<strong>实例属性</strong>；</li>
<li>调用对象方法，可以通过<code>self</code>来访问自己的属性，以及调用自己的方法。</li>
</ol>
<p><strong>结论</strong></p>
<ul>
<li>每一个对象都有自己<strong>独立的内存空间</strong>，保存<strong>各自不同的属性</strong>；</li>
<li><strong>多个对象的方法，在内存中只有一份</strong>，在调用方法时，需要把对象的引用传递到方法内部。</li>
</ul>
<h3 id="类是一个特殊的对象">类是一个特殊的对象</h3>
<p>在学习Python时，我们常常听到这样的话：</p>
<blockquote>
<p><code>Python</code>中一切皆无明：</p>
<ul>
<li><code>class AAA:</code>定义的类属于<strong>类对象</strong></li>
<li><code>obj1 = AAA()</code>属于<strong>实例对象</strong></li>
</ul>
</blockquote>
<ul>
<li>在程序运行时，<strong>类</strong>同样会被加载到内存中；</li>
<li>在<code>Python</code>中，<strong>类</strong>是一个特殊的对象——<strong>类对象</strong>；</li>
<li>在程序运行时，<strong>类对象</strong>在内存中<strong>只有一份</strong>，使用<strong>一个类</strong>可以创建出<strong>很多个对象实例</strong>；</li>
<li>除了封装<strong>实例</strong>的<strong>属性</strong>和<strong>方法</strong>外，<strong>类对象</strong>还可以拥有自己的<strong>属性</strong>和<strong>方法</strong>：即①<strong>类属性</strong>；②<strong>类方法</strong>。</li>
<li>通过<strong>类名.</strong>的方式哦可以<strong>访问类的属性</strong>或者<strong>调用类的方法</strong>，如下所示：</li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190524143316.png">

</div>
<h2 id="补充知识什么是对象">补充知识：什么是对象</h2>
<p>在面向对象的编程中，经常听到的一句话就是“一切皆对象”这句话到底是什么意思，可以看知乎的一个帖子，从Python的源码角度解释的：<a href="https://www.zhihu.com/question/27026782#answer-9368341" target="_blank" rel="external">《关于python中“赋值就是建立一个对象的引用”，大家怎么看？》</a></p>
<h2 id="类属性和实例属性">类属性和实例属性</h2>
<h3 id="概念和使用">概念和使用</h3>
<ul>
<li>类属性主浊给类对象中定义的属性</li>
<li>通常用来记录与这个类相关的特征</li>
<li>类属性不会以用于记录具体对象的特征。</li>
</ul>
<h4 id="示例需求">示例需求</h4>
<p>我们先来看一个案例：</p>
<ul>
<li>定义一个工具类</li>
<li>每件工具都有自己的<code>name</code></li>
<li>需求——知道使用这个类，创建了多少个工具对象？</li>
</ul>
<p>如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment">#  使用赋值语句定义类属性， 记录所有工具对象的数量</span></div><div class="line">    count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        <span class="comment"># 让类属性的值 + 1</span></div><div class="line">        Tool.count += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 1. 创建工具对象</span></div><div class="line">tool1 = Tool(<span class="string">"斧头"</span>)</div><div class="line">tool2 = Tool(<span class="string">"榔头"</span>)</div><div class="line">tool3 = Tool(<span class="string">"水桶"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 输出工具对象的总数</span></div><div class="line">print(Tool.count)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>从代码中我们可以看出来，我们先定义了一个<code>Tool</code>类，并且定义了相应的类属性，用来记录与这个类相关的特征。</p>
<h3 id="属性的获取机制">属性的获取机制</h3>
<p>属性的获取机制指的是，我们要编写代码时，在一个变量的后面接一点，再接这个变量的属性，Python的解释器是如何找到这个值的。</p>
<p>Python中属性的获取存在一个<strong>向上查找机制</strong>。这个机制的具体表现就是，先在对象的属性中查找类属性，如果没有找到类属性，就向上，向类中寻找这个类属性，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190524145829.png">

</div>
<p>因此，要访问类属性有两种方式：①<strong>类名.类属性</strong>；②<strong>对象.类属性</strong>（不推荐）。</p>
<p>需要注意的是，如何使用<code>对象.类属性 = 值</code>这样的赋值语句，只会给对象添加一个属性，而不会影响到类属性的值（从前面的笔记中可以了解到这些内容）。</p>
<p>前面我们看到，当我们输出<code>print(&quot;工具/对象总数 %d&quot; % tool3.count)</code>这个结果时，结果为<code>3</code>，因为通过对象可以访问类的创建数目，但是，如果我们使用了<code>对象.类属性 = 值</code>这样的赋值语句时，就会出问题，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment">#  使用赋值语句定义类属性， 记录所有工具对象的数量</span></div><div class="line">    count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        <span class="comment"># 让类属性的值 + 1</span></div><div class="line">        Tool.count += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 1. 创建工具对象</span></div><div class="line">tool1 = Tool(<span class="string">"斧头"</span>)</div><div class="line">tool2 = Tool(<span class="string">"榔头"</span>)</div><div class="line">tool3 = Tool(<span class="string">"水桶"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 输出工具对象的总数</span></div><div class="line">print(Tool.count)</div><div class="line">tool3.count = <span class="number">99</span></div><div class="line">print(<span class="string">"工具/对象总数 %d"</span> % tool3.count)</div><div class="line">print(<span class="string">"===&gt; %d"</span> % Tool.count)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span></div><div class="line">工具/对象总数 <span class="number">99</span></div><div class="line">===&gt; 3</div></pre></td></tr></table></figure>
<p>从结果可以看出来，<code>tools.count</code>它此时就代表的是不是类属性的值（类的值是<code>Tool.count</code>），而是又给它赋的值（因为解释器会先查找对象内部的count，如果没有，它再向上，在类中寻找count），因此在访问类的属性时，并不采用这种方式（也就是对过<code>对象.属性</code>这样的方式）。</p>
<h2 id="类方法和静态方法">类方法和静态方法</h2>
<p>注：需要补充类方法与实例方法的区别，以及应用范围，什么情况下使用。</p>
<h3 id="类方法">类方法</h3>
<ul>
<li><p>类属性就是针对类对象定义的属性</p></li>
<li>使用赋值语句在<code>class</code>关键字下方可以定义类属性；</li>
<li><p>类属性用于记录与这个类相关的特征</p></li>
<li><p>类方法就是针对类对象定义的方法</p></li>
<li><p>在类方法内部可以直接访问类属性或者调用其他的类方法</p></li>
</ul>
<h4 id="类方法语法">类方法语法</h4>
<p>类方法的语法与实例方法的语法非常类似，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@classmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> 类方法名<span class="params">(cls)</span></span></div><div class="line"><span class="function">    <span class="title">pass</span></span></div></pre></td></tr></table></figure>
<p>关于类方法需要注意以下几点：</p>
<ul>
<li>类方法需要用修饰器(<code>@classmethod</code>)来标记，<strong>告诉解释器这是一个类方法</strong>；</li>
<li>类方法的第一个参数应该是<code>cls</code>：</li>
<li>由哪一个类调用的方法，方法内的<code>cls</code>就是哪一个类的引用；</li>
<li>这个参数和实例方法的第一个参数是<code>self</code>类似；</li>
<li>提示使用其他名称也可以，不过习惯使用<code>cls</code></li>
<li>通过<code>类名.</code>调用<code>类方法</code>，调用方法时，不需要传递<code>cls</code>参数；</li>
<li>在方法内部：</li>
<li>可以通过<code>cls.</code>访问类的属性；</li>
<li>也可以通过<code>cls.</code>调用其他的类方法。</li>
</ul>
<h4 id="示意需求">示意需求</h4>
<p>现在我们看一下需求：</p>
<ul>
<li>定义一个工具类；</li>
<li>每件工具都有自己的<code>name</code>；</li>
<li>需求——在<code>类</code>中封装一个<code>show_tool_count</code>的类方法，输出使用当前这个类创建的对象个数，那么需求的大致要求就如下所示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Tool</div><div class="line">Tool.count</div><div class="line">name</div><div class="line"></div><div class="line">__init__(self, name)：</div><div class="line">show_tool_count(cls)</div></pre></td></tr></table></figure>
<p>完整的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment">#  使用赋值语句定义类属性， 记录所有工具对象的数量</span></div><div class="line">    count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="comment"># 定义一个类方法</span></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_tool_count</span><span class="params">(cls)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"工具对象的数据 %d"</span> % cls.count)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        <span class="comment"># 让类属性的值 + 1</span></div><div class="line">        Tool.count += <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 1. 创建工具对象</span></div><div class="line">tool1 = Tool(<span class="string">"斧头"</span>)</div><div class="line">tool2 = Tool(<span class="string">"榔头"</span>)</div><div class="line">tool3 = Tool(<span class="string">"水桶"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 输出工具对象的总数</span></div><div class="line">print(Tool.count)</div><div class="line">tool3.count = <span class="number">99</span></div><div class="line">print(<span class="string">"工具/对象总数 %d"</span> % tool3.count)</div><div class="line">print(<span class="string">"===&gt; %d"</span> % Tool.count)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span></div><div class="line">工具/对象总数 <span class="number">99</span></div><div class="line">===&gt; 3</div></pre></td></tr></table></figure>
<p>从上面的案例我们就知道，在<code>Tool</code>这个类内部，我们定义了一个类方法，也就是<code>@classmethod</code>这一部分的内容。</p>
<h3 id="静态方法">静态方法</h3>
<p>如果我们在开发过程中，霜肆在类中封装一个方法，这个方法有以下特性：</p>
<ul>
<li><strong>不需要</strong>访问<strong>实例属性</strong>或者<strong>调用实例方法</strong>；</li>
<li><strong>不需要</strong>访问<strong>类属性</strong>或者<strong>调用类方法</strong>。</li>
</ul>
<p>这个时候，我们就可以把这个方法封装成一个<strong>静态方法</strong>，静态方法的语法格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@staticmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> 静态方法名<span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 需要注意的是，括号里面没有self，也没有cls</span></div><div class="line">     <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<ul>
<li>静态方法需要用修饰器<code>@staticmethod</code>来标记，告诉解释器这是一个静态方法；</li>
<li>通过<code>类名.</code>来调用静态方法。</li>
</ul>
<p>下面来看一个简单的应用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></div><div class="line">        print(<span class="string">"小狗要跑..."</span>)</div><div class="line"></div><div class="line"><span class="comment"># 通过类名.调用静态方法</span></div><div class="line"><span class="comment"># 调用静态方法不需要创建对象</span></div><div class="line">Dog.run()</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">小狗要跑...</div></pre></td></tr></table></figure>
<p>在这个案例中，我们并没有创建实例对象，就调用了类中的方法。这里再说一下什么时候需要创建静态方法，那就是既不访问实例属性，也不访问类属性的情况下，我们就可以定义一个静态方法。</p>
<h4 id="案例分析">案例分析</h4>
<p>在这个案例中，我们先看一下需求：</p>
<ol style="list-style-type: decimal">
<li>设计一个<code>Game</code>类；</li>
<li>属性：</li>
</ol>
<ul>
<li>定义一个<code>类属性</code>，即<code>top_score</code>记录游戏的<strong>历史最高分</strong>；</li>
<li>定义一个<code>实例属性</code>，即<code>player_name</code>，记录当前游戏的玩家姓名。</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>方法：</li>
</ol>
<ul>
<li><strong>静态方法</strong>（<code>show_help</code>）显示游戏帮助信息；</li>
<li><strong>类方法</strong>（<code>show_top_score</code>）显示历史最高分，它跟所有的类有关；</li>
<li><strong>实例方法</strong>（<code>start_game</code>）开始当前玩家的游戏。</li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>主程序步骤：</li>
</ol>
<ul>
<li>查看帮助信息；</li>
<li>查看历史最高分；</li>
<li>创建游戏对象，开始游戏。</li>
</ul>
<p>那么这个游戏的大致框架如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Game</div><div class="line">Game.top_score</div><div class="line">player_name</div><div class="line"></div><div class="line">__init__(self, player_name):</div><div class="line">show_help():</div><div class="line">show_top_score(cls):</div><div class="line">start_game(self)</div></pre></td></tr></table></figure>
<p>具体代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 历史最高分</span></div><div class="line">    top_score = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, player_name)</span>:</span></div><div class="line">        self.player_name = player_name</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_help</span><span class="params">()</span>:</span></div><div class="line">        print(<span class="string">"帮助信息： 让僵尸进入大门"</span>)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_top_score</span><span class="params">(cls)</span>:</span></div><div class="line">        print(<span class="string">"历史记录 %d"</span> % cls.top_score)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_game</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 开始游戏了..."</span> % self.player_name)</div><div class="line"></div><div class="line"><span class="comment"># 1. 查看游戏的帮助信息</span></div><div class="line">Game.show_help()</div><div class="line"></div><div class="line"><span class="comment"># 2. 查看历史最高分</span></div><div class="line">Game.show_top_score()</div><div class="line"><span class="comment"># 3. 创建游戏对象</span></div><div class="line">game = Game(<span class="string">"小明"</span>)</div><div class="line">game.start_game()</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">帮助信息： 让僵尸进入大门</div><div class="line">历史记录 <span class="number">0</span></div><div class="line">小明 开始游戏了...</div></pre></td></tr></table></figure>
<h4 id="案例总结">案例总结</h4>
<ol style="list-style-type: decimal">
<li>实例方法——方法内部需要访问实例属性，实例方法内部可以使用<code>类名.</code>来访问属性。</li>
<li>类方法——方法内部只需要访问类属性；</li>
<li>静态方法——谅地内部，不需要访问实例属性和类属性。</li>
</ol>
<h2 id="单例">单例</h2>
<h3 id="单例设计模式">单例设计模式</h3>
<h5 id="什么是设计模式">什么是设计模式？</h5>
<p>直接引用菜鸟教程里面的话：</p>
<blockquote>
<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
</blockquote>
<p>使用设计模型是为了可重用代码、让仍茇以更容易被他人理解、保证代码的可靠性。</p>
<ul>
<li>目的——让<strong>类</strong>创建的对象，在系统中只有唯一的一个实例；</li>
<li>每一次执行<code>类名()</code>返回的对象，内存地址是相同的（内存地址相同，说明每次由这个类创建的这个对象只有一个）。</li>
</ul>
<h3 id="单例设计模式的应用场景">单例设计模式的应用场景</h3>
<ul>
<li>音乐播放对象（一次只播放一首歌曲）</li>
<li>回收站对象（一个电脑通常只有一个回收站）</li>
<li>打印机对象（打印一些文件时，通常是在同一台打印机进行打印）</li>
<li>……</li>
</ul>
<h3 id="new__方法"><code>__new__</code>方法</h3>
<p>在Python中，当我们使用<code>类名()</code>创建对象时，Python解释器<strong>首先</strong>会调用<code>__new__</code>方法为对象<strong>分配空间</strong>。这个<code>__new__</code>方法是一个由object基类提供的<strong>内置的静态方法</strong>，它的作用主要有两个：</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>在内存溃为对象分配空间；</li>
</ol></li>
<li>2)<strong>返回</strong>对象的引用。</li>
</ul>
<p>当Python的解释器获得对象的引用后，将引用作为<strong>第一个参数</strong>，传递给<code>__init__</code>方法。重写<code>__new__</code>方法的代码非常固定，只需要注意以下几点：</p>
<ul>
<li><p>重写<code>__new__</code>方法一定要<code>return super().__new__(cls)</code></p></li>
<li><p>否则Python解释器<strong>得不到</strong>分配了空间的<strong>对象引用</strong>，就不会调用对象的初始化方法；</p></li>
<li><p>注意：<code>__new__</code>是一个静态方法，在调用时需要<strong>主动传递(cls)</strong>参数。</p></li>
</ul>
<p>以创建一个<code>MusicPlayer</code>类为例说明一下：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190607184737.png">

</div>
<p>现在看一下代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"播放器初始化"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建播放器对象</span></div><div class="line">player = MusicPlayer()</div><div class="line"></div><div class="line">print(player)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">播放器初始化</div><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x000001C0FDC7B0F0</span>&gt;</div></pre></td></tr></table></figure>
<p>现在输出了对象中的内容（<code>播放器初始化</code>），并且还输出了对象的内存地址。现在我们重写<code>__new__</code>方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 创建对象时， new方法会被自动调用</span></div><div class="line">        print(<span class="string">"创建对象， 分配空间"</span>)</div><div class="line"></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"播放器初始化"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建播放器对象</span></div><div class="line">player = MusicPlayer()</div><div class="line"></div><div class="line">print(player)</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">创建对象， 分配空间</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>此时的结果中出现了<code>None</code>，这说明初始化方法并没有被调用（也就是没有出现<code>播放器初始化</code>字样）。</p>
<p>现在回顾一下前面的内容，也就是下面这一段文字：</p>
<blockquote>
<p>重写<code>__new__</code>方法一定要<code>return super().__new__(cls)</code></p>
</blockquote>
<p>再对照代码，也就是下面的这些内容：</p>
<blockquote>
<pre><code>def __new__(cls, *args, **kwargs):

    # 1. 创建对象时， new方法会被自动调用
    print(&quot;创建对象， 分配空间&quot;)</code></pre>
</blockquote>
<p>因此我们在重写<code>__new__</code>方法时，并没有写<code>return super().__new__(cls)</code>，因此Python解释器就得不到<strong>分配了空间的</strong>对象引用，因此就不会调用对象的初始化方法（也就是输出<code>播放器初始化</code>字样），只能输出<code>None</code>，现在我们输入下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 创建对象时， new方法会被自动调用</span></div><div class="line">        print(<span class="string">"创建对象， 分配空间"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 2. 为对象分配空间</span></div><div class="line">        instance = super().__new__(cls)</div><div class="line"></div><div class="line">        <span class="comment"># 3. 返回对象的引用</span></div><div class="line">        <span class="keyword">return</span> instance</div></pre></td></tr></table></figure>
<p>完整的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 创建对象时， new方法会被自动调用</span></div><div class="line">        print(<span class="string">"创建对象， 分配空间"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 2. 为对象分配空间</span></div><div class="line">        instance = super().__new__(cls)</div><div class="line"></div><div class="line">        <span class="comment"># 3. 返回对象的引用</span></div><div class="line">        <span class="keyword">return</span> instance</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"播放器初始化"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建播放器对象</span></div><div class="line">player = MusicPlayer()</div><div class="line"></div><div class="line">print(player)</div></pre></td></tr></table></figure>
<p>上述代码运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">创建对象， 分配空间</div><div class="line">播放器初始化</div><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x000002F2EDE6B2B0</span>&gt;</div></pre></td></tr></table></figure>
<p>上面的案例就说明了<code>__new__</code>方法的说用几。</p>
<h2 id="python中的单例">Python中的单例</h2>
<p><strong>单例</strong>——让<strong>类</strong>创建的对象，在系统中<strong>只有唯一的一个实例</strong>，它的设计流程如下所示：</p>
<ol style="list-style-type: decimal">
<li>定义一个<strong>类属性</strong>，初始值是<code>None</code>，用于记录<strong>单例对象的引用</strong></li>
<li>重写<code>__new__</code>方法；</li>
<li>如果<strong>类属性</strong><code>is None</code>，调用父类方法分配空间，并在类属性中记录结果；</li>
<li>返回<strong>类属性</strong>中记录的<strong>对象引用</strong>，整个流程如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190607190254.png">

</div>
<p>现在我们先来验证一个Python中单例是否是这个类创建出来的唯一实例，具体方法就是，我们创建几个对象，并返回对象的一内存地址，看它们是否一样，先来看一段简单的代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="comment"># 创建多个对象</span></div><div class="line">player1= MusicPlayer()</div><div class="line">print(player1)</div><div class="line"></div><div class="line">player2 = MusicPlayer()</div><div class="line">print(player2)</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x0000020CBAA5B0B8</span>&gt;</div><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x0000020CBAA5B160</span>&gt;</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，<code>player1</code>和<code>player2</code>这两个对象的内存地址并不相同，说明这两个对象是完全不同的对象。而单例设计模型则是，无论调用多少次对象创立的方法，得到的对象引用是相同的，也就是说控制台输出的内存地址都是相同的。</p>
<p>现在我们就来说明一下单例设计是如何实现的，流程就是前面的那些说明与示意图。</p>
<h3 id="单例案例分析">单例案例分析</h3>
<p>在这个案例中，我们会看一下，无论我们创建了多少个实例，它们的内存地址都是一样的，也就是说由这个类创建出来的对象只有一个，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></div><div class="line">    instance = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 判断类属性是否是空对象</span></div><div class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="comment"># 2. 调用父类的方法，为第一个对象分配空间</span></div><div class="line">            cls.instance = super().__new__(cls)</div><div class="line">        <span class="comment"># 3. 返回类属性保存的对象引用</span></div><div class="line">        <span class="keyword">return</span> cls.instance</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="comment"># 创建多个对象</span></div><div class="line">player1= MusicPlayer()</div><div class="line">print(player1)</div><div class="line"></div><div class="line">player2 = MusicPlayer()</div><div class="line">print(player2)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x000001CA0EF2B2B0</span>&gt;</div><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x000001CA0EF2B2B0</span>&gt;</div></pre></td></tr></table></figure>
<p>从结果中我们可以看出来，<code>player1</code>和<code>player2</code>是一个对象，它们的内存地址是一样的。</p>
<h3 id="只执行一次初始化工作">只执行一次初始化工作</h3>
<p>前面的暗到，当我们每次使用<code>类名()</code>创建对象时，Python的解释器都会自动调用两个方法：①<code>__new__</code>用来分配空间；②<code>__init__</code>对象初始化。</p>
<p>在前面一部分我们对<code>__new__</code>方法改造之后，每次都会得到<strong>第一次被创建对象的引用</strong>，但是，<strong>初始化方法还会被再次调用</strong>。</p>
<p>如果我们只想让<strong>初始化动作</strong>只被<strong>执行一次</strong>，那么就需要以下解决方法：</p>
<ol style="list-style-type: decimal">
<li>定义一个类属性<code>init_flag</code>标记是否<strong>执行过初始化动作</strong>，初始值为<code>False</code>；</li>
<li>在<code>__init__</code>方法中，判断<code>init_flag</code>，如果为<code>False</code>，就执行初始化动作；</li>
<li>然后将<code>init_flag</code>设置为<code>True</code>；</li>
<li>这样，再次<strong>自动</strong>调用<code>__init__</code>方法时，<strong>初始化动作就不会补再次执行了</strong>。</li>
</ol>
<p>我们来看一个案例，我们在前面代码的基础上，加上下面的这段代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">"初始化播放器"</span>)</div></pre></td></tr></table></figure>
<p>完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></div><div class="line">    instance = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 判断类属性是否是空对象</span></div><div class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="comment"># 2. 调用父类的方法，为第一个对象分配空间</span></div><div class="line">            cls.instance = super().__new__(cls)</div><div class="line">        <span class="comment"># 3. 返回类属性保存的对象引用</span></div><div class="line">        <span class="keyword">return</span> cls.instance</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"初始化播放器"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建多个对象</span></div><div class="line">player1= MusicPlayer()</div><div class="line">print(player1)</div><div class="line"></div><div class="line">player2 = MusicPlayer()</div><div class="line">print(player2)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">初始化播放器</div><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x000001B09074B2B0</span>&gt;</div><div class="line">初始化播放器</div><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x000001B09074B2B0</span>&gt;</div></pre></td></tr></table></figure>
<p>从结果中我们可以知道，我们用类创建了两个对象，因此初始化方法就被调用了2次。但是，我们在开发的过程中，有可能遇到这样的需求，也就是说，我们只想让初始化方法执行一次，解决方法前面已经提到，如下所示：</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>定义一个类属性<code>init_flag</code>标记是否<strong>执行过初始化动作</strong>，初始值为<code>False</code>；</li>
<li>在<code>__init__</code>方法中，判断<code>init_flag</code>，如果为<code>False</code>，就执行初始化动作；</li>
<li>然后将<code>init_flag</code>设置为<code>True</code>；</li>
<li>这样，再次<strong>自动</strong>调用<code>__init__</code>方法时，<strong>初始化动作就不会补再次执行了</strong>。</li>
</ol>
</blockquote>
<p>现在我们把下面的代码加到原代码中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 记录第一个被创建对象的引用</span></div><div class="line">instance = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="comment"># 记录是否执行过初始化动作</span></div><div class="line">init_flag = <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 1. 判断类属性是否是空对象</span></div><div class="line">    <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="comment"># 2. 调用父类的方法，为第一个对象分配空间</span></div><div class="line">        cls.instance = super().__new__(cls)</div><div class="line">    <span class="comment"># 3. 返回类属性保存的对象引用</span></div><div class="line">    <span class="keyword">return</span> cls.instance</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 1. 判断是否执行过初始化动作</span></div><div class="line">    <span class="keyword">if</span> MusicPlayer.init_flag:</div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line">    <span class="comment"># 2. 如果没有执行过，再执行初始化动作</span></div><div class="line">    print(<span class="string">"初始化播放器"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 3. 修改类属性的标记</span></div><div class="line">    MusicPlayer.init_flag = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></div><div class="line">    instance = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="comment"># 记录是否执行过初始化动作</span></div><div class="line">    init_flag = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 判断类属性是否是空对象</span></div><div class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="comment"># 2. 调用父类的方法，为第一个对象分配空间</span></div><div class="line">            cls.instance = super().__new__(cls)</div><div class="line">        <span class="comment"># 3. 返回类属性保存的对象引用</span></div><div class="line">        <span class="keyword">return</span> cls.instance</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 1. 判断是否执行过初始化动作</span></div><div class="line">        <span class="keyword">if</span> MusicPlayer.init_flag:</div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="comment"># 2. 如果没有执行过，再执行初始化动作</span></div><div class="line">        print(<span class="string">"初始化播放器"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 3. 修改类属性的标记</span></div><div class="line">        MusicPlayer.init_flag = <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="comment"># 创建多个对象</span></div><div class="line">player1= MusicPlayer()</div><div class="line">print(player1)</div><div class="line"></div><div class="line">player2 = MusicPlayer()</div><div class="line">print(player2)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">初始化播放器</div><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x000001922204B2B0</span>&gt;</div><div class="line">&lt;__main__.MusicPlayer object at <span class="number">0x000001922204B2B0</span>&gt;</div></pre></td></tr></table></figure>
<p>将代码更改后，从运行结果中我们就可以发现，初始化动作就只被执行了1次。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/14/Python/Python学习笔记（13）-面向对象之继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/14/Python/Python学习笔记（13）-面向对象之继承/" itemprop="url">Python学习笔记（13）-黑马教程面向对象之继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-14T12:00:00+08:00">
                2018-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,858
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这是黑马Python培训教程面向对象这一章中的<strong>继承(inheritance)</strong>部分。</p>
<h2 id="什么是继承inheritance">什么是继承(inheritance)</h2>
<p>观向对象的三大特征</p>
<ul>
<li>封装：根据需求将属性和方法封装到一个抽象的类中；</li>
<li>继承：实现代码的重用，也就是说相同部分的代码不需要重复编写；</li>
<li>多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度。</li>
</ul>
<h3 id="为什么要有继承">为什么要有继承</h3>
<p>现在我们假设我们已经有了一个类，并且还要创建一个与之很像的类（可能只是新增了几个方法），该如何办呢（不能复制旧类的代码），解决思路如下：</p>
<p>例如我们有了一个名为Shape的类，它知道将自己绘制到屏幕上，现在我们想创建一个名为Rectangle的类，但它不仅知道如何将自己绘制到屏幕上，而且还知道如何计算其面积，我们不想重新编写方法draw，因此Shape已经了这样一个方法，且效果很好，那么我们就可以让Rectange继承Shape的方法，使得对Rectangle对象调用方法draw时，将自动调用Shape类的方法。</p>
<p>继承概念：子类拥有父母的所有方法和属性。</p>
<p>现在我们先看一下继承的一个优点，也就是前面提到的<strong>相同部分的代码不需要重复编写</strong>，现在先看一个简单的案例，在这个案例中，我们先不用继承这个特点来实现这一功能。</p>
<h3 id="通过案例说明为什么需要继承">通过案例说明为什么需要继承</h3>
<p>明确需求：假如我们在一个需求中，我们要定义动物类(Animal)与狗类(Dog)，而动物类中则有4个方法，分别是吃(eat)、喝(drink)，跑(run)和睡(sleep)，而狗类(Dog)除了动物类(Animal)中的4个方法外，还有一个独特的方法，就是叫(bark)，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190522132843.png">

</div>
<p>按照前面的原始方法（也就是不使用继承的思路），我们先定义一个动物类(Animal)，然后使用这个动物类(Animail)创建一个叫“旺财”的狗对象，输入以下代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建一个叫“旺财”的狗对象，如下所示：</span></div><div class="line">wangcai = Animal()</div><div class="line"></div><div class="line">wangcai.eat()</div><div class="line">wangcai.drink()</div><div class="line">wangcai.run()</div><div class="line">wangcai.sleep()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建一个叫“旺财”的狗对象，如下所示：</span></div><div class="line">wangcai = Animal()</div><div class="line"></div><div class="line">wangcai.eat()</div><div class="line">wangcai.drink()</div><div class="line">wangcai.run()</div><div class="line">wangcai.sleep()</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">吃</div><div class="line">喝</div><div class="line">跑</div><div class="line">睡</div></pre></td></tr></table></figure>
<p>假设，我们要在同一个代码中再定义一个狗类(Dog)，前面提到，狗类(Dog)与动物类(Animal)的区别就在于狗类(Dog)多了一个叫(bark)的方法，定义完后，我们再通过个狗类(Dog)生成一个叫旺财(wangcai)的对象，此时我们定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"汪汪叫"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建一个叫“旺财”的狗对象，如下所示：</span></div><div class="line">wangcai = Dog()</div><div class="line"></div><div class="line">wangcai.eat()</div><div class="line">wangcai.drink()</div><div class="line">wangcai.run()</div><div class="line">wangcai.sleep()</div><div class="line">wangcai.bark()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">吃</div><div class="line">喝</div><div class="line">跑</div><div class="line">睡</div><div class="line">汪汪叫</div></pre></td></tr></table></figure>
<p>现在我们回顾一下动物类(Animal)与狗类(Dog)的代码，我们就可以发现，狗类(Dog)代码的前4个方法是直接从动物类(Animal)中复制过来的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190522134103.png">

</div>
<p>如果在一个项目中，我们就这样定义了2个类，即动物类(Animal)与狗类(Dog)，并且狗类(Dog)中的一部分与动物类(Animal)相同，我们可以把相同的代码复制过来，但是，如果还有其他的类，例如我们再定义一个哮天犬类(XiaoTianQuan)，它比狗类(Dog)又多了一个方法，即飞(fly)，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">XiaoTianQuan</div><div class="line">eat(self):</div><div class="line">drink(self):</div><div class="line">run(self):</div><div class="line">sleep(self):</div><div class="line">bark(self):</div><div class="line">fly(self):</div></pre></td></tr></table></figure>
<p>那么，如果我们不使用继承的思路，还要复制相同部分的代码。此时，如果我们要修改<code>eat(self)</code>这个方法，就需要三次，即动物类(Animal)、狗类(Dog)、哮天犬类(XiaoTianQuan)都要修改，因此效率非常低下，代码量还多，容易出错。</p>
<p>为了解决这类问题（也就是A类，B类，C类中有相同的部分，并且C类由B类衍生而来，B类由A类衍生而来），因此面向对象中就有了继承这种思路。</p>
<h2 id="继承的概念语法和特点">继承的概念、语法和特点</h2>
<p>类继承的概念：子类拥有父类的所有方法和属性。</p>
<p>前面我们提到了，我们定义了3个类，分别是动物类(Animal)、狗类(Dog)、哮天犬类(XiaoTianQuan)。在动物类(Animal)中有四个方法，即吃(eat)、喝(drink)、跑(run)、睡(sleep)这4个方法，这4种方法都是动物的基本特征。而狗(Dog)类可以看作是动物(Animal)的一个子集，也就是说狗类必然也有这4个方法，因此我们不需要重复编写这部分代码，可以从动物类中继承过来。</p>
<p>这里我们就可以说动物类(Animal)是父类，狗类(Dog)就是子类。</p>
<ul>
<li>子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次编写相同的代码；</li>
<li>子类中应根据需求，封专门讲用子类特有的属性和方法。</li>
</ul>
<h3 id="继承的语法">继承的语法</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(父类)</span>:</span></div><div class="line">    </div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>现在我们就以前面的动物类(Animal)与狗类(Dog)说明一下，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"汪汪叫"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建一个叫“旺财”的狗对象，如下所示：</span></div><div class="line">wangcai = Dog()</div><div class="line"></div><div class="line">wangcai.eat()</div><div class="line">wangcai.drink()</div><div class="line">wangcai.run()</div><div class="line">wangcai.sleep()</div><div class="line">wangcai.bark()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">吃</div><div class="line">喝</div><div class="line">跑</div><div class="line">睡</div><div class="line">汪汪叫</div></pre></td></tr></table></figure>
<p>从前面的代码我们可以知道，狗类(Dog)继承自动物类(Animal)，现在我们修改一下父类中的代码，例如将<code>print(&quot;吃&quot;)</code>改为<code>print(&quot;吃---&quot;)</code>如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡---"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"汪汪叫"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建一个叫“旺财”的狗对象，如下所示：</span></div><div class="line">wangcai = Dog()</div><div class="line"></div><div class="line">wangcai.eat()</div><div class="line">wangcai.drink()</div><div class="line">wangcai.run()</div><div class="line">wangcai.sleep()</div><div class="line">wangcai.bark()</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">吃---</div><div class="line">喝---</div><div class="line">跑---</div><div class="line">睡---</div><div class="line">汪汪叫</div></pre></td></tr></table></figure>
<p>当我们修改了父类后，子类中的相应方法也出现了变化，并且我们没有修改子类中的任何代码，子类继承自父类的东西，这就是继承的概念，也就是说，子类拥有父类的所有属性和方法。</p>
<p>再看一个案例：</p>
<p>前面提到过，子类扩展了超类的定义。要指定超类，可以在class语句中的类名后加上超类名，并将其用圆括号括起来，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></div><div class="line">        self.blocked = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, sequence)</span>:</span></div><div class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> sequence <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.blocked]</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SPAMFilter</span><span class="params">(Filter)</span>:</span> <span class="comment"># SPAMFilter是Filter的子类</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span> <span class="comment"># 重写超类Filter的方法init</span></div><div class="line">        self.blocked = [<span class="string">'SPAM'</span>]</div><div class="line"></div><div class="line">f = Filter()</div><div class="line">f.init()</div><div class="line">f.filter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = Filter()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.init()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.filter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>Filter是一个过滤序列的通用类。实际上，它不会过滤掉任何东西。 Filter类的用途在于可用作其他类（如将’SPAM’从序列中过滤掉的SPAMFilter类）的基类（超类），如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = SPAMFilter()</div><div class="line">s.init()</div><div class="line">s.filter([<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'eggs'</span>,<span class="string">'bacon'</span>,<span class="string">'SPAM'</span>])</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.filter([<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'eggs'</span>,<span class="string">'bacon'</span>,<span class="string">'SPAM'</span>])</div><div class="line">[<span class="string">'eggs'</span>, <span class="string">'bacon'</span>]</div></pre></td></tr></table></figure>
<p>需要注意SPAMFilter类的定义中有两个要点：</p>
<p>第一，以提供新定义的方式重写了Filter类中方法init的定义</p>
<p>第二，直接从Filter类继承了方法filter的定义，因此无需要重新编写其定义。第二点说明了继承很有用的原因：可以创建大量不同的过滤器类，它们都从Filter类派生而来，并且都使用已编写好的方法filter。</p>
<h2 id="深入继承">深入继承</h2>
<p>如果要确定一个类是否是另一个类的子类，可以使用<code>issubclass</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(SPAMFilter,Filter)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Filter,SPAMFilter)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>如果有一个类，想知道它的基类，可以访问其特殊属性<code>__bases__</code>，（需要注意的是，这里是复数，后来会提到），如下所示；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>SPAMFilter.__bases__</div><div class="line">(&lt;class '__main__.Filter'&gt;,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Filter.__bases__</div><div class="line">(&lt;class 'object'&gt;,)</div></pre></td></tr></table></figure>
<p>同样的，如果要确定某个对象是否是特定类的实例，可以使用isinstance，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = SPAMFilter()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, SPAMFilter)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, Filter)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, str)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>从上面的案例我们可以看出，s是SPAMFilter类的直接实例，但它也是Filter类的间接实例，因为SPMAFilter是Filter的子类，换句话讲，所有SPAMFilter对象都是Filter对象，从前面一个案例可以知道，isinstance也可用于类型，如字符串类型str，如果要想知道对象属于哪个类，可以使用属性<code>__class__</code>，或<code>type</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.__class__</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">SPAMFilter</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(s)</span></span></div><div class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SPAMFilter</span>'&gt;</span></div></pre></td></tr></table></figure>
<h3 id="相关术语">相关术语</h3>
<p>现在了解一些有关继承的相关术语，还以前面的案例为例说明一下：</p>
<ul>
<li><code>Dog</code>类是<code>Animal</code>类的子类，<code>Animal</code>类是<code>Dog</code>类的父类，<code>Dog</code>类从<code>Animal</code>类继承。</li>
<li><code>Dog</code>类是<code>Animal</code>类的派生类，<code>Animal</code>类是<code>Dog</code>类的基类，<code>Dog</code>类从<code>Animal</code>类派生。</li>
</ul>
<h3 id="继承的传递性">继承的传递性</h3>
<ul>
<li><code>C</code>类从<code>B</code>类继承，<code>B</code>类又从<code>A</code>类继承；</li>
<li>那么<code>C</code>类就具有<code>B</code>类和<code>A</code>类的所有属性的方法。</li>
</ul>
<p><strong>子类</strong>拥有<strong>父类</strong>以及<strong>父类的父类</strong>中封闭的所有属性和方法。</p>
<h3 id="案例分析">案例分析</h3>
<p>现在再看一个简单的案例，继续以前面的案例进行演示，我们先定义一个动物类(Animal)，再创建一个动物类(Animal)的子类，即狗类(Dog)，再创建一个狗类(Dog)的子类（在这个子类中增加一个叫(bard)的方法），哮天犬类(XiaoTianQuan)（在这个类中，再添加一个飞(fly)的方法），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190522183421.png">

</div>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡---"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"汪汪叫"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianQuan</span><span class="params">(Dog)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"我会飞"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建一个哮天犬对象</span></div><div class="line">xtq = XiaoTianQuan()</div><div class="line"></div><div class="line">xtq.fly()</div><div class="line"><span class="comment"># 使用哮天犬（XiaoTianQuan）这个类中的方法</span></div><div class="line"></div><div class="line">xtq.bark()</div><div class="line"><span class="comment"># 使用狗类(Dog)中的叫(bark)这个方法</span></div><div class="line"></div><div class="line">xtq.sleep()</div><div class="line"><span class="comment"># 使用动物类(Animal)中的睡觉(sleep)这个方法</span></div></pre></td></tr></table></figure>
<p>结果运行，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">我会飞</div><div class="line">汪汪叫</div><div class="line">睡---</div></pre></td></tr></table></figure>
<p>从结果我们可以发现，子类中的方法可以由父类继承，也可以由父类的父类继承，这就是继承的传递性，可以从解释器（这里的解释器是PyCharm）中看到这些继承关系：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190522184214.png">

</div>
<p>图1中显示：PyCharm中左侧有一个圆圈，鼠标移过去可以看到，图2中显示：Animal的子类是Dog与XiaoTianQuan，点击一下，显示图3，分别是这几个类。</p>
<p>现在再看一个案例，还是接上面的动物(Animal)类、狗类(Dog)和哮天犬类(XiaoTianQuan)案例，现在我们从动物类中派生出一个猫类(Cat)，猫类(Cat)中我们添加一个抓(Catch)这个方法，我们再看一下哮天犬类(XiaoTianQuan)还能否调用猫类(Cat)中的这个方法(Catch)，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190523124609.png">

</div>
<p>代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡---"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"汪汪叫"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianQuan</span><span class="params">(Dog)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"我会飞"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">catch</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"抓老鼠"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建一个哮天犬对象</span></div><div class="line">xtq = XiaoTianQuan()</div><div class="line"></div><div class="line">xtq.fly()</div><div class="line"><span class="comment"># 使用哮天犬（XiaoTianQuan）这个类中的方法</span></div><div class="line"></div><div class="line">xtq.bark()</div><div class="line"><span class="comment"># 使用狗类(Dog)中的叫(bark)这个方法</span></div><div class="line"></div><div class="line">xtq.sleep()</div><div class="line"><span class="comment"># 使用动物类(Animal)中的睡觉(sleep)这个方法</span></div><div class="line"></div><div class="line">xtq.catch()</div><div class="line"><span class="comment"># 调用catch这个方法</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">汪汪叫</div><div class="line">睡---</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/封装/hm_04_继承的传递注意事项.py"</span>, line <span class="number">44</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    xtq.catch()</div><div class="line">AttributeError: <span class="string">'XiaoTianQuan'</span> object has no attribute <span class="string">'catch'</span></div></pre></td></tr></table></figure>
<p>运行出错，因为根据继承的传递性，XiaoTianQuan可以继承Dog中的方法，也可以继承Animal中的方法，而Cat是Animal的子类，与Dog是平行关系，XiaoTianQuan无法继承Cat中的方法。</p>
<h2 id="方法的重写">方法的重写</h2>
<p>当我们遇到一种情况，例如当父类的方法实现不能满足子类需要时，就需要对方法进行重写(override)，例如Animal的子类是Dog，Dog的子类的XiaoTianQuan，而XiaoTianQuan中的叫(bark)这个方法与Dog中的(bark)不一样怎么办，这个时候就需要在XiaoTianQuan类中再次重写bark，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190523125502.png">

</div>
<p><strong>重写</strong>父类方法有两种情况：</p>
<ul>
<li><strong>覆盖</strong>父类的方法；</li>
<li><strong>扩展</strong>父类的方法。</li>
</ul>
<h3 id="覆盖父类的方法">覆盖父类的方法</h3>
<p>​ 如果在开发中，父类的方兴未艾实现和子类的方法实现完全不同，就可以采用覆盖的方式，在子类中重新编写父类的方法。具体的实现方法就是在子类中定义一个与父类相同的方法，但代码不同。</p>
<p>重写之后，代码运行时只会调用子类中重写的方法，而不会调用父类中封装的方法，下面看一下案例。</p>
<h3 id="覆盖方法案例分析">覆盖方法案例分析</h3>
<p>先看一下原来的代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡---"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"汪汪叫"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianQuan</span><span class="params">(Dog)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"我会飞"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建一个哮天犬对象</span></div><div class="line">xtq = XiaoTianQuan()</div><div class="line">xtq.bark()</div><div class="line"><span class="comment"># 使用狗类(Dog)中的叫(bark)这个方法</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">汪汪叫</div></pre></td></tr></table></figure>
<p>在这个案例中，我们创建了一个叫<code>xtq</code>的<code>XiaoTianQuan</code>的对象，调用了<code>XiaoTianQuan</code>中的<code>bark</code>方法，如果我们改变了需求，使用哮天犬(xtq)是一种神犬，它叫的方式跟普通的狗不一样，也就是说我们要让<code>xtq</code>中的叫法发生改变，例如由<code>汪汪叫</code>变成了<code>叫得跟神一样...</code>，那么如何实现呢，此时就需要在<code>XiaoTianQuan</code>这个类中重新再次定义<code>bark</code>这个方法，输入以下代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">    print(<span class="string">"叫得跟神一样。。。"</span>)</div></pre></td></tr></table></figure>
<p>再次运行时，这段代码就会屏蔽父类Dog中的bark方法，只使用XiaoTianQuan类中的方法，完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡---"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"汪汪叫"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianQuan</span><span class="params">(Dog)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"我会飞"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"叫得跟神一样..."</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建一个哮天犬对象</span></div><div class="line">xtq = XiaoTianQuan()</div><div class="line">xtq.bark()</div><div class="line"><span class="comment"># 使用XiaoTianQuan类中的叫(bark)这个方法</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">叫得跟神一样...</div></pre></td></tr></table></figure>
<p>从结果中我们就可以看到，xtq中调用了XiaoTianQuan类中重新定义的bark方法。</p>
<h3 id="扩展方法案例分析">扩展方法案例分析</h3>
<p>现在再看一下重写的另外一种形式，就是对父类方法进行<strong>扩展</strong>。</p>
<p>在实际开发中，有些子类中的方法实现包含了父类的方法实现，并且父类中的这些是子类中这些方法一部分，此时就用到了重写中的<strong>扩展</strong>形式，它的具体步骤如下所示：</p>
<ol style="list-style-type: decimal">
<li>在子类中重写<strong>父类</strong>（有的教程称为<strong>超类</strong>）的方法；</li>
<li>在需要的位置使用<code>super().父类方法</code>来调用<strong>父类中同样的方法</strong>；</li>
<li>代码其他的位置针对子类的需求，编写<strong>子类中特有的代码实现方式</strong>。</li>
</ol>
<h4 id="关于super">关于super</h4>
<p>此处介绍一下Python中的<code>super</code>：</p>
<ul>
<li><code>super</code>是Python中的一个特殊的类；</li>
<li><code>super()</code>就是使用<code>super</code>类创建出来的对象；</li>
<li>最常用的场景就是在重写父类方法时，调用父类中封装好的方法。</li>
</ul>
<h4 id="具体案例">具体案例</h4>
<p>现在再来分析一下案例，还以前面的案例说明一下，我们此时又改变了需求，既要求xtq能够像普通狗一样叫（即“汪汪叫”），也能表达出它与普通狗不同的地方，此时们就需要对Dog类中的<code>bark</code>方法进行扩展，因此我们要做以下三点改变：</p>
<ol style="list-style-type: decimal">
<li>针对子类特有的需求编写代码；</li>
<li>使用<code>super().父类中的方法</code>来调用原本在父类中封装的方法；</li>
<li>增加其他子类的代码。</li>
</ol>
<p>也就是说我们要在<code>XiaoTianQuan</code>这个类中重写<code>bark</code>这个方法，并且进行改变，这一部分的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 1. 针对子类特有的需求进行编写</span></div><div class="line">    print(<span class="string">"神一样的叫唤..."</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 2. 使用super().调用原本在父类中封装的方法</span></div><div class="line">    super().bark()</div><div class="line"></div><div class="line">    <span class="comment"># 3. 增加其他子类的代码</span></div><div class="line">    print(<span class="string">"#$@#@!@#@$!!@"</span>)</div></pre></td></tr></table></figure>
<p>完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"吃---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"喝---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"跑---"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"睡---"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"汪汪叫"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianQuan</span><span class="params">(Dog)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"我会飞"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 针对子类特有的需求进行编写</span></div><div class="line">        print(<span class="string">"神一样的叫唤..."</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 2. 使用super().调用原本在父类中封装的方法</span></div><div class="line">        super().bark()</div><div class="line"></div><div class="line">        <span class="comment"># 3. 增加其他子类的代码</span></div><div class="line">        print(<span class="string">"#$@#@!@#@$!!@"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建一个哮天犬对象</span></div><div class="line">xtq = XiaoTianQuan()</div><div class="line">xtq.bark()</div><div class="line"><span class="comment"># 使用狗类(Dog)中的叫(bark)这个方法</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">神一样的叫唤...</div><div class="line">汪汪叫</div><div class="line"><span class="comment">#$@#@!@#@$!!@</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以看到，我们为<code>bark</code>方法添加了新的功能，它不仅继承了原来父类中的功能，还有新的功能。</p>
<h4 id="注意事项">注意事项</h4>
<p>在<code>python2.x</code>中调用父类方法中无法使用前面提到的<code>super()</code>，它只能使用<code>父类名.方法(self)</code>来实现，这一区别需要注意，这里不再详述。</p>
<h2 id="父类的私有属性和私有方法">父类的私有属性和私有方法</h2>
<p>前面我们提到了<strong>私有属性</strong>和<strong>私有方法</strong>的一些知识：</p>
<blockquote>
<ul>
<li><strong>私有属性、方法</strong>是对象的隐私，不对外公开，<strong>外界</strong>以及<strong>子类</strong>都不能直接访问；</li>
<li><strong>私有属性、方法</strong>通常用于做一些内部的事情。</li>
</ul>
</blockquote>
<p>从原来的知识点中我们知道了：</p>
<ol style="list-style-type: decimal">
<li><strong>子类对象</strong>不能在自己的方法内部<strong>直接</strong>访问父类的<strong>私有属性或私有方法</strong>；</li>
<li><strong>子类对象</strong>可以通过父类的公有方法<strong>间接</strong>访问到<strong>私有属性或私有方法</strong>。</li>
</ol>
<p>先看下面的一张示意图：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190523133308.png">

</div>
<p>从上面的示意图我们知道，<code>A</code>是父类，<code>B</code>是<code>A</code>的子类，其中：</p>
<ul>
<li><code>B</code>的对象不能直接访问<code>__num2</code>属性；</li>
<li><code>B</code>的对象不能在<code>demo</code>方法内访问<code>__num2</code>的属性；</li>
<li><code>B</code>的对象可以在<code>demo</code>方法内调用父类的<code>test</code>方法；</li>
<li>父类的<code>test</code>方法内部，能够访问<code>__num2</code>属性和<code>__test</code>方法。</li>
</ul>
<h3 id="案例分析1子类无法直接访问父类的属性与方法">案例分析1——子类无法直接访问父类的属性与方法</h3>
<p>现在用代码来分析一下上面提到的父类私有属性和私有方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        self.num1 = <span class="number">100</span></div><div class="line">        self.__num2 = <span class="number">200</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"私有方法　%d %d"</span> %(self.num1, self.__num2))</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建一个子类对象</span></div><div class="line">b = B()</div><div class="line">print(b)</div><div class="line"></div><div class="line"><span class="comment"># 在外界不能直接访问对象的私有属性/调用私有方法</span></div><div class="line">print(b.__num2)</div><div class="line">b.__test()</div></pre></td></tr></table></figure>
<p>代码运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">&lt;__main__.B object at <span class="number">0x00000170DA378BA8</span>&gt;</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/封装/hm_07_父类的私有属性和私有方法.py"</span>, line <span class="number">20</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    print(b.__num2)</div><div class="line">AttributeError: <span class="string">'B'</span> object has no attribute <span class="string">'__num2'</span></div></pre></td></tr></table></figure>
<p>结果出错。因此可以看出来，虽然<code>B</code>的父类是<code>A</code>，但在<code>B</code>中也无法调用<code>A</code>的私有属性和方法。</p>
<p>再修改一下代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        self.num1 = <span class="number">100</span></div><div class="line">        self.__num2 = <span class="number">200</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"私有方法　%d %d"</span> %(self.num1, self.__num2))</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 在子类的对象方法中，无法访问父类的私有属性</span></div><div class="line">        print(<span class="string">"访问父类的私有属性 %d"</span> % self.__num2)</div><div class="line"></div><div class="line">        <span class="comment"># 2. 在子类的对象方法中，无法调用父类的私有方法</span></div><div class="line">        self.__test()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建一个子类对象</span></div><div class="line">b = B(A)</div><div class="line">print(b)</div><div class="line"></div><div class="line"><span class="comment"># 在外界不能直接访问对象的私有属性/调用私有方法</span></div><div class="line">print(b.__num2)</div><div class="line">b.__test()</div></pre></td></tr></table></figure>
<p>结果运行仍然出错，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/封装/hm_07_父类的私有属性和私有方法.py"</span>, line <span class="number">23</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    b = B(A)</div><div class="line">TypeError: object() takes no parameters</div></pre></td></tr></table></figure>
<p>在子类中无法调用父类的方法。</p>
<h3 id="案例分析2间接访问父类私有属性调用私有方法">案例分析2——间接访问父类私有属性，调用私有方法</h3>
<p>虽然子类不能在自己的方法内部直接访问父类的私有属性和私有方法，但是可以访问其公有属性与公有方法，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        self.num1 = <span class="number">100</span></div><div class="line">        self.__num2 = <span class="number">200</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"私有方法　%d %d"</span> %(self.num1, self.__num2))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"父类的公有方法"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">b = B() <span class="comment"># 创建一个子类对象</span></div><div class="line">print(b) <span class="comment"># 输出b的内存地址</span></div><div class="line">print(b.num1) <span class="comment"># 输出B的父类的公有属性num1</span></div><div class="line">b.test() <span class="comment"># 调用父类的公有方法</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;__main__.B object at <span class="number">0x000002291BB00550</span>&gt;</div><div class="line"><span class="number">100</span></div><div class="line">父类的公有方法</div></pre></td></tr></table></figure>
<p>从结果我们可以知道，子类可以访问父类的公有属性，调用公有方法。</p>
<p>现在我们继续看案例，在子类<code>B</code>中的方法<code>demo()</code>能否访问父类的公有属性，调用父类的公有方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        self.num1 = <span class="number">100</span></div><div class="line">        self.__num2 = <span class="number">200</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"私有方法　%d %d"</span> %(self.num1, self.__num2))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"父类的公有方法"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 在子类的对象方法中，不能访问父类的私有属性</span></div><div class="line">        <span class="comment"># print("访问父类的私有属性 %d" % self.__num2)</span></div><div class="line"></div><div class="line">        <span class="comment"># 2. 在子类的对象方法中，不能调用父类的私有方法</span></div><div class="line">        <span class="comment"># self.__test()</span></div><div class="line"></div><div class="line">        <span class="comment"># 3. 访问父类的公有属性</span></div><div class="line">        print(<span class="string">"子类方法 %d"</span> % self.num1)</div><div class="line"></div><div class="line">        <span class="comment"># 4. 调用父类的公有方法</span></div><div class="line">        self.test()</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">b = B() <span class="comment"># 创建一个子类对象</span></div><div class="line">b.demo()</div><div class="line"><span class="comment"># print(b) # 输出b的内存地址</span></div><div class="line"><span class="comment"># print(b.num1) # 输出B的父类的公有属性num1</span></div><div class="line"><span class="comment"># b.test() # 调用父类的公有方法</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以看到，子类中可以调用父类中的公有方法。</p>
<p>再继续看案例，在这个案例中，我们会看到：①在父类中，通过父类的公用方法（假设是<code>abc</code>这个方法）调用父类私有方法或访问父类的私有属性；②在子类中，调用父类的这个公有方法（就是<code>abc</code>这个方法）。</p>
<p>这种情况会是什么样子，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        self.num1 = <span class="number">100</span></div><div class="line">        self.__num2 = <span class="number">200</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"私有方法　%d %d"</span> %(self.num1, self.__num2))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"父类的公有方法 %d"</span> % self.__num2)</div><div class="line">        <span class="comment"># 在父类中，test()是一个公有方法，而__num2是一个私有属性</span></div><div class="line">        self.__test()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 在子类的对象方法中，不能访问父类的私有属性</span></div><div class="line">        <span class="comment"># print("访问父类的私有属性 %d" % self.__num2)</span></div><div class="line"></div><div class="line">        <span class="comment"># 2. 在子类的对象方法中，不能调用父类的私有方法</span></div><div class="line">        <span class="comment"># self.__test()</span></div><div class="line"></div><div class="line">        <span class="comment"># 3. 访问父类的公有属性</span></div><div class="line">        print(<span class="string">"子类方法 %d"</span> % self.num1)</div><div class="line"></div><div class="line">        <span class="comment"># 4. 调用父类的公有方法</span></div><div class="line">        self.test()</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">b = B() <span class="comment"># 创建一个子类对象</span></div><div class="line">b.demo()</div><div class="line"><span class="comment"># print(b) # 输出b的内存地址</span></div><div class="line"><span class="comment"># print(b.num1) # 输出B的父类的公有属性num1</span></div><div class="line"><span class="comment"># b.test() # 调用父类的公有方法</span></div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">子类方法 <span class="number">100</span></div><div class="line">父类的公有方法 <span class="number">200</span></div><div class="line">私有方法　<span class="number">100</span> <span class="number">200</span></div></pre></td></tr></table></figure>
<p>从结果中我们可以看到：</p>
<ol style="list-style-type: decimal">
<li><code>b</code>是<code>B</code>的对象，<code>B</code>是<code>A</code>的子类；</li>
<li><code>b</code>无法直接访问<code>A</code>的私有属性，也无法直接调用<code>A</code>的私有方法；</li>
<li><code>A</code>中定义了一个公有方法<code>test()</code>，这个公有方法中调用了私有方法<code>__test()</code>，访问了私有属性<code>__num2</code>；</li>
<li><code>b</code>中调用了<code>A</code>的公有方法<code>test()</code>，因此<code>b</code>也能调用<code>A</code>的私有方法<code>__test()</code>，访问了私有属性<code>__num2</code>，这种途径是间接实现的，而非直接实现的，相当于使用<code>test()</code>来做了一个中转。</li>
</ol>
<h2 id="多继承">多继承</h2>
<h3 id="单继承与多继承">单继承与多继承</h3>
<p>前面我们提到的案例都是单继承，也就是一个子类只有一个父类，在这一部分中，我们会涉及到多继承：</p>
<ul>
<li>子类可以拥有<strong>多个父类</strong>，并且具有<strong>所有父类</strong>的<strong>属性</strong>和<strong>方法</strong>；</li>
<li>例如：孩子会继承息父类和母亲的特性，如下所示：</li>
</ul>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190523141917.png">

</div>
<h4 id="多继承的语法">多继承的语法</h4>
<p>多继承的语法如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> 子类名<span class="params">(父类名<span class="number">1</span>, 父类名<span class="number">2.</span>..)</span></span></div><div class="line"><span class="class">    <span class="title">pass</span></span></div></pre></td></tr></table></figure>
<h4 id="多继承案例分析">多继承案例分析</h4>
<p>现在我们根据前面的多继承示意图来看一个案例，在这个案例中，我们定义2个父类，分别是<code>A</code>和<code>B</code>，在<code>A</code>中定义一个<code>test()</code>方法，在<code>B</code>中定义一个<code>demo()</code>方法，然后再定义一个子类，即<code>C</code>类，让<code>C</code>类继承<code>A</code>类和<code>B</code>类，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"test 方法"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"demo 方法"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">c = C()</div><div class="line">c.test()</div><div class="line">c.demo()</div></pre></td></tr></table></figure>
<p>代码运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test 方法</div><div class="line">demo 方法</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，<code>C</code>既可以调用<code>A</code>中的<code>test()</code>方法，也能调用<code>B</code>中的<code>demo()</code>方法。多继承可以在很大程度上节省代码量。</p>
<h4 id="多继承的注意事项">多继承的注意事项</h4>
<p>在使用多继承的时候，我们可以会遇到这样的问题：如果不同的父类中存在同名的方法，子类对象在调用方法时，会调用哪一个父类的方法呢？就像下面的这个样子：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190523142920.png">

</div>
<p><code>A</code>中有<code>test()</code>方法，<code>B</code>中也有<code>test()</code>方法，如果<code>C</code>同时继承A与B，那么在调用<code>test()</code>方法时，就会有问题。</p>
<p>我们来分析一下这种情况，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"A --- test 方法"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"A --- demo 方法"</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"B --- demo 方法"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"B --- test 方法"</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">c = C()</div><div class="line">c.test()</div><div class="line">c.demo()</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A --- test 方法</div><div class="line">A --- demo 方法</div></pre></td></tr></table></figure>
<p>从结果中可以发现，<code>C</code>中的<code>test()</code>与<code>demo()</code>方法都继承自<code>A</code>。从<code>class C(A,B)</code>这段代码中我们可以知道，<code>C</code>是先继承自<code>A</code>，再继承自<code>B</code>，因此，如果遇到相同名称的方法，那么就是先<code>A</code>后<code>B</code>，如果我们把代码改为<code>class C(B,A)</code>，那么运行结果就是下面的这个样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">B --- test 方法</div><div class="line">B --- demo 方法</div></pre></td></tr></table></figure>
<p>此时就会发现，<code>C</code>中的方法都继承自<code>B</code>。但Python中子类关于父类的继承顺序并不是如此简单，举这个例子主要是为了说明，当两个父类中含有相同名称的方法时，慎重选择多继承。</p>
<h4 id="mro">MRO</h4>
<p>MRO全称是Method Resolution Order，即方法解析顺序。它用于在多继承时判断方法、属性的调用路径。Python中针对类提供了一个内置属性<code>__mro__</code>用于查看方法搜索顺序。</p>
<p>在前面的代码中补充一句<code>print(C.__mro__)</code>，结果如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</div></pre></td></tr></table></figure>
<p>从结果中可以看出以下信息：</p>
<ol style="list-style-type: decimal">
<li>输出结果是一个元组；</li>
<li>元组中的顺序就是一些类，分别是C，B，A，原来结果中的运行原理就是，当我们使用<code>c=C()</code>来创建一个<code>C</code>类的<code>c</code>对象时，如果有<code>C</code>类，那么就调用<code>C</code>类中的方法，如果没有，就按照从左到右的顺序进行搜索，也就是按C，B，A这三个类中方法进行调用，的顺序来进行调用。</li>
<li>最后一个是<code>&lt;class 'object'&gt;</code>，它是Python3中的所有类的基类，也就是说，只要我们定义了一个类，所有类的基类都是<code>&lt;class 'object'&gt;</code>，此处先不详述。</li>
<li>如果查找到最后一个基类，还没有找到相应的类，python就会报错。</li>
</ol>
<h2 id="多个超类">多个超类</h2>
<p>前面我们说了，<code>__bases__</code>是复数形式，我们可以用它来知道类的基类，而基类可能有多个，为说明如何继承多个类，下面我们来看一下案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculatro</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(selfself, expression)</span>:</span></div><div class="line">        self.value = eval(expression)</div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Talker</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hi, my value is "</span>, self.value)</div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingCalculator</span><span class="params">(Calculator, Talker)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>子类TalkingCalculator本身无所作为，其所有的行为都是从超类那里继承的，关键是通过Calculator那里继承calculate，并从Talker那里继承talk，它能了会说话的计算器，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, expression)</span>:</span></div><div class="line">        self.value = eval(expression)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Talker</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hi, my value is "</span>, self.value)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingCalculator</span><span class="params">(Calculator, Talker)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">tc = TalkingCalculator()</div><div class="line">tc.calculate(<span class="string">'1 + 2 *3'</span>)</div><div class="line">tc.talk()</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>tc = TalkingCalculator()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tc.calculate(<span class="string">'1 + 2 *3'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tc.talk()</div><div class="line">Hi, my value <span class="keyword">is</span>  <span class="number">7</span></div></pre></td></tr></table></figure>
<p>这种情况称为多重继承，这是一种功能强大的工具，然而除非万不得已，尽量避免使用这种方法。在使用多重继承时，有一点需要注意：如果多个超类以不同的方式实现了同一个方法（即有多个同名方法），必须在class语句中仔细排列这些超类，因此位于前面的类的方法会覆盖位于后面的类的方法。因此，在前面的救命中，如何Calculator类包含方法talk，那么这个方法将覆盖Talker类的方法talk，导致它不可访问，如果像下面这样反转超类的排列顺序，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingCalculator</span><span class="params">(Talker, Calculator)</span>:</span><span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>这将导致Talker的方法talk是可以访问的，多个超类的超类相同时，查找特定方法或属性时访问超类的顺序称为方法解析顺序（MRO）。</p>
<h3 id="新式类与旧式经典类">新式类与旧式（经典）类</h3>
<p>上面提到，<code>object</code>是Python为所有对象提供的基类，提供有一些内置的属性和方法，可以使用<code>dir</code>函数查看。</p>
<p>Python中有新式类与旧式类区分，其中：</p>
<ul>
<li>新式类：以<code>object</code>为基类的类，推荐使用；</li>
<li>经典类：不以<code>object</code>为基类的类，不推荐使用。</li>
<li>在<code>Python 3.x</code>中定义的类，如果没有指定父类，会默认使用<code>object</code>作为该类的基类，<code>Python 3.x</code>中定义的类都是新式类；</li>
<li>在<code>Python 2.x</code>中定义类时，如果没有指定父类，则不会以<code>object</code>作为基类。</li>
<li>新式类和经典类在多继承时会影响到方法的搜索顺序。</li>
<li>为了保证编写的代码能够同时在<code>Python 2.x</code>和<code>Python 3.x</code>中同时运行，在定义类时，如果没有父类，建议统一继承自<code>object</code>类。</li>
</ul>
<p>现在我们看一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">   ...:     <span class="keyword">pass</span></div><div class="line">   ...:</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: a = A()</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: dir(a)</div><div class="line">Out[<span class="number">3</span>]:</div><div class="line">[<span class="string">'__class__'</span>,</div><div class="line"> <span class="string">'__delattr__'</span>,</div><div class="line"> <span class="string">'__dict__'</span>,</div><div class="line"> <span class="string">'__dir__'</span>,</div><div class="line"> <span class="string">'__doc__'</span>,</div><div class="line"> <span class="string">'__eq__'</span>,</div><div class="line"> <span class="string">'__format__'</span>,</div><div class="line"> <span class="string">'__ge__'</span>,</div><div class="line"> <span class="string">'__getattribute__'</span>,</div><div class="line"> <span class="string">'__gt__'</span>,</div><div class="line"> <span class="string">'__hash__'</span>,</div><div class="line"> <span class="string">'__init__'</span>,</div><div class="line"> <span class="string">'__init_subclass__'</span>,</div><div class="line"> <span class="string">'__le__'</span>,</div><div class="line"> <span class="string">'__lt__'</span>,</div><div class="line"> <span class="string">'__module__'</span>,</div><div class="line"> <span class="string">'__ne__'</span>,</div><div class="line"> <span class="string">'__new__'</span>,</div><div class="line"> <span class="string">'__reduce__'</span>,</div><div class="line"> <span class="string">'__reduce_ex__'</span>,</div><div class="line"> <span class="string">'__repr__'</span>,</div><div class="line"> <span class="string">'__setattr__'</span>,</div><div class="line"> <span class="string">'__sizeof__'</span>,</div><div class="line"> <span class="string">'__str__'</span>,</div><div class="line"> <span class="string">'__subclasshook__'</span>,</div><div class="line"> <span class="string">'__weakref__'</span>]</div></pre></td></tr></table></figure>
<p>在上面的代码中我们可以知道，我们开始定义了一个A类，代码为<code>class A(object):</code>，从这里可以看出来，这是一个新式类，然后我们使用了<code>dir(a)</code>来查看这个类的方法，可以看到许多方法，但是，如果在Python3中，即使你输入的是<code>class A():</code>，没有指定继承自<code>object</code>，那么A类也是新式类，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">5</span>]: <span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></div><div class="line">   ...:     <span class="keyword">pass</span></div><div class="line">   ...:</div><div class="line"></div><div class="line">In [<span class="number">6</span>]: b = B()</div><div class="line"></div><div class="line">In [<span class="number">7</span>]: dir(b)</div><div class="line">Out[<span class="number">7</span>]:</div><div class="line">[<span class="string">'__class__'</span>,</div><div class="line"> <span class="string">'__delattr__'</span>,</div><div class="line"> <span class="string">'__dict__'</span>,</div><div class="line"> <span class="string">'__dir__'</span>,</div><div class="line"> <span class="string">'__doc__'</span>,</div><div class="line"> <span class="string">'__eq__'</span>,</div><div class="line"> <span class="string">'__format__'</span>,</div><div class="line"> <span class="string">'__ge__'</span>,</div><div class="line"> <span class="string">'__getattribute__'</span>,</div><div class="line"> <span class="string">'__gt__'</span>,</div><div class="line"> <span class="string">'__hash__'</span>,</div><div class="line"> <span class="string">'__init__'</span>,</div><div class="line"> <span class="string">'__init_subclass__'</span>,</div><div class="line"> <span class="string">'__le__'</span>,</div><div class="line"> <span class="string">'__lt__'</span>,</div><div class="line"> <span class="string">'__module__'</span>,</div><div class="line"> <span class="string">'__ne__'</span>,</div><div class="line"> <span class="string">'__new__'</span>,</div><div class="line"> <span class="string">'__reduce__'</span>,</div><div class="line"> <span class="string">'__reduce_ex__'</span>,</div><div class="line"> <span class="string">'__repr__'</span>,</div><div class="line"> <span class="string">'__setattr__'</span>,</div><div class="line"> <span class="string">'__sizeof__'</span>,</div><div class="line"> <span class="string">'__str__'</span>,</div><div class="line"> <span class="string">'__subclasshook__'</span>,</div><div class="line"> <span class="string">'__weakref__'</span>]</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/13/Python/Python学习笔记（12）-面向对象之封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/13/Python/Python学习笔记（12）-面向对象之封装/" itemprop="url">Python学习笔记（12）-黑马教程-面向对象之封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-13T12:00:00+08:00">
                2018-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12,884
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  50
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="面向对象相关知识背景">面向对象相关知识背景</h2>
<p>面向对象即Object Oriented,OO，这是一种软件开发方法，具体的定义也说不清楚，根据书中的描述，对象大致意味着一系列数据或属性以及一套访问这些数据的方法。在《Python无师自通》这本书中提到：</p>
<blockquote>
<p>在 Python 中，每一个数据值，如 2 或“Hello, World!”，被称为对象（object）。可以把对象看作拥有 3 个属性的数据值：唯一标识（identity）、数据类型和值。</p>
<p>对象的唯一标识，指的是其在计算机内存中的地址，该地址不会变化。</p>
<p>对象的数据类型是对象所属的数据类别，这决定了对象的属性，也不会变化。</p>
<p>对象的值是其表示的数据，例如数字 2 的值即为 2。</p>
<p>“Hello, World!”这个对象的数据类型为字符串（str，string 的缩写），值为“Hello, World!”。如果提及数据类型为 str 的对象，可以称其为字符串。</p>
</blockquote>
<p>与面向对象有关的一些术语有多态、封装、方法、属性、超类和继承。</p>
<p>多态：可对不同类型的对象执行相同的损伤；；</p>
<p>封装：对外部隐藏有关对象工作原理的细节。</p>
<p>继承：可基于通用类创建出专用类。</p>
<p>在后面的笔记中会详细说明这是什么意思。</p>
<h2 id="什么是类">什么是类</h2>
<p>类是一种对象，每个对象都属于特定的类，并被称为该类的实例。例如，如果你在窗外看到一只鸟，这只鸟就是“鸟类”的一个实例，鸟类是一个非常通用（抽象）的类，它有许多个子类：你看到的那只鸟可能属于子类”云雀“。你可以将“鸟类”视为由所有鸟组成的集合，而“云雀”是其一个子集，一个类的对象为另一个类的对象的子集时，前者就是后者的子类。因此“云雀”为“鸟类”的子类，而“鸟类”为“云雀”的超类。并且在面向对象的编程中，是先定义类，然后再由类生成一个实例。</p>
<p>通过上面的比喻，我们大致就理解了类，子类，超类。但在面向对象的编程中，子类可能还要更复些，因为类是由其支持的方法定义的。类的所有实例都有该类的所有方法，因此子类的所有实例都有超类的所有方法。因此，要定义子类，只需要定义多出来的方法（或者是重写某个方法）即可。例如鸟类（我们用Bird替代）可能提供方法fly，而Penguin类（Bird的一个子类）可能新增方法eat_fish。创建Penguin类时，我们还可能要重写超类方法，即方法fly，企鹅Penguin不会飞，我们要在Penguin的实例中，方法fly应什么都不做或引发异常。</p>
<h3 id="创建类">创建类</h3>
<p>在使用面向对象开发之前，应该首先分析一下需要，确定程序中需要包括哪些类。在程度开发中，要设计一个类，通常需要满足以下三个要求：</p>
<ol style="list-style-type: decimal">
<li>类名。类名的命名要以驼峰式命名法进行命名，也就是每个单词的首字母要大写，例如<code>CapWords</code>；</li>
<li>属性。属性赋予事物具有什么样的特性；</li>
<li>方法。方法赋予事物具有什么样的行为。</li>
<li></li>
</ol>
<h2 id="封装encapsulation">封装(encapsulation)</h2>
<p>封装指的是向外部隐藏不必要的细节。这听起来有点像多态（无需知道对象的内部细节就可使用它）。这两个概念很像，因为它们都是抽象的原则。它们都像函数一样，可帮助你处理程序的组成部分，让你无需关心不必要的细节。</p>
<p>但封装与多态又有所不同，多态让你无需知道对象所属的类（对象的类型）就能调用其方法，而封闭则是让你需知道对象的构造就能使用它，下面展示一个案例，在这个案例中，使用了多态，但是没有使用封闭，发吭你有一个名为OpenObject的类，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;o = OpenObject()</div><div class="line">&gt;&gt;&gt;o.set_name(<span class="string">'Sir Lancelot'</span>)</div><div class="line">&gt;&gt;&gt;o.get_names()</div><div class="line">&gt;&gt;&gt;<span class="string">'Sir Lancelot'</span></div></pre></td></tr></table></figure>
<p>在上面的案例中，我们像调用函数一样调用了类，创建了一个对象，并将其关联到变量o，然后使用了<code>set_name</code>和<code>get_name</code>这两个方法（假设OpenObject支持这些方法），但是，如果o将其名称储存在全局变量global_name中，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;gloabl_name</div><div class="line"><span class="string">'Sir Lancelot'</span></div></pre></td></tr></table></figure>
<p>这就意味着使用OpenObject类的实例（对象）时，就需要考虑global_name的内容，事实上，必须确保无人能修改它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;global_name = <span class="string">'Sir Gumby'</span></div><div class="line">&gt;&gt;&gt;o.get_name()</div><div class="line"><span class="string">'Sir Gumby'</span></div></pre></td></tr></table></figure>
<p>d如果浓度创建多个OpenObject对象，则会出现问题，因为它们共用同一个变量，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>o1 = OpenObject() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = OpenObject() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>o1.set_name(<span class="string">'Robin Hood'</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>o2.get_name() </div><div class="line"><span class="string">'Robin Hood'</span></div></pre></td></tr></table></figure>
<p>在上面的这个案例中，设置一个对象的名称时，将自动设置另一个对象的名称，这可能不是我们想要的结果。基本上，你希望对象是抽象的：当调用方法时，无需操心其他的事情，如避免干扰全局变量。如何将名称“封装”在对象中呢，将其作为一种<code>属性</code>即可，属性是归属于对象的变量，就像方法一样，实际上，方法差不多就是与函数相关联的属性，如果你使用属性而非全局变量重新编写前面的类，并将其重命名为ClosedObject，就可以像下面这样使用它，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = ClosedObject() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.set_name(<span class="string">'Sir Lancelot'</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.get_name() </div><div class="line"><span class="string">'Sir Lancelot'</span></div></pre></td></tr></table></figure>
<p>到目前为止，一切顺利，但这并不能证明名称不是存储在全局变量中的，现在再来创建一个对象，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = ClosedObject() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set_name(<span class="string">'Sir Robin'</span>) </div><div class="line">r.get_name()</div><div class="line"><span class="string">'Sir Robin'</span></div></pre></td></tr></table></figure>
<p>从中可知正确地设置了新对象的名称，此时再来看一下第一个对象，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.get_name() </div><div class="line"><span class="string">'Sir Lancelot'</span></div></pre></td></tr></table></figure>
<p>其名称还在，因为这个对象有自己的状态，对象的状态由其属性（如名称）描述，对象的方法可能修改这些属性，因此对象将一系列函数（方法）组合起来，并赋予它们访问一些变量（属性）的权限，而属性可用于在两次函数调用之间存储值。</p>
<h3 id="属性和方法的确定">属性和方法的确定</h3>
<p>描述对象特征的内容可以定义为<code>属性</code>。对象具有的某些行为（动词），就可以定义为<code>方法</code>。</p>
<p>例如我们看下面一个案例：</p>
<ul>
<li><strong>小明</strong>今年<strong>18岁</strong>，身高<strong>1.75</strong>，每天早上<strong>跑</strong>完步，会去<strong>吃</strong>东西。</li>
<li><strong>小美</strong>今年<strong>17岁</strong>，身高<strong>1.65</strong>，小美<strong>不跑步</strong>，小美喜<strong>欢</strong>吃东西。</li>
</ul>
<p>从上面的描述我们可以这么思考，我们可以设计一个人类，例如<code>persion</code>，这个类中需要包含3个属性，即名字<code>name</code>，年龄<code>age</code>，和身高<code>height</code>，此外，还要包括2个动作，分别为是跑步<code>run</code>和吃东西<code>eat</code>。</p>
<p>再看一个案例：</p>
<p>我们有以下需求：</p>
<ul>
<li>一只<strong>黄颜色</strong>的狗，叫<strong>大黄</strong></li>
<li>看见生人<strong>叫</strong></li>
<li>看见家人<strong>摇尾巴</strong></li>
</ul>
<p>那么我们就会设计这样一个狗类(<code>Dog</code>)，这个类中含有2个属性，分别是名字(<code>name</code>）用于记录狗的名字，颜色(<code>color</code>)用于记录狗的颜色；含有2个方法，分别是叫(<code>shout</code>)和摇尾巴(<code>shake</code>)。</p>
<p>以上就是类是如何设计的，总之就是一句话，先考虑需求，然后考虑类，描述性的文字是属性，动作性的文字是方法。</p>
<h2 id="面向对象基础语法">面向对象基础语法</h2>
<p>在Python中，对象无所不在，变量、数据、函数都是对象。在Python中，可能通过两种方法来验证以对象：</p>
<ol style="list-style-type: decimal">
<li>在标记符/数据后输入一个<code>.</code>，然后按下<code>TAB</code>键，<code>ipython</code>就会提示该对象能够调用的<code>方法列表</code>。</li>
<li>使用内置函数<code>dir</code>传入标识符/数据，可以查看对象内的<strong>所有属性及方法</strong>。</li>
</ol>
<p>先看第一种方法，在<code>ipython</code>中定义一个列表变量，即<code>gl_list=[]</code>，然后输入<code>gl_list.</code>（后面有一个点），按下<code>TAB</code>键，后面就会出现这个对象能使用的方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">3</span>]: gl_list = []</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: gl_list.</div><div class="line">    append() count() insert() reverse()</div><div class="line">    clear() extend() pop() sort()</div><div class="line">    copy() index() remove()</div></pre></td></tr></table></figure>
<p>现在定义一个函数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">6</span>]: <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></div><div class="line">   ...:     <span class="string">"""这是一个测试函数"""</span></div><div class="line">   ...:     print(<span class="string">"Hello python"</span>)</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [<span class="number">7</span>]: demo()</div><div class="line">Hello python</div><div class="line"></div><div class="line">In [<span class="number">8</span>]: demo.</div></pre></td></tr></table></figure>
<p>此时输入demo后面再加一个点<code>.</code>，没有任何信息，此时就需要用另外一种方法来验证它是一个对象，也就是使用<code>dir</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">10</span>]: dir(demo)</div><div class="line">Out[<span class="number">10</span>]:</div><div class="line">[<span class="string">'__annotations__'</span>,</div><div class="line"> <span class="string">'__call__'</span>,</div><div class="line"> <span class="string">'__class__'</span>,</div><div class="line"> <span class="string">'__closure__'</span>,</div><div class="line"> <span class="string">'__code__'</span>,</div><div class="line"> <span class="string">'__defaults__'</span>,</div><div class="line"> <span class="string">'__delattr__'</span>,</div><div class="line"> <span class="string">'__dict__'</span>,</div><div class="line"> <span class="string">'__dir__'</span>,</div><div class="line"> <span class="string">'__doc__'</span>,</div><div class="line"> <span class="string">'__eq__'</span>,</div><div class="line"> <span class="string">'__format__'</span>,</div><div class="line"> <span class="string">'__ge__'</span>,</div><div class="line"> <span class="string">'__get__'</span>,</div><div class="line"> <span class="string">'__getattribute__'</span>,</div><div class="line"> <span class="string">'__globals__'</span>,</div><div class="line"> <span class="string">'__gt__'</span>,</div><div class="line"> <span class="string">'__hash__'</span>,</div><div class="line"> <span class="string">'__init__'</span>,</div><div class="line"> <span class="string">'__init_subclass__'</span>,</div><div class="line"> <span class="string">'__kwdefaults__'</span>,</div><div class="line"> <span class="string">'__le__'</span>,</div><div class="line"> <span class="string">'__lt__'</span>,</div><div class="line"> <span class="string">'__module__'</span>,</div><div class="line"> <span class="string">'__name__'</span>,</div><div class="line"> <span class="string">'__ne__'</span>,</div><div class="line"> <span class="string">'__new__'</span>,</div><div class="line"> <span class="string">'__qualname__'</span>,</div><div class="line"> <span class="string">'__reduce__'</span>,</div><div class="line"> <span class="string">'__reduce_ex__'</span>,</div><div class="line"> <span class="string">'__repr__'</span>,</div><div class="line"> <span class="string">'__setattr__'</span>,</div><div class="line"> <span class="string">'__sizeof__'</span>,</div><div class="line"> <span class="string">'__str__'</span>,</div><div class="line"> <span class="string">'__subclasshook__'</span>]</div></pre></td></tr></table></figure>
<p>从上面的我们可以看出来，这里面是一个列表，它列出了很多方法，这些方法都是双下划线开头，双下划线结尾，这些东西都是Python内置的方法（<code>__方法名__</code>)，有些可以直接使用，例如<code>__doc__</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">11</span>]: demo.__doc__</div><div class="line">Out[<span class="number">11</span>]: <span class="string">'这是一个测试函数'</span></div></pre></td></tr></table></figure>
<p>此时我们就可以看到，使用<code>__doc__</code>这个内置方法就能查看函数的文档说明，常用的一些内置方法/属性有以下这些：</p>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>方法名</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><code>__new__</code></td>
<td>方法</td>
<td>创建对象时，会被自动调用</td>
</tr>
<tr class="even">
<td>2</td>
<td><code>__init__</code></td>
<td>方法</td>
<td>对象被初始化时，会被自动调用</td>
</tr>
<tr class="odd">
<td>3</td>
<td><code>__del__</code></td>
<td>方法</td>
<td>对象被从内存中销毁之前，会被自动调用</td>
</tr>
<tr class="even">
<td>4</td>
<td><code>__str__</code></td>
<td>方法</td>
<td>返回对象的工描述信息，print函数输出使用</td>
</tr>
</tbody>
</table>
<p>因此，<code>dir()</code>这个函数很有用，例如当我想调用某个函数的方法时，一时想不想来，就可以使用<code>dir()</code>这个函数。</p>
<h2 id="定义简单的类">定义简单的类</h2>
<h3 id="格式">格式</h3>
<p>在Python中要定义一个只包含方法的类，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> 类名</span></div><div class="line"><span class="class">    <span class="title">def</span> 方法1<span class="params">(self, 参数列表)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> 方法2<span class="params">(self, 参数列表)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>先看下面的一个案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hello, wolrd! I'm &#123;&#125;."</span>.format(self.name))</div></pre></td></tr></table></figure>
<p>在上面的这个案例中，一共定义了3种方法，它们类似于函数定义，但都位于class语句语，Person是类的名称。class语句创建独立的命名空间，用于在其中定义方法（其实就是定义函数）。self它指向对象本身，具体是哪个对象呢，我们再来看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo = Person()</div><div class="line">bar = Person()</div><div class="line">foo.set_name(<span class="string">'Luke Skywalker'</span>)</div><div class="line">bar.set_name(<span class="string">'Anakin Skywalker'</span>)</div><div class="line">foo.greet()</div><div class="line">bar.greet()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, wolrd! I<span class="string">'m Luke Skywalker.</span></div><div class="line"><span class="string">Hello, wolrd! I'</span>m Anakin Skywalker.</div></pre></td></tr></table></figure>
<p>这个案例主要是用来说明self是什么，对foo调用set_name和greet时，foo都会做为第一个参数自动传递给它们，也就是命名为self的原因（其实可以任意命名），如果没有self，所有的方法都无法访问对象本身，也就是要损伤的属性所属的对象。此外，也可以从外部访问这些属性，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo.name</div><div class="line">bar.name = <span class="string">'Yoda'</span></div><div class="line">bar.greet()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hello, wolrd! I<span class="string">'m Luke Skywalker.</span></div><div class="line"><span class="string">Hello, wolrd! I'</span>m Anakin Skywalker.</div><div class="line">Hello, wolrd! I<span class="string">'m Yoda.</span></div></pre></td></tr></table></figure>
<h2 id="属性函数和方法">属性、函数和方法</h2>
<p>方法和函数的区别表现在前面提到的参数self上，方法更准确地说是关联的方法，是将第一个参数关联到它所属的实例中，因此无需提供这个参数。也可以将属性关联到一个普通的函数，但这样就没有特殊的self参数了，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I have a self"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"I don't..."</span>)</div><div class="line"></div><div class="line">instance = Class()</div><div class="line">instance.method()</div><div class="line">instance.method= function</div><div class="line">instance.method()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I have a self</div><div class="line">I don<span class="string">'t...</span></div></pre></td></tr></table></figure>
<p>从上面可以知道，有没有参数self并不取决于是否以刚才使用的方式（如instance.method）调用方法。实际上，完全可以让另一个变量指向同一个方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    song = <span class="string">'Squaawk!'</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.song)</div><div class="line"></div><div class="line">bird = Bird()</div><div class="line">bird.sing()</div><div class="line">birdsong = bird.sing</div><div class="line">birdsong()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Squaawk!</div><div class="line">Squaawk!</div></pre></td></tr></table></figure>
<p>最后一个方法调用看起来很像函数调用，但变量birdsong指向的是关联的方法bird.song，这意味着它也能够访问参数self（即使它被关联到类的实例）。</p>
<h2 id="隐藏">隐藏</h2>
<p>默认情况下，我们可以从外部访问对象的属性，看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;c.name</div><div class="line"><span class="string">'Sir Lancelot'</span></div><div class="line">&gt;&gt;&gt;c.name = <span class="string">'Sir Gumby'</span></div><div class="line">&gt;&gt;&gt;c.get_name()</div><div class="line"><span class="string">'Sir Gumby'</span></div></pre></td></tr></table></figure>
<p>如果我们不让其他人从外部访问属性，就可能将属性定义为私有，私有属性不能从对象外部访问，而只能通过存取器（例如get_name和set_name）来访问。</p>
<p>要让方法或属性成为私有的（不能从外部访问），只需要让其名称以两个下划线打头即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secrective</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__inaccessible</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Bet you can't see me..."</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accessible</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"The secret message is: "</span>)</div><div class="line">        self.__inaccessible()</div><div class="line"></div><div class="line">s = Secrective()</div><div class="line">s.accessible()</div><div class="line">s.__inaccessible()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">s.accessible()</div><div class="line">The secret message <span class="keyword">is</span>: </div><div class="line">Bet you can<span class="string">'t see me...</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">s.__inaccessible()</span></div><div class="line"><span class="string">Traceback (most recent call last):</span></div><div class="line"><span class="string">  File "C:/Users/20161111/PycharmProjects/untitled2/test.py", line 11, in &lt;module&gt;</span></div><div class="line"><span class="string">    s.__inaccessible()</span></div><div class="line"><span class="string">AttributeError: '</span>Secrective<span class="string">' object has no attribute '</span>__inaccessible<span class="string">'</span></div></pre></td></tr></table></figure>
<p>从上面的案例我们可以看出来，无法从外部访问<code>__inaccessible</code>，但是在类中，例如<code>accessible</code>中我们仍然可以使用它。虽然以两个下划线打头有点奇怪，但这样的方法类似于其他语言中的标准私有方法。然后背后的处理手法并不标准：在类定义中，对所有以两个下划线打头的名称都进行转换，即在开头加上一个下划线和类名，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Secretive._Secretive__inaccessible </div><div class="line">&lt;unbound method Secretive.__inaccessible&gt;</div></pre></td></tr></table></figure>
<p>上面的代码在我的编辑器中无法运行，可以直接跳过，但知道了这种幕后处理手法，就能从类外部访问私有方法，但是不建议这么做，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s=Secrective()</div><div class="line">s._Secrective__inaccessible()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bet you can<span class="string">'t see me...</span></div></pre></td></tr></table></figure>
<p>总之，你无法禁止别人访问对象的私有方法和属性，但这种名称修改方式发出了强烈的信号，让他们不要这样做。如果你不希望名称被悠，又想发出不要从外部修改属性或方法的信号，可以用一个下划线打头，这虽然只是一种约定，但也有些作用，例如使用<code>from module import *</code>就不会导入以一个下划线打头的名称。</p>
<h2 id="类的命名空间">类的命名空间</h2>
<p>下面的两条语句大致等价：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span><span class="keyword">return</span> x*x</div><div class="line">foo = <span class="keyword">lambda</span> x: x*x</div></pre></td></tr></table></figure>
<p>它们𨝌会创建一个返回参数平方的函数，并将这个函数关联到变量foo，可以在全局（模块）作用域内定义名称foo，也可以在函数或方法内定义。定义类时情况也是如此，在class语句中定义的代码都是在一个特殊的命名空间（类的命名空间）内执行的，而类的所有成员都可以访问这个命名空间。类定义其实就是要执行的代码段。例如，在类定义中，并非只能包括def语句，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'Class C being defined...'</span>)</div><div class="line">...</div><div class="line">Class C being defined...</div></pre></td></tr></table></figure>
<p>这个案例非常简单，再看下一个案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberCounter</span>:</span></div><div class="line">   members = <span class="number">0</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></div><div class="line">       MemberCounter.members += <span class="number">1</span></div><div class="line"></div><div class="line">m1 = MemberCounter()</div><div class="line">m1.init()</div><div class="line">MemberCounter.members</div><div class="line">m2 = MemberCounter()</div><div class="line">m2.init()</div><div class="line">MemberCounter.members</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>上述代码在类作用域内定义了一个变量，所有的成员（实例）都可以访问它，这里使用它来计算类实例的数量，注意到这里使用了init来初始化所有的实例，也就是将init转换为合适的构造函数，每个实例都可以访问这个类作用域内的变化，就像方法一样，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m1.members</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m2.members</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>如果在一个实例中给属性members赋值，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m1.members=<span class="string">'two'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m1.members</div><div class="line"><span class="string">'two'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m2.members</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>新值被写入m1的一个属性中，这个属性遮住了类的变量。</p>
<h2 id="创建对象">创建对象</h2>
<p>当一个类定义完全成，要使用这个类来创建对象，语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对象变量=类名()</div></pre></td></tr></table></figure>
<h3 id="创建对象-1">创建对象</h3>
<p>先看一个案例：例如小猫爱吃鱼，小猫要喝水。</p>
<p>分析：</p>
<ol style="list-style-type: decimal">
<li>定义一个猫类，Cat()</li>
<li>定义两个方法<code>eat</code>和<code>drink</code></li>
<li>此时并没有涉及属性，因此我们不用定义属性。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"小猫爱吃鱼"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"小猫要喝水"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建猫对象</span></div><div class="line">tom = Cat()</div><div class="line"></div><div class="line">tom.eat()</div><div class="line">tom.drink()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">小猫爱吃鱼</div><div class="line">小猫要喝水</div></pre></td></tr></table></figure>
<p>在这个案例中，我们先定义了一个猫类(Cat)，然后创建了一个猫对象，再后，使这个对象赋予了吃与喝这两个方法，这两个方法已经封装到了类中，并不需要知道它的执行细节。</p>
<p>如果要用<code>print</code>函数直接输出对象，那么输出结果就是此对象创建的内存地址，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(tom)</div><div class="line">&lt;__main__.Cat object at <span class="number">0x0000017F72807A90</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="创建多个对象">创建多个对象</h2>
<p>类只有一个，类只是一个模板，使用这个模板可以创建多个对象，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"小猫爱吃鱼"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"小猫要喝水"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建猫对象</span></div><div class="line">tom = Cat()</div><div class="line"></div><div class="line">tom.eat()</div><div class="line">tom.drink()</div><div class="line"></div><div class="line"><span class="comment"># 再创建一个猫对象</span></div><div class="line">lazy_cat = Cat()</div><div class="line">lazy_cat.drink()</div><div class="line">lazy_cat.eat()</div><div class="line"></div><div class="line">print(tom)</div><div class="line">print(lazy_cat)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"小猫爱吃鱼"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"小猫要喝水"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建猫对象</span></div><div class="line">tom = Cat()</div><div class="line"><span class="comment"># 再创建一个猫对象</span></div><div class="line">lazy_cat = Cat()</div><div class="line"></div><div class="line">print(tom)</div><div class="line">print(lazy_cat)</div></pre></td></tr></table></figure>
<p>我们来看一下结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;__main__.Cat object at <span class="number">0x0000020AF8E47A90</span>&gt;</div><div class="line">&lt;__main__.Cat object at <span class="number">0x0000020AF8E5F4E0</span>&gt;</div></pre></td></tr></table></figure>
<p>从结果可以看出来，tom与lazy_cat这两个对象的内存地址不一样，它们是不一样的对象，再看一下以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lazy_cat2 = lazy_cat</div><div class="line">print(lazy_cat2)</div><div class="line">print(lazy_cat)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;__main__.Cat object at <span class="number">0x000001C0424B7A90</span>&gt;</div><div class="line">&lt;__main__.Cat object at <span class="number">0x000001C0424B7A90</span>&gt;</div></pre></td></tr></table></figure>
<p>可以发现，lazy_cat和lazy_cat2这两个对象是一样的。</p>
<h2 id="方法中的self参数">方法中的self参数</h2>
<h3 id="给对象添加属性">给对象添加属性</h3>
<p>在Python中很容易给对象添加属性，但是这种做法并不推荐，因为对象的属性通常都已经封装到类中了，没必要再单独给对象添加属性，虽然不推荐，但还是要看一下案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tom.name = <span class="string">"Tom"</span></div></pre></td></tr></table></figure>
<h3 id="输出对象属性">输出对象属性</h3>
<p>前面是找到，在类中定义的方法中的一个参数<code>self</code>，这个self是指：哪一个对象调用的方法，self就是哪一个对象的引用。</p>
<p>例如代码中的<code>tom = Cat()</code>，tom指向的对象就是由Cat这个类创建的，此时这个对象调用了Cat中的eat这个方法时，self指的也是这个对象，如果要想访问这个对象的属性，那么就是self加一个点(<code>.</code>)即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 爱吃鱼"</span>% self.name)<span class="comment">#这一步我们可以使用self.name来访问对象的属性</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">""</span>%s 要喝水<span class="string">"% self.name)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"># 创建猫对象</span></div><div class="line"><span class="string">tom = Cat()</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"># 可能使用 .属性名 利用赋值语句就可以为对象添加属性</span></div><div class="line"><span class="string">tom.name = "</span>Tom<span class="string">"</span></div><div class="line"><span class="string">tom.eat()</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"># 再创建一个猫对象</span></div><div class="line"><span class="string">lazy_cat = Cat()</span></div><div class="line"><span class="string">lazy_cat.name = "</span>大懒猫<span class="string">"</span></div><div class="line"><span class="string">lazy_cat.eat()</span></div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Tom 爱吃鱼</div><div class="line">大懒猫 爱吃鱼</div></pre></td></tr></table></figure>
<p>我们可以看到，原来的“小猫”就被替换成了“Tom”和“大懒猫”。也就是说，由哪一个对象调用的方法，方法内的self就是哪一个对象的引用。在类封装的方法内部，self就表示当前调用方法的对象自己。调用方法时，程序员不需要传递self参数。在方法内部，可以通过<code>self.</code>访问对象的属性，也可以通过<code>self.</code>调用其它的对象方法。</p>
<h2 id="初始化方法">初始化方法</h2>
<p>当使用<code>类名()</code>创建对象时，会自动执行以下操作：</p>
<ol style="list-style-type: decimal">
<li>为对象在内存中分配空间——创建对象</li>
<li>为对象的属性设置初始值——初始化方法(init)</li>
</ol>
<p>这个初始化方法就是<code>__init__</code>方法，<code>__init__</code>是对象的内置的方法，此方法是<strong>专门用来定义一个类具有哪些属性的方法</strong>，这个方法是固定的。我们在<code>Cat</code>中增加<code>__init__</code>方法，验证此方法在创建对象时会被自动调用，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"这是一个初始化方法"</span>)</div><div class="line"></div><div class="line"></div><div class="line">tom = Cat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是一个初始化方法</div></pre></td></tr></table></figure>
<p>从结果我们可以发现，使用类名()来创建对象的时候，会自动调用初始化方法<code>__init__</code>。</p>
<h3 id="在初始化方法内部定义属性">在初始化方法内部定义属性</h3>
<p>在<code>__init__</code>方法内部使用<code>self.属性名 = 属性的初始值</code>就可以定义属性</p>
<p>定义属性之后，再使用Cat类创建的对象都会拥有该属性，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"这是一个初始化方法"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># self.属性名 = 属性的初始值</span></div><div class="line">        self.name = <span class="string">"Tom"</span></div><div class="line"></div><div class="line"></div><div class="line">tom = Cat()</div><div class="line"></div><div class="line">print(tom.name)</div></pre></td></tr></table></figure>
<p>运行结果，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是一个初始化方法</div><div class="line">Tom</div></pre></td></tr></table></figure>
<p>现在解释一下上面的代码，代码是从上到下执行的：</p>
<ol style="list-style-type: decimal">
<li>当Python解释器遇到<code>class Cat:</code>时，这段代码是不执行的，直接跳过去，跳到<code>tom=Cat()</code>处；</li>
<li>我们的代码运行到<code>tom=Cat()</code>处时，Python解释器此时会做两件事情：①在内存中为Cat对象分配一块空间，假设就是0x1234这块空间（16进制）；②然后执行<code>class Cat</code>这块的代码，类代码中的<code>self</code>也会指向这块空间（即0x1234），此时也是从上到下执行的，执行到<code>self.name = &quot;Tom&quot;</code>时，这块空间就被命名为了Tom，因此在使用<code>print(tom.name)</code>时，就输出了空间的名字。</li>
</ol>
<h3 id="初始化方法的改造">初始化方法的改造</h3>
<p>在前面代码的基础上，我们再创建一个对象，<code>lazy_cat</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"这是一个初始化方法"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># self.属性名 = 属性的初始值</span></div><div class="line">        self.name = <span class="string">"Tom"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s爱吃鱼"</span>%self.name)</div><div class="line"></div><div class="line"></div><div class="line">tom = Cat()</div><div class="line"></div><div class="line">print(tom.name)</div><div class="line"></div><div class="line">lazy_cat = Cat()</div><div class="line">lazy_cat.eat()</div></pre></td></tr></table></figure>
<p>从上面代码我们可知，<code>lazy_cat</code>这个对象的名称还是<code>Tom</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这是一个初始化方法</div><div class="line">Tom</div><div class="line">这是一个初始化方法</div><div class="line">Tom爱吃鱼</div></pre></td></tr></table></figure>
<p>运行后，发现果然如此。因为我们在初始化时，已经把对象的名称固定了，就是<code>self.name = &quot;Tom&quot;</code>这句代码。现在我们要解决这个问题。</p>
<p>如果要解决这个问题，我们需要在初始化方法中再定义一个形参，用于输入不同对象的名称，现在我们在<code>def __init__(self)</code>中添加一个参数，new_name，即<code>def __init__(self, new_name)</code>，当我们已经添加了这个形参后，在原来代码创建一个新对象时，也要添加相应的实参，例如<code>tom = Cat()</code>就需要写为<code>tom= Cat(&quot;Tom&quot;)</code>，完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"这是一个初始化方法"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># self.属性名 = 属性的初始值</span></div><div class="line">        self.name = new_name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s爱吃鱼"</span>%self.name)</div><div class="line"></div><div class="line"></div><div class="line">tom = Cat(<span class="string">"Tom"</span>)</div><div class="line"></div><div class="line">print(tom.name)</div><div class="line"></div><div class="line">lazy_cat = Cat(<span class="string">"大懒猫"</span>)</div><div class="line">lazy_cat.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这是一个初始化方法</div><div class="line">Tom</div><div class="line">这是一个初始化方法</div><div class="line">大懒猫爱吃鱼</div></pre></td></tr></table></figure>
<p>此时我们就发现了，一个对象对应一个名称。</p>
<p>总结一下就是，在开发中，如果希望在创建对象的同时就设置对象的属性，就可以对<code>__init__</code>方法进行改造：</p>
<ol style="list-style-type: decimal">
<li>把希望设置的属性值，定义成<code>__init__</code>方法的参数；</li>
<li>在方法内部使用<code>self.属性 = 形参</code>接收外部 传递的参数；</li>
<li>在创建对象时，使用<code>类名(属性1,属性2...)</code>调用。</li>
</ol>
<h2 id="内置方法和属性">内置方法和属性</h2>
<p>这一部分介绍两个内置方法，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>方法名</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td><code>__del__</code></td>
<td>方法</td>
<td>对象被从内存中销毁之前，会被自动调用</td>
</tr>
<tr class="even">
<td>02</td>
<td><code>__str__</code></td>
<td>方法</td>
<td>返回对象的描述信息，print函数输出使用</td>
</tr>
</tbody>
</table>
<h3 id="del__方法"><code>__del__</code>方法</h3>
<ul>
<li>在Python中，当使用<code>类名()</code>创建对象时，为对象分配完空间后，自动调用<code>__init__</code>方法。</li>
<li>当一个对象被从内存中销毁之前，会自动调用<code>__del__</code>方法。</li>
</ul>
<h3 id="应用场景">应用场景</h3>
<ul>
<li><code>__init__</code>改造初始化方法，可以让创建对象更加灵活。</li>
<li><code>__del___</code>如果希望在对象被销毁之前，再做一些事情，可以使用<code>__del__</code>方法。</li>
</ul>
<h3 id="生命周期">生命周期</h3>
<ul>
<li>一个对象从调用<code>类名()</code>创建，生命周期开始。</li>
<li>一个对象的<code>__del__</code>方法一旦被调用，生命周期结束。</li>
<li>在对象的生命周期内，可以访问对象属性，或者让对象调用方法。</li>
</ul>
<p>先来看一个案例，代码如下所示：</p>
<p>代码A：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></div><div class="line"></div><div class="line">        self.name = new_name</div><div class="line"></div><div class="line">        print(<span class="string">"%s 来了"</span> % self.name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"%s 我去了"</span>% self.name)</div><div class="line"></div><div class="line"><span class="comment"># tom是一个全局变量</span></div><div class="line">tom = Cat(<span class="string">"Tom"</span>)</div><div class="line">print(tom.name)</div><div class="line"></div><div class="line"><span class="comment"># del tom</span></div><div class="line"></div><div class="line">print(<span class="string">"-"</span>*<span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Tom 来了</div><div class="line">Tom</div><div class="line">--------------------------------------------------</div><div class="line">Tom 我去了</div></pre></td></tr></table></figure>
<p>现在，我们将代码中的<code>del tom</code>显示出来，如下所示：</p>
<p>代码B：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></div><div class="line"></div><div class="line">        self.name = new_name</div><div class="line"></div><div class="line">        print(<span class="string">"%s 来了"</span> % self.name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"%s 我去了"</span>% self.name)</div><div class="line"></div><div class="line"><span class="comment"># tom是一个全局变量</span></div><div class="line">tom = Cat(<span class="string">"Tom"</span>)</div><div class="line">print(tom.name)</div><div class="line"></div><div class="line"><span class="keyword">del</span> tom</div><div class="line"></div><div class="line">print(<span class="string">"-"</span>*<span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Tom 来了</div><div class="line">Tom</div><div class="line">Tom 我去了</div><div class="line">--------------------------------------------------</div></pre></td></tr></table></figure>
<p>从结果中我们可以发现，代码A中的运行结果中，<code>Tom 我去了</code>出现在了点线下面，而代码B中的<code>Tom 我去了</code>则出现在了点线上面。而代码A与代码B的区别就在于，代码A中没有<code>del tom</code>这段代码，而代码B中有。</p>
<p>代码A中没有<code>del tom</code>这段代码，就说明，只有Python把tom这个对象自动删除（不是指操作者自己操作）后，才会出现<code>__del__</code>方法中的字符。我猜测这可能是Python自动回收内存的一种机制（注：关于Python的内存回收机制我也不太懂，有空了再补上）。而如果你自己亲自操作，也就是说使用了<code>del tom</code>这个代码后，Python就知道你把tom这个对象删除了，就开始运行<code>__del__</code>方法中的内容，然后再运行<code>print(&quot;-&quot;*50)</code>这段代码。</p>
<h3 id="str__方法"><code>__str__</code>方法</h3>
<ul>
<li><p>在Python中，使用<code>print</code>输出对象变量，默认情况下，会输出这个变量引用的对象是由哪一个类创建的对象，以及在内存中的地址（十六进制表示）。</p></li>
<li><p>如果在开发中，希望使用<code>print</code>输出对象变量时，能够打印自定义的内容，就可以利用<code>__str__</code>这个内置方法了。需要注意的是，<code>__str__</code>方法必须返回一个字符。</p></li>
</ul>
<p>看下面的案例，在这个案例，我们直接输出一个对象（有的教程在此处称之为“实例”），如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></div><div class="line"></div><div class="line">        self.name = new_name</div><div class="line"></div><div class="line">        print(<span class="string">"%s 来了"</span> % self.name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"%s 我去了"</span>% self.name)</div><div class="line"></div><div class="line"><span class="comment"># tom是一个全局变量</span></div><div class="line">tom = Cat(<span class="string">"Tom"</span>)</div><div class="line">print(tom)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Tom 来了</div><div class="line">&lt;__main__.Cat object at <span class="number">0x0000021E1311B278</span>&gt;</div><div class="line">Tom 我去了</div></pre></td></tr></table></figure>
<p>其中第二行，即<code>&lt;__main__.Cat object at 0x0000021E1311B278&gt;</code>这里输出的是Cat这个类，并把tom这个对象在内存中的地址显示出来。现在我们在类中增加<code>__str___</code>这个方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></div><div class="line"></div><div class="line">        self.name = new_name</div><div class="line"></div><div class="line">        print(<span class="string">"%s 来了"</span> % self.name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"%s 我去了"</span>% self.name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="string">"我是小猫"</span></div><div class="line"></div><div class="line"><span class="comment"># tom是一个全局变量</span></div><div class="line">tom = Cat(<span class="string">"Tom"</span>)</div><div class="line">print(tom)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Tom 来了</div><div class="line">我是小猫</div><div class="line">Tom 我去了</div></pre></td></tr></table></figure>
<p>此时，我们改造了<code>__str__</code>这个方法后，输出的就不再是这个对象的类，以及这个对象的地址了。而是我们自定义的内容，现在把<code>__str__</code>中的方法再改造一下，改成<code>return &quot;我是小猫[%s]&quot;% self.name</code>，则结果就如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Tom 来了</div><div class="line">我是小猫[Tom]</div><div class="line">Tom 我去了</div></pre></td></tr></table></figure>
<h2 id="面向对象封装encapsulation案例">面向对象封装(encapsulation)案例</h2>
<h3 id="封装">封装</h3>
<ol style="list-style-type: decimal">
<li>封装是面向对象编程的一大特点；</li>
<li>面向对象编程的第一步就是将属性和方法封装到一个抽象的类中；</li>
<li>外界使用类创建对象（有的教程叫实例），然后让对象调用方法；</li>
<li>对象方法中的细节都被封装在类的内部。</li>
</ol>
<h3 id="案例分析小明爱跑步">案例分析——小明爱跑步</h3>
<p>我们以“小明爱跑步”为例说明一下，先分析需求，如下所示：</p>
<ol style="list-style-type: decimal">
<li>小明体重75.0公斤；</li>
<li>小明每次跑步会减肥0.5公斤；</li>
<li>小明每次吃东西体重增加1公斤。</li>
</ol>
<h3 id="代码分析">代码分析</h3>
<p>代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight)</span>:</span></div><div class="line"></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.weight = weight</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="string">"我的名字叫 %s 体重是 %.2f 公斤"</span> %(self.name, self.weight)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 爱跑步， 跑步锻炼身体"</span>%self.name)</div><div class="line"></div><div class="line">        self.weight -= <span class="number">0.5</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 是吃货，吃完这顿再减肥"</span>%self.name)</div><div class="line"></div><div class="line">        self.weight += <span class="number">1</span></div><div class="line"></div><div class="line">xiaoming = Person(<span class="string">"小明"</span>, <span class="number">75.0</span>)</div><div class="line"></div><div class="line">xiaoming.run()</div><div class="line">xiaoming.eat()</div><div class="line"></div><div class="line">print(xiaoming)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">小明 爱跑步， 跑步锻炼身体</div><div class="line">小明 是吃货，吃完这顿再减肥</div><div class="line">我的名字叫 小明 体重是 <span class="number">75.50</span> 公斤</div></pre></td></tr></table></figure>
<p>如果我们把<code>Person</code>这个类折叠起来，就是下面的这个样子，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>...</div><div class="line"></div><div class="line">xiaoming = Person(<span class="string">"小明"</span>, <span class="number">75.0</span>)</div><div class="line"></div><div class="line">xiaoming.run()</div><div class="line">xiaoming.eat()</div><div class="line"></div><div class="line">print(xiaoming)</div></pre></td></tr></table></figure>
<p>从上面折叠后的代码我们就知道，我们创建了一个<code>Person</code>这个类，再由这个类创建了一个叫<code>xiaoming</code>的对象，然后这个对象进行了跑步(<code>run</code>)和吃东西(<code>eat</code>)，具体这跑步与吃东西它们的代码，都已经封装到了<code>Person</code>这个类中，我们直接调用即可。</p>
<h3 id="案例扩展小美也爱跑步">案例扩展——小美也爱跑步</h3>
<p>在原来案例的基础上进行扩展，先看一下需要：</p>
<ol style="list-style-type: decimal">
<li>小明和小美都爱跑步；</li>
<li>小明体重75.0公斤；</li>
<li>小美体重45.0公斤；</li>
<li>每次跑步都会减少0.5公斤；</li>
<li>每次吃东西都会增加1公斤。</li>
</ol>
<h4 id="代码分析案例扩展">代码分析——案例扩展</h4>
<p>再使用<code>Persion</code>这个类创建一个新对象，即<code>xiaomei</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight)</span>:</span></div><div class="line"></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.weight = weight</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="string">"我的名字叫 %s 体重是 %.2f 公斤"</span> %(self.name, self.weight)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 爱跑步， 跑步锻炼身体"</span>%self.name)</div><div class="line"></div><div class="line">        self.weight -= <span class="number">0.5</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 是吃货，吃完这顿再减肥"</span>%self.name)</div><div class="line"></div><div class="line">        self.weight += <span class="number">1</span></div><div class="line"></div><div class="line">xiaoming = Person(<span class="string">"小明"</span>, <span class="number">75.0</span>)</div><div class="line"></div><div class="line">xiaoming.run()</div><div class="line">xiaoming.eat()</div><div class="line"></div><div class="line">print(xiaoming)</div><div class="line"></div><div class="line"><span class="comment"># 小美爱跑步</span></div><div class="line">xiaomei = Person(<span class="string">"小美"</span>, <span class="number">45</span>)</div><div class="line"></div><div class="line">xiaomei.eat()</div><div class="line">xiaomei.run()</div><div class="line"></div><div class="line">print(xiaomei)</div><div class="line">print(xiaoming)</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">小明 爱跑步， 跑步锻炼身体</div><div class="line">小明 是吃货，吃完这顿再减肥</div><div class="line">我的名字叫 小明 体重是 <span class="number">75.50</span> 公斤</div><div class="line">小美 是吃货，吃完这顿再减肥</div><div class="line">小美 爱跑步， 跑步锻炼身体</div><div class="line">我的名字叫 小美 体重是 <span class="number">45.50</span> 公斤</div><div class="line">我的名字叫 小明 体重是 <span class="number">75.50</span> 公斤</div></pre></td></tr></table></figure>
<p>我们可以看到，由一个类创建的两个对象。在每个对象的方法内部，可以直接访问对象的属性。每个对象各自使用各自的方法，属性互不影响。</p>
<h3 id="案例分析三摆放家具">案例分析三——摆放家具</h3>
<p>现在我们再看一个案例，摆放家具，看一下需求：</p>
<ol style="list-style-type: decimal">
<li>房子(House)有户型、总面积和家具名称列表，而新房子没有任何家具；</li>
<li>家具(HouseItem)有名字和占地面积，其中不同的家具占地面积也不一样，例如床(bed)占地4平方米，衣柜(chest)占地2平方米，餐桌(table)占地1.5平方米；</li>
<li>现在我们要将2中的3样家具添加到房子中；</li>
<li>输出房子时，要求输出这些信息：户型、总面积、剩余面积和家具名称列表。</li>
</ol>
<p>有了上面需求后，我们要考虑一下如何设计代码：</p>
<ol style="list-style-type: decimal">
<li>定义2个类，一个是房子(House)，一个是家具(HouseItem)。</li>
<li>房子有4个属性；</li>
<li>家具有2个属性。</li>
</ol>
<p>但是，房子与家具这两个类先定义哪个？思路就是，由于房子这个类中要用到家具（家具有面积，房子的剩余面积与家具有关），因此我们要先定义家具这个类，总之就是，被使用的类要先定义。</p>
<h4 id="定义家具类">定义家具类</h4>
<p>根据前面的分析思路，现在先定义一个家具类，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseItem</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, area)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.area = area</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="string">"[%s] 占地 %.2f"</span>%(self.name, self.area)</div><div class="line"></div><div class="line"><span class="comment"># 创建家具</span></div><div class="line">bed = HouseItem(<span class="string">"床"</span>, <span class="number">4</span>)</div><div class="line">chest = HouseItem(<span class="string">"衣柜"</span>, <span class="number">2</span>)</div><div class="line">table = HouseItem(<span class="string">"餐桌"</span>, <span class="number">1.5</span>)</div><div class="line"></div><div class="line">print(bed)</div><div class="line">print(chest)</div><div class="line">print(table)</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[床] 占地 <span class="number">4.00</span></div><div class="line">[衣柜] 占地 <span class="number">2.00</span></div><div class="line">[餐桌] 占地 <span class="number">1.50</span></div></pre></td></tr></table></figure>
<h4 id="定义房子类">定义房子类</h4>
<p>思路：房子中需要定义4个属性，分别为房子类型(house_type)，面积(area)，剩余面积(free_area)，家具列表(item_list)。但是，在给房子传递参数时，只需要传递其中的2个即可，分别是房子类型(house_type)与面积(area)，因为剩余面积(free_area)可以由这2个参数算出来，而家具列表(item_list)在初始情况下是一个空列表，，也不需要传入。</p>
<p>注：在同一个代码文件中，如果要定义2个以及2个以上的类，类与类的代码之间要空两行，现在前2个属性的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, house_type, area)</span>:</span></div><div class="line"></div><div class="line">        self.house_type = house_type </div><div class="line">        self.area = area</div></pre></td></tr></table></figure>
<p>这段代码定义了房子的2个需要传入的属性，现在再定义剩余面积(free_area)和家具名称列表，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, house_type, area)</span>:</span></div><div class="line"></div><div class="line">        self.house_type = house_type</div><div class="line">        self.area = area</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#剩余面积</span></div><div class="line">        self.free_area = area</div><div class="line"></div><div class="line">    <span class="comment">#家具名称</span></div><div class="line">        self.item_list = []</div><div class="line">        <span class="comment"># 刚开始的时候，就是一个空列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 定义描述方法</span></div><div class="line">    <span class="comment"># 这里显示的是return返回的内容，如下所示：</span></div><div class="line">        <span class="keyword">return</span> (<span class="string">"户型：%s \n总面积： %.2f[剩余: %.2f]\n家具: %s"</span></div><div class="line">                % (self.house_type,</div><div class="line">                   self.area,</div><div class="line">                   self.free_area,</div><div class="line">                   self.item_list))</div><div class="line">    </div><div class="line">    <span class="comment"># 创建房子对象</span></div><div class="line">my_house = House(<span class="string">"两室一厅"</span>, <span class="number">60</span>)</div><div class="line"></div><div class="line">my_house.add_item(bed)</div><div class="line"><span class="comment"># 添加一张床</span></div><div class="line"></div><div class="line">my_house.add_item(chest)</div><div class="line"><span class="comment"># 添加一个衣柜</span></div><div class="line"></div><div class="line">my_house.add_item(table)</div><div class="line"><span class="comment"># 添加一张餐桌</span></div></pre></td></tr></table></figure>
<p>此时，完成的任务包括：定义了一个家具类，定义了一个房子类。当输入了房子类型与面积这2个参数后，代码可以显示用房输入的这些内容，前面的这些代码运行的结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[床] 占地 <span class="number">4.00</span></div><div class="line">[衣柜] 占地 <span class="number">2.00</span></div><div class="line">[餐桌] 占地 <span class="number">1.50</span></div><div class="line">要添加 [床] 占地 <span class="number">4.00</span></div><div class="line">要添加 [衣柜] 占地 <span class="number">2.00</span></div><div class="line">要添加 [餐桌] 占地 <span class="number">1.50</span></div><div class="line">户型：两室一厅 </div><div class="line">总面积： <span class="number">60.00</span>[剩余: <span class="number">60.00</span>]</div><div class="line">家具: []</div></pre></td></tr></table></figure>
<p>但是，还有2个任务没有完成，分别是①剩余面积还没有计算；②家具列表还是空的。下面完成这2个任务，思路是这个样子的：</p>
<ol style="list-style-type: decimal">
<li>我们需要判断一下家具的面积是否超过了剩余面积，如果超过，则提示不能添加这些家具；</li>
<li>将家具的名称追加到家具名称的列表中；</li>
<li>用房子的剩余面积减去家具面积。</li>
</ol>
<p>现在我们往代码中补充一个添加家具(add_item)方法，这个方法的代码以及要实现的功能如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, item)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">"要添加 %s"</span> % item)</div><div class="line">    <span class="comment"># 1. 判断家具的面积</span></div><div class="line">    <span class="keyword">if</span> item.area &gt; self.free_area:</div><div class="line">        print(<span class="string">"%s 的面积太大了，无法添加"</span>% item.name)</div><div class="line"></div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line">    <span class="comment"># 2. 将家具的名称添加到列表中</span></div><div class="line">    self.item_list.append(item.name)</div><div class="line"></div><div class="line">    <span class="comment"># 3. 计算剩余面积</span></div><div class="line">    self.free_area -= item.area</div></pre></td></tr></table></figure>
<p>实现全部功能的完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseItem</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, area)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.area = area</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="string">"[%s] 占地 %.2f"</span>%(self.name, self.area)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, house_type, area)</span>:</span></div><div class="line"></div><div class="line">        self.house_type = house_type</div><div class="line">        self.area = area</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">#剩余面积</span></div><div class="line">        self.free_area = area</div><div class="line"></div><div class="line">    <span class="comment">#家具名称</span></div><div class="line">        self.item_list = []</div><div class="line">        <span class="comment"># 刚开始的时候，就是一个空列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 这里显示的是return返回的内容，如下所示：</span></div><div class="line">        <span class="keyword">return</span> (<span class="string">"户型：%s \n总面积： %.2f[剩余: %.2f]\n家具: %s"</span></div><div class="line">                % (self.house_type,</div><div class="line">                   self.area,</div><div class="line">                   self.free_area,</div><div class="line">                   self.item_list))</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, item)</span>:</span></div><div class="line"></div><div class="line">        print(<span class="string">"要添加 %s"</span> % item)</div><div class="line">        <span class="comment"># 1. 判断家具的面积</span></div><div class="line">        <span class="keyword">if</span> item.area &gt; self.free_area:</div><div class="line">            print(<span class="string">"%s 的面积太大了，无法添加"</span>% item.name)</div><div class="line"></div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="comment"># 2. 将家具的名称添加到列表中</span></div><div class="line">        self.item_list.append(item.name)</div><div class="line"></div><div class="line">        <span class="comment"># 3. 计算剩余面积</span></div><div class="line">        self.free_area -= item.area</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建家具</span></div><div class="line">bed = HouseItem(<span class="string">"床"</span>, <span class="number">4</span>)</div><div class="line">chest = HouseItem(<span class="string">"衣柜"</span>, <span class="number">2</span>)</div><div class="line">table = HouseItem(<span class="string">"餐桌"</span>, <span class="number">1.5</span>)</div><div class="line"></div><div class="line">print(bed)</div><div class="line">print(chest)</div><div class="line">print(table)</div><div class="line"></div><div class="line"><span class="comment"># # 创建房子对象</span></div><div class="line">my_house = House(<span class="string">"两室一厅"</span>, <span class="number">60</span>)</div><div class="line"><span class="comment">#</span></div><div class="line">my_house.add_item(bed)</div><div class="line"><span class="comment"># # 添加一张床</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># my_house.add_item(chest)</span></div><div class="line"><span class="comment"># # 添加一个衣柜</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># my_house.add_item(table)</span></div><div class="line"><span class="comment"># # 添加一张餐桌</span></div><div class="line"></div><div class="line">print(my_house)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[床] 占地 <span class="number">4.00</span></div><div class="line">[衣柜] 占地 <span class="number">2.00</span></div><div class="line">[餐桌] 占地 <span class="number">1.50</span></div><div class="line">要添加 [床] 占地 <span class="number">4.00</span></div><div class="line">户型：两室一厅 </div><div class="line">总面积： <span class="number">60.00</span>[剩余: <span class="number">56.00</span>]</div><div class="line">家具: [<span class="string">'床'</span>]</div></pre></td></tr></table></figure>
<p>如果我们把床的面积改为40，那么运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[床] 占地 <span class="number">40.00</span></div><div class="line">[衣柜] 占地 <span class="number">2.00</span></div><div class="line">[餐桌] 占地 <span class="number">1.50</span></div><div class="line">要添加 [床] 占地 <span class="number">40.00</span></div><div class="line">户型：两室一厅 </div><div class="line">总面积： <span class="number">60.00</span>[剩余: <span class="number">20.00</span>]</div><div class="line">家具: [<span class="string">'床'</span>]</div></pre></td></tr></table></figure>
<p>如果我们把这三个家具的总面积改为大于60（例如床面积为40，餐桌为20，衣柜为20），结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[床] 占地 <span class="number">40.00</span></div><div class="line">[衣柜] 占地 <span class="number">20.00</span></div><div class="line">[餐桌] 占地 <span class="number">20.00</span></div><div class="line">要添加 [床] 占地 <span class="number">40.00</span></div><div class="line">要添加 [衣柜] 占地 <span class="number">20.00</span></div><div class="line">要添加 [餐桌] 占地 <span class="number">20.00</span></div><div class="line">餐桌 的面积太大了，无法添加</div><div class="line">户型：两室一厅 </div><div class="line">总面积： <span class="number">60.00</span>[剩余: <span class="number">0.00</span>]</div><div class="line">家具: [<span class="string">'床'</span>, <span class="string">'衣柜'</span>]</div></pre></td></tr></table></figure>
<p>从添加家具这个案例我们可以知道这个案例中的面向对象思想：</p>
<ol style="list-style-type: decimal">
<li>主程序只负责创建房子对象和家具对象；</li>
<li>让房子对象调用add_item方法将家具添加到房子中；</li>
<li>面积计算、剩余面积、家具列表等处理都被封装到房子类的内部中。</li>
</ol>
<h3 id="案例分析四士兵突击">案例分析四——士兵突击</h3>
<p>在这里再次复习一下封装：</p>
<ol style="list-style-type: decimal">
<li>封装是面积对象编程的一个特点；；</li>
<li>面积对象编程的第一步就是将属性和方法封装到一个抽象的类中；</li>
<li>外界使用类创建对象（有的教程叫实例），然后让对象调用方法；</li>
<li>对象方法的细节都被封装到类的内部。</li>
</ol>
<p>在这一小节中，还要学到一个知识点就是：一个对象的属性可以是另外一个类创建的对象。</p>
<h4 id="案例需求">案例需求</h4>
<p>现在我们先看一下这个案例的需求：</p>
<ol style="list-style-type: decimal">
<li>士兵许三多有一把AK47</li>
<li>士兵可以开火；</li>
<li>枪能发射子弹；</li>
<li>枪装填子弹——增加子弹的数量。</li>
</ol>
<p>从第一项需求中我们可以知道，我们要创建一个士兵类(Soldier)以及一个枪类(Gun)，并且这个士兵类(Soldier)中含有枪类(Gun)这样一个属性，而这个属性则是由枪类(Gun)创建出来的一个对象。这就对应了我们前面提到的这个知识点，也就是说<strong>一个对象的属性可以是另外一个类创建的对象</strong>。</p>
<p>从第二项和第三项需求我们可以知道，士兵(Solider)对象中有一个开火(fire)的方法，而开火则是由枪发射子弹，那么还要在枪类(Gun)中创建一个发射的方法(shoot)。</p>
<p>从第四项需求可以知道，枪里面还应该有一个子弹数量这个属性，同时还要给枪创建一个装填子弹方法。</p>
<p>因此总结如下：</p>
<ol style="list-style-type: decimal">
<li>需要创建一个士兵类(Soldier)，这个类中含有2属性，一个是士兵的名字(name)，一个是枪(gun)，同时还要定义一个方法，即开火(fire)；</li>
<li>需要创建一个枪类(Gun)，这个类中含有2个属性，一个是型号(model)，即AK47，还有一个是子弹数量(count)，同时还要定义2个方法，即装填子弹(add_bullet)与射击(shoot)这两个方法。</li>
<li>这里还有一个问题，是先定义枪类，还是士兵类，根据前面的知识，哪个类要被使用，就先定义哪个类。在这个案例中，是士兵使用枪，就先定义枪类。因为如果我们先定义士兵类，那么在士兵类的内部，还要用到枪的对象，此时枪类还没有被定义，就会比较麻烦。个人觉得，这个思路就是从小范围到大范围，从局部到整体。</li>
</ol>
<p>以上两个类的示意图如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190520193938.png">

</div>
<h4 id="创建枪gun类">创建枪(Gun)类</h4>
<p>在枪这个类中，型号(model)需要外界传递，而子弹数量(bullet_count)这个属性，我们假定开始的时候是没有子弹的，设为0，子弹需要人工装填，因此这个属性在初始阶段不需要外界输入，从上面的类图可以知道，枪里还有一个装填子弹方法(add_bullet)和发射子弹方法(shoot)，因此枪类代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gun</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 枪的型号</span></div><div class="line">        self.model = model</div><div class="line"></div><div class="line">        <span class="comment"># 2. 子弹的数量</span></div><div class="line">        self.bullet_count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_bullet</span><span class="params">(self, count)</span>:</span></div><div class="line">        self.bullet_count += count</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shoot</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 判断子弹数量</span></div><div class="line">        <span class="keyword">if</span> self.bullet_count &lt;= <span class="number">0</span>:</div><div class="line">            print(<span class="string">"[%s] 没有子弹了..."</span> % self.model)</div><div class="line"></div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="comment"># 2. 发射子弹</span></div><div class="line">        self.bullet_count -= <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="comment"># 3. 提示发射信息</span></div><div class="line">        print(<span class="string">"[%s] 突突突...[%d]"</span> % (self.model, self.bullet_count))</div><div class="line"></div><div class="line"></div><div class="line">ak47 = Gun(<span class="string">"AK47"</span>)</div><div class="line">ak47.add_bullet(<span class="number">50</span>)</div><div class="line">ak47.shoot()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[AK47] 突突突...[<span class="number">49</span>]</div></pre></td></tr></table></figure>
<p>代码能够正常运行，到此，枪类(Gun)的定义已经完成。</p>
<p>现在设计士兵类(Soldier)，这个类中含有2个属性，分别是姓名(name)和枪(gun)，不过在这里，先假设每一个新兵都没有枪。在这里还要提示一下，如果不知道设置什么初始值，可以设置为<code>None</code>。</p>
<ul>
<li><code>None</code>关键字表示什么都没有；</li>
<li>表示一个空对象，没有方法和属性，是一个特殊的常量；</li>
<li>可以将<code>None</code>赋值给任何一个变量。</li>
</ul>
<p>现在分析一下士兵类中的<code>fire</code>方法需求：</p>
<ol style="list-style-type: decimal">
<li>判断是否有枪，没有枪法没法冲锋；</li>
<li>减一声口号；</li>
<li>装填子弹；</li>
<li>射击。</li>
</ol>
<p>完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gun</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 枪的型号</span></div><div class="line">        self.model = model</div><div class="line"></div><div class="line">        <span class="comment"># 2. 子弹的数量</span></div><div class="line">        self.bullet_count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_bullet</span><span class="params">(self, count)</span>:</span></div><div class="line">        self.bullet_count += count</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shoot</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 判断子弹数量</span></div><div class="line">        <span class="keyword">if</span> self.bullet_count &lt;= <span class="number">0</span>:</div><div class="line">            print(<span class="string">"[%s] 没有子弹了..."</span> % self.model)</div><div class="line"></div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="comment"># 2. 发射子弹</span></div><div class="line">        self.bullet_count -= <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="comment"># 3. 提示发射信息</span></div><div class="line">        print(<span class="string">"[%s] 突突突...[%d]"</span> % (self.model, self.bullet_count))</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soldier</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 姓名</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment"># 2. 枪 - 新兵没有枪</span></div><div class="line">        self.gun = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fire</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 1. 判断士兵是否有枪</span></div><div class="line">        <span class="keyword">if</span> self.gun == <span class="keyword">None</span>:</div><div class="line">            print(<span class="string">"[%s] 还没有枪..."</span>% self.name)</div><div class="line"></div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 2. 高喊口号</span></div><div class="line">        print(<span class="string">"冲啊...[%s]"</span>% self.name)</div><div class="line"></div><div class="line">        <span class="comment"># 3. 让枪装填子弹</span></div><div class="line">        self.gun.add_bullet(<span class="number">50</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 4. 发射子弹</span></div><div class="line">        self.gun.shoot()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">ak47 = Gun(<span class="string">"AK47"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 创建许三多</span></div><div class="line">xusanduo = Soldier(<span class="string">"许三多"</span>)</div><div class="line">xusanduo.gun = ak47</div><div class="line">xusanduo.fire()</div><div class="line">print(xusanduo.gun)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">冲啊...[许三多]</div><div class="line">[AK47] 突突突...[<span class="number">49</span>]</div><div class="line">&lt;__main__.Gun object at <span class="number">0x000002E8B48D9668</span>&gt;</div></pre></td></tr></table></figure>
<p>在这个案例中，我们学到的内容就是：如果我们要实现某个任务，这个任务中有两个类，例如A类与B类，那么通过A类创建的对象中的属性可以是B类来源的对象，此时A创建的这个对象中的属性就是能调用B类中的方法。这个案例我觉得有点复杂，笔记不太可能记得很详细，可以多看几遍视频。</p>
<h4 id="身份运算符">身份运算符</h4>
<p>再来看一下前面代码中的某一句，即<code>if self.gun == None</code>，选中后，会出现如下提示信息：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190521124623.png">

</div>
<p>PyCharm的提示信息显示，如果与<code>None</code>进行比较时，最好使用<code>is</code>或<code>is not</code>，而不是使用<code>==</code>。这里的<code>is</code>就是身份运算符。</p>
<p>身份运算符用于比较两个对象的内存地址是否一致，也就是说是否是对同一个对象的引用。在Python中，针对<code>None</code>进行比较时，建议使用<code>is</code>判断。Python中的身份运算符有2个，分别是<code>is</code>与<code>is not</code>，它们的功能如下所示：</p>
<table>
<thead>
<tr class="header">
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>is</td>
<td>is是判断两个标识符是不是引用同一个对象</td>
<td>x is y，类似id(x)==id(y)</td>
</tr>
<tr class="even">
<td>is not</td>
<td>is not是判断两个标识符是不是引用不同的对象</td>
<td>x is not y，类似id(x)!=id(y)</td>
</tr>
</tbody>
</table>
<p>这里需要区分一下<code>is</code>与<code>==</code>的区别</p>
<p><code>is</code>用于判断两个变量引用对象是否为同一个；</p>
<p><code>==</code>用于判断引用变量的值是否相等，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: id(a)</div><div class="line">Out[<span class="number">2</span>]: <span class="number">2681339468296</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: id(b)</div><div class="line">Out[<span class="number">4</span>]: <span class="number">2681339465864</span></div><div class="line"></div><div class="line">In [<span class="number">5</span>]: a == b</div><div class="line">Out[<span class="number">5</span>]: <span class="keyword">True</span></div><div class="line"></div><div class="line">In [<span class="number">6</span>]: a <span class="keyword">is</span> b</div><div class="line">Out[<span class="number">6</span>]: <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>从上面的案例我们可以知道，a与b这两个列表的值相等，但引用不相等（也就是说这两个变量引用的内存地址不相同）。</p>
<p>而<code>None</code>在Python中算是一个空对象，空对象不能把它理解为零，它是Python中的一个特殊的常量，指向内存中的一个地址，一个变量如果是None，它一定和None指向同一个内存地址。在上面的代码中，即<code>if self.gun == None</code>这句中，<code>==</code>后面接的是一个对象，因此最好使用<code>is</code>，因为<code>is</code>主要用于判断对象的引用，而不是值，因此Python建议使用<code>is</code>来判断None。</p>
<p>网上又检索到了一些资料，如下所示：</p>
<p>在区分<code>is</code>和<code>==</code>这两种运算符区别之前，首先要知道Python中对象包含的三个基本要素，分别是：<code>id</code>(身份标识)、<code>type</code>(数据类型)和<code>value</code>(值)。<code>is</code>和<code>==</code>都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。<code>==</code>比较操作符和<code>is</code>同一性运算符区别</p>
<p><code>==</code>是python标准操作符中的比较操作符，用来比较判断两个对象的value(值)是否相等，<code>is</code>也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同。</p>
<h2 id="私有属性和私有方法">私有属性和私有方法</h2>
<h3 id="应用场景及定义方式">应用场景及定义方式</h3>
<h4 id="应用场景-1">应用场景</h4>
<ul>
<li>在实际开发中，对象的某些属性和方法可能只希望在对象的内部被使用，而不希望在外部被访问到；</li>
<li>私有属性就是对象不希望公开的属性；</li>
<li>私有方法就是对象不希望公开的方法。</li>
</ul>
<h4 id="定义方式">定义方式</h4>
<ul>
<li>在定义属性和方法时，在属性名或者方法名前增加两个下划线，定义的就是私有属性或方法；</li>
<li>我们先看一个最常规的案例，如下所示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.age = <span class="number">18</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">secret</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 的年龄是%d"</span>%(self.name, self.age))</div><div class="line"></div><div class="line">xiaofang = Women(<span class="string">"小芳"</span>)</div><div class="line"></div><div class="line">print(xiaofang.age)</div><div class="line"></div><div class="line">xiaofang.secret()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">18</span></div><div class="line">小芳 的年龄是<span class="number">18</span></div></pre></td></tr></table></figure>
<p>在这个案例中，我们定义了一个女人类(Women)，通过这个类创建了一个xiaofang对象，然后输出了这个对象的属性(age)与方法(secret)。</p>
<p>现在我们将age这个属性与方法改为私有属性，也就是在它们前面加两个下划线，变成<code>__age</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.__age = <span class="number">18</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">secret</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 的年龄是%d"</span>%(self.name, self.__age))</div><div class="line"></div><div class="line">xiaofang = Women(<span class="string">"小芳"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 私有属性在外界不能被直接访问</span></div><div class="line">print(xiaofang.__age)</div><div class="line"></div><div class="line">xiaofang.secret()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/面向对象/hm_17_私有属性和方法.py"</span>, line <span class="number">13</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    print(xiaofang.__age)</div><div class="line">AttributeError: <span class="string">'Women'</span> object has no attribute <span class="string">'__age'</span></div></pre></td></tr></table></figure>
<p>运行结果出错，系统提示缺少属性<code>__age</code>。现在我们将<code>print(xiaofang.__age)</code>这句注释掉，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.__age = <span class="number">18</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">secret</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 在对象的方法内部，是可以访问对象的私有属性的</span></div><div class="line">        print(<span class="string">"%s 的年龄是%d"</span>%(self.name, self.__age))</div><div class="line"></div><div class="line">xiaofang = Women(<span class="string">"小芳"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 私有属性在外界不能被直接访问</span></div><div class="line"><span class="comment"># print(xiaofang.__age)</span></div><div class="line"></div><div class="line">xiaofang.secret()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">小芳 的年龄是<span class="number">18</span></div></pre></td></tr></table></figure>
<p>能够正常运行，这说明在对象的<code>secret</code>这个方法内部，可以访问这个对象的私有属性，也就是<code>self.__age</code>。</p>
<p>现在我们把<code>secret</code>这个方法也改为私有方法，即改为<code>__secret</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.__age = <span class="number">18</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__secret</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 的年龄是%d"</span>%(self.name, self.__age))</div><div class="line"></div><div class="line">xiaofang = Women(<span class="string">"小芳"</span>)</div><div class="line"></div><div class="line"><span class="comment"># print(xiaofang.__age)</span></div><div class="line"></div><div class="line">xiaofang.__secret()</div></pre></td></tr></table></figure>
<p>结果运算如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/面向对象/hm_17_私有属性和方法.py"</span>, line <span class="number">15</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    xiaofang.__secret()</div><div class="line">AttributeError: <span class="string">'Women'</span> object has no attribute <span class="string">'__secret'</span></div></pre></td></tr></table></figure>
<p>结果也无法运行，提示没有<code>__secret</code>这个方法。</p>
<h3 id="伪私有属性和伪私有方法">伪私有属性和伪私有方法</h3>
<p>在Python中并没有真正意义上的私有：</p>
<ul>
<li>在给属性、方法命名时，实际是对名称做了一些特殊处理，使得外界无法访问到；</li>
<li>如果我们要强行访问这些智能属性与方法，处理方式就是在名称前面加上<code>__类名</code>=&gt;<code>_类名__名称</code></li>
</ul>
<p>因此在Python中是有办法访问这些私有属性和私有方法，但在日常开发中，我们最好不要用这种方式来访问对象的私有属性或私有方法。</p>
<p>还来看一下前面的案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.__age = <span class="number">18</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__secret</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 的年龄是%d"</span>%(self.name, self.__age))</div><div class="line"></div><div class="line">xiaofang = Women(<span class="string">"小芳"</span>)</div><div class="line"></div><div class="line">print(xiaofang.__age)</div><div class="line"></div><div class="line"><span class="comment"># xiaofang.__secret()</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/黑马教程笔记/面向对象/hm_18_伪私有属性和方法.py"</span>, line <span class="number">13</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    print(xiaofang.__age)</div><div class="line">AttributeError: <span class="string">'Women'</span> object has no attribute <span class="string">'__age'</span></div></pre></td></tr></table></figure>
<p>解释器提示，没有<code>__age</code>这个属性，现在我们改变一下代码，也就是将<code>print(xiaofang.__age)</code>这句改为<code>print(xiaofang._Women__age)</code>，改动的地方就是将私有属性前面添加上类名，并在类名前面再加一个下划线，完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.__age = <span class="number">18</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__secret</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 的年龄是%d"</span>%(self.name, self.__age))</div><div class="line"></div><div class="line">xiaofang = Women(<span class="string">"小芳"</span>)</div><div class="line"></div><div class="line">print(xiaofang._Women__age)</div><div class="line"></div><div class="line"><span class="comment"># xiaofang.__secret()</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">18</span></div></pre></td></tr></table></figure>
<p>通过这种方法，我们就能访问对象的私有属性。再来看一下<code>__secret</code>这个私有方法的访问，也是同样的方法，即<code>xiaofang._Women__secret</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line">        self.__age = <span class="number">18</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__secret</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"%s 的年龄是%d"</span>%(self.name, self.__age))</div><div class="line"></div><div class="line">xiaofang = Women(<span class="string">"小芳"</span>)</div><div class="line"></div><div class="line">print(xiaofang._Women__age)</div><div class="line"></div><div class="line">xiaofang._Women__secret()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">18</span></div><div class="line">小芳 的年龄是<span class="number">18</span></div></pre></td></tr></table></figure>
<p>我们现在也能访问这个私有方法，因此在Python中，没有绝对意义上的私有属性与私有方法，因此可以称为<code>伪私有属性和伪私有方法</code>。</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>黑马Python视频教程</li>
<li>Python基础教程(第3版).Magnus Lie Hetland</li>
<li>Python无师自通：专业程序员的养成</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/12/Python/Python学习笔记（10）-输入输入与文件及目录操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/Python/Python学习笔记（10）-输入输入与文件及目录操作/" itemprop="url">Python学习笔记（10）-文件、目录和输入输出操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T12:00:00+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,841
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="读取键盘的输入">读取键盘的输入</h2>
<p>Python提供了<code>input()</code>内置函数从标准输入读入一行文本，默认的标准输入是键盘。<code>input</code>可以接收一个Python表达式作为输入，并将运算结果返回，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat input.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">str=input(<span class="string">"Please input:  "</span>)</div><div class="line">print(<span class="string">"What you input is: "</span>,str)</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 input.py </div><div class="line">Please input:  Hello</div><div class="line">What you input <span class="keyword">is</span>:  Hello</div></pre></td></tr></table></figure>
<h2 id="文件目录的斜杠处理">文件目录的斜杠处理</h2>
<p>在Python中，<code>\</code>是转义字符的标志，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"Hello, \npython"</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, </div><div class="line">python</div></pre></td></tr></table></figure>
<p>如果文件目录的首字母有<code>n</code>，那么就容易出错，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"c:\nowhere"</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c:</div><div class="line">owhere</div></pre></td></tr></table></figure>
<h4 id="目录的处理方法之一加r">目录的处理方法之一加<code>r</code></h4>
<p>此时可以在目录前面加一个<code>r</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">r"c:\nowhere"</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c:\nowhere</div></pre></td></tr></table></figure>
<h4 id="目录的处理方法之二加双斜杠">目录的处理方法之二加双斜杠<code>\\</code></h4>
<p>加双斜杠<code>\\</code>其实就是把<code>\</code>进行转义，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"c:\\nowhere"</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c:\nowhere</div></pre></td></tr></table></figure>
<h4 id="末尾左斜杠的处理">末尾左斜杠的处理</h4>
<p>但是还要注意的是，如果目录后面还有<code>\</code>，上面的两种方式就不合适了，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">r"c:\nowhere\")</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  File <span class="string">"&lt;ipython-input-8-2406b3e40ced&gt;"</span>, line <span class="number">1</span></div><div class="line">    print(<span class="string">r"c:\nowhere\")</span></div><div class="line"><span class="string">                         ^</span></div><div class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></div></pre></td></tr></table></figure>
<p>运行出错，EOL是End-of-life(项目终止/停产)的缩写。此时位于末尾的左斜杠的前面应该再加一个左斜杠，并用引号隔开，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">r"c:\nowhere"</span> <span class="string">"\\"</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c:\nowhere\</div></pre></td></tr></table></figure>
<h2 id="文件对象的方法">文件对象的方法</h2>
<h3 id="file对象常用函数">file对象常用函数</h3>
<p>file对象使用open函数来创建，下表列出了file对象常用的函数：</p>
<table style="width:92%;">
<colgroup>
<col width="6%">
<col width="84%">
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>方法及描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>file.close()：关闭文件。关闭后文件不能再进行读写操作。</td>
</tr>
<tr class="even">
<td>2</td>
<td>file.flush()：刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>
</tr>
<tr class="odd">
<td>3</td>
<td>file.fileno()：返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>
</tr>
<tr class="even">
<td>4</td>
<td>file.isatty()：如果文件连接到一个终端设备返回 True，否则返回 False。</td>
</tr>
<tr class="odd">
<td>5</td>
<td>file.next()：返回文件下一行。</td>
</tr>
<tr class="even">
<td>6</td>
<td>file.read([size])：从文件读取指定的字节数，如果未给定或为负则读取所有。</td>
</tr>
<tr class="odd">
<td>7</td>
<td>file.readline([size])：读取整行，包括 “” 字符。</td>
</tr>
<tr class="even">
<td>8</td>
<td>file.readlines([sizeint])：读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td>
</tr>
<tr class="odd">
<td>9</td>
<td>file.seek(offset[, whence])：设置文件当前位置</td>
</tr>
<tr class="even">
<td>10</td>
<td>file.tell()：返回文件当前位置。</td>
</tr>
<tr class="odd">
<td>11</td>
<td>file.truncate([size])：从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。</td>
</tr>
<tr class="even">
<td>12</td>
<td>file.write(str)：将字符串写入文件，没有返回值。</td>
</tr>
<tr class="odd">
<td>13</td>
<td>file.writelines(sequence)：向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody>
</table>
<h3 id="f.read">f.read()</h3>
<p>为了读取一个文件的内容，调用<code>f.read(size)</code>,这将读取一定数目的数据,然后作为字符串或字节对象返回。<code>size</code>是一个可选的数字类型的参数。当<code>size</code>被忽略了或者为负,那么该文件的所有内容都将被读取并且返回，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt</div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat read.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line"><span class="comment"># open a file</span></div><div class="line">f = open(<span class="string">"foo.txt"</span>,<span class="string">"r"</span>)</div><div class="line"></div><div class="line">str=f.read()</div><div class="line">print(str)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 read.py </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div></pre></td></tr></table></figure>
<h3 id="f.readline">f.readline()</h3>
<p><code>f.readline()</code>会从文件中读取单独的一行，换行符为<code>\n</code>，<code>f.readline()</code>如果返回一个空字符串，说明已经读取到了最后一下，看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat readline.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">f=open(<span class="string">"foo.txt"</span>,<span class="string">"r"</span>)</div><div class="line"></div><div class="line">str=f.readline()</div><div class="line">print(str)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 readline.py </div><div class="line">Python <span class="keyword">is</span> a good program language.</div></pre></td></tr></table></figure>
<h3 id="f.readlines">f.readlines()</h3>
<p><code>f.readlines()</code>将返回该文件中包含的所有行。如果设置可选参数<code>sizehint</code>,则读取指定长度的字节,并且将这些字节按行分割，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat readlines.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">f = open(<span class="string">"foo.txt"</span>,<span class="string">"r"</span>)</div><div class="line">str=f.readlines()</div><div class="line">print(str)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 readlines.py </div><div class="line">[<span class="string">'Python is a good program language.\n'</span>, <span class="string">' Yes, it is very good!\n'</span>]</div></pre></td></tr></table></figure>
<p>另外一种读取文件内容的方式就是对文件中的行进行迭代，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat iteration.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line">f=open(<span class="string">"foo.txt"</span>,<span class="string">"r"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">    print(line,end=<span class="string">" "</span>)</div><div class="line"></div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 iteration.py </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line">  Yes, it <span class="keyword">is</span> very good!</div></pre></td></tr></table></figure>
<h3 id="f.write">f.write()</h3>
<p>f.write(string)会将string写入到文件中，然后返回写入的字符数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good program language.</div><div class="line"> Yes, it <span class="keyword">is</span> very good!</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat f_write.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">f = open(<span class="string">"foo.txt"</span>,<span class="string">"w"</span>)</div><div class="line"></div><div class="line">num = f.write(<span class="string">"Python is a good tool.\n Yes, it is good!\n"</span>)</div><div class="line">print(num)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 f_write.py </div><div class="line"><span class="number">41</span></div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo.txt </div><div class="line">Python <span class="keyword">is</span> a good tool.</div><div class="line"> Yes, it <span class="keyword">is</span> good!</div></pre></td></tr></table></figure>
<p>如果要写入一些非字符串的东西, 那么将需要先进行转换，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat string_trans.py </div><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">f = open(<span class="string">"foo1.txt"</span>,<span class="string">"w"</span>)</div><div class="line">value = (<span class="string">'www.runoob.com'</span>,<span class="number">14</span>)</div><div class="line">s = str(value)+<span class="string">"\n"</span></div><div class="line">f.write(s)</div><div class="line">f.close()</div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ python3 string_trans.py </div><div class="line">biotest@biotest-VirtualBox:~/python3/<span class="number">03</span>file$ cat foo1.txt </div><div class="line">(<span class="string">'www.runoob.com'</span>, <span class="number">14</span>)</div></pre></td></tr></table></figure>
<h3 id="f.tell">f.tell()</h3>
<p><code>f.tell()</code>返回文件对象当前所处的位置,它是从文件开头开始算起的字节数。</p>
<h3 id="f.seek">f.seek()</h3>
<p>如果要改变文件当前的位置,可以使用<code>f.seek(offset,from_what)</code>函数。 <code>from_what</code>的值,如果是0表示开头,如果是1表示当前位置,2表示文件的结尾，例如：</p>
<ol style="list-style-type: decimal">
<li>seek(x,0)：从起始位置即文件首行首字符开始移动x个字符</li>
<li>seek(x,1)：表示从当前位置往后移动x个字符</li>
<li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li>
<li>from_what值为默认为0，即文件开头。</li>
</ol>
<p>看下面的案例： <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f=open(<span class="string">'foo.txt'</span>,<span class="string">'rb+'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b'0123456789abcdef'</span>)</div><div class="line"><span class="number">16</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">5</span>)</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</div><div class="line"><span class="string">b'5'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">-3</span>,<span class="number">2</span>)</div><div class="line"><span class="number">38</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</div><div class="line"><span class="string">b'd'</span></div></pre></td></tr></table></figure></p>
<h3 id="f.close">f.close()</h3>
<p>在文本文件中(那些打开文件的模式下没有<code>b</code>的)，只会相对于文件起始位置进行定位。当你处理完一个文件后，调用<code>f.close()</code>来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">ValueError: read of closed file</div></pre></td></tr></table></figure>
<p>当处理一个文件对象时,使用<code>with</code>关键字是非常好的方式。在结束后,它会帮你正确的关闭文件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'foo.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line"><span class="meta">... </span>    read_data = f.read()</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>菜鸟教程</li>
<li>MagnusLieHetland. Python基础教程.第3版[M]. 人民邮电出版社, 2018.</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/12/Python/Python学习笔记（11）-魔法方法、特性和迭代器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/Python/Python学习笔记（11）-魔法方法、特性和迭代器/" itemprop="url">Python学习笔记（11）-魔法方法、特性和迭代器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T12:00:00+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,808
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="魔法方法">魔法方法</h2>
<p>魔法方法(Magic methods)在Python中是一类特殊的方法，它们的形式就是前后有两个下划线，例如<code>__init__</code>这个方法，这个方法是我们最常见的魔法方法之一。</p>
<h2 id="构造函数">构造函数</h2>
<p>构造函数(constructor)是Python中的一个魔法方法，例如我们在创建某个类的时候使用的初始化方法<code>__init__</code>。<code>构造函数</code>不同的于普通方法的地方在于，对象创建后会自动调用魔法方法，例如常规的方法使用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f = FooBar()</div><div class="line">f.init()</div></pre></td></tr></table></figure>
<p>但是构造函数的使用如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f = FooBar()</div></pre></td></tr></table></figure>
<p>从上面可以看出，构造函数不用初始化，只要创建这个对象，它自己就自动初始化了，来看一个简单的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.somevar = <span class="number">42</span></div><div class="line">        </div><div class="line">f = FooBar()</div><div class="line">f.somevar</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.somevar = <span class="number">42</span></div><div class="line">f = FooBar()</div><div class="line">f.somevar</div><div class="line">Out[<span class="number">2</span>]: <span class="number">42</span></div></pre></td></tr></table></figure>
<p>从上面的结果可以看出来，在创建了<code>f</code>这个对象后，我们并没有给<code>f.somevar</code>添加属性，但是在<code>__init__</code>中我们已经初始化了这个属性，因此不用再次定义属性。</p>
<p>再给这个构造函数添加几个参数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value = <span class="number">24</span>)</span>:</span></div><div class="line">        self.somevar = value</div><div class="line"></div><div class="line">f = FooBar(<span class="string">"This is a constructor argument"</span>)</div><div class="line">f.somevar</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span>^M</div><div class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value = <span class="number">24</span>)</span>:</span>^M</div><div class="line">   ...:         self.somevar = value^M</div><div class="line">   ...: ^M</div><div class="line">   ...: f = FooBar(<span class="string">"This is a constructor argument"</span>)^M</div><div class="line">   ...: f.somevar</div><div class="line">   ...:</div><div class="line">Out[<span class="number">1</span>]: <span class="string">'This is a constructor argument'</span></div></pre></td></tr></table></figure>
<p>从这个案例中可以知道，如果指定了参数，那么最终属性显示的结果就是添加的指定的参数。</p>
<h3 id="重写普通方法和特殊的构造函数">重写普通方法和特殊的构造函数</h3>
<p>在面向对象的编程中，每个类都有一个或多个超类，并从它们那里继承行为，对<code>类B</code>的实例调用方法或访问其属性时，如果找不到该方法或属性，将在其<code>超类A</code>中查找，可以看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hello, I'm A."</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">a = A()</div><div class="line">b = B()</div><div class="line">a.hello()</div><div class="line">b.hello()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, I<span class="string">'m A.</span></div><div class="line"><span class="string">Hello, I'</span>m A.</div></pre></td></tr></table></figure>
<p>在这个案例中，我们可以看到，由于<code>类B</code>自己没有定义方法<code>hello</code>，因此对其调用方法<code>hello</code>时，打印的消息是<code>Hello, I'm A.</code>。要在子类中添加功能，一种基本方法是添加方法，但是如果你想写超类的某些方法，以定制继承而来的行为。还以上面的案例为例说明一下，<code>类B</code>可以重写方法<code>hello</code>，如下述修改后的<code>类B</code>定义如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hello, I'm A."</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hello, I'm B"</span>)</div><div class="line"></div><div class="line">a = A()</div><div class="line">b = B()</div><div class="line">a.hello()</div><div class="line">b.hello()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, I<span class="string">'m A.</span></div><div class="line"><span class="string">Hello, I'</span>m B</div></pre></td></tr></table></figure>
<p>重写是继承机制的一个重要方法，对构造函数来说万为重要，构造函数用于初始化新建对象的状态，而对于大多数子类来说，除超类的初始化代码外，还要有自己的初始化值代码。虽然所有方法的重写机制都相同，但与重写普通方法相比，重写构造函数时更有可能遇到一个特别的问题：重写构造函数时，必须调用超类（继承的类）的构建函数，否则无法正确地初始化对象，看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hungry = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hungry:</div><div class="line">            print(<span class="string">"Aaaah ..."</span>)</div><div class="line">            self.hungry = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"No, thanks!"</span>)</div><div class="line"></div><div class="line">b = Bird()</div><div class="line">b.eat()</div><div class="line">b.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Aaaah ...</div><div class="line">No, thanks!</div></pre></td></tr></table></figure>
<p>从这个案例中我们可以知道，初始情况下，<code>鸟b</code>处于饥饿状态(<code>hungry = True</code>)，第一次<code>b.eat()</code>后，输出的是<code>Aaaah ...</code>， 此时并把<code>hungry = True</code>切换为<code>hungry = False</code>，当第二次<code>b.eat()</code>后，就输出了<code>No, thanks !</code>。</p>
<p>再看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hungry = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hungry:</div><div class="line">            print(<span class="string">"Aaaah ..."</span>)</div><div class="line">            self.hungry = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"No, thanks!"</span>)</div><div class="line"></div><div class="line">b = Bird()</div><div class="line">b.eat()</div><div class="line">b.eat()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongBird</span><span class="params">(Bird)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.sound = <span class="string">"Squawk!"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.sound)</div><div class="line"></div><div class="line">singbird = SongBird()</div><div class="line">singbird.sing()</div><div class="line">singbird.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Aaaah ...</div><div class="line">Traceback (most recent call last):</div><div class="line">No, thanks!</div><div class="line">Squawk!</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">24</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    singbird.eat()</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> eat</div><div class="line">    <span class="keyword">if</span> self.hungry:</div><div class="line">AttributeError: <span class="string">'SongBird'</span> object has no attribute <span class="string">'hungry'</span></div></pre></td></tr></table></figure>
<p>在这个案例中，<code>SongBird</code>是<code>Bird</code>的子类，继承了方法<code>est</code>，但如果你要尝试调用它，就出现了问题。</p>
<p>异常提示，<code>SongBird</code>没有属性<code>hungry</code>，这是因为，在<code>SongBird</code>类中重写了构造函数，但新的构造函数中没有包含任何初始化属性<code>hungry</code>的代码。如果要消除这种错误，<code>SongBird</code>的构造函数必须调用其超类<code>Bird</code>的构造函数，以确保基本的初始化得以执行。</p>
<p>为此，有两种方法：</p>
<p>第一，调用未关联的超类构造函数；</p>
<p>第二，使用函数<code>super</code>。</p>
<h3 id="调用未关联的超类构建函数">调用未关联的超类构建函数</h3>
<p>还以上面的案例为例说明一下，如果要调用未关联的超类方法，就要添加一行<code>Bird.__init__(self)</code>，完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hungry = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hungry:</div><div class="line">            print(<span class="string">"Aaaah ..."</span>)</div><div class="line">            self.hungry = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"No, thanks!"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongBird</span><span class="params">(Bird)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        Bird.__init__(self)</div><div class="line">        self.sound = <span class="string">"Squawk!"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.sound)</div><div class="line"></div><div class="line">singbird = SongBird()</div><div class="line">singbird.sing()</div><div class="line">singbird.eat()</div><div class="line">singbird.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Squawk!</div><div class="line">Aaaah ...</div><div class="line">No, thanks!</div></pre></td></tr></table></figure>
<p>在常规的面向对象编程中，对<code>实例调用方法时</code>，方法的参数<code>self</code>将自动关联到实例（称为关联的方法）。</p>
<p>如果通过<code>类调用方法</code>（例如<code>Bird.__init__</code>），就没有实例与其相关联，在这种情况下，可以随便设置参数<code>self</code>，这样的方法称为<code>未关联</code>。参过将这个未关联方法的<code>self</code>参数设置为当前实例，将使用超类的构造函数来初始化<code>singbird</code>对象，这表明将设置其属性<code>hungry</code>。</p>
<h3 id="使用super函数">使用<code>super()</code>函数</h3>
<p>这一种方法只适用Python3。调用<code>super</code>这个函数时，将当前类和当前实例作为参数。对其返回的对象调用方法时，调用的是将是超类（而不是当前类）的方法，因此在<code>singbird</code>的构造函数中，可以不使用<code>Bird</code>而是使用了<code>super(singbird, self)</code>，另外，可以像常规调用方法那样（也就是调用关联的方法那样）调用方法<code>__init__</code>。在Python3中调用函数<code>super</code>，可以不提供任何参数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hungry = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hungry:</div><div class="line">            print(<span class="string">"Aaaah ..."</span>)</div><div class="line">            self.hungry = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"No, thanks!"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongBird</span><span class="params">(Bird)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super().__init__()</div><div class="line">        self.sound = <span class="string">"Squawk!"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.sound)</div><div class="line"></div><div class="line">singbird = SongBird()</div><div class="line">singbird.sing()</div><div class="line">singbird.eat()</div><div class="line">singbird.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Squawk!</div><div class="line">Aaaah ...</div><div class="line">No, thanks!</div></pre></td></tr></table></figure>
<h2 id="元素访问">元素访问</h2>
<p>这一部分是其他的魔法方法。</p>
<h3 id="基本的序列和映射协议">基本的序列和映射协议</h3>
<p>序列和映射基本上是<code>元素(item)</code>的集合，要实现它们的基本行为（协议），不可变对象需要实现2个方法，而可变对象要实现4个：</p>
<ul>
<li><code>__len__(self)</code>：这个方法返回集合包含的项数，对序列来说就是元素个数，对映射来说，就是<code>键-值</code>对。如果<code>__len__(self)</code>返回零（且没有实现覆盖这种行为的<code>__nonzero__</code>），对象在布尔上下文中将被视为假（就像空的列表、元组、字符串和字典一样）。</li>
<li><code>__getitem__(self, key)</code>：返回与指定键相关联的值。对序列来说，键应该是<code>0~n-1</code>的整数（也可以是负数），其中<code>n</code>为序列的长度，对映射来说，键可以是任何类型。如果键为负责，应从末尾往前数，也就是说<code>x[-n]</code>应与<code>x[len(x)-n]</code>等效。</li>
<li><code>__setitem__(self, key8, value)</code>：这个方法应以与键相关联的方式存储值，以便以后能够使用<code>__getitem__</code>来获取。</li>
<li><code>__delitem__(self, key)</code>：这个方法在对对象的组成部分使用<code>__del__</code>语句时被调用，应删除与key相关联的值，同样，仅当对象可变（且允许其值被删除）时，才需要实现这个方法。</li>
</ul>
<p>另外，如果键的类型不合适（如对序列使用字符串键），可能引发<code>TypeError</code>异常。对于序列，如果索引的类型是正确的，但不在允许的范围内，会引发<code>IndexError</code>异常。</p>
<p>下面看一个案例，观察一下能否创建一个无穷序列，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=utf8</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_index</span><span class="params">(key)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    指定的键上是否是可接受的索引？</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    键必须是非负整数，才是可接受的；</span></div><div class="line"><span class="string">    如果不是整数，将引发TypeError异常；</span></div><div class="line"><span class="string">    如果是负数，将引发IndexError异常（因为这个序列是无穷的）</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(key, int): <span class="keyword">raise</span> TypeError</div><div class="line">    <span class="keyword">if</span> key &lt; <span class="number">0</span>:<span class="keyword">raise</span> IndexError</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArithmeticSequence</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start = <span class="number">0</span>, step = <span class="number">1</span>)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        初始化这个算术序列</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        start --- 序列中的第一个值</span></div><div class="line"><span class="string">        step  --- 两个相邻的值的差</span></div><div class="line"><span class="string">        changed - 一个字典，包含用户修改后的值</span></div><div class="line"><span class="string">        """</span></div><div class="line">        self.start = start <span class="comment">#存储起始值</span></div><div class="line">        self.step = step</div><div class="line">        self.changed = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        从算术序列中获取一个元素</span></div><div class="line"><span class="string">        """</span></div><div class="line">        check_index(key)</div><div class="line"></div><div class="line">        <span class="keyword">try</span>: <span class="keyword">return</span> self.changed[key]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">return</span> self.start + key*self.step</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        修改算术序列中的元素</span></div><div class="line"><span class="string">        """</span></div><div class="line">        check_index(key)</div><div class="line">        self.changed[key] = value</div><div class="line"></div><div class="line">s = ArithmeticSequence(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">s[<span class="number">4</span>]</div><div class="line">s[<span class="number">4</span>] = <span class="number">2</span></div><div class="line">s[<span class="number">4</span>]</div><div class="line">s[<span class="number">5</span>]</div><div class="line">print(s[<span class="number">4</span>])</div><div class="line">print(s[<span class="number">5</span>])</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span></div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure>
<p>这些代码实现的是一个<code>算术序列</code>，其中任何两个相邻数字的差都相同，第一值是由构造函数的参数<code>start</code>（默认为0）指定的，而相邻值之间的差是由参数<code>step</code>（默认为1）指定的。允许允许修改某些元素，这是通过将不符合规则的值保存在字典<code>changed</code>中实现的。如果元素未被修改，就用公式<code>self.start + key*self.step</code>来计算它的值。</p>
<p>这段代码中禁止删除元素，因此没有实现<code>__del__</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">del</span> s[<span class="number">4</span>]</div><div class="line">File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">52</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">del</span> s[<span class="number">4</span>]</div><div class="line">AttributeError: __delitem__</div></pre></td></tr></table></figure>
<p>另外这个类中没有方法<code>__len__</code>，因此其长度是无穷的，如果所使用考虑综的类型非法，将引发TypeError异常，如果索引的类型正确，但不在允许的范围内（即为负数），将引发IndexError异常，其中索引的检查是源代码中的<code>check_index</code>这个函数负责的，如果出现索引错误，就是如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">s[<span class="string">"four"</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">49</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    s[<span class="string">"four"</span>]</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">31</span>, <span class="keyword">in</span> __getitem__</div><div class="line">    check_index(key)</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> check_index</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(key, int): <span class="keyword">raise</span> TypeError</div><div class="line">TypeError</div><div class="line">s[<span class="number">-42</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">49</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    s[<span class="number">-42</span>]</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">31</span>, <span class="keyword">in</span> __getitem__</div><div class="line">    check_index(key)</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> check_index</div><div class="line">    <span class="keyword">if</span> key &lt; <span class="number">0</span>:<span class="keyword">raise</span> IndexError</div><div class="line">IndexError</div></pre></td></tr></table></figure>
<h3 id="从listdict和str派生">从list、dict和str派生</h3>
<p>关于序列/映射的一些方法可以还从已有方法中继承，在标准库<code>collections</code>这个模块中提供了抽象和具体的基类，用户也能继承内置类型。因此如果要实现一种行为类似于内置列表的序列类型，可以直接继承list，在下面这个案例中，来实现一个带访问计数器的列表，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterList</span><span class="params">(list)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        super().__init__(*args)</div><div class="line">        self.counter = <span class="number">0</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></div><div class="line">        self.counter += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> super(CounterList, self).__getitem__(index)</div></pre></td></tr></table></figure>
<p>在上面的这段代码中，<code>CounterList</code>类依赖于其超类<code>List</code>的行为。<code>CounterList</code>没有重写的方法（如<code>append</code>、<code>extend</code>，<code>index</code>等）都可以直接使用。在两个被重写的方法中，使用<code>super</code>来调用超类的相应方法，并添加了必要的行为：初始化属性<code>counter</code>（在<code>__init__</code>中）和更新属性<code>counter</code>（在<code>__getitem__</code>）。需要注意的是，重写<code>__getitem__</code>并不能保证一定会捕捉用户的访问操作，因为还有其他访问列表内容的方法，例如通过方法<code>pop</code>，下面来演示一下<code>CounterList</code>的可能用法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterList</span><span class="params">(list)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        super().__init__(*args)</div><div class="line">        self.counter = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></div><div class="line">        self.counter += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> super(CounterList, self).__getitem__(index)</div><div class="line"></div><div class="line">cl = CounterList(range(<span class="number">10</span>))</div><div class="line">print(cl)</div><div class="line">cl.reverse()</div><div class="line">print(cl)</div><div class="line"><span class="keyword">del</span> cl[<span class="number">3</span>:<span class="number">6</span>]</div><div class="line">print(cl.counter)</div><div class="line">print(cl[<span class="number">4</span>] + cl[<span class="number">2</span>])</div><div class="line">print(cl.counter)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>在上面的案例中，<code>CounterList</code>的行为在大多数方面的都类型于列表，但它有一个<code>counter</code>属性（其初始值为0），每当访问列表元素时，这个属性的值就都加1，执行加法运算<code>cl[4] + cl[2]</code>后，<code>counter</code>的值递增了2次，变成了2。</p>
<h2 id="特性">特性</h2>
<p><code>存取方法</code>是名称类似于<code>getHeight</code>和<code>setHeight</code>的方法，用于获取或设置属性，如果访问给定属性时，必须采取特定的措施，那么像这样的封装状态变量（属性）很重要，例如看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.width = <span class="number">0</span></div><div class="line">        self.height = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_size</span><span class="params">(self, size)</span>:</span></div><div class="line">        self.width, self.height = size</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.width, self.height</div><div class="line"></div><div class="line">r = Rectangle()</div><div class="line">r.width = <span class="number">10</span></div><div class="line">r.height = <span class="number">5</span></div><div class="line">print(r.get_size())</div><div class="line">r.set_size((<span class="number">150</span>, <span class="number">100</span>))</div><div class="line">print(r.width)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(r.get_size())</div><div class="line">(<span class="number">10</span>, <span class="number">5</span>)</div><div class="line">print(r.width)</div><div class="line"><span class="number">150</span></div></pre></td></tr></table></figure>
<p><code>get_size</code>和<code>set_size</code>是假想属性<code>size</code>的存取方法，这个属性是一个由<code>width</code>和<code>height</code>组成的元组，这些代码并非完全错误，但存在缺陷。使用这个类时，用户无需关心它是如何被封装的。如果用户想要修改实现，让size成为真正的属性，而width和height是动态计算出来的，就需要提供用于访问width和height的存取方法，使用这个类的程序也必须重写。应当客户代码能够以同样的方式对待所有的属性。</p>
<p>那么如何解决这个问题呢？给所有的属性都提供存取方法并不现实。而Python能够隐藏存取方法，让所有的属性看起来都一样，通过存取方法定义的属性通常称为<code>特性(property)</code>。在Python中有两种创建特性的机制，但Python中只用<code>property</code>函数。</p>
<h3 id="property函数"><code>property</code>函数</h3>
<p>以前面的<code>Rectangle</code>类为例说明一下，在使用<code>property</code>函数时，只需要添加一行代码，即<code>size = property(get_size, set_size)</code>即可，完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.width = <span class="number">0</span></div><div class="line">        self.height = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_size</span><span class="params">(self, size)</span>:</span></div><div class="line">        self.width, self.height = size</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.width, self.height</div><div class="line">    size = property(get_size, set_size)</div><div class="line"></div><div class="line">r = Rectangle()</div><div class="line">r.width = <span class="number">10</span></div><div class="line">r.height = <span class="number">5</span></div><div class="line">print(r.size)</div><div class="line">r.size = <span class="number">150</span>, <span class="number">100</span></div><div class="line">print(r.width)</div></pre></td></tr></table></figure>
<p>在上面的这段代码中，通过调用<code>property</code>函数，将存取方法作为参数（<code>获取方法</code>在前，<code>设置方法</code>在后）创建了一个特性，然后将名称<code>size</code>关联到这个特性。这样就能以同样的方式对待width、height和size了，而无需关心它们是如何实现的，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(r.size)</div><div class="line">(<span class="number">10</span>, <span class="number">5</span>)</div><div class="line">print(r.width)</div><div class="line"><span class="number">150</span></div></pre></td></tr></table></figure>
<p>从运行结果中可以看到，属性<code>size</code>依然受制于<code>get_size</code>和<code>set_size</code>执行的计算，但是看起来就像普通属性一样。</p>
<p>事实上，调用函数<code>property</code>时，还可以①不指定参数；②指定一个参数；③指定三个参数或四个参数。</p>
<p>如果没有指定任何参数，创建的特性将既不可读，也不可写。如果只指定一个参数（获取方法），创建的特性将是只读的。第三个参数是可选的，指定用于删除属性的方法（这个方法不接受任何参数）。第四个参数也是可选的，指定一个文档字符串，这些参数分别命名为<code>fget</code>、<code>fset</code>、<code>fdel</code>和<code>doc</code>。如果要创建一个只可写且带文档字符串的特性，可使用它们作为关键字参数。</p>
<h3 id="property函数的工作原理"><code>property</code>函数的工作原理</h3>
<p><code>property</code>其实并不一个函数，而是一个类，它的实例包含一些魔法方法，而所有的魔法都是由这些方法完成的。这些魔法方法为<code>__get__</code>，<code>__set__</code>和<code>__delete__</code>，它们一道定义了所谓的描述符协议。只要对象实现了这些方法中的任何一个，它就是一个描述符。描述符的独特之处在于其访问方式。例如，读取属性（具体来说，是在实例中访问类中定义的属性）时，如果它关联的是一个实现了<code>__get__</code>的对象，将不会返回这个对象，而是调用方法<code>__get__</code>并将其结果返回。实际上，这是隐藏在特性、关联的方法、静态方法和类方法。</p>
<h3 id="静态方法和类方法">静态方法和类方法</h3>
<p>静态方法和类方法是这样创建的：将它们分别包装在<code>staticmethod</code>和<code>classmethod</code>类的对象中。静态方法的定义中没有参数<code>self</code>，可直接通过类来调用。类方法的定义中包含类似于self的参数，通常被命令为cls，对于类方法，也可通过对象直接调用，但参数cls将自动关联到类。</p>
<p>看下面的一个简单案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smeth</span><span class="params">()</span>:</span></div><div class="line">        print(<span class="string">"This is a static method"</span>)</div><div class="line">    smeth = staticmethod(smeth)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmeth</span><span class="params">(cls)</span>:</span></div><div class="line">        print(<span class="string">"This is a class method of"</span>,cls)</div><div class="line">    cmeth = classmethod(cmeth)</div></pre></td></tr></table></figure>
<p>像这样手工包装和替换方法有点繁琐。在Python2中，引入了一种名为<code>装饰器</code>的新语法，可用于像这样包装方法（实际上，装饰器可用于包装任何可调用的对象，并且可用于方法和函数）。要指定一个或多个装饰器，为此可在方法（或函数）前面使用运算符<code>@</code>列出这些装饰器（指定了多少装饰器时，应用的顺序与列出的顺序相反），如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smeth</span><span class="params">()</span>:</span></div><div class="line">        print(<span class="string">"This is a static method"</span>)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmeth</span><span class="params">(cls)</span>:</span></div><div class="line">        print(<span class="string">"This is a class methods of "</span>, cls)</div><div class="line"></div><div class="line">MyClass.smeth()</div><div class="line">MyClass.cmeth()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">This <span class="keyword">is</span> a static method</div><div class="line">This <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">of</span>  &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">MyClass</span>'&gt;</span></div></pre></td></tr></table></figure>
<h3 id="getattr____setattr__等方法"><code>__getattr__</code>、<code>__setattr__</code>等方法</h3>
<p>可以拦截对象属性的所有访问企图、其用途之一是在旧式类中实现特性（在旧类中，函数<code>property</code>的行为可能不符合预期）。要在属性被访问时执行一段代码，必须使用一些魔法方法，以下的4个魔法方法提供了你需要的所有功能：</p>
<ul>
<li><code>__getattribute__(self, name)</code>：在属性被访问时自动调用；</li>
<li><code>__getattr__(self, name)</code>：在属性被访问而对象没有这样的属性时自动调用；</li>
<li><code>__setattr__(self, name, value)</code>：试图给属性赋值时自动调用；</li>
<li><code>__delattr__(self, name)</code>：试图删除属性时自动调用。</li>
</ul>
<p>相比函数<code>property</code>，这些魔法方法使用起来比较麻烦。但它们很有用，因为用户可以在这些方法中编写处理多个特性的代码。然而在可能的情况下，最好还是首选<code>property</code>函数。</p>
<p>还看一下前面的<code>Rectangle</code>的案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.width = <span class="number">0</span></div><div class="line">        self.height = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">"size"</span>:</div><div class="line">            self.width, self.height = value</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.__dict__[name] = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">"size"</span>:</div><div class="line">            <span class="keyword">return</span> self.width, self.height</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError()</div></pre></td></tr></table></figure>
<p>如上面代码所示，这个版本需要处理额外的管理细节，对于这段代码，需要注意以下两点：</p>
<ol style="list-style-type: decimal">
<li>即使涉及的属性不是<code>size</code>，也将调用方法<code>__setattr__</code>。因此这个方法必须考虑如下两种情形：如果涉及的属性为<code>size</code>，就执行与以前一样的操作；否则就使用魔法属性<code>__dict__</code>。<code>__dict__</code>属性是一个字典，其中包含所有的实例属性。使用它们而不是执行常规属性赋值，是因为旨在避免再次调用<code>__setattr__</code>，进而导致无限循环。</li>
<li>仅当没有找到指定的属性时，才会调用方法<code>__getattr__</code>。这意味着如果指定的名称不是<code>size</code>，这个方法将引发<code>AttributeError</code>异常。这在要让类能够正确地支持<code>__hasattr__</code>和<code>__getattr__</code>等内置函数时非常重要。如果指定的名称为<code>size</code>，就使用前一个实现中的表达式。</li>
</ol>
<p>需要注意的是：编写方法<code>__setattr__</code>时需要避开无限循环陷阱，编写<code>__getattribute__</code>时也是如此。由于它拦截对所有属性的访问，因此将拦截对<code>__dict__</code>的访问。在<code>__getattribute__</code>中访问当前实例的属性时，唯一案例的方式是使用父类的方法<code>__getattribute__</code>（使用<code>super</code>）。</p>
<h2 id="迭代器">迭代器</h2>
<p>有关迭代器的魔法方法是<code>__iter__</code>，它是迭代器协议的基础。</p>
<h3 id="迭代器协议">迭代器协议</h3>
<p><code>迭代(iterate)</code>意味着重复多次，就像循环那样。方法<code>__iter__</code>返回一个迭代器，它是包含方法<code>__next__</code>的对象，而调用这个方法时可不提供任何参数，当调用<code>__next__</code>方法时，迭代器应返回其下一个值。如果迭代器没有可供返回的值，应引发<code>StopIteration</code>异常。另外，还可以使用内置的函数<code>next</code>，在这种情况下<code>next(it)</code>与<code>it.__next__()</code>等效。</p>
<p>这有什么意义呢，为什么不使用列表？</p>
<p>因为在很多情况下，使用列表都点大材小用。例如，现在有一个可逐个计算值的函数，你可能只想逐个地获取值，而不是使用列表一次性获取。这是因为如果有很多值，列表可以战用太多的内存。但还有其他原因：使用迭代器更通用与简便。</p>
<p>在下面的案例中就可以看到不能使用列表的案例，因为如果要使用列表，这个列表的长度必须是无穷大的，下面的这个案例是有关斐波那契数列的，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibs</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a = <span class="number">0</span></div><div class="line">        self.b = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a, self.b = self.b, self.a + self.b</div><div class="line">        <span class="keyword">return</span> self.a</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div></pre></td></tr></table></figure>
<p>这个迭代器实现了方法<code>__iter__</code>，而这个方法返回迭代器本身，在很多情况下，都在<code>另一个</code>对象中实现返回迭代器的方法<code>__iter__</code>，并在for循环中使用这个对象。在推荐在迭代器中也实现方法<code>__iter__</code>（并像刚才那样让它返回self），这样迭代器就可直接用于for循环中。</p>
<p>有关<code>迭代</code>更正规的定义是，实现了方法<code>__iter__</code>的对象是<strong>可迭代的</strong>，而实现了方法<code>__next__</code>的对象是<strong>迭代器</strong>。</p>
<p>来看一下迭代器的for循环案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibs</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a = <span class="number">0</span></div><div class="line">        self.b = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a, self.b = self.b, self.a + self.b</div><div class="line">        <span class="keyword">return</span> self.a</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line"></div><div class="line">fibs = Fibs()</div><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> fibs:</div><div class="line">    <span class="keyword">if</span> f &gt; <span class="number">1000</span>:</div><div class="line">        print(f)</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1597</span></div></pre></td></tr></table></figure>
<p>这个循环会停止是因为其中包含break语句，否则这个for循环会一直执行下去。</p>
<p>通过对可迭代对象调用内置函数<code>iter</code>就可以获得一个迭代器，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</div><div class="line"><span class="number">1</span></div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h3 id="从迭代器创建序列">从迭代器创建序列</h3>
<p>除了对迭代器和可迭代对象进行迭代外，还可以将它们转换为序列。在可以使用序列的情况下，大多数也可以使用迭代器或可迭代对象（索引和切片这种操作除外）。</p>
<p>看下面的一个案例，使用构造函数list显式地将迭代器转换为列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestIterator</span>:</span></div><div class="line">    value = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        self.value += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> self.value &gt; <span class="number">10</span>:<span class="keyword">raise</span> StopIteration</div><div class="line">        <span class="keyword">return</span> self.value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">ti = TestIterator()</div><div class="line">list(ti)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div></pre></td></tr></table></figure>
<h2 id="生成器">生成器</h2>
<p>生成器是一种使用普通函数语法定义的迭代器。</p>
<h3 id="创建生成器">创建生成器</h3>
<p>现在创建一个将嵌套列表展开的函数，这个函数以类似于下面的列表作为参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nested = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>]]</div></pre></td></tr></table></figure>
<p>上面的这个参数其实是一个列表的列表，现在定义这样的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(nested)</span>:</span></div><div class="line">    <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</div><div class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> sublist:</div><div class="line">            <span class="keyword">yield</span> element</div></pre></td></tr></table></figure>
<p>这个函数首选迭代所提供嵌套列表中的所有子列表，然后按顺序迭代每个子列表的元素。</p>
<p>这个函数的最后一行含有<code>yield</code>语句，像含有<code>yield</code>语句的函数都被称为<strong>生成器</strong>。生成器与普通函数的区别在于，生成器不是使用<code>return</code>返回一个值，而是生成多个值，一次一个。每次使用<code>yield</code>生成一个值后，函数都将冻结，即在此停止执行，等待被重新唤醒，被唤醒后，函数将从停止的地方开始继续执行。</p>
<p>为使用所有的值，可对生成器进行迭代，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">nested = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>]]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(nested)</span>:</span></div><div class="line">    <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</div><div class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> sublist:</div><div class="line">            <span class="keyword">yield</span> element</div><div class="line"></div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> flatten(nested):</div><div class="line">    print(num)</div><div class="line">    </div><div class="line"><span class="comment"># 或者如下所示</span></div><div class="line">list(flatten(nested))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> flatten(nested):</div><div class="line"><span class="meta">... </span>    print(num)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 或者如下所示</span></div><div class="line"><span class="meta">... </span>list(flatten(nested))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>
<h3 id="生成器推导">生成器推导</h3>
<p><strong>生成器推导</strong>也叫<strong>生成器表达式</strong>，这是一个类似于列表推导的概念。其工作原理与列表推导相同，但不是创建一个列表，而是返回一个生成器，让你能够逐步执行计算，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i + <span class="number">2</span> **<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">27</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">7</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>在这段代码中，使用的是圆括号。像在这种简单的情形下，不如使用列表推导；但如果要包装可迭代对象（可能生成大量的值），使用列表推导将立即实例化一个列表，从而丧失迭代的优势。另一个好处是，直接在一对既有的圆括号内（如在函数中调用）使用生成器推导时，无需再添加一对圆括号。也就是可编写下面这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum(i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"><span class="number">285</span></div></pre></td></tr></table></figure>
<h3 id="递归生成器">递归生成器</h3>
<p>前面的生成器是使用了2个for循环实现的，如果要处理更多层的嵌套列表，此时就需要使用递归的思路，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(nested)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</div><div class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> flatten(sublist):</div><div class="line">                <span class="keyword">yield</span> element</div><div class="line">    <span class="keyword">except</span> TypeError:</div><div class="line">        <span class="keyword">yield</span> nested</div></pre></td></tr></table></figure>
<p>调用<code>flatten</code>时，有两种可能性：</p>
<p>第一，<strong>基线条件</strong>。在基线条件下，要求这个函数展开单个元素，例如一个数，在这种情况下，for循环将引发TypeError异常（因为用户此时试图迭代一个数），而这个生成器只生成一个元素。</p>
<p>第二，<strong>递归条件</strong>。如果要展开的是一个列表，就需要做这些工作：遍历所有的子列表，并对它们调用<code>flatten</code>，然后使用另一个for循环生成展开后的子列表中的所有元素，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(flatten([[[<span class="number">1</span>],<span class="number">2</span>],<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]],<span class="number">8</span>]))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
<p>但是这种方案存在一个问题，如果<code>nested</code>是字符串或类似于字符串的对象，它就属于序列，因此不会引发TypeError异常。要处理这种问题，必须要在生成器开头进行检查。要检查对象是否类似于字符串，最简单的方式就是尝试将对象与一个字符串拼接起来，并检查这是否会引发TypeError异常，添加后的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=utf8</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(nested)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="comment"># 不迭代类似于字符串的对象：</span></div><div class="line">        <span class="keyword">try</span>:nested +<span class="string">""</span></div><div class="line">        <span class="keyword">except</span> TypeError:<span class="keyword">pass</span></div><div class="line">        <span class="keyword">else</span>:<span class="keyword">raise</span> TypeError</div><div class="line">        <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</div><div class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> flatten(sublist):</div><div class="line">                <span class="keyword">yield</span> element</div><div class="line">    <span class="keyword">except</span> TypeError:</div><div class="line">        <span class="keyword">yield</span> nested</div><div class="line"></div><div class="line">list(flatten([<span class="string">'foo'</span>, [<span class="string">'bar'</span>,[<span class="string">'baz'</span>]]]))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(flatten([<span class="string">'foo'</span>, [<span class="string">'bar'</span>,[<span class="string">'baz'</span>]]]))</div><div class="line">[<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</div></pre></td></tr></table></figure>
<p>在这个案例中，如查表达式<code>nested + &quot;&quot;</code>引发了TypeError异常，就忽略这种异常；如果没有引发TypeError异常，内部<code>try</code>语句中的else语句就引发TypeError异常，这样将在外部的except中生成类似于字符串的对象。</p>
<p>需要注意的是，这段代码没有进行类型检查，也就是说没有检查<code>nested</code>是否为字符串，而是只检查了它的行为是否类似于字符串，即能否与字符串拼接。对于这种检查，更符合常规思路的方案是使用<code>isinstance</code>以及字符串和类似于字符串的对象的一些抽象父类，但是Python中没这样的标准类。</p>
<h3 id="通用生成器">通用生成器</h3>
<p>这里再描述一下生成器，生成器是含有<code>yield</code>的函数，但被调用时不会执行函数体内的代码，而是返回一个迭代器，每次请求值时，都将执行生成器的代码，直到遇到<code>yield</code>或<code>return</code>，<code>yield</code>意味着应生成一个值，而<code>return</code>意味着生成器应停止执行（即不再生成值，仅当在生成器调用<code>return</code>时，才能不提供任何参数）。</p>
<p>换句话讲就是，生成器由两个单独的部分构成：①<strong>生成器的函数</strong>和②<strong>生成器的迭代器</strong>。生成器的函数是由<code>def</code>语句定义的，其中包含<code>yield</code>。生成器迭代器是这个函数返回的结果。用不太精准的话讲，生成器就是这两个东西的组合，看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_generator</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></div><div class="line">...</div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>simple_generator</div><div class="line">&lt;function simple_generator at <span class="number">0x0000021C0C224840</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>simple_generator()</div><div class="line">&lt;generator object simple_generator at <span class="number">0x0000021C0C203F68</span>&gt;</div></pre></td></tr></table></figure>
<h3 id="生成器的方法">生成器的方法</h3>
<p>在生成器开始运行后，可使用生成器和外部之间的通信渠道向它提供值，这个通信渠道包含如下两个商战：</p>
<ul>
<li><strong>外部世界</strong>：外部世界可访问生成器的方法<code>send</code>，这个方法类似于<code>next</code>，但接受一个参数（要发挥的<code>消息</code>可以是任何对象）。</li>
<li><strong>生成器</strong>：在挂起的生成器内部，<code>yield</code>可能用作<strong>表达式</strong>而不是<strong>语句</strong>。也就是说，在生成器重新运行时，<code>yield</code>返回一个值，也就是通过<code>send</code>从外部世界发达的值。如果使用的是<code>next</code>，<code>yield</code>将返回<code>None</code>。需要注意的是，仅当生成器被挂起（也就是遇到第一个<code>yield</code>）后，使用<code>send</code>（而不是<code>next</code>）才有意义。要在此之前向生成器提供消息，可使用生成器的函数的参数，下面的一个简单的案例就说明了这个机制：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeater</span><span class="params">(value)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        new = (<span class="keyword">yield</span> value)</div><div class="line">        <span class="keyword">if</span> new <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:value = new</div><div class="line">        </div><div class="line">r = repeater(<span class="number">42</span>)</div><div class="line">next(r)</div><div class="line">r.send(<span class="string">"Hello, python"</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = repeater(<span class="number">42</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(r)</div><div class="line"><span class="number">42</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.send(<span class="string">"Hello, python"</span>)</div><div class="line"><span class="string">'Hello, python'</span></div></pre></td></tr></table></figure>
<p>在上面代码中，使用圆括号将<code>yield</code>表达式圈了起来。</p>
<p>生成器还有另外两种方法，分别是<code>throw</code>与<code>close</code>。其中：</p>
<p><code>throw</code>方法用于在生成器中（yield表达式处）引发异常调用时可提供一个异常类型、一个可选值和一个<code>traceback</code>对象。</p>
<p><code>close</code>方法用于停止生成器，调用时无需提供任何参数。方法<code>close</code>也是基于异常的。在<code>yield</code>处引发<code>GeneratorExit</code>异常。因此如果要在生成器中提供一些清理代码，可将<code>yield</code>放在一条<code>try/finally</code>语句中。如果愿意，也可以捕获<code>GeneratorExit</code>异常，但随后必须重新引发它（可能在清理后）、引发其他 异常或直接返回。对生成器调用<code>close</code>方法后，再试图从它那里获取值将导致<code>RuntimeError</code>异常。</p>
<h2 id="生成器的使用案例八皇后问题">生成器的使用案例——八皇后问题</h2>
<p>现在使用生成器来解决一个经典的编程问题。</p>
<h3 id="问题背景">问题背景</h3>
<p>对于逐步得到结果的复杂递归算法，非常适合使用生成器来实现。要在不使用生成器的情况下实现这些算法，通常必须通过额外的参数来传递部分结果，让递归调用能够接着往下计算。通过使用生成器，所有的递归调用进乞只需要生成其负责部分的结果。在前面的递归函数<code>flatten</code>就是这样做的，可以使用这种策略来遍历<code>图结构</code>和<code>树结构</code>。</p>
<p>然而在有些应用程序中，你不能马上得到答案。你必须尝试多次，且在每个递归层级中都如此。</p>
<p>这里讲一个简单的案例。假设你要去参加一个很重要的会议，你不知道会议在哪里召开，但前面有两扇门，而会议室就在其中一扇门的后面。你选择进入左边的那扇门后，又看到两扇门。你再次选择进入左边的那扇门，但发现走错了。因此你往回走，并进入右边那扇门，但发现也走错了。因此你继续往回走到起始，现在可以尝试进入右边那扇门了。</p>
<p>对于需要尝试所有组合直到找到答案的问题，这种回溯策略对其解决很有帮助。这种问题的解决方案类似于以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> each possibility at level <span class="number">1</span>:</div><div class="line">    <span class="keyword">for</span> each possibility at level <span class="number">2</span>:</div><div class="line">        ...</div><div class="line">            <span class="keyword">for</span> each possibility at level n:</div><div class="line">                is it viable?</div></pre></td></tr></table></figure>
<p>如果要直接使用for循环来实现，就要写许多层，此时就可以使用递归。</p>
<h3 id="问题描述">问题描述</h3>
<p>将8个皇后（这个皇后指的是国际象棋中的皇后）放在棋盘上，条件是任何一个皇后都不能威胁其他皇后，即任何两个皇后都不能吃掉对方。</p>
<p>这里再讲一下国际象棋的部分规则。</p>
<p>第一，国际象棋的棋盘是<code>8 x 8</code>的方格，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190626144020.png">

</div>
<p>第二，皇后是国际象棋中的一个柜子，并且是棋局中实力最强的一种棋子，但同时也是最容易被吃掉的棋子。皇后可横着走，可以直着走，可以斜着走，且格数不限。</p>
<p>第三，因此如果不想让8个皇后中的任何1个被其他的皇后吃掉，那么要满足：①任意2个皇后不能处于同一条横线上；②任意2个皇不能处于同一条竖线上；③任意2个皇后不能处于同一条斜线上。</p>
<h3 id="解决思路">解决思路</h3>
<p>八皇后问题是一个典型的回溯问题：</p>
<p>第一，在棋盘的第一行尝试为第一个皇后选择一个位置；</p>
<p>第二，在第二行尝试为第二个皇后选择一个位置，依次类推；</p>
<p>第三，当发现无法为一个皇后选择合适的位置后，回溯到前一个皇后，并尝试为它选择另外一个位置；</p>
<p>第四，最终要么要尝试完所有的可能性，要么找到答案。</p>
<h3 id="代码实现">代码实现</h3>
<p>现在使用Python来解决一下这个问题。</p>
<h4 id="状态表示">状态表示</h4>
<p>可以简单地使用元组或列表来表示可能的解，其中每个元素表示相应行中皇后所在的位置（即列）。因此如果<code>state[0] = 3</code>就说明第1行的皇后放在第4列。在特定的递归层级（特定的行），你只需要知道上面各皇后的位置即可，因此状态元组的长度是小于8（即皇后的总数）。</p>
<h4 id="检测冲突">检测冲突</h4>
<p>先来做些简单的抽象。要找到没有冲突，即任何一个皇后都无法吃掉其他皇后的位置组合，首选必须定义冲突是什么。此时我们就可以使用一个函数<code>conflict</code>来定义一下。</p>
<p>函数<code>conflict</code>接受现有皇后的位置，并确定下一个皇后的位置是否会导致冲突，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conflict</span><span class="params">(state, nextX)</span>:</span></div><div class="line">    nextY = len(state)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nextY):</div><div class="line">        <span class="keyword">if</span> abs(state[i] - nextX) <span class="keyword">in</span> (<span class="number">0</span>, nextY - i):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>参数描述：</p>
<ol style="list-style-type: decimal">
<li><code>nextX</code>表示下一个皇后的水平位置，也就是x坐标；</li>
<li><code>nextY</code>表示下一个皇后的垂直位置，也就是y坐标；</li>
<li>这个函数对现有的每个皇后执行简单的检查：如果下一个皇后与当前皇后的<code>x</code>坐标相同或在同一条对角线上，将发生冲突，因此会返回<code>True</code>，如果没有发生冲突，就返回<code>False</code>；</li>
<li><code>abs(state[i] - nextX) in (0, nextY - i)</code>表示：如果下一个皇后和当前皇后的水平距离为0，就表示他们同一列；或者是他们的垂直距离相等，这表示他们位于同一条对角线上，这个表达式就为真，否则为假。</li>
</ol>
<h4 id="基线条件">基线条件</h4>
<p>基线条件：最后一个皇后，对于这个皇后，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num, state)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(state) == num - <span class="number">1</span>:</div><div class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line">                <span class="keyword">yield</span> pos</div></pre></td></tr></table></figure>
<p>这段代码的意思是：</p>
<ol style="list-style-type: decimal">
<li>如果只剩下最后一个皇后没有放好，就遍历所有可能的位置，并返回那些不会引发冲突的位置；</li>
<li>参数<code>num</code>是皇后总数，而参数<code>state</code>是一个元组，包含已经放好的皇后位置，例如，假设总共有4个皇后，而前3个皇后的位置分别是1、3和0，如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190626184432.png">

</div>
<p>从上图可知，每个皇后都占据一行，而皇后的位置是从0开始编号的，<code>queens</code>函数的代码运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">conflict</span><span class="params">(state, nextX)</span>:</span></div><div class="line"><span class="meta">... </span>    nextY = len(state)</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(nextY):</div><div class="line"><span class="meta">... </span>        <span class="keyword">if</span> abs(state[i] - nextX) <span class="keyword">in</span> (<span class="number">0</span>, nextY - i):</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num, state)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(state) == num - <span class="number">1</span>:</div><div class="line"><span class="meta">... </span>        <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line"><span class="meta">... </span>            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line"><span class="meta">... </span>                <span class="keyword">yield</span> pos</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(queens(<span class="number">4</span>, (<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>)))</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>使用list旨在让生成器生成所有的值，在这个案例中，只有一个位置符合条件，就是上面白色棋子的位置。</p>
<h4 id="递归条件">递归条件</h4>
<p>处理好基线条件后，可在递归条件中假设来自更低层级（编号更大的皇后）的结果都是正确的，因此，只需要在函数queens的前述实现中给if语句添加一个else语句。最终我们想要的返回结果是当前行下面所有皇后的位置，假设位置是以元组的形式返回的，因此需要修改基线条件，使其返回一个（长度为1的）元组。</p>
<p>因此，对于递归调用，向它提供的是当前行上面的皇后位置组成的元组。对于当前皇后的每个合法位置，递归调用返回的是由下面的皇后位置组成的元组。为了让这个过程不断进行下去，只需将当前皇后的位置插入返回结果的开头即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num=<span class="number">8</span>, state=<span class="params">()</span>)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(state) == num - <span class="number">1</span>:</div><div class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line">                <span class="keyword">yield</span> pos</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num, state + (pos, )):</div><div class="line">                    <span class="keyword">yield</span> (pos, ) + result</div></pre></td></tr></table></figure>
<p>这里的<code>for pos</code>和前面的<code>if not conflict</code>部分与前面相同，因此哦可以稍微简化一下代码，另外还可以给参数指定默认值，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num = <span class="number">8</span>, state = <span class="params">()</span>)</span>:</span></div><div class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line">            <span class="keyword">if</span> len(state) == num - <span class="number">1</span>:</div><div class="line">                <span class="keyword">yield</span> (pos,)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num, state + (pos, )):</div><div class="line">                    <span class="keyword">yield</span> (pos, ) + result</div></pre></td></tr></table></figure>
<h4 id="扫尾工作">扫尾工作</h4>
<p>在代码结束部分，可以让输出更容易理解一些，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prettyprint</span><span class="params">(solution)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(pos, length=len<span class="params">(solution)</span>)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'. '</span>*(pos) + <span class="string">'X '</span> + <span class="string">'. '</span> *(length - pos - <span class="number">1</span>)</div><div class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> solution:</div><div class="line">        print(line(pos))</div></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>MagnusLieHetland. Python基础教程.第3版[M]. 人民邮电出版社, 2018.</li>
</ol>
<h2 id="参考资料-1">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="">A Guide to Python’s Magic Methods</a></li>
<li></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">211</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">99</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共828.5k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
