<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="RVDSD的个人笔记本">
<meta property="og:url" content="http://rvdsd.top/page/9/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RVDSD的个人笔记本">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/page/9/"/>





  <title>RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/09/StatQuest/生物统计-StatQuest学习笔记26-RNA-seq中的技术重复问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/StatQuest/生物统计-StatQuest学习笔记26-RNA-seq中的技术重复问题/" itemprop="url">StatQuest学习笔记26——RNA-seq中的技术重复问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T12:10:54+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,192
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这是StatQuest系列视频教程笔记的最后一篇，我在YouTube上看了一下，作者还有其他的几个视频，有兴趣的同学还可以看看。这篇笔记是视频教程的第62节，主要内容是讲RNA-Seq中的技术重复问题。</p>
<h2 id="是否需要技术重复">是否需要技术重复</h2>
<p>前面有一篇笔记我们提到了<a href="http://rvdsd.top/2018/06/02/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E6%A0%B7%E6%9C%AC%E9%87%8F%E4%B8%8E%E9%87%8D%E5%A4%8D/">技术重复与生物重复</a>。但在RNA-Seq中，我们是否需要做技术重复呢？</p>
<p>答案是否，如果你做了生物学重复，就不需要做技术重复。或许有同学知道这个答案，但是却不清楚为什么做了生物学重复后，就不需要做技术重复了呢，后面我们就会回答这个问题，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190359.jpg">

</div>
<h2 id="rna-seq变异的两个来源">RNA-Seq变异的两个来源</h2>
<p>RNA-Seq的测序数据的变异（variation）主要来源两个方面，第一个是生物学变异（Biological Variation），第二个是技术变异（technical variation）。</p>
<h3 id="生物学变异">生物学变异</h3>
<p>生物学变异是指生物本身本身造成的变异，例如，即使是遗传背景完全一样的小鼠，例如像C57BL/6N这样遗传背景都非常清楚的小鼠，也不存在RNA转录本数目完全相同的两只小鼠（只能是接近，而不是完全相同）。</p>
<p>任何物种的两个生物个体都不可能完全一样，无论这种生物是人，小鼠，还是果蝇。</p>
<h3 id="技术变异">技术变异</h3>
<p>每当我们做一个实验时，在实验过程中都会参杂一些零碎的非实验因素（例如今天你的心情，不同批次的培养基，移液枪的吹打次数，细胞培养的时间，细胞的传代次数等等），其中的一些是完全100%的随机因素。因此，当我们再次重复这个实验的时，即使实验条件与上一次的实验条件完全相同，也不可能得到与上次实验100%相同的结果（当然，总体的结果会相差不大，会很接近），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190404.jpg">

</div>
<h2 id="生物学变异的案例">生物学变异的案例</h2>
<p>为了说明这生物学变异和技术变异的问题，我们先来看一个简单的案例。</p>
<p>在这个案例中，我们只研究生物学变异。例如，我们对几只小鼠做了RNA-Seq，没有做任何技术重复。在下面的二维坐标系中，X轴是小鼠的编号，Y轴是小鼠基因X的reads数，下图是第1只小鼠的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190410.jpg">

</div>
<p>我们再看一下第2只小鼠的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190414.jpg">

</div>
<p>由于我们没有做技术重复，因此从上图中，我们可以知道，第2只小鼠与第1只小鼠的基因X的reads数差异就是完全来源于生物学变异了，也就是这两只小鼠自身的变异，现在看第其它小鼠的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190418.jpg">

</div>
<p>假设我们把地球上的所有小鼠都给测了，也就是说上图的X轴上有无数个小鼠的基因X的reads数，此时，我们求出这所有小鼠基因X的reads数的平均值，并用希腊字母μ表示，这个μ就是小鼠基因X的reads数真正的均值，就是下面的这个样子：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190422.jpg">

</div>
<p>现在我们计算出每只小鼠基因X的reads数与真实均值μ的差值，先看第1只小鼠，它与均值μ的差值是5，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190433.jpg">

</div>
<p>现在再计算出剩下的所有小鼠的基因X的reads数与reads数平均值的差值，为了方便说明问题，这里我们只计算前5只小鼠的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190438.jpg">

</div>
<p>此时，我们使用数学公式来表示这前5只小鼠的基因X的reads数，这个公式很简单，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190442.jpg">

</div>
<p>现在我们计算出这5只小鼠的基因X的reads数的均值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190445.png">

</div>
<p>把上面的公式再整理一下，应时下面的这个样子，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190451.jpg">

</div>
<p>其中上图公式右侧红圏的部分是几个常数，也就是每只小鼠基因X的reads数与均值μ的差值的均值，并且这个红圏中的计算结果（5-1+4+2-5=1）会随着小鼠样本数目的增多而缩小，从而最终近于0，那么上面的均值最终会等于实际的均值μ了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190456.jpg">

</div>
<h2 id="考虑生物学变异与技术变异的情况">考虑生物学变异与技术变异的情况</h2>
<p>还以上述的案例来说明一下生物学变异和技术变异，为了清楚地说明这两个变异，在下图中，我们使用橘黄色的线段来表示生物学变异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190514.jpg">

</div>
<p>我们使用绿色的箭头来表示技术变异，其中绿色箭头向下表示技术重复导致的reads数降低，绿色箭头向上表示reads数上升的情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190517.jpg">

</div>
<p>现在我们考虑生物学变异和技术变异的情况下，来计算一下前5只小鼠的基因X的reads数均值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190522.jpg">

</div>
<p>现在整理一下上面的均值公式，我们可以发现，这个公式可以公为3部分，第1部分是均值μ，第2部分是生物学变异，第3部分是技术变异，如果我们增加样本的话，那么这两个变异就会接近于0，因为它们的分子中既有正值，又有负值，因此最终会相互抵消，因此，做了生物学重复（一共有5只小鼠）的这批小鼠的最终基因X的reads均值就是<code>μ</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190527.jpg">

</div>
<h2 id="只做技术重复的情况">只做技术重复的情况</h2>
<p>我们现在考虑另外一种情况，即我们只做了技术重复。例如针对第1只小鼠，我们做了5次技术重复，它的基因X的reads数如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190531.jpg">

</div>
<p>其中生物学变异使用橘黄色表示，橘黄色线段的大小都一样，这是因为对同一只小鼠做了5次技术重复，同一只小鼠的生物学变异是一样的，另外，在下图中我们再添加上技术变异，技术变异使用绿色表示，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190535.jpg">

</div>
<p>现在我们计算一下第1只小鼠的基因X的reads数均值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190539.jpg">

</div>
<p>其中我们可以发现，在这个案例中，第1只小鼠的基因X的reads数的均值由3部分构成。</p>
<p>第1部分是实际均值μ，第2部分是生物学变异，它是一个固定的值，因为对于一只确定的小鼠来说，它的生物学变异是确定的，因此针对这只确定的小鼠来说，无论做多少次技术重复，它的生物学变异都是一个固定值，不会相互抵消，在这里，这个值是5。第3部分是技术变异，不过由于技术变异的分子部分有正数，有负数，因此随着技术重复的增多，技术变异的分子会相互抵消，最终接近于0，因此第1只小鼠基因X的reads数的均值最终结果是<code>μ+5</code>。</p>
<h2 id="比较生物学重复和技术重复">比较生物学重复和技术重复</h2>
<h3 id="生物学重复">生物学重复</h3>
<p>现在我们比较一下生物学重复和技术重复，回到我们前面的部分，我们知道，基因X的reads数的平均值公式是由3三部分构成的，其中第1部分是真实的均值μ，第2部分是生物学重复，用橘黄色表示，第3部分是技术重复，用绿色表示，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190545.png">

</div>
<p>第1部分是真实的均值μ，这里再强调一下，真实的均值可以理解为所有小鼠基因X的reads数的均值，而我们平时所测的小鼠基因X的reads数是对这个均值μ的估计值，因为我们不可能把所有的小鼠基因X都给测了，估计值只能无限接近于真实均值μ，但法等于均值，不过当样本量足够大时，此时的估计值就可以视为均值μ。</p>
<p>公式的第2部分是生物学变异，第3部分是技术变异。由于生物学变异和技术变异的分子部分都是有正值，负值，因此第2部分与第3部分最终会抵消，得到的结果就会非常接近于真正的均值μ，它就代表了所有的小鼠基因X的reads数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190549.jpg">

</div>
<h3 id="无生物学重复">无生物学重复</h3>
<p>现在我们再看一下无生物学重复，有技术重复的情况下，我们计算一下第1只小鼠的基因X的reads数均值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190555.png">

</div>
<p>这个公式由3部分组成，即真实均值μ，生物学变异和-技术变异，如果我们不断地增加样本，那么这个均值就成了<code>Average = μ +5</code>，最终这个结果只能提供第1只小鼠的信息，而非其它所有小鼠的信息，也就是说，此时的这个<code>μ+5</code>只是第1只小鼠基因X的reads数均值，而不是真实的均值μ，它不能代表整个小鼠的基因X的reads数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190635.jpg">

</div>
<p>结论就是，如果我们只对这个小鼠做多次技术重复，最终得到的数据就是这个小鼠的数据，不具有代表性，也就是说，如果别人的实验室重复这个实验的话，有可能重复不出来。</p>
<h2 id="同时做生物学重复和技术重复">同时做生物学重复和技术重复</h2>
<p>此时我们可能会想，如果我既做了生物学重复，又做了技术重复，那么是不是能得到最精确的结果？</p>
<p>很不幸，答案是否定的。在下面的这个案例中，我们对第1只小鼠做了2个技术重复，第2只小鼠做了3个技术重复，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190641.jpg">

</div>
<p>那么我们求出均值，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190646.jpg">如果我们不再做另外的生物学重复，那么上述公式的第2部分（也就是橘黄色的生物学变异部分）就不会相互抵消，最终接近于0，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190655.jpg">

</div>
<p>但是，如果做了更多的生物学重复，那么它会接近于0，不过需要的生物学重复数量会更多，因为如果生物学重复的数量量不是特别多的话，这第2部分就不会很快地接近0，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190659.jpg">

</div>
<p>我们就看一下，将中间这一项相互抵消为0需要多少个生物学重复。我们对第2只小鼠做了3次技术重复，这3次技术重复中，每个技术重复的生物学变异是相同的，例如第2只小鼠的生物学变异是-1，那么第2只小鼠做了3次技术重复，这3次技术重复的变异分别为2，-2，-1（图中数据），由于是同一只小鼠，那么这3次技术变异对应的生物学变异是一样的，分别是-1，-1，-1（还是图中数据）。</p>
<p>因此，为了降低这种生物学变异的程度，至少也是降低到与前面测了5只小鼠（第1只小鼠到第5只小鼠）同等的水平，那么我们一共需要做15次，这15次就是：5个生物学重复，1个生物学重复做3次技术重复，一共是15次。用公式表示就是下图中的最后一行，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190703.jpg">

</div>
<p>现在我们比较一下这三种实验（分别是①只做生物学重复；②既做生物学重复，又做技术重复；③只做技术重复）的情况：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190707.jpg">

</div>
<p>从上述的结果我们可以发现这些规律：</p>
<ol style="list-style-type: decimal">
<li>只做生物学生重复的结果最接近于均值μ，这是最好的结果；</li>
<li>既做了生物学重复，又做了技术重复的话，它要么接近于均值μ（这个需要做更多的生物学重复，生物学重复与技术重复加起来要做15次），要么是均值<code>μ+常数</code>（只做更多的技术重复，不做更多的生物学重复）；</li>
<li>最差的结果就是不做生物学重复，只做技术重复，如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190712.jpg">

</div>
<p>结论就是，只做生物学重复就行了，就像上面的第1种情况，此时，我们只需要测序5次即可，如果既做生物学重复，又做技术重复，那么我们就需要测序15次，相当于成本直接上升到原来的3倍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/08/StatQuest/生物统计-StatQuest学习笔记25-差异表达分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/StatQuest/生物统计-StatQuest学习笔记25-差异表达分析/" itemprop="url">StatQuest学习笔记25——差异表达分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T12:10:54+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11,311
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列视频教程的第59，60，61节。主要内容讲的是高通测序数据的差异基因分析，其中，第59节的内容是edgeR进行的文库均一化；第60节是DESeq2的文库均一化；第61节则是讲的是edgeR和DESeq2均一化的一些阈值选择。</p>
<h2 id="rpkm等均一化的局限">RPKM等均一化的局限</h2>
<p>edgeR与DESeq2这两种方法并不使用RPKM，FPKM，TPM等方法来进行均一化，edgeR与DESeq2在对文库进行均一化时要考虑两个方面的问题：</p>
<p>第一，测序深度（RPKM，FPKM，TPM方法也能做到）；</p>
<p>第二， 文库补偿（library composition没有找到相应的中文译名，此处译为“文库补偿”），因为不同的样本含有不同的活跃基因（FPKM，FPKM和TPM做不到），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191128.jpg">

</div>
<h2 id="edger均一化步骤">edgeR均一化步骤</h2>
<p>下面是edgeR进行文库均一化的步骤。</p>
<h3 id="第一步移除所有未转录的基因">第一步：移除所有未转录的基因</h3>
<p>我们先看下面的一批测序数据，在这批数据中，有3个样本，每个样本有5个基因（这个数据只是虚拟的，为了方便说明问题，实际测序中不可能只有这几个基因），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191133.jpg">

</div>
<p>其中我们可以发现，Gene5在这3个样本中的reads数都是0，因此我们要把Gene 5给去掉，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191137.jpg">

</div>
<h3 id="第二步选择参考样本">第二步：选择参考样本</h3>
<p>在这个步骤中，我们需要在一批样本中，挑选一个样本作为“参考样本”，随后，我们会使用这个样本来均一化其他的样本，我个人理解，这个参考样本其实就相当于qPCR中的参考基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191140.jpg">

</div>
<p>现在我们就遇到另外一个新问题了，什么是好的参考样本，什么是坏的参考样本，好坏的标准是什么？</p>
<p>我们先看一个案例，这个案例讲的是坏的参考样本，所有的样本如下所示，其中Sample #3是一个非常差的参考样本，Sample #3中所有基因的reads数的均一化都只是基于一个reads数，即Gene 3，因为其它的基因都是0，因此Sample #3有很大的噪音，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191146.jpg">

</div>
<p>为了避免找到这样极端的样本，edgeR会选择那些最“平均”的样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191152.jpg">

</div>
<p>我们现在看一下edgeR如何找到这个最“平均”的样本，我们再看一批数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191157.jpg">

</div>
<p>在寻找最“平均”的样本时，我们需要进行a，b，c，d这四步。</p>
<h4 id="第a步用总reads数校正每个样本">第a步：用总reads数校正每个样本</h4>
<p>注：原文是Scale each sample by its total read counts，我这里使用“校正”来指scale。</p>
<p>计算出每个样本的所有基因的总reads数，如下图左图所示，然后使用每个样本中每个基因的reads数除以每个样本的总reads数，如下图右图所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191212.jpg">

</div>
<h4 id="第b步计算75百分位数">第b步：计算75%百分位数</h4>
<p>注：关于百分位数的一些内容，可以参见<a href="http://rvdsd.top/2018/06/06/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006-%E5%88%86%E4%BD%8D%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/">《StatQuest学习笔记06——分位数及其应用》</a>这篇笔记。</p>
<p>对于每个样本，计算出校正后的数据的75%百分位数的值，或者是小于75%百分位数的值，例如，对于样本1来说，它的75%百分位数是0.26，或者是小于0.26，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191216.jpg">

</div>
<p>对于样本2来说，它的75%百分位数是0.36，或者是小于0.36，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191220.jpg">

</div>
<p>对于样本3来说，它的75%百分位数是0.13，或者是小于0.13，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191224.jpg">

</div>
<p>现在把这3个样本的75%百分位数放在一起，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191228.jpg">

</div>
<h4 id="第c步计算平均75百分位数">第c步：计算平均75%百分位数</h4>
<p>现在计算这3个样本的平均75%百分位数，加起来，除以3即可，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191232.jpg">

</div>
<h4 id="第d步找出最近接近于平均75百分位数的样本">第d步：找出最近接近于平均75%百分位数的样本</h4>
<p>“参考样本”的标准就是它的75%百分位数最接近于平均75%百分位数，样本1，样本2和样本3的75%百分位数分别为0.26，0.36，0.13，它们与平均75%百分位数的差值分别为0.01，0.11，0.12，其中，最接近于0.26的样本是样本1，因此样本1就是“参考样本”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191238.jpg">

</div>
<h3 id="第三步计算标准化因子">第三步：计算标准化因子</h3>
<h4 id="基本思路">基本思路</h4>
<p>在这一步骤中，我们需要选择一些基因集（genes，复数）来创建标准化因子（scaling factors），计算的过程就是针对“参考样本”，分别选择其余的样本的基因集来创建标准化因子（也就是说不同样本创建标准化因子的基因集不同）。我们在第二步中找到了参考样本，也就是Sample #1，现在分别针对Sample #1，来计算Sample #2和样本3的标准化因子，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191242.jpg">

</div>
<p>这是edgeR方法的一个局限，针对不同的样本，edgeR会使用不同的基因集来计算它们的标准化因子（原文是this is one of the ramifications of edgeR’s approach. Different samples use different genes to derive their scaling factors.不知道我理解的对不对，可以对比一下原文自己理解），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191246.jpg">

</div>
<p>现在我们以Sample #2为例，说明一下如何选择用于创建标准化因子的基因集，我们先来看一下用于选择的基因的不同类型，下图是一个XY二维坐标系，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191249.jpg">

</div>
<p>XY轴把这个坐标系分成了四个象限，这个很好理解，我们先看下图中的第1个点（蓝色的），这个点位于左上部分，它表示这个基因主要在参考样本（reference）中转录，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191253.jpg">

</div>
<p>我们再看第2个点，这个点位于最右的坐标轴上，根据坐标轴的说明，我们知道，这个基因主要在Sample #2中转录，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191257.jpg">

</div>
<p>我们再看第3个点（下图中红色圆圈标出的点），这个点位于正中间的坐标轴上，它表示这个基因的很多reads在参考样本和Sample #2中都存在，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191300.jpg">

</div>
<p>我们再看第4个点，它们于中间最下面的坐标轴上，根据坐标轴的说明，我们知道，在参考样本和Sample #2中，都很少含有这个基因的reads，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191304.jpg">

</div>
<p>这样，我们把所有的基因的reads数都放到这个坐标上，我们就可以发现，中间有很大一部分基因没有偏倚，没有偏倚的意思是说，在中间的这些基因，它们在参考样本和Sample #2中的reads数都差不多，区别不大，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191308.jpg">

</div>
<p>而edgeR就会选择中间区域（红色椭圆区域）里的这些基因，排除那些有偏倚的基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191313.jpg">

</div>
<h4 id="计算过程">计算过程</h4>
<p>上面只是edgeR选择基因集的基本思路。现在我们看一下edgeR是如何计算标准化因子的。</p>
<h5 id="第a步过滤偏倚基因">第a步：过滤偏倚基因</h5>
<p>计算所用的数据是已经均一化后的数据（也就是每个基因的reads数除以总的reads数），下图中表示的是全部的N个基因，基因虽然很多，但是这些基因均一化的方法还是与前面所述的4个基因是一样的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191325.jpg">

</div>
<p>edgeR是通过倍数差异的log转换（<code>log fold differences</code>）来过滤偏倚基因（<code>biased genes</code>）的，它的公式是<code>log fold differences = log2（Reference/sample 2)</code>。从这个公式我们就可以看出来，如果Reference的某个基因的值相对于Sample #2比较高，那么这个<code>log fold differences</code>就是一个正值（图中指向3），如果Sample #2的某个基因的值相对于Reference比较高，那么这个<code>log fold differences</code>就是一个负值（图中指向-3），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191330.jpg">

</div>
<p>最终，我们会选择一个阈值，例如<code>+/-6</code>，超过这个范围就认为是极度偏倚的值，需要除去，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191335.jpg">

</div>
<p>我们现在以Gene 1为例来说明一下，它的计算公式如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191339.jpg">

</div>
<p>由于参考样本的Gene1是0，因此这个最终的log fold differences数值为<code>-Inf</code>，它表示无穷小。现在我们看一下Gene2的计算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191343.jpg">

</div>
<p>最终计算出所有的结果，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191346.jpg">

</div>
<p>此时，我们就要移除那些<code>Inf</code>的基因，也就是说，要移除那些在样本中（无论是同时在两个样本，还是任何一个样本中）reads数为0的基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191350.jpg">

</div>
<p>经过上面的计算，我们就得到了一个新的数据集，这个数据集是经过<code>log fold differences</code>转换后的数据集，此数据集用于排除偏倚基因。</p>
<h5 id="第b步计算几何均数">第b步：计算几何均数</h5>
<p>现在我们还需要另外一个数据集，用于观察哪些基因在两个样本是高转录和低转录的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191353.jpg">

</div>
<p>计算基因的高转录和低转录时，首选要计算每个基因的几何均数（<code>the geometric mean</code>），几何均数很有用，因为它不太容易受到异常值的影响，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191356.jpg">这里要注明一下，严格意义来说，上面的这个公式只是经log转换后的数字的算术均数，由于经过了log转换，因此log转换后的算术均数其实上就是原始数据（未经log转换的数据）的几何均数，因为我们并不把log转换后的算术均数转换回正常的数值（也就是没有经过log转换后的数值），因此在这里，我们使用了log转换后的数值的算术均数，但它们的最终的效应是一样的，即异常值很少影响这些数据，下面以Gene 2为例说明一下这个计算过程：</p>
<p>Gene 2在参考样本中的数值为0.04，在Sample #2中的数值为0.05，它的几何均值其实应该是下面的这个样子：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191401.png">

</div>
<p>现在对0.0447213595进行log2转换，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191405.png">

</div>
<p>我们再来看一下视频中的计算结果，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191410.jpg">

</div>
<p>从上面的结果我们可以发现，这个数值是一样的，经过计算，所有的结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191413.jpg">

</div>
<p>现在我们移除那些infinite的值，也就是那些没有任何reads的基因（也就是计算结果中是<code>-Inf</code>或<code>Inf</code>的值），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191417.jpg">

</div>
<h5 id="第c步计算代表基因集">第c步：计算代表基因集</h5>
<p>经过前面的计算，此时，我们就有了两张表，第一张表是<code>log2(reference/Sample #2)</code>的数据，它用于确定偏倚基因，另外一张表的数据是经log2转换后的均值数据，这批数据用于确定哪些基因是高转录的，哪些基因是低转录的，这两张表如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191421.jpg">

</div>
<p>此时，我们将这两张表中的数据都按从小到大的顺序进行排列，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191425.jpg">

</div>
<p>在第一张表中，去掉前30%的数据，以及去掉后30%的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191431.jpg">

</div>
<p>在第二张表中，去掉前5%的数据，以及去掉后5%的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191434.jpg">

</div>
<p>用两张表中剩下的数据来计算标准化因子（取两张表基因的交集），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191441.jpg">

</div>
<p>不过在这个案例中，这两终表中剩余的基因并没有列出，都在省略号中，但是这个案例只是在讲edgeR的算法原理，并不涉及具体的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191445.jpg">

</div>
<p>为了方便理解，我们就假定，下图就是最终于用计算Sample #2的标准化因子的基因集，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191448.jpg">

</div>
<p>同样的，还有计算Sample #3标准化因子的基因集，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191452.jpg">

</div>
<h3 id="第四步计算加权均数">第四步：计算加权均数</h3>
<p>在这一步骤中，edgeR会计算代表性基因集的log fold的加权平均数，在edgeR中，这个log fold的加权平均数称为为“weighted trimmed mean of the log2 ratio”，因为这些数据已经剔除掉（trim）了那些表达比较极端的基因（特别高的和特别低的），这样，计算结果就不会受到表达异常基因的影响，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191507.jpg">

</div>
<p>现在我们回到Sample #2的基因集上，这些基因是经过了第三步的筛选过的基因，只是我们假定的数据，就是我们上面说的省略号中的基因，只是用来计算的，不用管它的实际意义，它的log fold如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191511.jpg">

</div>
<p>一旦我们选择了这些基因用于计算标准化因子，那么我们就仅需要计算出它们的log 2的加权均数即可，也就是说，比对到某个基因上的reads数越多，这个基因的权重就越大，这是因为对于那些低reads数的基因来的，log fold数值的变异程度比较大，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191516.jpg">

</div>
<p>为了说明reads数少的基因经过log fold转换后的变异程度比较大的问题，我们这里插入一个案例，下图是几个基因的reads数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191520.jpg">

</div>
<p>从上面的数据中我们可以知道，Gene #1、Gene #2、Gene #3的reads数比较高，不过Gene #1比Gene #3的reads数还是多了4，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191524.jpg">

</div>
<p>我们再看Gene #4和Gene #6，虽然它们的reads数比较少，不过它们之间的reads数也是差了4，这个数值与Gene #1比Gene #3的差值一样，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191528.jpg">

</div>
<p>不过，我们看一下右侧的经过log2 fold转换后的数据，我们可以发现，Gene #1和Gene #3的log2 fold的值差别并不大，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191531.jpg">

</div>
<p>但是，我们看一下Gene #4和Gene #6，虽然它们的reads数相差是4，但是，它们的log2 fold的值相差却是1.6，这个值是非常大的值了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191534.jpg">

</div>
<p>案例结束。</p>
<p>针对这种情况，我们就需要对那些有着高reads数的基因加上更大的权重，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191538.jpg">

</div>
<p>对于Sample #3的处理，也是如此，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191542.jpg">log2 fold的加权均数的计算公式如下所示：</p>
<p>简单来说就是log2 foldA的值乘以相应基因的reads数的和，然后除以所有的reads数之和。</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191546.png">

</div>
<h3 id="第五步将加权log2-fold值转换为真值">第五步：将加权log2 fold值转换为真值</h3>
<p>在这一步中，我们需要把前面过计算出来的加权平均值转换为真值（也就是log2转换前的数值）。</p>
<p>标准化因子的公式如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191600.png">

</div>
<p>不过，此时的这个“标准化因子”并不是edgeR所使用的标准化因子，为了区分edgeR中的标准化因子，我暂时称它为“原始标准化因子”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191604.jpg">

</div>
<p>按照上述方法，再计算出Sample #3的“原始标准化因子”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191611.jpg">

</div>
<p>经过上面的计算，这个原始标准化因子还要进行进一步的计算，才是edgeR的标准化因子。</p>
<p>我们来看一个实际的案例，这个案例使用的一个RNA-Seq实验中的数据计算出来的原始标准化因子（就是按上面的公式计算出来的标准化因子），其中，WT2是参考样本，其余的样本根据WT2进行均一化，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191615.jpg">

</div>
<h3 id="第六步原始标准化因子的中心化">第六步：原始标准化因子的中心化</h3>
<p>下图是我们计算出来的原始标准化因子，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191619.jpg">

</div>
<p>这些值在数轴上主要以0.95为中心进行排列，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191624.jpg">

</div>
<p>我们对这批数据进行“中心化”，其实就是用它们的每个值除以这4个数据的几何均数，几何均数就是如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191630.png">

</div>
<p>最终计算的edgeR标准化因子（也就是中心化的原始标准化因子）如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191636.jpg">

</div>
<p>虽然除以几何均数并不会改变最终的计算结果，但是Mark Robinson（edgeR包的开发者）说，经过中心化的处理就能赋予标准化因子一些数学上的美感。</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191642.jpg">

</div>
<p>此时，edgeR的标准化因子计算到此，接着把表达矩阵中的数值除以这个标准化因子即可，现在讲另外一种标准化文库的方法，即DESeq2。</p>
<h2 id="deseq2均一化思路">DESeq2均一化思路</h2>
<h3 id="文库均一化面临的问题">文库均一化面临的问题</h3>
<p>DESeq2是另外一个分析差异基因的R包，它的功能很多，使用也比较复杂。我们在前面提到过，RPKM，FPKM与TPM是常用的用于均一化不同的样本reads数的方法，不过DESeq2和edgeR并不使用前面的三种方法，因为在对文库进行均一化时，存在两个问题，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191656.jpg">

</div>
<p>第1个问题就是，不同样本的文库大小还有差异，需要对其进行调整。我们先看一个简单的案例，在这个案例中，我们假设某个物种的基因组上只有6个基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191701.jpg">

</div>
<p>现在我们手中有这个物种的两个测序样本，其中Sample #1的reads数为635，Sample #2的reads数为1270，它们的各自基因对应的reads数如下所示，从中我们可以看到，Sample #1的reads总数是Sample #2的reads总数的一半，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191706.jpg">

</div>
<p>我们再看一下这两个样本每个基因对应的reads数，从中我们可以发现，Sample #2中每个基因对应的reads数也基本上是Sample #1中每个基因对应的reads数的2倍，这种差异不可能是生物学的原因，因为物种都一样，出现这种现象的原因就是测序深度，而RPKM，FPKM和TPM都能处理这样的问题（也就是测序深度不同造成的reads不同），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191710.jpg">

</div>
<p>第2个问题是，我们需要调整由于文库补偿（library composition没有找到相应的中文翻译，此处译为“文库补偿”）造成的差异。RNA-seq或者是其它的高通量测序技术通常会比较不同组织类型之间的测序数据差异，例如我们可能会比较肝脏与脾脏的差异。这个时候就可能会出现问题，因为在肝脏中，存在着某些特异性基因，这些基因只在肝脏中大量转录，而在脾脏中转录不活跃，这就是文库补偿造成的差异的一个案例，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191714.jpg">

</div>
<p>还有一种文库补偿造成差异的案例就是在同一种类型的细胞中会出现，例如针对某细胞，我们敲除掉这个细胞中的某个转录因子或者是某些具有调控功能的基因，那么野生型细胞和敲除型细胞的转录组就有可能出现差异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191718.jpg">

</div>
<p>针对这个问题，我们看一个简单的案例，在这个案例中，我们有2个样本，这2个样本的总reads数是相同的，都是635个reads，我们假设它们的所有基因都是一样的，不过有一处不同，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191723.jpg">

</div>
<p>我们看一下A2M这个基因，在Sample #1中，这个基因的reads数是635，而在Sample #2中这个基因的reads数是0，这就说明，A2M这个基因只在Sample #1中转录，它的reads数是563，但是在Sample #2中，这个563的reads数必定是分配到其它的基因上去了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191728.jpg">

</div>
<p>现在我们看一下Sample #2中所有基因的reads数，我们可以发现，在Sample #2中，A2M的reads数为0，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191733.jpg">

</div>
<p>如果出现了这种情况，那么RPKM，FPKM和TPM是无法处理的，此时就需要使用DESeq2（或者是edgeR）来处理，DESeq2能处理各种测序的数据集，它能解决的两个问题：</p>
<p>第一，不同文库大小之间的差异；</p>
<p>第二，文库补偿效应造成的差异。</p>
<p>如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191739.jpg">

</div>
<h2 id="deseq2均一化的步骤">DESeq2均一化的步骤</h2>
<p>现在我们看一个简单的案例，在下面的这个案例中，我们有3个样本，每个样本有3个基因，在这个案例中，我们的目标是计算每个样本的标准化因子（scaling factor），标准化因子会解决测序深度（read depth）和文库补偿（library composition）的问题，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191805.jpg">

</div>
<h3 id="第一步对reads数取自然对数">第一步：对reads数取自然对数</h3>
<p>DESeq2中默认是对reads数取以e为底的对数（但是也可能设置以2或10为底的对数）如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191809.jpg">

</div>
<p>自然对数比较好理解，以Sample #2的Gene 1为例，它的reads数是10，那么<code>loge(10)=2.3</code>，另外需要注意的是，如查reads数为0，那么对数就是<code>-Infinity</code>，缩写为<code>-Inf</code>，表示负无穷，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191813.jpg">

</div>
<h3 id="第二步求所有样本中相同基因对数的均值">第二步：求所有样本中，相同基因对数的均值</h3>
<p>在这一步中，我们需要对同一个基因在所有样本中的数值取均数，以Gene 1为例，Gene 1在这三个样本中的数值分别为-Inf，2.3，1.4，由于-Inf是负无穷，因此加起来也是-Inf，再除以3，还是这个数，我们再看Gene 2的数值，它在3个样本中的数值分别为0.7，1.8，2.5，那么它的均值就是1.7，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191817.jpg">

</div>
<p>用对数的一个原因就是对数不太容易受到异常值的影响，我们看一下Gene3，它在Sample #3中的原始reads数是200，而在Sample #1和Sample #2中的数值分别为33和55，因此200明显是一个异常值，如果直接使用reads数来计算均数，那么结果就是96，我们再看一下使用对数的均值，计算结果是4.3，这个4.3是指数，现在把它转换成与reads数对应的原始数值，也就是e的4.3次方，结果为73.7，与96相比，前者还是比较小的，说明使用对数的受异常值的影响比较小（这种先取对数，后用对数求均值的方法叫几何平均数），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191821.jpg">

</div>
<h3 id="第三步去除掉infinity">第三步：去除掉Infinity</h3>
<p>在这一步中，我们要把在第二步中计算出的含有Inf的基因给剔除掉，也就是说要在样本中把reads数为0的基因给剔除掉，如果如果我们比较的是肝脏和脾脏的转录组，按这种剔除方法，我们会把那些所有只在肝脏（或脾脏）中转录的基因都给剔除掉，从理论上讲，最终剩下的基因基本上就是管家基因（house keeping genes）了，也就是说在不同组织类型中都表达相似的基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191825.jpg">

</div>
<h3 id="第四步矩阵减均值">第四步：矩阵减均值</h3>
<p>在上一步中，我们把数据中的Inf值去除了，在这一步中，把每个样本中的每个基本减去该基因在所有样本中的均值，以Gene 2为例，它在经对数转换后的Sample #1、Sample #2、Sample #3中的数值分别为0.7，1.8和2.5，它在所有样本中的均值为1.7，这3个数值都减去1.7，就是-1.0，0.1，0.5，其余基因操作均如此，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191828.jpg">

</div>
<p>在这一步骤中，我们用的是对数转换后的数值相减，其本质上是以某个基因（这里称为基因X）的平均值为参考，对每个样本中的基因X进行均一化，就是原始reads数的相除，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191832.jpg">

</div>
<h3 id="第五步计算每个样本的中位数">第五步：计算每个样本的中位数</h3>
<p>在这一步中，我们要计算每个样本中，所有基因的对数的中位数，以Sample #1为例，在这个样本中，它所有的基因只有Gene2和Gene3，分别为-1.0和-0.8，它的中位数就是-0.9，其余的样本的计算也是如此，这里需要注明一下，因为在这个案例中，一个样本的所有基因只有2个，因此它的中位数和无数是相等的，但是如果基因的数目很大，这两个值就不一定相等了，例如某批数据，分别为1，3，5，7，10000，那么这批数据的中位数就是5，均值则为2003.2，这个均值受异常值的影响很大，再看一批数据，分别为-1000，3，5，7，9，那么这批数据的中位数还是5，均值就变成了-195.2了，从中我们可以发现，均值比较容易受异常值的影响，但中位数对异常值则不敏感。</p>
<p>这里使用中位数主要是为了排除一些极端表达基因的影响，极端表达指的是表达量极高或极低，它们能够对均值造成很大的影响，而那些表达量差异极大的基因对于中位数的影响，并不比那些表达量差异较小的基因对中位数的影响大。再加上那些表达量差异极大的基因数量通常情况下很少，因此，更多情况下，中等程度表达差异的基因和管家基因对中位数的影响更大一些，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191836.jpg">

</div>
<h3 id="第六步将中位数转换为真数计算每个样本最终的标准化因子">第六步：将中位数转换为真数，计算每个样本最终的标准化因子</h3>
<p>在这一步中，我们要把第五步中的对数中位数转换为真数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191840.jpg">

</div>
<p>此时，我们就得到了这3个样本的标准化因子了，此时进入第七步。</p>
<h3 id="第七步原始reads数除以标准化因子">第七步：原始reads数除以标准化因子</h3>
<p>在这一步中，我们要把原始的reads数除以这个标准化因子，以Sample #1为例，它的标准化因子为0.4，那么Gene 1，Gene2和Gene 3的reads数分别为0，2，33，它们分别除以0.4，结果为0，5，82.5，由于read不可能是小数，四舍五入，结果就是0，5，83，其余的样本均按此方法处理，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191845.jpg">

</div>
<h2 id="deseq2文库标准化因子总结">DESeq2文库标准化因子总结</h2>
<p>log转换会剔除那些只在某个样本类型中的转录的所有基因（例如肝脏与脾脏），这种处理也会消除原始reads数的异常值（通过几何均数）。</p>
<p>中位数的处理会进一步降低那些高数值reads数基因的影响，从而关注那些中等表达程度的基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191850.jpg">

</div>
<h2 id="不相关过滤independent-filtering">不相关过滤（Independent Filtering）</h2>
<p>在这一部分中，我们会讲一下对那些低reads数的基因过滤的方法，这个过程又叫不相关过滤（Independent Filtering没有找到相应的中文译名，这里译为“不相关过滤”），也叫解决多重检测问题，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191854.jpg">

</div>
<h3 id="有关假阳性">有关假阳性</h3>
<p>当我们做一个统计学检验时，就有一定的概率得到的是错误结论，关于这个问题，可以参见<a href="http://rvdsd.top/2018/06/12/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011-p%E5%80%BC%E8%AF%A6%E8%A7%A3/">《StatQuest学习笔记11——p值详解》</a>，简单来说就是，我们认为“p值小于0.05就是有统计学差异的”，也可以这么说，“我们有5%的概率会得到一个假阳性的结果”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191900.jpg">

</div>
<p>我们来用一个简单的案例来说明这个问题，在下面的这个案例中，其中红点表示突变组，黑点表示对照组，我们检测了Gene 1和Gene 2的这两个基因，它们对应的p值如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191904.jpg">

</div>
<p>从上面的结果可以看出，它们的p值分别为0.03和0.13，基因数目是2，2的5%是一个很小的数值，因此，我们很不太可能得到一个假阳性的结果，但是，如果我们比较了整个基因组中的所有基因（大概有2万个），用于观察哪些基因调控出现了异常时，情况就不太一样了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191910.jpg">

</div>
<p>2万的5%就是1000，也就是说，如果我们以p值0.05为阈值进行统计的话，我们有可能得到约1000个假阳性结果，对于这个问题，我们通常会采用FDR和Benjamini-Hochberg方法来解决，具体的可能参考<a href="http://rvdsd.top/2018/06/18/BioStatistics/%E7%94%9F%E7%89%A9%E7%BB%9F%E8%AE%A1-StatQuest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012-FDR%E5%8F%8A%E5%AE%9E%E7%8E%B0/">《StatQuest学习笔记12——FDR及实现》</a>这篇笔记，不过，即使是这样，我们还会遇到另外的一个问题，先看一个案例。</p>
<p>在下面的图形中，我们看到了两个独立的分布，其中红色曲线表示X品系小鼠的体重，蓝色的曲线表示Y品系小鼠的体重分布，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191914.jpg">

</div>
<p>如果我们称量一个X品系小鼠的体重，那么它有很大的概率会落到红色曲线的中间部分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191918.jpg">

</div>
<p>如果我们称量3只X品系的小鼠，它们都有可能落在红色曲线的中间部分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191922.jpg">

</div>
<p>同样类似的，还有Y品系小鼠的体重，如果我们称量3只Y品系的小鼠，那么它们也有很大的概率会落在蓝色曲线的中间区域，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191926.jpg">

</div>
<p>如果我们对这两批数据进行t检验，得到的p值小于0.05的话，我们就可以正确地下一个结论，即这两批数据存在着差异，这种差异是来源于两种小鼠的体重分布不同，也就是说这是由于小鼠品系不同千万的体重差异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191931.jpg">

</div>
<p>但是，有时候我们称量的小鼠体重会出现重叠，此时，我们进行t检验，它的p值有可能就是大于0.05的，这就是假阴性，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191935.jpg">

</div>
<p>如果我们使用计算机从这些分布中进行1000次抽样（一次抽样包括从对照组中抽3只，突变组中抽3只），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191938.jpg">

</div>
<p>现在做1000次t检验，我们看一下这1000次的p值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191942.jpg">

</div>
<p>其中我们可以发现，有949个结果的p值是小于0.05的，有51个假阴性（p值大于0.05），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714191946.jpg">

</div>
<p>目前为止，我们进行的每次检验都被认为应该是一个真阳性，它的p值是小于0.05的，这句话的意思是说，我们希望检验的这两个数据（也就是突变组与对照组的数据）是有差异，当然了，实际结果可能没有差异，这就是假阴性。出现真阳性是因为我们每次检验使用的样本都是来源于不同的分布，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192001.jpg">

</div>
<p>当我们加入一些没有统计学差异的样本时，也就是说来源于同一个分布的样本时，它的p值就会大于0.05，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192005.jpg">

</div>
<p>但是，即使是来源于同一分布的两组数据，有的时候，也会出现p值小于0.05的情况，就像下面的这个样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192009.jpg">

</div>
<p>现在我们绘制一个直方图，这个直方图是2000个p值，其中1000个来源于两个不同的分布的两组数据的t检验的p值，另外的1000个是来源于同一个分布的两组数据的t检验的p值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192014.jpg">

</div>
<p>从上面的直方图我们可以知道，其中有993个小于0.05的p值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192018.jpg">

</div>
<p>在这993个小于0.05的p值中，有949个是真阳性（这是由第一组p值构成的，也就是来源于两个不同分布的两组数据的t检验的p值），有44个假阳性的p值（这是由第二组p值构成的，也就是来源于同一个分布的两组数据的t检验的p值），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192021.jpg">

</div>
<p>由于在这些小于0.05的p值中，只有约4%的p值是假阳性（44/993=4.4%），因此我们并不需要FDR校正，但是，如果在实际的分析中，我们并不知道p值的构成，因此就需要进行FDR校正，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192025.jpg">

</div>
<p>我们来看一下，这个数据经过FDR校正后的结果，校正后，有846个p值仍然小于0.05，在这846个数值中，有827个是来源于原来真阳性的949个，所占比例为89%，有19个是假阳性，占846的比例为2%，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192029.jpg">

</div>
<p>现在我们把数据的构成改变一下，让它更像RNA-seq的数据，此时我们增加样本的数目到6000个，其中1000个来源于两个不同的分布，5000个来源于相同的分布，这5000个样本进行t检验，它们的p值有更大的可能性大于0.05，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192035.jpg">

</div>
<p>绘图出样本t检验的p值直方图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192041.jpg">

</div>
<p>现在我们看一下这些p值的分布，其中有1215个p值小于0.05，其中949个p值是真阳性，有266个p值是假阳性，假阳性的比例为22%，此时就需要进行FDR校正，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192046.jpg">

</div>
<p>经过FDR校正，我们发现，只有256个校正后的p值小于0.05，其中250个来源于原来的949个真阳性，其比例为26%，剩下的6个是假阳性，来源于原来256个假阳性，比例为2%，从这个结果我们可以看出来，FDR能够限制假阳性的数目，但是它同时还能减少真阳性的数目，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192049.jpg">

</div>
<p>现在我们把样本数目增加到11000，其中1000个来源于两个不同的分布的两组数据，10000个来源于相同的分布的两组数据，现在对这些样本进行t检验，将它们的p值绘制成直方图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192053.jpg">

</div>
<p>其中1430个p值小于0.05，跟前面的结果一样，有949个真阳性的p值，但是有481个假阳性的p值，假阳性的比例高达34%（481/1430），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192058.jpg">

</div>
<p>经过FDR校正，只有56个p值仍然是小于0.05，其中54个真阳性的p值，2个假阳性的p值，也就是说，原来949个真阳性中，只剩下了54个真阳性，只有原来的6%，而假阳性占到FDR校正后的小于0.05的p值数目的4%，从前面的计算结果可以看出来（2000个样本，6000个样本，11000个样本），每当我们增加样本的检验数目时，通过FDR校正的真阳性的（p小于0.05）数目都会减少，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192102.jpg">

</div>
<p>用折线图表示就是下面的这个样子，其中绿色曲线表示的是通过FDR校正后，p值仍然小于0.05的数目，橘黄色的线表示经过FDR校正后，p值仍然小于0.05的假阳性的数目，这张图表说明，无论检验的数目是多少，FDR总能控制假阳性的比例，这在我们的模拟数据中已经得到了很好验证，不过随着检验数目的增多，真阳性的比例却在下降，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192107.jpg">

</div>
<p>这也说明了，Benjamni-Hochberg方法时行的FDR校正还有很大的改进空间，edgeR和DESeq2都有自己的方法来对前面的模拟检验进行过滤。</p>
<h2 id="edger和deseq2的过滤">edgeR和DESeq2的过滤</h2>
<p>edgeR和DESeq2对检验结果进行过滤的基本思路就是，那些reads数极少的基因提供的信息量有限，可以把它们从数据集中剔除掉。换句话讲，如果这个基因在一个样本中只有1个或2个转录本，在另外一个同样的样本中只有3或4个转录本，那么就很难得到它们的精确reads数，即使这些低reads数的基因有着生物学意义，那么我们也能剔除它们，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192114.jpg">

</div>
<h3 id="edger的过滤">edgeR的过滤</h3>
<p>在了解edgeR过滤数据之前，我们先了解另外一个概念，即CPM，CPM的全称是Counts Per Million，它用于校正不同文库之间的由于测序深度造成的差异，edgeR是按照CPM来剔除数据的，它的阈值是1，edgeR会保留那些在2个及2个以上的样本中CPM大于1的基因，剩余的基因就被剔除掉，具体的后面我们会讲到，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192125.jpg">

</div>
<h3 id="cpm">CPM</h3>
<p>下图说明了如何计算CPM，流程为：①总reads数除以100万；②用每个样本中的每个基因对应的reads数再除以①中的数字，就是CPM。</p>
<p>总reads数除以100万主要是为了方便计算CPM，否则CPM的数值会非常小，不方便，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192130.jpg">

</div>
<p>现在我们有了所有样本中的所有基因的CPM值，此时就要保留那些有2个或2个以上样本中，CPM值大于1的基因，剩下的基因除去，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192134.jpg">

</div>
<p>现在我们看一下如何保留需要的基因，一个基因一个基因地来看：</p>
<p>gene 1，它在kidney 1和kidney 2这两个样本中的CPM值都大于1，因此保留，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192139.jpg">再看gene 2，gene2在kidney 1和kidney 2这两个样本中，CPM值都大于1（有一个是等于1，但视频中就是这么描述了），因此我们保留基因2，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192146.jpg">

</div>
<p>再看gene 3，由于gene 3只在一个样本，即liver 2中的CPM值大于1，即使这个值很大，我们也不需要（下图中的这个值是103.3，跟前面视频的数据不一样的，我估计作者在这里主要是为了说明一个问题，即使某个值在一个样本中很大，在其他样本中仍然小于1，也是要剔除这个数据），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192150.jpg">

</div>
<p>再看Gene 4，由于有2个样本的CPM值小于1（可能作者没有算另外两个CPM等于0的样本），因此也要剔除，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192154.jpg">

</div>
<p>再看Gene 5，它在所有的4个样本中CPM值都小于1，因此Gene 5也不用保留，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192158.jpg">

</div>
<p>再看Gene 6，这个基因在2个样本中CPM值大于1，即使这两个样本不是同一类型的，但我们可以保留这个基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192205.jpg">

</div>
<p>edgeR的这种方法很简单，但我们要知道，测序深度会影响这个数值，例如如果一个样本中有500万条reads，那么CPm的标准化因子就是500万/100万=5，如果我们有5条reads比对到某个基因上了，那么我们就会知道这个基因是1CPM，即5/5=1CPM，如果我们有800万个基因，那么标准化因子就是80，1CPM=80 reads，这个数值就非常大了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192208.jpg">

</div>
<p>换句话讲，有时候，我们也需要一个比较大的CPM阈值了，例如，如果我们的一个样本中有5万条reads（单细胞测序的reads数可能就这么多了），那么它的CPM标准化因子为0.05，即5万/100万=0.05，如果一个基因有一条reads比对上了，那么这个基因的CPM就是20，即1/0.05=20。即使一个基因在生物学水平进行了转录，但是你只能低到一个低的reads数和低的总reads数，它仍然存在着很大的噪音，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192212.jpg">

</div>
<h3 id="edger中cpm阈值的确认">edgeR中CPM阈值的确认</h3>
<p>此时，我们可能面临一个问题：如何找一个很好的阈值（cutoff）？</p>
<p>我们来看一个真实的案例。</p>
<ol style="list-style-type: decimal">
<li>这个案例是从别人那里得到的一批真实数据，在这批数据中，每个样本有2200万条reads（8个样本，其中包括4个野生型，4个敲除型）；</li>
<li>在不剔除任何基因的情况下，运行edgeR，得到一批原始的p值；</li>
<li>使用不同的CPM阈值（cutoff）来过滤基因，然后对这些p值进行校正，如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192226.jpg">

</div>
<p>此时我们使用不同的CPM阈值来过滤一下基因，然后再校正p值，就是下图所示的内容，其中y轴表示经过FDR校正后，p值仍然小于0.05的基因的数目，x轴表示最小的CPM的阈值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192230.jpg">

</div>
<p>其中横坐标上的0表示，没有剔除掉任何一个基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192234.jpg">

</div>
<p>如果我们选择1，也就是Minimum CPM Threshold的值为1（也就是推荐的值），此时FDR小于0.05的基因的数目大概是3400个，在此处的reads数还是比较多的，这说明这个阈值还是比较严格的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192239.jpg">

</div>
<p>如果我们使用一个较低的阈值，我们就会发现，此时FDR小于0.05的值基因数目大概是3600个，比CPM=1时的数目多了约200个，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192243.jpg">

</div>
<p>总之，edgeR的主旨就是：仔细选择阈值（cutoff），你需要在计算了p值之后再尝试不同的CPM阈值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192246.jpg">

</div>
<h3 id="deseq2中cpm阈值的确认">DESeq2中CPM阈值的确认</h3>
<p>在确认CPM的阈值方面，edgeR和DESeq2有两点不同。</p>
<p>第一，edgeR计算CPM的阈值时，它会检查每个基因在不同样本中的数值，从而确定保留下来的基因中，至少有2个样本的CPM值大于阈值，在下面的这个案例中，我们就发现，gene 1在kidney 1和kidney 2这2个样本中，它的CPM值都大于1，因此保留gene 1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192252.jpg">

</div>
<p>相比之下，DESeq2则是要检查某个基因在所有样本中均一化后的数值的均值，还是以上面的案例说明，如果是DESeq2，它比较的结果就是，这4个样本的平均值都在阈值之上，因此可以保留gene 1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192258.jpg">

</div>
<p>此时，你或许会想，如果我使用了DESeq2的方法，那么对于异常值，该如何处理？</p>
<p>看下面的案例，gene 1在kidney 1，kidney 2，liver 1中的CPM都是0，而在liver 2中则是5000，平均值是1250 CPM，按照edgeR的标准，gene 1不会被保留，因此它只有一个样本的CPM大于1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192301.jpg">

</div>
<p>但是对于DESeq2来说，gene 1在4个样本中的平均值为1250，它会被DESeq2保留（这种情况下DESeq2无法处理，也就是一个类型中有2个样本），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192305.jpg">

</div>
<p>但DESeq2本身具备异常值的检测方法，不过这种方法只有在每类别中，有超过2个样本的时候才发挥作用（具体的可以参考这篇文献：<a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8" target="_blank" rel="external">Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2</a>）。</p>
<p>下图是分别使用这两种方法（edgeR和DESeq2）对同一批数据进行计算的结果，其中横坐标表示最小CPM阈值，纵坐标表示有显著差异的基因的数目，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192310.jpg">

</div>
<p>从中我们可以发现，这两种方法基本上都有在同一区域达到顶点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192313.jpg">

</div>
<p>这两种方法同时会产生一个相似的阈值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192317.jpg">

</div>
<p>现在我们看一下这两种方法不同之处，其中一处区别在于x轴，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192321.jpg">

</div>
<p>再看另外一处差异，DESeq2能绘制X轴是百分位数（用于替代min CPM 阈值），Y轴是显著差异基因数目的二维坐标系，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192325.jpg">

</div>
<p>根据这种二维坐标图，我们可以看出来，0表示在这个阈值之下的基因是0%，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192328.jpg">

</div>
<p>0.2表示在这个阈值之下，有20%的基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192332.jpg">

</div>
<p>分位数（Quantiles）非常有用，因为我们可以看到，CPMs的计算依赖于测序深度。无论这个文库是800万条reads，还是8000万条reads，10%的基因总是总是小于0.1百分倍数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192337.jpg">

</div>
<p>我们可以选择使用分位数法和最小CPM，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192341.jpg">

</div>
<p>现在看第三处差异，DeSeq2会对这些点进行拟合，找到一曲线，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192345.jpg">

</div>
<p>DESeq2就会找到这条拟合曲线的最大位置处，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192348.jpg">

</div>
<p>阈值就在这条曲线的最大位置处，关送去拟合曲线和原始值之间的标准差，换句话讲，在峰值的噪声范围内，第一个分位数就是CPM的阈值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192352.jpg">

</div>
<p>如果在这个阈值之上没有原始值，那么就不过滤，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192356.jpg">

</div>
<p>至此，我们就知道了edgeR和DESeq2是如何过滤基因的，其中edgeR是保留那些在2个或2个以上样本中，CPM大于最小阈值的基因，而DESeq2则是，保留那些平均CPM大于最小CPM的基因，然后绘制显著基因与分位数的散点图，找到拟合曲线，再用最大值减去噪声，即是阈值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192402.jpg">

</div>
<p>不过现在我们知道，我们可以同时联合使用这两种方法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192406.jpg">

</div>
<h2 id="建议">建议</h2>
<p>如果你使用edgeR，㙘在计算出了p值之后，找到CPM的阈值。在edgeR的基因选择标准方面，使用DESeq2可以很容易地找到找到最优的CPM阈值。</p>
<p>如果你使用DESeq2时，如果在每个分类（例如野生型组和突变型组）只有2个样本，此时要尤其注意异常值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714192410.jpg">

</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/07/StatQuest/生物统计-StatQuest学习笔记24-RPKM FPKM TPM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/StatQuest/生物统计-StatQuest学习笔记24-RPKM FPKM TPM/" itemprop="url">StatQuest学习笔记24——RPKM FPKM TPM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T12:10:54+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,100
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列笔记的第63节，这篇笔记跳过59节，60节，61节主要是因为第63节的内容是讲RPKM，FPKM和TPM这几个概念的区别，在进行差异分析前，有必要了解一下这几个概念。</p>
<h2 id="测序的度量单位">测序的度量单位</h2>
<p>在RNA-Seq中，我们通常使用RPKM（全称为Reads Per Kilobase Million）或FPKM（Fragments Per Kilobase Million）来进行均一化，这些均一化的数据（normalized data）主要解决两个问题：</p>
<ol style="list-style-type: decimal">
<li>测序深度（这个是指Million这一部分，侧重于数量），我们知道，测序深度越高，那么比对到基因上的reads数就越多；</li>
<li>基因的长度（这个指的是Kilobase这一部分，侧生于长度），我们知道，一个基因越长，那么比对到这个基因上的reads数就越多。</li>
</ol>
<p>不过现在我们还使用TPM（全称为Transcripts per million）来作为均一化后的基因的表达单位，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185837.jpg">

</div>
<p>为了能够更好的区分这三个单位，即RPKM，FPKM和TPM，我们就通过一个简单的案例来说明一下，在这个案例中，我们一共有3个重复，分别为Rep1，Rep2和Rep3，检测了4个基因，分别为A，B，C，D，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185844.jpg">

</div>
<p>从上面的图表可以发现，Rep3的reads数比其它的2个更多，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185849.jpg">

</div>
<p>我们再看一下基因B，它的长度（4kb）是基因A（2kb）的2倍，这个或许就可以说明为什么基因B的reads数是基因A的reads数的2倍了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185852.jpg">

</div>
<h2 id="rpkm">RPKM</h2>
<p>RPKM的全称为Reads Per Kilobase Million，中文翻译就是<code>每千个碱基的转录每百万映射读取的reads数</code>。</p>
<p>现在我们使用RPKM来均一化这些数据，如下所示</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185902.jpg">

</div>
<h3 id="均一化的步骤如下所示">均一化的步骤如下所示</h3>
<p>第一步：均一化read深度。</p>
<p>我们计算一下某个重复的总reads数，然后用它们除以10，这里我们只是简单地模拟一下，真正的应该是除以1000000，因为RPKM的M指的就是million，是百万，但如果要除以1百万的话，小数点太多，不太直观，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185907.jpg">

</div>
<p>现在就得到了总reads数除以10的结果，分别为3.5，4.5，10.6，此时，再用每个基因对应的reads数除以相应的前面结果，例如对于Rep1中的基因A来说，就是使用10除以3.5，也就是2.86，得到的这个单位我们称之为RPM，也就是reads per million，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185912.jpg">

</div>
<p>第二步：均一化基因长度。</p>
<p>在这一步骤中，我们需要对基因的长度进行均一化，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185916.jpg">

</div>
<p>此时，用RPM的数值除以每个基因的长度，例如，对于Rep1的基因A来说，就是2.86，基因A的长度是2kb，那么这个数值就是2.86除以2等于1.43，这就是RPKM，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185919.jpg">

</div>
<p>现在我们看一下RPKM的效果，在均一化之前的数据与均一化之后的数据，我们可以发现，经过均一化后的数据，每个重复里的每个基因的RPKM就非常接近了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185922.jpg">

</div>
<h2 id="fpkm">FPKM</h2>
<p>FPKM的全称为Fragments Per Kilobase Million，对应的中文就是<code>每千个碱基的转录每百万映射读取的fragments</code>。FPKM与RPKM的计算非常接近，其中区别就在于一个是FPKM的Fragemnts，而RPKM则是reads。</p>
<p>另外，RPKM通常用于单端测序，FPKM常用于双端测序，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185927.jpg">

</div>
<p>在RNA-Seq中，我们建库时会把DNA打断成小片段（fragment），两端加上接头，然后测序。</p>
<p>如果是单端测序，那么一个fragmetns就对应了一条read，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185930.jpg">

</div>
<p>如果是双端测序，那么一条fragments就对应两条reads，当然，有时候双端测序也有可能出现一条fragment对应一条read（另外一条read有可能会因为质量低而被剔除），FPKM就保证了，一条fragment的两条reads不会被统计2次，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185934.jpg">

</div>
<p>也就是说FPKM是以fragment为准，而不是以reads数为准，它们的计算方式是一样的。</p>
<h2 id="tpm">TPM</h2>
<p>TPM的全称为Transcripts per million，中文就是<code>每百万条reads的转录本</code>。我们现在还以原来的案例，看一下TPM是如何计算的。</p>
<p>第一步：均一化基因长度。</p>
<p>每个重复中的每个基因的reads数除以该基因的长度，对于Rep1的基因A来说，就是10除以2，也就是5，也叫RPK，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185937.jpg">

</div>
<p>第二步：均一化测序深度。</p>
<p>先计算出一个重复中总的RPK之和，然后除以10，对于Rep1来说，总的RPK是15，除以10就是1.5，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185941.jpg">

</div>
<p>然后再用每个基因的RPK除以上面计算出来的数值，对于Rep1的基因A来说，就是5除以1.5，即3.33，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185945.jpg">

</div>
<p>经过TPM这样的均一化后，我们可以发现，这3个重复的数值就比较接近了。</p>
<h2 id="tpm和rpkm的区别">TPM和RPKM的区别</h2>
<p>我们比较一下RPKM与TPM均一化扣的结果，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185953.jpg">

</div>
<p>TPM和RPKM（FPKM）都是基于基因的长度与测序深度进行均一化的，但是它们也有所不同。我们看一下，对于每个重复来说，它们的总TPM和RPKM的数据数据之间的是存在一定差异的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185956.jpg">

</div>
<p>对于RPKM来说，每个重复的总RPKM值不一样，分别是4.29，4.5和4.25。</p>
<p>对于TPM来说，每个重复的总TPM是相同的，都是10（也就是说总的TPM）。</p>
<p>我们再来看一下这两种的差异有何重要意义。</p>
<p>我们先看下面的3个饼图，每个饼图的有大小相同，数值都是10。从中我们可以发现，对于同样的饼图来说，一份3.33的扇形（它代表了Rep1中的基因A）肯定比一份3.32的扇形（它代表了Rep2中的基因A）要大。而TPM就能发现这种3.33和3.32的这种差异，我们可以看到，在Rep1的总reads数中，比对到基因A上的reads数的比例肯定比Rep3中相应的比例要高，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190000.jpg">

</div>
<p>为什么会出现这种差异，我们可以再看上图，我们可以发现，在Rep3中，比对到基因D上的reads数所占的比例要大于Rep1中，比对到基因D的reads数的比例。通过TPM我们更容易发现，在每个重复中，比对到哪些基因上的reads更高或更低。</p>
<p>而对于RPKM这种均一化来说，很难比较比对到哪个基因上的总reads高，因为每个重复的总reads数都不同，也就是说这个饼图形的大小都不一样，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190005.jpg">

</div>
<p>还看上图，对于Rep1中的基因A来说，它的RPKM是1.43，而在Rep3中，基因A的RPKM是1.42，那么我们不能直接说在Rep1中，比对到基因A上的总Reads数大于Rep3中基因A的总Reads数，也就是无法直接说在Rep1中基因A的转录水平高于Rep3中基因A的转录水平，因为Rep1和Rep3的总RPKM不同。</p>
<p>而对于TPM就不一样，每个重复的总TPM是一样的，这样很容易比较相同基因在不同的重复中的转录水平高低。由于RNA-Seq主要是研究基因的转录水平，也就是说研究基因的转录本的reads的相对比例，因此使用TPM更加合理，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190010.jpg">

</div>
<h2 id="cpm">CPM</h2>
<p>有的时候还需要做到CPM，CPM的计算流程为：①总reads数除以100万；②用每个样本中的每个基因对应的reads数再除以①中的数字，就是CPM。</p>
<p>总reads数除以100万主要是为了方便计算CPM，否则CPM的数值会非常小，不方便，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714190014.jpg">

</div>
<p>用途：在某些情况下，只想了解每个基因被覆盖到的相对reads数，而不希望对其做长度校正，就会使用这个指标。在某些RNA-seq文章或一些软件输出结果中（如edgeR）会出现。CPM只对read count相对总reads数做了数量的均一化。当如果想进行表达量的基因间比较，则就需要考虑基因长度的不同。如果进一步做长度的均一化，就是RPKM。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/06/StatQuest/生物统计-StatQuest学习笔记23-RNA-seq简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/06/StatQuest/生物统计-StatQuest学习笔记23-RNA-seq简介/" itemprop="url">StatQuest学习笔记23——RNA-seq简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-06T12:10:54+08:00">
                2018-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,512
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列笔记的第58节，主要内容是讲RNA-seq的原理。StatQuest系列教程的58到62节是协录组测序的内容。</p>
<h2 id="rna-seq研究的是什么">RNA-seq研究的是什么</h2>
<p>我们先来看一个案例，在下面的这个案例中，蓝色的细胞是一群正常的神经细胞，红色的细胞是一群突变的神经细胞。其中，突变的神经细胞表型与正常的神经细胞表型不同，此时，我们想知道，是什么遗传机制导致了这两群细胞表型的差异，这就意味着，我们要研究一下这两种细胞基因表达的差异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182928.jpg">

</div>
<p>接下来，我们就来看一下，怎么找出这两群细胞基因表达的差异。</p>
<p>首先，根据高中的生物知识我就知道，一个细胞都有一群染色体（其数目因物种的不同而异），每条染色体上都有一些基因，在这些基因中，有些基因处于活跃状态，在下图中，这些活跃基因上面的波形图案表示这些基因mRNA的转录本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182933.jpg">

</div>
<p>但是，还有一些基因是不活跃的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182938.jpg">

</div>
<p>而高通量测序技术就能告诉我们，哪些基因是活跃的，以及它们的转录水平是多少，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182945.jpg">

</div>
<p>那么我们就可以通过RNA-Seq技术检测一下正常细胞的基因表达，再检测一下突变细胞的基因表达，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182949.jpg">

</div>
<p>然后我们比较一下这两种细胞基因表达的差异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182952.jpg">

</div>
<p>例如，在这个案例中，我们就可以发现，经过RNA-Seq检测后，基因1的转录水平在这两种细胞内是没有差异的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182956.jpg">

</div>
<p>但是，基因2的转录则有很大的差异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183002.jpg">

</div>
<p>基因3的转录水平也有差异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183005.jpg">

</div>
<h2 id="rna-seq的步骤">RNA-Seq的步骤</h2>
<p>RNA-Seq主要有三个步骤，分别是第一：建库；第二，测序；第三，数据分析，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183019.jpg">

</div>
<h3 id="第一步建库">第一步：建库</h3>
<p>在这一步，我们就以Illumina的实验流程和测序仪为标准进行讲解，其他公司的流程和测序仪可能略有出入，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183025.jpg">

</div>
<p>建库又分这些步骤：</p>
<p>第一步，提取RNA；</p>
<p>第二步，将RNA打断成小的片段，打断的目的主要是因为RNA的长度有几千个碱基，而测序仪的读长只有200到300个bp，因此要进行打断，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183028.jpg">

</div>
<p>第三步，将RNA反转录为DNA，这一步的目的在于，双链DNA比RNA更加稳定，双链DNA更容易扩增与修饰，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183032.jpg">

</div>
<p>第四步，添加接头。接头主要发挥两个作用，第一，使测序仪识别加了接头的片段，因为接头上的序列与测序仪芯片上序列互补；第二，添加接头可以在一次测序中区分不同的样本，因为不同的样本可以使用不同的接头，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183036.jpg">

</div>
<p>但我们需要注意的是，在加接头这个步骤中，它的效率并不是100%的，有些片段并不会被加上接头，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183045.jpg">

</div>
<p>第五步：PCR扩增，这一步的扩增引物是接头上序列，只有那些加上了接头的序列才能扩增，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183050.jpg">

</div>
<p>第六步：质控。这一步主要是看两个指标：第一，确定文库的浓度，第二，确定文库的长度。确定文库的浓度方法就是（根据我们实验室自己的流程），用Qubit检测一下文库的浓度，这个浓度比较粗略，不能当成精确的数值，接着，使用qPCR的方法，对文库进行绝对定量，经过qPCR绝对定量方法得到的文库浓度才是最终的文库浓度。在确定文库片段的长度方面，通常是使用Agilent 2100进行检测，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183053.jpg">

</div>
<h3 id="第二步测序">第二步：测序</h3>
<p>测序测的其实就是文库，我们假设DNA片段的序列是下图的左侧部分，它是垂直的，因为在测序仪的芯片上，文库就是垂直排列的，在测序芯片上的一个小方格（grid）中将近有4亿条这样的序列，为了方便讲解，我们在下图的右侧只列出4条这样的序列，这样的一个小方格被称为flowcell，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183111.jpg">

</div>
<p>下图是一个flowcell：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183117.jpg">

</div>
<p>在测序仪所使用的测序试剂中，含有一些特殊的碱基，这些碱基带有荧光探针，这些荧光探针按其结合碱基的不同，其颜色也不同，当测序仪开始测序时，这些带有荧光探针的碱基就会结合到DNA片段上第1个碱基，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183121.jpg">

</div>
<p>一旦这些带有荧光探针的碱基结合到DNA片段的碱基上，此时测序仪就会拍下一张照片，如果从上往下看，就是下图中红框所示的图片，这张图片会告诉测序仪，左下角的碱基是A，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183127.jpg">

</div>
<p>右下角的碱基就是G，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183130.jpg">

</div>
<p>左上角与右上角的碱基就是C，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183134.jpg">

</div>
<p>拍照结束后，测序仪会把这些这些碱基上的探针给冲走（测序试剂中有其他的成分，可以切掉这些荧光探针），此时，这些携带有探针的碱基就成了普通碱基，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183138.jpg">

</div>
<p>然后再加入含有荧光探针的碱基，再次与片段结合，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183142.jpg">

</div>
<p>在第二次结合后，测序仪会拍照，从上往下看，就是下图红框内的图片，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183152.jpg">

</div>
<p>这样测序仪就知道，左下角的碱基是C，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183156.jpg">

</div>
<p>右下角的碱基是G，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183203.jpg">

</div>
<p>左上与右上的碱基是T，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183218.jpg">

</div>
<p>第2张图片识别后，再次用试剂切掉这些碱基上的荧光探针，并冲走，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183223.jpg">

</div>
<p>再进行第3次反应，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183228.jpg">

</div>
<p>总之，测序仪会不断地循环这个过程，直到测完所有的碱基，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183233.jpg">

</div>
<p>不过在实际的测序过程，这些DNA链的密度非常大，构成了一个密度极高的颜色矩阵，这个过程中也会产生一些问题，在下面我们就用一个简单的矩阵来说明这个问题，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183237.jpg">

</div>
<p>有时候，一个荧光探针的亮度可能不够，此时测序仪就没有足够的把握能够识别这种颜色，而在测序的过程中，根据这些探针的亮度，会生成一个质量评分（Quality score），这个质量评分反映了测序仪对这个颜色识别的可信程度，像在下面的这个图片中，这个比较暗的点可能就会得到一个比较低的质量评分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183240.jpg">

</div>
<p>还有另外一种情况可能会得到一个质量评分，就是在某个区域内，相同的碱基数目太多，都呈现出一种颜色，如下图绿框所示部分，这种现象称为多样性差（low diversity），这种情况下，由于存在着大量的单一荧光，测序仪很难识别单独的碱基，这些颜色会混到一起。当测序仪测序时，对于文库中前几个碱基的识别很容易出现多样性差的问题，这是因为在刚开始的时候，测序仪要识别DNA片段位于芯片上的位置时，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183244.jpg">

</div>
<p>我们看一下测序后的原始数据，下图是测序的一个read的信息，它由4行构成，如下所示</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183251.jpg">

</div>
<p>第1行通常是由<code>@</code>开头的，它对于每条read，它都有唯一的ID，如下所示；</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183256.jpg">

</div>
<p>第2行是测序的文库片段的碱基序列，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183300.jpg">

</div>
<p>第3行是一个加号，它通常是空的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183300.jpg">

</div>
<p>第4行是质量信息，它用一个字符表示这个字符对应的碱基的质量评分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183309.jpg">

</div>
<p>一次测序通常有4亿条reads数，一共会产生16亿行信息，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183315.jpg">

</div>
<h3 id="数据预处理">数据预处理</h3>
<p>我们现在已经知道了原始数据，以及原始数据如何产生的，那么我们下面要做这三件事情：</p>
<p>第一， 过滤掉垃圾reads；</p>
<p>第二，将高质量的reads比对到基因组上；</p>
<p>第三，对每个基因的reads数进行统计，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183330.jpg">

</div>
<h4 id="过滤垃圾reads">过滤垃圾reads</h4>
<p>垃圾reads是指：第一，某些reads的碱基质量低；第二，这些reads是明显的结合错误（第二种低质量的reads我不太清楚，原文我也看不太懂，我个人理解就是两个接头直接连接在一起的read）。</p>
<p>一条典型的read是一个DNA片段加上两个接头，但是在某些情况下，两个接头会直接加在一起，这就是垃圾reads，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183335.jpg">

</div>
<h4 id="将read比对到基因组">将read比对到基因组</h4>
<p>我们先看一下基因组上的碱基序列，由于基因组的碱基序列很长，我们只截取一段出来，如下图中的红框所示，把这条基因组的碱基打断，会生成这些短的碱基序列，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183339.jpg">

</div>
<p>此时，我们把基因组的这些片段加上索引，并记录下它们在染色体上的位置，就是下图蓝框中的部分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183342.jpg">

</div>
<p>此时，我们把我们的测序read也打成小片段，就像上面的基因组打成小片段一样，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183347.jpg">

</div>
<p>然后把reads的小片段与基因组的小片段进行匹配，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183351.jpg">

</div>
<p>那些与reads的小片段匹配的基因组小片段就是这些read小片段在基因组上的位置（哪条染色体上，染色体的哪个位置），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183355.jpg">

</div>
<p>此时，我们可能有一个问题，为什么要把这些序列打断成小片段，这是因为即使reads与参考基因组在不是特别精确匹配的情况下，也能进行匹配，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183359.jpg">

</div>
<p>我们来看一个简单的例子，在下图中，某条read最左侧是A，而对应的基因组上并没有这个A（打个很简单的案例，我自己的基因组肯定与别人的基因组略有差异），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183403.jpg">

</div>
<p>即使这个小片段无法与基因组上相匹配，那么其它的小片段还是能够匹配的，此时我们仍然可以找到这条read来源于基因组的哪个位置，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714183407.jpg">

</div>
<h4 id="每个基因的reads计数">每个基因的reads计数</h4>
<p>一旦我们知道了某条read的位置（也就是说知道了这条read在哪条染色体上，以及在染色体的哪个位置上），那么我们就可以看一下这条read是否能够落在某个基因的坐标中（或者是某些其它感兴趣的区域），例如在下图中，我们列出了<code>Xkr4</code>和<code>Rp1</code>这两个基因的坐标，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185221.jpg">

</div>
<p>当我们统计了每个基因的reads数后，我们就会得到下面这样的矩阵，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185225.jpg">

</div>
<p>第1列是基因名，在人类中，人类大概有20000个基因，因此这个矩阵的大概有2万行（下图中并没列完所有的基因），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185229.jpg">

</div>
<p>剩余的几列是每个样本对应的基因的reads数，这里的样本数目大概是6到800个，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185232.jpg">

</div>
<p>对于大部分的RNA-Seq来说，一个“样本”通常是一群细胞的平均值（通常是600万个细胞），一次实验，一般有3个正常的样本，3个疾病状态的样本，总共就是6个样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185238.jpg">

</div>
<p>而对于单细胞测序（Single-cell RNA-Seq）来说，每个细胞就是一个样本，因此这个矩阵中会出现有几百个样本，例如800多个，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185242.jpg">

</div>
<p>我们现在看某一行数据，如下所示，在这行数据中，我们可以看到每个样本中，每个特定基因的reads数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185246.jpg">

</div>
<p>如果这个矩阵是单细胞测序的数据，那么这个矩阵有2万行（基因数目），800多列（样本数），大概有1600万个数值，这是一个极大的矩阵，并且随着测序技术发展，所测样本数目的增多，这样的矩阵会越来越大，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185249.jpg">

</div>
<p>在进行最终的数据分析之前，我们还要对数据进行均一化，这是因为每个样本比对到基因组上的reads数都不同，这可能是由于在测序时，有些样本的reads质量低，而另外某些样本的浓度略大，导致其总的reads数略高，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185253.jpg">

</div>
<p>例如，在下图中，Sample 1有635个reads比对上了，而Sample 2则有1270个reads数比对上了，Sample 2是Sample 1的两倍。但是这无法说明，Sample 2转录的基因是Sample 1的2倍，相反，这只能说明，Sample 2中的低质量reads数少，它在测序时，被测序仪识别的荧光更多而已，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185256.jpg">

</div>
<p>但是，我们发现，Sample 2中基因的reads数貌似是Sample 1中的基因reads数的2倍，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185259.jpg">

</div>
<p>A2M基因也是如此，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185303.jpg">

</div>
<p>因此，我们需要调整每个基因的reads数，从这样才能真正反映出不同样本中比对上的reads数之间的差异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185307.jpg">

</div>
<p>均一化最简单的方法就是在每个样本中，每个基因的reads数除以总的比对上的reads数，不过，还有其他更复杂的方法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185310.jpg">

</div>
<p>我们再回到最初的正常细胞与突变细胞的比较，我们先有了这两群细胞，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185315.jpg">

</div>
<p>然后提取RNA，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185319.jpg">

</div>
<p>随后，进行测序，比对，统计每个基因的reads数，然后均一化，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185324.jpg">

</div>
<p>此时，开始数据处理。</p>
<h3 id="第三步数据处理">第三步：数据处理</h3>
<p>数据处理的第一步通常都是相同，那就是绘图，我们要记住，这个表达矩阵非常大，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185339.jpg">

</div>
<p>如果每个样本只有2基因，那么绘图非常简单，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185345.jpg">

</div>
<h4 id="第1步绘图">第1步：绘图</h4>
<p>首先我们用XY来替代这两个基因，根据它们的表达水平来绘图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185350.jpg">

</div>
<p>但是，我们有2万个基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185354.jpg">

</div>
<p>因此我们会用PCA或者是类似的方法来绘图，PCA能够降低坐标轴的数目（也就是把2万个基因对应的2万个坐标轴给降低到3个或2个），从而更加直观地表现数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185359.jpg">

</div>
<p>下图是我们利用PCA绘制的图形，正常的细胞是<code>wt</code>，突变的 细胞是<code>ko</code>，其中正常的细胞集中在左下角，敲除的细胞集中在右下方，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185402.jpg">

</div>
<p>从图中我们可以发现，这两类数据的差异主要体现在x轴上，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185406.jpg">

</div>
<p>相反，Y轴的差异没那么大，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185412.jpg">

</div>
<p>这就说明，<code>wt</code>组与<code>ko</code>组的差异主要集中于X轴，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185416.jpg">

</div>
<p>但是，当我们进行下一步的分析时，就需要排除<code>wt2</code>这个样本了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185419.jpg">

</div>
<p>下图是单细胞测序的PCA图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185424.jpg">

</div>
<p>上面的不同颜色绘图依据是这些细胞行为的不同，绿色表示的是静止的细胞，橘黄色表示的是迁移到培养皿周围的细胞，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185429.jpg">

</div>
<p>大多数橘黄色的细胞与绿色的细胞是不同的，但是在左侧绿色的细胞中，也有几个是橘黄色的细胞，这说明这几个细胞的表型与绿色细胞更接近，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185435.jpg">

</div>
<p>如果我们想要研究上面两个大群细胞的差异，那么此时我们就要排除左下那几个橘黄色的细胞，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185438.jpg">

</div>
<p>总之，在对数据绘图后，我们可以从中得到这些信息：</p>
<ol style="list-style-type: decimal">
<li>找到感兴趣的差异部分；</li>
<li>在进行下游的分析之前，应该排除哪些数据，如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185441.jpg">

</div>
<h4 id="第2步寻找差异基因">第2步：寻找差异基因</h4>
<p>绘图后，我们就需要找到正常样本与突变样本有哪些差异表达基因，在分析差异基因时，通常使用R中的<code>edgeR</code>或<code>DESeq2</code>，它们通常以下图进行展示，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185446.jpg">

</div>
<p>其中红色部分是正常样本与突变样本的差异基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185449.jpg">

</div>
<p>中间的黑色部分是没有差异的基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185454.jpg">

</div>
<p>其中X轴表示的是基因的转录水平，它的单位是logCPM，其中CPM是counts per million的缩写，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185458.jpg">

</div>
<p>Y轴则是表示在正常样本与突变样本之间，差异基因的差异程度有多大，单位是logFC，即log(fold change)，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185501.jpg">

</div>
<p>此时我们已经找到了感兴趣的基因（也就是差异基因），此时我们要做哪些事情呢？</p>
<p>第一，如果你知道你找的是什么（我的理解就是找的是具体的哪个基因），那么就要做实验，看能否验证你的假设；</p>
<p>第二，如果你不知道你接下来做什么，那么就你可以看一下这些差异基因集能否在某些通路上富集，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714185504.jpg">

</div>
<p>每个样本对于每个特定的基因，它的reads数都不同，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/05/StatQuest/生物统计-StatQuest学习笔记22-交叉验证/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/StatQuest/生物统计-StatQuest学习笔记22-交叉验证/" itemprop="url">StatQuest学习笔记22——交叉验证</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T12:10:54+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,320
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列视频的第57节，主要内容是交叉验证。</p>
<h2 id="选择哪些方法">选择哪些方法</h2>
<p>我们先看一个简单的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181835.jpg">

</div>
<p>我们要使用下面左侧的这些变量来预测右侧的心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181840.jpg">

</div>
<p>当我们遇到一个新的病人时，检测这些指标（左侧）来预测是否得了心脏病（右侧），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181844.jpg">

</div>
<p>此时，我们就面临一个问题，使用哪种方法来预测这个病人是否得有心脏病？如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181847.jpg">

</div>
<p>是采用逻辑回归，还是KNN（K邻近算法），支持向量机（SVM）等等，如下所示：</p>
<h2 id="交叉验证">交叉验证</h2>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181853.jpg">

</div>
<p>此时就需要进行交叉验证（cross validation），用于比较不同的机器学习方法，然后在实际中运用，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181858.jpg">

</div>
<p>我们看下面的蓝色柱子，它代表了我们收集到的，没有心脏病患者的数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181901.jpg">

</div>
<p>对于这个数据，我们需要做2件事情，如下所示：</p>
<p>第一，估计机器学习方法的参数。例如对于逻辑回归来说，我们需要使用一些数据来估计这个曲线的形状，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181905.jpg">

</div>
<p>用机器学习的术语来说，用于估计参数的过程叫做“训练算法”（training the algorithm），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181911.jpg">

</div>
<p>第二件事情就是，我们要评估一下所选的这个方法工作起来到底行不行。也就是说，我们需要评估一下，找出的这条曲线能否对新的数据进行很好地归类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181915.jpg">

</div>
<p>用机器学习的术语来讲，评估一个方法的好坏叫做“检验算法”（testing the algorithm），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181920.jpg">

</div>
<p>综上所述，我们对于选定的方法，需要做两件事情，第一，训练机器学习方法；第二，检验机器学习方法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181925.jpg">

</div>
<p>比较麻烦的一点就是如果使用所有的数据来估计参数（例如训练算法），那么就没有余下的数据来测试这个算法的好坏，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181930.jpg">

</div>
<p>如果重新使用相同的数据用于训练，也用于检验，也不合适，因为我们要测试算法所使用的数据不能是训练数据，简单来说，就是不能同一批数据既用于训练，也用于检验，这样你无法判断这个算法是好是坏，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181935.jpg">

</div>
<p>一种比较好的思路就是，对于同一批数据，使用这批数据的75%用于训练，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181939.jpg">

</div>
<p>剩下的25%用于检验，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181943.jpg">

</div>
<p>然后我们就能通过查看测试数据中的归类情况来比较算法的好坏，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714181947.jpg">

</div>
<h2 id="交叉验证原理">交叉验证原理</h2>
<p>但是，我们是怎么知道把数据分为前75%和后25%是一种最好的方法呢，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182012.jpg">

</div>
<p>为什么不使用前25%的数据用于检验算法，或者是使用中间25%的数据来检验算法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182016.jpg">

</div>
<p>对此，不用多虑，因为无论选择哪一部分数据，交叉验证都会使用到这些数据，最终会把结果汇总出来，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182020.jpg">

</div>
<p>例如，交叉验证在开始的时候，使用前75%的数据来训练算法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182025.jpg">

</div>
<p>用剩下的25%数据来检验算法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182028.jpg">

</div>
<p>然后我们看一下这个算法对于测试数据的归类情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182032.jpg">

</div>
<p>然后，我们再看一下，使用其他的75%数据来训练算法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182036.jpg">

</div>
<p>使用中间偏下的那25%数据用于检验，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182040.jpg">

</div>
<p>记录一下测试的结果，4个正确，2个错误，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182045.jpg">

</div>
<p>就像上面的过程一样，不断地采用各种75%的数据来训练，25%的数据来检验，同时记录下每次检验的结果，等等，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182048.jpg">

</div>
<p>最终，每一部分数据都用于了检验，然后我们就可以比较不同的算法检验的结果，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182051.jpg">

</div>
<p>从上面的结果来，SVM这个算法最好，因为它的正确率最高，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182055.jpg">

</div>
<p>我们需要注意的是，在这个案例中，我们把数据分成了4份，这种方法称为四重交叉验证（Four-Fold Cross Validation），不过个数字不一定是4，也可以是其他的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182059.jpg">

</div>
<p>我们看一个比较极端的案例，在这个案例中，我们把每一个数据都当成一份，这种方法称为留一法交叉验证（Leave One Out Cross Validation），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182106.jpg">

</div>
<p>但在实际计算过程中，把数据分成10份也是常见的方法，这种方法称为十重交叉验证（Ten-Fold Cross Validation），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182110.jpg">

</div>
<p>调整参数不是估计值，是某种猜测值，当我们要使用某个涉及一个“调整参数”（tuning parameter）的方法时，例如岭回归（ridge regression）就有一个调整参数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182114.jpg">

</div>
<p>此时，我们就可以使用十重交叉验证来找到这个最佳的调整参数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714182120.jpg">

</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/04/StatQuest/生物统计-StatQuest学习笔记21-逻辑回归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/04/StatQuest/生物统计-StatQuest学习笔记21-逻辑回归/" itemprop="url">StatQuest学习笔记21——逻辑回归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-04T12:10:54+08:00">
                2018-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,266
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列视频教程的第56小节，主要内容是逻辑回归（Logistic Regression）。</p>
<h2 id="回顾线性回归">回顾线性回归</h2>
<p>在讲逻辑回归之前，我们先回顾一下线性回归。</p>
<p>例如我们有一批数据，研究的是体重与小鼠的大小之间的关系，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180352.jpg">

</div>
<p>我们可以找到一条回归曲线，来研究这两者之间的关系，通过这条曲线，我们可以得到以下信息：</p>
<ol style="list-style-type: decimal">
<li>计算出<span class="math inline">\({R}^2\)</span>，这个数值可以看出体重与大小之间的相关程度，数值越大，就越能表明这两者关系密切；</li>
<li>计算出p值，这个p值可以看出<span class="math inline">\({R}^2\)</span>是否有统计学上的意义；</li>
<li>计算出这个曲线的方程，利用体重来预测小鼠的大小。</li>
</ol>
<p>如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180357.jpg">

</div>
<p>例如，我们有一个新的小鼠体重，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180400.jpg">

</div>
<p>通过这个点向做一条垂直于x轴（也就是体重）的直线，然后找到这个直线与前面回归曲线的交点，再通过这个交点做一条平行于x轴的直线，与y轴交叉的地方就是小鼠的大小，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180404.jpg">

</div>
<p>这种用某个数据预测另外一个数据的方法其实就是机器学习的范畴了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180410.jpg">

</div>
<p>现在我们再回顾一下多元线性回归，现在我们利用体重（weight），血量（blood volumne）来预测小鼠的大小（size），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180414.jpg">

</div>
<p>多元线性回归的计算与二元线性回归的计算一样，计算出<span class="math inline">\({R}^2\)</span>，再计算出<span class="math inline">\({R}^2\)</span>的p值，然后利用线性回归的方程通过体重和血量来预测小鼠的大小，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180417.jpg">

</div>
<p>此外，我们还提到了通过不同的检测指标，例如表型（genotype）来预测小鼠的大小，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180421.jpg">

</div>
<p>现在我们比较一下二元线性回归与多元线性回归，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180425.jpg">

</div>
<p>通过比较这两种线性回归，我们知道，如果我们使用更多的变量（例如在多元线性回归中，我们添加了血量这个变量）来预测大小，结果会更加精确，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180430.jpg">

</div>
<h2 id="逻辑回归简介">逻辑回归简介</h2>
<p>现在要学习另外一种回归，就是逻辑回归。逻辑回归与线性回归比较类似，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180442.jpg">

</div>
<p>逻辑回归预测的结果并不是具体的某个数据，而某个结果是<code>True</code>还是<code>False</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180447.jpg">

</div>
<p>例如，在上面的案例中，有9只小鼠，最上面的5只小鼠是肥胖小鼠，下面的4只小鼠是非肥胖型小鼠，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180451.jpg">

</div>
<p>此时，我们要找一条曲线来拟合这些数据，不过这条曲线与线性回归的直线不同，它是S型的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180455.jpg">

</div>
<p>其中纵坐标的范围是0到1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180459.jpg">

</div>
<p>这就说明，我们最终计算的结果是一个概率，就是由小鼠的体重来预测这个小鼠是否是肥胖小鼠的概率，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180503.jpg">

</div>
<p>如果一个小鼠的体重很重，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180507.jpg">

</div>
<p>那么，通过这个点做一条垂直于横坐标的直线，与逻辑回归的曲线相交，我们就可以发现，这个小鼠有很大的概率是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180511.jpg">

</div>
<p>如果一个小鼠的体重处于中间地带，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180516.jpg">

</div>
<p>那么这只小鼠可能只有50%的可能性是肥胖小鼠，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180520.jpg">如果一只小鼠的体重很小，那么它就不太可能是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180524.jpg">

</div>
<p>虽然逻辑回归会告诉我们一只小鼠是否是肥胖小鼠，但是逻辑回归在多数情况下，是用于分类的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180527.jpg">

</div>
<p>同理，如果一只小鼠是肥胖小鼠的概率是50%，那么我们就会把它归于肥胖小鼠这一类，否则，我们会把这只小鼠归于非肥胖小鼠这一类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180531.jpg">

</div>
<h2 id="逻辑回归简单案例">逻辑回归简单案例</h2>
<p>现在我们来看一个逻辑回归的简单案例，在这个案例中，我们使用小鼠的体重来预测是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180542.jpg">

</div>
<p>我们还有可能会涉及一个更复杂的案例，例如通过体重和表型来预测小鼠是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180547.jpg">

</div>
<p>或者是更加复杂的案例，例如使用体重，表型，年龄来预测小鼠是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180553.jpg">

</div>
<p>或者说，还要复杂，例如通过体重，表型，年龄，星座（astrological sign？？）来预测小鼠是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180557.jpg">

</div>
<p>换句话说，逻辑回归与线性回归相同之处在于，逻辑回归也可以使用连续型变量（例如体重与年龄），，与离散型变量（例如表型与星座）来进行计算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180602.jpg">

</div>
<p>我们还检测一下每个变量是否能够用于预测小鼠是否是肥胖小鼠，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180606.jpg">

</div>
<p>但是，逻辑回归与线性回归不同，我们不太容易比较复杂回归与简单回归，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180610.jpg">

</div>
<p>相反，我们不会直接比较复杂回归与简单回归，而是通过Wald方法检验一下，一个变量是否能够对预测结果产生明显的影响（与0相比），如果这个变量对预测结果没有什么影响，那么此变量就无法为预测提供相应的信息，这种如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180613.jpg">

</div>
<p>如果我们检验了这些变量的话，那么我们就发现，星座这个变量对预测小鼠是否肥胖没什么帮助，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180619.jpg">

</div>
<p>这就说明，我们在计算逻辑回归的方程时，就可以不使用星座这个变量，从而节省时间与空间，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180622.jpg">

</div>
<p>逻辑回归使用连续型变量和离散型变来来计算概率，它能对一个新的样本进行分类，这是一种常用的机器学习方法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180626.jpg">

</div>
<p>线性回归与逻辑回归的一个最大的区别在于，如何找到一条拟合这些数据的曲线，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180631.jpg">

</div>
<p>在线性回归中，我们通常使用最小二乘法来寻找拟合这些数据的曲线，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180635.jpg">

</div>
<p>换句话说，我们找到的这条曲线，每个点到这条曲线的距离平方和（残差）最小，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180639.jpg">

</div>
<p>我们还要利用残差来计算<span class="math inline">\({R}^2\)</span>，用于比较简单线性回归与复杂线性回归，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180644.jpg">

</div>
<p>逻辑回归没有线性回归中“残差”的概念，因此，我们无法使用最小二乘法来计算曲线，也无法计算<span class="math inline">\({R}^2\)</span>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180648.jpg">

</div>
<p>计算逻辑回归曲线方程的方法是“最大似然法”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180652.jpg">

</div>
<p>最大似然法以前讲过，在这里，只是用一种比较简单粗糙，不严谨的语言来描述一下。</p>
<p>首先，把小鼠的体重经过缩放（scaled），先拟合出一条曲线，此时，这条曲线只是初步的一条曲线，不是最终的曲线。找到第1只小鼠（这只小鼠是非肥胖小鼠）的体重在这条曲线上对应的概率，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180655.jpg">

</div>
<p>此时，计算一下这个非肥胖小鼠（也就是第1只小鼠）与这条曲线上小鼠对应的概率的相符的似然性（likelihood），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180702.jpg">

</div>
<p>然后，再找到第2只小鼠在这条曲线上对应的概率，以及计算第2只小鼠与这个概率的似然性，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180706.jpg">

</div>
<p>所有的小鼠都这么计算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180709.jpg">

</div>
<p>最终，把这些小鼠的所有似然性都相乘，就是这条曲线与这些数据的似然性，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180713.jpg">

</div>
<p>此时，我们已经计算了第1条曲线了的似然性了，此时，还转换一下曲线，计算这条新的曲线的似然性，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180719.jpg">

</div>
<p>还有第3条曲线，也是如此计算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180722.jpg">

</div>
<p>最终，我们会通过极大似然法找到最适合的这条曲线，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180726.jpg">

</div>
<p>现在总结一下，逻辑回归是用于对样本分类的算法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180730.jpg">

</div>
<p>它可以使用不同的数据类型（例如大小和表型）来对数据进行分类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714180733.jpg">

</div>
<p>这种方法还可以用评估哪些变量可以用于分类（例如星座就无法用于分类），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190707084243.png">

</div>
<h2 id="总结">总结</h2>
<p>上面只是一种非常精浅的逻辑回归的描述，并没有涉及到如何计算，如果看结果。如果真正要运用的话，还需要看其他的统计学书籍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/02/StatQuest/生物统计-StatQuest学习笔记20-随机森林/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/StatQuest/生物统计-StatQuest学习笔记20-随机森林/" itemprop="url">StatQuest学习笔记20——随机森林</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T12:10:54+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,869
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言主要内容">前言——主要内容</h2>
<p>这篇笔记是StatQuest系列视频的第53-55节，其中第53节讲的是随机森林，第54节讲的是缺失值的处理，第55节讲的是R与随机森林。</p>
<h2 id="决策树的局限">决策树的局限</h2>
<p>随机森林（Random Forests）来源于决策树，因此如果不了解决策树的话，可以看上一篇笔记，决策树如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174102.jpg">

</div>
<p>决策树很容易构建，也很好用，也很好题解。但事实上，决策树并非完美无缺，引用《The Elements of Statistical Learning》（又名《The Bible of Machine Learning》），中文译名为《统计学习基础：数据挖掘、推理与预测》的话讲，决策树的不精确准确（inaccuracy）决定了它无法作为一个理想的预测学习工具，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174109.jpg">

</div>
<p>换句话说，就是决策树的构建要利用大量的数据，但是当用这个构建好的决策树来对一批新的数据进行分类时，决策树并不能灵活地处理这些新数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174113.jpg">

</div>
<h2 id="随机森林的优势">随机森林的优势</h2>
<p>随机森林综合了决策树简洁的特征，同时又具备灵活性，因此随机森林在精确性方面也得到了极大的提高，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174128.jpg">

</div>
<h2 id="构建随机森林">构建随机森林</h2>
<p>接着，我们来看一下随机森林的构建过程。</p>
<h3 id="第一步构建自举数据集">第一步：构建自举数据集</h3>
<p>构建随机森林的第一步就是从原始数据中随机挑选数据，构建“自举”数据集（自举：bootstrap），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174134.jpg">

</div>
<p>下面是原始的数据集，这个数据集还是我们上篇笔记中的那个数据集，里面有4个变量，分别为<code>胸痛（Chest Pain）</code>，<code>良好血液循环（Good Blood Circ.）</code>，<code>动脉阻塞（Blocked Arteries）</code>，<code>体重（Weight），</code>虽然这个数据集非常小，但是不影响使用，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174139.jpg">

</div>
<p>为了构建一个与原始数据集同样大小的自举数据集（bootstrapped dataset），我们仅需要随机地从原始数据中挑选样本即可，这个随机挑选的过程是有放回地挑选（这就是bootstrap），也就是我从原始数据集中随机挑一个样本，然后放回去，再随机挑一个样本，这样的话，相同有样本有可能被挑中好几次，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174147.jpg">

</div>
<p>我们先随机挑一个样本，这次挑中了第2个样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174151.jpg">

</div>
<p>把这个样本放到我们的自举数据集中，就成了自举数据集中的第1个样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174156.jpg">

</div>
<p>再随机挑一个样本，这次挑中了原始数据集中的第1个样本，把它放到我们的自举数据集中，就是自举数据集中的第2个样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174159.jpg">

</div>
<p>再从原始数据中随机挑一个，放到自举数据集中，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174205.jpg">

</div>
<p>再随机挑一个，放到自举数据集中，这里需要注意的是，我们挑了两次原始数据集中第4个样本，这样在自举数据集中就有了2个重复的样本，这个没关系，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174208.jpg">

</div>
<p>此时，我们就构建好了一个自举数据集，这个自举数据集的大小与原始数据集的大小相同，也就是说有同样数目的样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174213.jpg">

</div>
<h3 id="第二步构建树">第二步：构建树</h3>
<p>构建随机森林的第二步就是利用我们构建的自举数据集来构建一个决策树，并且一次只能使用一个变量（或列）的随机亚集（subset）进行构建，在这个案例中，我们每一步只会使用2个变量（列），至于为什么使用2个变量，后文会讲解，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174232.jpg">

</div>
<p>因此，我们不会使用所有的4个变量来区分根节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174236.jpg">

</div>
<p>而是随机选择2个变量来区分根节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174241.jpg">

</div>
<p>在这个案例中，我们随机使用<code>良好血液循环（Good Blood Circulation）</code>和<code>动脉阻塞（Blocked Arteries）</code>这两个变量来区分根节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174244.jpg">

</div>
<p>就像我们这个案例的目的一样，我们假设良好血液循环（Good Blood Circulation）能够很好地区分样本，我们就用它作为根节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174248.jpg">

</div>
<p>由于我们使用过了良好血液循环（Good Blood Circulation）这个变量，因此这里把它变灰，以便于我们研究剩余的变量，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174252.jpg">

</div>
<p>现在我们看一下中间节点如何区分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174255.jpg">

</div>
<p>与根节点一样，我们并不使用剩余的所有3个变量，而是随机选择2个变量用于区分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174259.jpg">

</div>
<p>接着，我们就像以前构建决策树那样，构建树，不过我们一次只使用一个变量的随机亚集，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174303.jpg">

</div>
<p>最终的结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174307.jpg">

</div>
<p>现在回顾一下我们构建这个树的过程：第一步，构建自举数据集；第二步，每一步随机选择一个变量亚集来构建节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174310.jpg">

</div>
<h3 id="第三步循环第1到到第2步">第三步：循环第1到到第2步</h3>
<p>此时，我们就构建好了一个树，现在我们再回到第一步，重复操作，再生成一个自举数据集，还是一次使用变量的一个随机亚集来构建一个树（就是下图中第2个树），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174347.jpg">

</div>
<p>不断地重复这个过程，重复100次，这样我们会构建一系列的树，下图只是显示了其中的6种树，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174353.jpg">

</div>
<p>通过利用一个自举样本，一次只利用变量的一个随机亚集，就会产生大量不同的树，这些树就构成了随机森林（一次生成一棵树，多次运算，就是多棵树，也就是森林了），它远比单一的决策树有效，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174357.jpg">

</div>
<h2 id="随机森林的使用">随机森林的使用</h2>
<p>此时，我们已经学会了构建随机森林的基本思想，那么随机森林有什么用处呢，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174407.jpg">

</div>
<p>我们看一个案例，例如，我们遇到了一个新病人，他的各种参数如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174412.jpg">

</div>
<p>现在我们想知道，他是否得有心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174416.jpg">

</div>
<p>那么，我们把他的数据放到我们生成随机森林中，先放到第1棵树上，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174421.jpg">

</div>
<p>运算结果显示Yes，此时记录一下这个数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174425.jpg">

</div>
<p>现在把这个人的参数放到随机森林中的第2棵树上运行，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174429.jpg">

</div>
<p>计算结果是Yes，此时记录下这个数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174433.jpg">

</div>
<p>我们把这个人的数据再放到随机森林中的其他的树中运算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174436.jpg">

</div>
<p>总之，就是不断地放到不同的树上运算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174442.jpg">

</div>
<p>当运算结果后，我们记录下所有树的运算结果，我们会看到Yes或No哪个得票最多，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174445.jpg">

</div>
<p>在这个案例中，明显Yes得票最多，因此我们就能下结论，这个人得了心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174449.jpg">

</div>
<h2 id="随机森林相关术语">随机森林相关术语</h2>
<p>自举数据并对它们进行汇总做出的决策称为袋装法（Bagging），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174503.jpg">

</div>
<h2 id="随机森林的评估">随机森林的评估</h2>
<p>我们已经了解了随机森林构建的基本思想，也知道了如何使用它，此时可能还有一个问题，这个模型的好坏程度到底如何，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174508.jpg">

</div>
<p>我们回到前面构建自举数据集的内容，我们在前文中说过，在一个自举数据集中，我们允许两条相同的记录（entry，记录可以理解为一个样本，也就是一行数据）存在，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174511.jpg">

</div>
<p>最终在自举数据集中，没有包含原始数据集中的第3条目录，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174515.jpg">

</div>
<p>通常来说，大概会有三分之一的原始数据集中的记录不会包含在自举数据集中，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174518.jpg">

</div>
<p>下图的右侧就是那条未包含在自举数据集中的记录，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174522.jpg">

</div>
<p>如果原始数据集非常大的话，那么就有不止一条记录不包含在自举数据集中，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174526.jpg">

</div>
<p>这些不包含在自举数据集上的记录被称为“出袋数据集”（out-of-bag dataset，未找到相应的中文译名，此处暂译为“出袋数据集”），这样命名主要是因为，如果把自举数据集看成一个袋子，这些数据并不在这个袋子中，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174529.jpg">

</div>
<p>由于这些出袋数据集并没有用于构建这些树，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174533.jpg">

</div>
<p>因此，我们可以把这个数据集当作是一个新的样本，把它放到随机森林中计算，看能不能得到想要的结果（没得心脏病），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174537.jpg">

</div>
<p>在这个案例中，这个样本最终的计算结果是No，也就是没得心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174541.jpg">

</div>
<p>然后我们把这些出袋数据集放到其他树中计算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174546.jpg">

</div>
<p>有一个树计算的结果是Yes，这个明显是错误的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174551.jpg">

</div>
<p>其他的树计算结果是No，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174555.jpg">

</div>
<p>对所有树的计算结果进行统计，我们发现，No的得票最多，那么我们就能下结论，这个样本的结果是没得心脏病，与样本本身的结果一致，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174558.jpg">

</div>
<p>我们对其他的出袋数据集继续进行计算（出袋数据据不止一个样本，有很多），这个样本的结果是Yes，与样本本身的结果一致，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174602.jpg">

</div>
<p>再计算另外的样本，样本本身的结果是No，但计算出来的结果却是Yes，并不一致，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174606.jpg">

</div>
<p>经过不断地计算，我们会得到很多计算结果，最终我们再计算一下，随机森林计算的样本结果与样本本身的结果一致的比例，我们就能得到随机森林的精确程度，其中随机森林计算的结果与样本本身的结果不一致的比例，我们称为出袋错误（Out-Of-Bag Error）（未找到相应的中文译名，此处暂译为“出袋错误”），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174611.jpg">

</div>
<p>至此，我们了解了这些内容：第一，构建随机森林；第二，使用随机森林；第三，评估随机森林的精确性。</p>
<p>既然我们知道了如何评估随机森林的精确性，那么此时我们再回到第一部分，了解一下随机森林是的构建原理，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174617.jpg">

</div>
<p>在构建随机森林时，我们最初在每一步中，使用的是随机选择的2个变量，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174621.jpg">

</div>
<p>现在我们就要比较一下，使用随机选择的2个变量与3个变量导致的出袋错误的差异，我们测试一些不同的参数，来研究一下如何选择一个最为精确的随机森林，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174624.jpg">

</div>
<p>换句话讲，我们做上述事件的顺序是：</p>
<p>第一，构建随机森林；</p>
<p>第二，评估随机森林的精确性。</p>
<p>接着，改变每一个步骤中的变量数目，不断地重复这个过程，得到一个最精确的随机森林，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174630.jpg">

</div>
<p>通常来说，我们最初使用的变量数目为总变量数目的平方根，例如在前面的案例中，总变量数目是4，它的平方根是2，那么我们一开始就先使用2个变量作为每次运算时变量的数目，然后在这个数目上下进行调整，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174634.jpg">

</div>
<p>在构建随机森林的过程中我们可能会遇到缺失值，缺失值有两种，我们先看第一种缺失值的处理。</p>
<h2 id="第一种缺失值的处理">第一种缺失值的处理</h2>
<p>我们看一下我们的原始数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174651.jpg">

</div>
<p>原始数据一共是4个患者，其中第4名患者有2个数据缺失，用问号表示，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174655.jpg">

</div>
<p>随机森林中有2类缺失值，分别为：第一，用于构建随机森林的原始数据集中的数据缺失，就是上面的情况；第二，用于归类的，一个新的样本中的数据缺失情况，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174659.jpg">我们先讲第一种数据的缺失情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174703.jpg">

</div>
<p>我们要从上面的原始数据集中构建随机森林，但是不清楚第4个患者的动脉阻塞与体重数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174707.jpg">

</div>
<p>处理这种缺失数据的常规方式是观察其他数据，先做出一个可能不太好的初始猜测，然后逐步改进这个猜测，直到这个猜测变得比较好为止（希望如此），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174711.jpg">

</div>
<p>现在我们就做这样的猜测，我们先看血管阻塞这个变量，然后找到这个变量出现最多的数据就可做出猜测，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174715.jpg">

</div>
<p>我们发现，在这个变量中，<code>No</code>出现的频率最高（2个No，1个Yes），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174720.jpg">

</div>
<p>因此，我们就可以猜测，在这个变量中，第4个患者的值可能是<code>No</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174724.jpg">

</div>
<p>猜测完血管阻塞这个变量中的缺失值后，我们再猜测一下体重这个变量在第4个患者中的缺失值，体重是一种连续型变量（数值），因此我们可以看一下这个变量中其他数值的中位数即可（在决策树中，这种缺失值的处理，要么使用中位数，要么使用中位数），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174729.jpg">

</div>
<p>在其他的患者中，体重这个变量的中位数是180，因此我们就可以把第4个患者的体重缺失值写为180，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174732.jpg">

</div>
<p>经过这样的处理，原始数据中缺失的数据就填充好了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174736.jpg">

</div>
<p>填充好缺失值后，我们还要评估这些数据猜测得到底合理不合理，现在就需要看一下哪些样本与含有缺失值的样本比较类似，接着我们就会讲一下这种相似性如何计算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174739.jpg">

</div>
<p>第一步：构建随机森林，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174743.jpg">

</div>
<p>第二步：将所有的原始数据放到随机森林中运行，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174747.jpg">

</div>
<p>我们先在随机森林中的第1棵树上运行，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174750.jpg">

</div>
<p>把所有患者的数据依次放进去，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174754.jpg">

</div>
<p>这4个患者的数据经过计算后，我们会发现，患者3和患者4最终位于同一片叶子节点上，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174758.jpg">

</div>
<p>这就说明，第3个患者与第4个患者相似，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174801.jpg">

</div>
<h3 id="相似性矩阵">相似性矩阵</h3>
<p>现在我们用一个相似性矩阵（Proximity Matrix）来研究相似的患者数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174816.jpg">

</div>
<p>相似性矩阵的每行代表一个样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174822.jpg">

</div>
<p>相似性矩阵的每列也代表一个样本，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174825.jpg">

</div>
<p>因为第3个样本与第4个样本最终位于同一个叶子节点上，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174828.jpg">

</div>
<p>我们把患者3和患者4交叉的地方填上1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174833.jpg">

</div>
<p>此外，还有一个交叉点，也填上1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174837.jpg">

</div>
<p>由于在随机森林中第1棵树上运行后，除了第3个患者和第4个患者的最终结果相同外，并没有其他的患者结果相同，因此我们在第1棵树上运行后，得到的相似性矩阵就如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174840.jpg">

</div>
<p>现在我们把所有的数据放到随机森林的第2棵树上运行，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174845.jpg">

</div>
<p>运行过程如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174848.jpg">

</div>
<p>最终我们发现，患者2，患者3和患者4位于同一个叶子节点上，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174852.jpg">

</div>
<p>我们再看一下，经过第1棵树运行后的相似性矩阵如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174857.jpg">

</div>
<p>经过第2棵树的运算，我们把有相同结果的患者交叉处填上1，如果原来的交叉位置有1，就加1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174901.jpg">

</div>
<p>从中我们可以看到，患者3和患者4还是位于同一个叶子节点上，因此就在原有的基础上再加1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174904.jpg">

</div>
<p>患者2和患者3位于同一个节点，患者2和患者4位于同一个节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174908.jpg">

</div>
<p>现在我们把所有的数据放到第3棵树上运行，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174911.jpg">

</div>
<p>得到结果后，我们再更新一下相似性矩阵，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174915.jpg">

</div>
<p>其中我们发现，患者3和患者4还是位于同一个节点上，再加1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174919.jpg">

</div>
<p>最终，我们运行完所有的树，得到一个最终的相似性矩阵，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174922.jpg">

</div>
<p>然后，我们把这个相似性矩阵中的所有值除以所有树的数目，在这个案例中，所有的树的数目是10，得到结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174926.jpg">

</div>
<p>现在我们使用这个近似矩阵来评估一下我们对缺失值猜测的效果如何，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174929.jpg">

</div>
<p>对于动脉阻塞这个变量来说，我们使用这个近似值来计算Yes与No的加权频率，对于体重缺失值的处理，也是如此，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174935.jpg">

</div>
<p>其中动脉阻塞这个变量中，除了缺失值外，在剩下的数据中，Yes的频率是1/3，No的频率是2/3，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174940.jpg">

</div>
<p>那么对Yes的加权频率计算如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174948.jpg">

</div>
<p>患者2中Yes对应的近似值为0.1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174953.jpg">

</div>
<p>然后除以患者4中所有近似值的和，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714174957.jpg">

</div>
<p>Yes的权重是0.1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175005.jpg">

</div>
<p>那么Yes的加权频率就是0.03，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175009.jpg">

</div>
<p>再来计算No的权加频率，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175012.jpg">

</div>
<p>它的公式为：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175017.jpg">

</div>
<p>No的权重是0.9，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175021.jpg">

</div>
<p>最终计算结果是0.6，我们发现，No的加权频率更高，也就是说，我们可以在这个缺失值处填上No，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175026.jpg">

</div>
<p>对于体重缺失值的处理，我们也是采用近似值来计算它的加权平均数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175031.jpg">

</div>
<p>加权平均数的的公式如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175034.jpg">

</div>
<p>第一个样本的加权平均体重是0.1，用125乘以它即可，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175037.jpg">

</div>
<p>接着计算患者2的权加平均数，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175040.jpg">最终计算出加权平均数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175044.jpg">

</div>
<p>此时，把这个结果（也就是198.5）填到缺失值处，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175048.jpg">

</div>
<p>现在我们再重新审视一下我们的猜测，重新再运行一次数据，然后构建一个随机森林，在所有的树中计算数据，重新计算近似值，再次计算缺失值，这个过程要重复6或7次，直接覆盖所有的缺失值（直到我们再次计算时，这个数据不再变化为止），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175055.jpg">

</div>
<h2 id="相似矩阵的拓展">相似矩阵的拓展</h2>
<p>这里我们先看一下相似矩阵的一些很有意思的东西，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175112.jpg">我们再看一下在除以10（随机森林的所有树的数目）之间前的相似矩阵，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175122.jpg">

</div>
<p>如果样本3和样本4最终都落在了所有的10个树的同一个叶子节点上，那么上述的数字8就是10，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175126.jpg">

</div>
<p>我们再除以10（所有树的数目），我们就看到在这个相似矩阵中最大的数值就是1，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175129.jpg">

</div>
<p>在这个近似矩阵中，1意味着这两个样本是尽可能接近的，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175134.jpg">此时，我们用1减去这些近似值，就得到了某个距离，那么样本3和样本4的近似值是1，1减去1，就是0，也就是说这两个样本之间没有距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175137.jpg">

</div>
<p>样本1和样本4之间的的估计值是0.1，用1减去这个数值，得到0.9，那么这就表示，这两个样本的距离很大，也就表示它们之间离得远，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175142.jpg">

</div>
<p>我们把1减去这个近似值矩阵得到的新矩阵称为距离矩阵（distance matrix），画出热图就是下面的这个样子：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175145.jpg">

</div>
<p>我们也可以绘制出MDS图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175148.jpg">

</div>
<p>我们对相似矩阵的这些拓展计算很有意思，因为，无论你的数据是什么形式（有序数据，多个选择，连续型数据），如果我们使用这些数据构建一个树，我们就能画出热图或者是MDS图，用于研究不同样本的之间的相似性，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175152.jpg">

</div>
<h2 id="第二种缺失值的处理">第二种缺失值的处理</h2>
<p>此时，再回到缺失值的处理上来，前面我们只是介绍了一种缺失值的处理，也就是用于构建随机森林的原始数据中的缺失值处理，现在我们介绍一下另外一种缺失值的处理，也就是我们想用于分类的新的样本中的缺失值处理，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175205.jpg">

</div>
<p>试想，我们已经通过现有的数据构建了一个随机森林，此时我们要将下面的的这个患者进行分类，不过他的一个动脉阻塞参数是缺失的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175210.jpg">

</div>
<p>但我们还是想要知道这个患者是否患有心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175214.jpg">

</div>
<p>但我们不知道动脉阻塞这个参数，因此我们需要对这个参数进行一个猜测，其过程就是把这个患者的其他参数放到随机森林中运行，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175217.jpg">

</div>
<p>第一步：我们先猜测这个患者得了心脏病与不得心脏病这两种情况，做出两份数据，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175222.jpg">

</div>
<p>然后我们使用先前提到的迭代方法来对这动脉阻塞这个参数进行猜测，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175226.jpg">

</div>
<p>猜测结果一个是Yes，一个是No，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175230.jpg">

</div>
<p>然后把这两个数据放到随机森林中运算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175235.jpg">

</div>
<p>然后我们观察这两个数据在随机森林中的运行结果，看一下哪个结果数目最多，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175238.jpg">

</div>
<p>在第一个数据中，所有的3个树都标记了其为Yes，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175242.jpg">

</div>
<p>在第二个数据中，只有一个树正确地标记了No，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175247.jpg">

</div>
<p>因此第一个数据是正确的数据，因为所有的树中它被正确计算的次数最多，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175250.jpg">

</div>
<h2 id="r语言与随机森林">R语言与随机森林</h2>
<h3 id="加载包">加载包</h3>
<p>在使用R语言构建随机森林的时候，需要使用如下三个包：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(ggplot2)</div><div class="line"><span class="keyword">library</span>(cowplot)</div><div class="line"><span class="keyword">library</span>(randomForest)</div></pre></td></tr></table></figure>
<h3 id="数据集的处理">数据集的处理</h3>
<p>原始数据使用UCI机器学习的数据，这里的数据很多，我们只用其中的心脏病方面的一个数据集，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175307.jpg">

</div>
<p>代码如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">url &lt;- <span class="string">"http://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data"</span></div><div class="line">data &lt;- read.csv(url, header=<span class="literal">FALSE</span>)</div><div class="line">head(data)</div></pre></td></tr></table></figure>
<p>数据如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(data)</div><div class="line">  V1 V2 V3  V4  V5 V6 V7  V8 V9 V10 V11 V12 V13 V14</div><div class="line"><span class="number">1</span> <span class="number">63</span>  <span class="number">1</span>  <span class="number">1</span> <span class="number">145</span> <span class="number">233</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">150</span>  <span class="number">0</span> <span class="number">2.3</span>   <span class="number">3</span> <span class="number">0.0</span> <span class="number">6.0</span>   <span class="number">0</span></div><div class="line"><span class="number">2</span> <span class="number">67</span>  <span class="number">1</span>  <span class="number">4</span> <span class="number">160</span> <span class="number">286</span>  <span class="number">0</span>  <span class="number">2</span> <span class="number">108</span>  <span class="number">1</span> <span class="number">1.5</span>   <span class="number">2</span> <span class="number">3.0</span> <span class="number">3.0</span>   <span class="number">2</span></div><div class="line"><span class="number">3</span> <span class="number">67</span>  <span class="number">1</span>  <span class="number">4</span> <span class="number">120</span> <span class="number">229</span>  <span class="number">0</span>  <span class="number">2</span> <span class="number">129</span>  <span class="number">1</span> <span class="number">2.6</span>   <span class="number">2</span> <span class="number">2.0</span> <span class="number">7.0</span>   <span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="number">37</span>  <span class="number">1</span>  <span class="number">3</span> <span class="number">130</span> <span class="number">250</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">187</span>  <span class="number">0</span> <span class="number">3.5</span>   <span class="number">3</span> <span class="number">0.0</span> <span class="number">3.0</span>   <span class="number">0</span></div><div class="line"><span class="number">5</span> <span class="number">41</span>  <span class="number">0</span>  <span class="number">2</span> <span class="number">130</span> <span class="number">204</span>  <span class="number">0</span>  <span class="number">2</span> <span class="number">172</span>  <span class="number">0</span> <span class="number">1.4</span>   <span class="number">1</span> <span class="number">0.0</span> <span class="number">3.0</span>   <span class="number">0</span></div><div class="line"><span class="number">6</span> <span class="number">56</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">120</span> <span class="number">236</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">178</span>  <span class="number">0</span> <span class="number">0.8</span>   <span class="number">1</span> <span class="number">0.0</span> <span class="number">3.0</span>   <span class="number">0</span></div></pre></td></tr></table></figure>
<p>从数据中我们可以发现，第一行对于每个变量的命名并不是特别的规范，因此，根据网站提供的信息，我们把这些变量名改一下，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">colnames(data) &lt;- c(</div><div class="line">  <span class="string">"age"</span>,</div><div class="line">  <span class="string">"sex"</span>,</div><div class="line">  <span class="string">"cp"</span>,</div><div class="line">  <span class="string">"trestbps"</span>,</div><div class="line">  <span class="string">"chol"</span>,</div><div class="line">  <span class="string">"fbs"</span>,</div><div class="line">  <span class="string">"restecg"</span>,</div><div class="line">  <span class="string">"thalach"</span>,</div><div class="line">  <span class="string">"exang"</span>,</div><div class="line">  <span class="string">"oldpeak"</span>,</div><div class="line">  <span class="string">"slope"</span>,</div><div class="line">  <span class="string">"ca"</span>,</div><div class="line">  <span class="string">"thal"</span>,</div><div class="line">  <span class="string">"hd"</span></div><div class="line">)</div><div class="line">head(data)</div></pre></td></tr></table></figure>
<p>更改后的结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(data)</div><div class="line">  age sex cp trestbps chol fbs restecg thalach exang oldpeak slope  ca thal hd</div><div class="line"><span class="number">1</span>  <span class="number">63</span>   <span class="number">1</span>  <span class="number">1</span>      <span class="number">145</span>  <span class="number">233</span>   <span class="number">1</span>       <span class="number">2</span>     <span class="number">150</span>     <span class="number">0</span>     <span class="number">2.3</span>     <span class="number">3</span> <span class="number">0.0</span>  <span class="number">6.0</span>  <span class="number">0</span></div><div class="line"><span class="number">2</span>  <span class="number">67</span>   <span class="number">1</span>  <span class="number">4</span>      <span class="number">160</span>  <span class="number">286</span>   <span class="number">0</span>       <span class="number">2</span>     <span class="number">108</span>     <span class="number">1</span>     <span class="number">1.5</span>     <span class="number">2</span> <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">2</span></div><div class="line"><span class="number">3</span>  <span class="number">67</span>   <span class="number">1</span>  <span class="number">4</span>      <span class="number">120</span>  <span class="number">229</span>   <span class="number">0</span>       <span class="number">2</span>     <span class="number">129</span>     <span class="number">1</span>     <span class="number">2.6</span>     <span class="number">2</span> <span class="number">2.0</span>  <span class="number">7.0</span>  <span class="number">1</span></div><div class="line"><span class="number">4</span>  <span class="number">37</span>   <span class="number">1</span>  <span class="number">3</span>      <span class="number">130</span>  <span class="number">250</span>   <span class="number">0</span>       <span class="number">0</span>     <span class="number">187</span>     <span class="number">0</span>     <span class="number">3.5</span>     <span class="number">3</span> <span class="number">0.0</span>  <span class="number">3.0</span>  <span class="number">0</span></div><div class="line"><span class="number">5</span>  <span class="number">41</span>   <span class="number">0</span>  <span class="number">2</span>      <span class="number">130</span>  <span class="number">204</span>   <span class="number">0</span>       <span class="number">2</span>     <span class="number">172</span>     <span class="number">0</span>     <span class="number">1.4</span>     <span class="number">1</span> <span class="number">0.0</span>  <span class="number">3.0</span>  <span class="number">0</span></div><div class="line"><span class="number">6</span>  <span class="number">56</span>   <span class="number">1</span>  <span class="number">2</span>      <span class="number">120</span>  <span class="number">236</span>   <span class="number">0</span>       <span class="number">0</span>     <span class="number">178</span>     <span class="number">0</span>     <span class="number">0.8</span>     <span class="number">1</span> <span class="number">0.0</span>  <span class="number">3.0</span>  <span class="number">0</span></div></pre></td></tr></table></figure>
<p>查看一下数据结构，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; str(data)</div><div class="line"><span class="string">'data.frame'</span>:	<span class="number">303</span> obs. of  <span class="number">14</span> variables:</div><div class="line"> $ age     : num  <span class="number">63</span> <span class="number">67</span> <span class="number">67</span> <span class="number">37</span> <span class="number">41</span> <span class="number">56</span> <span class="number">62</span> <span class="number">57</span> <span class="number">63</span> <span class="number">53</span> <span class="keyword">...</span></div><div class="line"> $ sex     : num  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ cp      : num  <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="keyword">...</span></div><div class="line"> $ trestbps: num  <span class="number">145</span> <span class="number">160</span> <span class="number">120</span> <span class="number">130</span> <span class="number">130</span> <span class="number">120</span> <span class="number">140</span> <span class="number">120</span> <span class="number">130</span> <span class="number">140</span> <span class="keyword">...</span></div><div class="line"> $ chol    : num  <span class="number">233</span> <span class="number">286</span> <span class="number">229</span> <span class="number">250</span> <span class="number">204</span> <span class="number">236</span> <span class="number">268</span> <span class="number">354</span> <span class="number">254</span> <span class="number">203</span> <span class="keyword">...</span></div><div class="line"> $ fbs     : num  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ restecg : num  <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ thalach : num  <span class="number">150</span> <span class="number">108</span> <span class="number">129</span> <span class="number">187</span> <span class="number">172</span> <span class="number">178</span> <span class="number">160</span> <span class="number">163</span> <span class="number">147</span> <span class="number">155</span> <span class="keyword">...</span></div><div class="line"> $ exang   : num  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ oldpeak : num  <span class="number">2.3</span> <span class="number">1.5</span> <span class="number">2.6</span> <span class="number">3.5</span> <span class="number">1.4</span> <span class="number">0.8</span> <span class="number">3.6</span> <span class="number">0.6</span> <span class="number">1.4</span> <span class="number">3.1</span> <span class="keyword">...</span></div><div class="line"> $ slope   : num  <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="keyword">...</span></div><div class="line"> $ ca      : Factor w/ <span class="number">5</span> levels <span class="string">"?"</span>,<span class="string">"0.0"</span>,<span class="string">"1.0"</span>,..: <span class="number">2</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ thal    : Factor w/ <span class="number">4</span> levels <span class="string">"?"</span>,<span class="string">"3.0"</span>,<span class="string">"6.0"</span>,..: <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="keyword">...</span></div><div class="line"> $ hd      : int  <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="keyword">...</span></div></pre></td></tr></table></figure>
<p>现在解释一下各个变量：</p>
<p><code>sex</code>是性别，其中0表示女性，1表示男性，在分析时，需要把<code>sex</code>这个变量根据1或0更改为M或F。</p>
<p><code>cp</code>是<code>chest pain</code>的缩写，其数值是1-3，这个范围表示不同类型的胸痛，4表示没有胸痛。</p>
<p><code>ca</code>与<code>thal</code>是因子数据类型，我们看到，其中有的数值是<code>?</code>，这个是不符合规范的，因此后面我们会把它改为<code>NA。</code></p>
<p>此外，还要把其它的变量更改为因子类型，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">data[data == <span class="string">"?"</span>] &lt;- <span class="literal">NA</span></div><div class="line">data[data$sex == <span class="number">0</span>,]$sex &lt;- <span class="string">"F"</span></div><div class="line">data[data$sex == <span class="number">1</span>,]$sex &lt;- <span class="string">"M"</span></div><div class="line">data$sex &lt;- as.factor(data$sex)</div><div class="line">data$cp &lt;- as.factor(data$cp)</div><div class="line">data$fbs &lt;- as.factor(data$fbs)</div><div class="line">data$restecg &lt;- as.factor(data$restecg)</div><div class="line">data$exang &lt;- as.factor(data$exang)</div><div class="line">data$slope &lt;- as.factor(data$slope)</div><div class="line">data$ca &lt;- as.integer(data$ca)</div><div class="line">data$ca &lt;- as.factor(data$ca)</div><div class="line">data$thal &lt;- as.factor(data$thal)</div><div class="line">data$hd &lt;- ifelse(test=data$hd == <span class="number">0</span>, yes = <span class="string">"Healthy"</span>, no=<span class="string">"Unhealthy"</span>)</div><div class="line">data$hd &lt;- as.factor(data$hd)</div></pre></td></tr></table></figure>
<p>查看一下数据类型，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; str(data)</div><div class="line"><span class="string">'data.frame'</span>:	<span class="number">303</span> obs. of  <span class="number">14</span> variables:</div><div class="line"> $ age     : num  <span class="number">63</span> <span class="number">67</span> <span class="number">67</span> <span class="number">37</span> <span class="number">41</span> <span class="number">56</span> <span class="number">62</span> <span class="number">57</span> <span class="number">63</span> <span class="number">53</span> <span class="keyword">...</span></div><div class="line"> $ sex     : Factor w/ <span class="number">2</span> levels <span class="string">"F"</span>,<span class="string">"M"</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ cp      : Factor w/ <span class="number">4</span> levels <span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>: <span class="number">1</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="keyword">...</span></div><div class="line"> $ trestbps: num  <span class="number">145</span> <span class="number">160</span> <span class="number">120</span> <span class="number">130</span> <span class="number">130</span> <span class="number">120</span> <span class="number">140</span> <span class="number">120</span> <span class="number">130</span> <span class="number">140</span> <span class="keyword">...</span></div><div class="line"> $ chol    : num  <span class="number">233</span> <span class="number">286</span> <span class="number">229</span> <span class="number">250</span> <span class="number">204</span> <span class="number">236</span> <span class="number">268</span> <span class="number">354</span> <span class="number">254</span> <span class="number">203</span> <span class="keyword">...</span></div><div class="line"> $ fbs     : Factor w/ <span class="number">2</span> levels <span class="string">"0"</span>,<span class="string">"1"</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ restecg : Factor w/ <span class="number">3</span> levels <span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>: <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="keyword">...</span></div><div class="line"> $ thalach : num  <span class="number">150</span> <span class="number">108</span> <span class="number">129</span> <span class="number">187</span> <span class="number">172</span> <span class="number">178</span> <span class="number">160</span> <span class="number">163</span> <span class="number">147</span> <span class="number">155</span> <span class="keyword">...</span></div><div class="line"> $ exang   : Factor w/ <span class="number">2</span> levels <span class="string">"0"</span>,<span class="string">"1"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="keyword">...</span></div><div class="line"> $ oldpeak : num  <span class="number">2.3</span> <span class="number">1.5</span> <span class="number">2.6</span> <span class="number">3.5</span> <span class="number">1.4</span> <span class="number">0.8</span> <span class="number">3.6</span> <span class="number">0.6</span> <span class="number">1.4</span> <span class="number">3.1</span> <span class="keyword">...</span></div><div class="line"> $ slope   : Factor w/ <span class="number">3</span> levels <span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>: <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="keyword">...</span></div><div class="line"> $ ca      : Factor w/ <span class="number">4</span> levels <span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>: <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="keyword">...</span></div><div class="line"> $ thal    : Factor w/ <span class="number">4</span> levels <span class="string">"?"</span>,<span class="string">"3.0"</span>,<span class="string">"6.0"</span>,..: <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="keyword">...</span></div><div class="line"> $ hd      : Factor w/ <span class="number">2</span> levels <span class="string">"Healthy"</span>,<span class="string">"Unhealthy"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="keyword">...</span></div></pre></td></tr></table></figure>
<h3 id="补充缺失值">补充缺失值</h3>
<p>由于我们要生成随机森林，此时我们设一个种子，用于生成随机数，这样我们可以重复我们的计算结果，在构建随机森林之间，由于我们的数据集中的缺失值，此时要对缺失值进行补充，补充缺失值使用的是<code>rfImpute()</code>函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set.seed(<span class="number">42</span>)</div><div class="line">data.imputed &lt;- rfImpute(hd ~.,data=data,iter=<span class="number">6</span>)</div></pre></td></tr></table></figure>
<p><code>hd~.</code>是第1个参数，它表示，我们使用hd（heart disease）这一列作为最终的预测，也就是说拿一个患者的数据，预测患者是否得有心脏病。</p>
<p><code>data = data</code>这个表示，我们使用<code>data</code>这个数据集来构建随机森林。</p>
<p><code>iter=6</code>用来指定迭代多少次来评估缺失值，从理论上讲，这个值是4到6就足够了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175318.jpg">

</div>
<p>运行结果如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; data.imputed &lt;- rfImpute(hd ~.,data=data,iter=<span class="number">6</span>)</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">17.49</span>% <span class="number">12.80</span>% <span class="number">23.02</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">16.83</span>% <span class="number">14.02</span>% <span class="number">20.14</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">17.82</span>% <span class="number">13.41</span>% <span class="number">23.02</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">17.49</span>% <span class="number">14.02</span>% <span class="number">21.58</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">17.16</span>% <span class="number">12.80</span>% <span class="number">22.30</span>%</div><div class="line">ntree      OOB      <span class="number">1</span>      <span class="number">2</span></div><div class="line">  <span class="number">300</span>:  <span class="number">18.15</span>% <span class="number">14.63</span>% <span class="number">22.30</span>%</div></pre></td></tr></table></figure>
<p>经过每次迭代，<code>rflmpute()</code>就会在第2列输出出袋错误率（OOB，即Out-of-Bag），如果估计值在不断地改善，那么这个值就会不断地变小，但在这个结果中，我们发现这个值并没有不断地变小，那么我们就可以认为，我们利用此函数得到的估计值可以满足计算，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175327.jpg">

</div>
<h3 id="构建随机森林-1">构建随机森林</h3>
<p>接着，我们使用<code>randomForest()</code>函数来构建随机森林，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">model &lt;- randomForest(hd ~., data=data.imputed, proximity= <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>在这些参数中，第1个参数不用解释，跟前面的一样，第2个参数<code>data.imputed</code>是填充了估计值后的数据集，第3个参数是<code>proximity = TRUE</code>，它表示要返回相似矩阵，最终我们可以使用这个数据来进行聚类。</p>
<p>现在我们看一下结果，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; model</div><div class="line"></div><div class="line">Call:</div><div class="line"> randomForest(formula = hd ~ ., data = data.imputed, proximity = <span class="literal">TRUE</span>) </div><div class="line">               Type of random forest: classification</div><div class="line">                     Number of trees: <span class="number">500</span></div><div class="line">No. of variables tried at each split: <span class="number">3</span></div><div class="line"></div><div class="line">        OOB estimate of  error rate: <span class="number">16.83</span>%</div><div class="line">Confusion matrix:</div><div class="line">          Healthy Unhealthy class.error</div><div class="line">Healthy       <span class="number">142</span>        <span class="number">22</span>   <span class="number">0.1341463</span></div><div class="line">Unhealthy      <span class="number">29</span>       <span class="number">110</span>   <span class="number">0.2086331</span></div></pre></td></tr></table></figure>
<p>现在说明一下这个结果，先看第一部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Call:</div><div class="line"> randomForest(formula = hd ~ ., data = data.imputed, proximity = <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>这一部分是构建随机森林的一些参数。</p>
<p>再看第二部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Type of random forest: classification</div></pre></td></tr></table></figure>
<p>这一部分的意思是讲，我们构建随机森林的类型是分类（classification），如果我们使用随机森林来预测体重或身高这种连续型变量，那么这个就是回归（regression），如果我们忽略随机森林要预测的某个变量（我的理解就是，即不预测分类，也就是说不预测心脏病，也不预测回归，也就是说不预测体重或身高），那么这里就是无监督（unsupervised），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175334.jpg">

</div>
<p>再看下一部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Number of trees: <span class="number">500</span></div></pre></td></tr></table></figure>
<p>这里是说，随机森林中有多少棵树，默认的数字是500，随后我们会看一下500棵树能否做出一个很好的分类。</p>
<p>再看下一部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No. of variables tried at each split: <span class="number">3</span></div></pre></td></tr></table></figure>
<p>这一段文字是说，在每个内部节点上，使用的变量（也就是列）的数目，用于分类的随机森林默认使用变量数目的平方根进行计算，例如在这个案例中，变量的数目是13（不包括hd这个变量），那么13的平方根就是3.6，取整数（这里不是四舍五入），就是3，至于这个3是不是最好的数值，我们随后会进行调整，如果是用于回归的随机森林，那么这个数字就是变量的数目除以3，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175339.jpg">

</div>
<p>再看下一部分，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OOB estimate of  error rate: <span class="number">16.83</span>%</div></pre></td></tr></table></figure>
<p>这一部分是出袋错误率（OOB，即Out-of-Bag），这表明，这个随机森林能够将83.5%的OOB样本正确地归类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175343.jpg">

</div>
<p>最后一部分是混淆矩阵（confusion matrix），如下所示（可能与教程中的有些出入，但整体相差不大）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Confusion matrix:</div><div class="line">          Healthy Unhealthy class.error</div><div class="line">Healthy       <span class="number">142</span>        <span class="number">22</span>   <span class="number">0.1341463</span></div><div class="line">Unhealthy      <span class="number">29</span>       <span class="number">110</span>   <span class="number">0.2086331</span></div></pre></td></tr></table></figure>
<p>混淆矩阵是总结分类模型预测结果的情形分析表，它以矩阵形式将数据集中的记录按照真实的类别与分类模型作出的分类判断两个标准进行汇总，那么，在上面的这个矩阵中，我们可以看到：</p>
<ol style="list-style-type: decimal">
<li>有142名健康的病人被正确地标记为“健康”；</li>
<li>有29名健康的病人被错误地标记为“健康”；</li>
<li>有22名健康的病人被错误地标记为“不健康”；</li>
<li>有110名不健康的病人被正确地标记为“不健康”。</li>
</ol>
<h3 id="绘制错误率图">绘制错误率图</h3>
<p>此时，我们看一下，500棵树能否做出一个良好的分类，我们先画出错误率，绘图使用的是ggplot2包，因此要构建一个数据框用于ggplot2的识别，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">oob.error.data &lt;- data.frame(</div><div class="line">  Trees=rep(<span class="number">1</span>:nrow(model$err.rate),times=<span class="number">3</span>),</div><div class="line">  Type=rep(c(<span class="string">"OOB"</span>,<span class="string">"Healthy"</span>,<span class="string">"Unhealthy"</span>),each=nrow(model$err.rate)),</div><div class="line">  Error=c(model$err.rate[,<span class="string">"OOB"</span>],</div><div class="line">          model$err.rate[,<span class="string">"Healthy"</span>],</div><div class="line">          model$err.rate[,<span class="string">"Unhealthy"</span>]))</div></pre></td></tr></table></figure>
<p>这段代码有点复杂，现在解释一下：</p>
<ol style="list-style-type: decimal">
<li>这段代码的大部分都是基于<code>model</code>这个数据中的<code>err.rate</code>来构建的，我们查看下这个数据，如下所示：</li>
</ol>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; head(model$err.rate)</div><div class="line">           OOB   Healthy Unhealthy</div><div class="line">[<span class="number">1</span>,] <span class="number">0.2571429</span> <span class="number">0.2765957</span> <span class="number">0.2413793</span></div><div class="line">[<span class="number">2</span>,] <span class="number">0.2470588</span> <span class="number">0.2068966</span> <span class="number">0.2891566</span></div><div class="line">[<span class="number">3</span>,] <span class="number">0.2783019</span> <span class="number">0.2758621</span> <span class="number">0.2812500</span></div><div class="line">[<span class="number">4</span>,] <span class="number">0.2704918</span> <span class="number">0.2647059</span> <span class="number">0.2777778</span></div><div class="line">[<span class="number">5</span>,] <span class="number">0.2592593</span> <span class="number">0.2600000</span> <span class="number">0.2583333</span></div><div class="line">[<span class="number">6</span>,] <span class="number">0.2597865</span> <span class="number">0.2467532</span> <span class="number">0.2755906</span></div><div class="line">&gt; tail(model$err.rate)</div><div class="line">             OOB   Healthy Unhealthy</div><div class="line">[<span class="number">495</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">496</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">497</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">498</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">499</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div><div class="line">[<span class="number">500</span>,] <span class="number">0.1683168</span> <span class="number">0.1341463</span> <span class="number">0.2086331</span></div></pre></td></tr></table></figure>
<p>其中第1列是OOB错误率，第2列是健康患者错误率（就是说有多大的可能性会把健康患者错误分类），第3列是不健康患者错误率（就是说有多大的可能性会把不健康患者错误分类）。</p>
<p>每1行表示的是，在构建随机森林的不同阶段的的错误率，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175350.jpg">

</div>
<p>其中，第1行表示构建了第1棵树后的错误率，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175350.jpg">

</div>
<p>第2行表示，构建了前2棵树后的错误率，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175354.jpg">

</div>
<p>那么最后1行则表示，已经构建了随机森林中500棵树后的错误率，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175359.jpg">

</div>
<p>因此，使用上述代码，我们最终生成的数据框则是下面的这个样本，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; head(oob.error.data)</div><div class="line">  Trees Type     Error</div><div class="line"><span class="number">1</span>     <span class="number">1</span>  OOB <span class="number">0.2571429</span></div><div class="line"><span class="number">2</span>     <span class="number">2</span>  OOB <span class="number">0.2470588</span></div><div class="line"><span class="number">3</span>     <span class="number">3</span>  OOB <span class="number">0.2783019</span></div><div class="line"><span class="number">4</span>     <span class="number">4</span>  OOB <span class="number">0.2704918</span></div><div class="line"><span class="number">5</span>     <span class="number">5</span>  OOB <span class="number">0.2592593</span></div><div class="line"><span class="number">6</span>     <span class="number">6</span>  OOB <span class="number">0.2597865</span></div></pre></td></tr></table></figure>
<p>第1列数字则表示的是随机森林中树的数目，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175402.jpg">

</div>
<p>第2列则是错误类型，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175407.png">

</div>
<p>再看一下其他的：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175538.png">

</div>
<p>最后1列是错误的实际数值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175529.png">

</div>
<p>调用ggplot函数，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ggplot(data=oob.error.data,aes(x=Trees,y=Error)) +</div><div class="line">  geom_line(aes(color=Type))</div></pre></td></tr></table></figure>
<p>绘图结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175523.png">

</div>
<p>其中蓝线是对不健康患者进行归类时的错误率，绿线是总的OOB错误率，红线是对健康患者进行归类时的错误率。通常我们发现，随着随机森林中的树越来越多，错误率是逐步下降的，如下所示</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175519.jpg">

</div>
<h3 id="各项参数调整">各项参数调整</h3>
<h4 id="添加树的数目">添加树的数目</h4>
<p>我们试想一下，如果我们增加更多的树，错误率会不会更低，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175514.jpg">

</div>
<p>此时，我们将树的数目设为1000，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">model &lt;- randomForest(hd ~., data=data.imputed, ntree = <span class="number">1000</span>, proximity= <span class="literal">TRUE</span>)</div></pre></td></tr></table></figure>
<p>这里我们需要注意一下，前面我们并没有使用<code>ntree=1000</code>这个参数，这是因为<code>randomForest</code>默认的<code>ntree=500</code>，因此这个参数如果使用默认值，就可以不添加，如果要改变这个数字，就需要更改，现在看一下结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Call:</div><div class="line"> randomForest(formula = hd ~ ., data = data.imputed, ntree = <span class="number">1000</span>,      proximity = <span class="literal">TRUE</span>) </div><div class="line">               Type of random forest: classification</div><div class="line">                     Number of trees: <span class="number">1000</span></div><div class="line">No. of variables tried at each split: <span class="number">3</span></div><div class="line"></div><div class="line">        OOB estimate of  error rate: <span class="number">16.5</span>%</div><div class="line">Confusion matrix:</div><div class="line">          Healthy Unhealthy class.error</div><div class="line">Healthy       <span class="number">142</span>        <span class="number">22</span>   <span class="number">0.1341463</span></div><div class="line">Unhealthy      <span class="number">28</span>       <span class="number">111</span>   <span class="number">0.2014388</span></div></pre></td></tr></table></figure>
<p>看一下<code>OOB estimate of  error rate: 16.5%</code>这一行，它的OOB值是16.5%，而当<code>ntree=500</code>时，这个数值是16.83%，基本上两者是相同的，我们再看一下<code>ntree=500</code>时的混淆矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Confusion matrix:</div><div class="line">          Healthy Unhealthy class.error</div><div class="line">Healthy       <span class="number">142</span>        <span class="number">22</span>   <span class="number">0.1341463</span></div><div class="line">Unhealthy      <span class="number">29</span>       <span class="number">110</span>   <span class="number">0.2086331</span></div></pre></td></tr></table></figure>
<p>这两者的数值也差不多，再看一下绘图结果，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175507.png">

</div>
<p>从这个绘图结果来看，当树的数目超过500后，错误率基本上就稳定了，因此我们添加再多的树，意义不大，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175504.jpg">

</div>
<h4 id="更改节点变量数目">更改节点变量数目</h4>
<p>现在我们再来看一下构建原来内部节点时使用的变量数目，原来使用的是3，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175459.jpg">

</div>
<p>现在我们改一下这个数字，此时我们需要一个空向量，它所含元素的数目是10，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">oob.values &lt;- vector(length = <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>然后再使用一个循环，用于测试构建每个内部节点的不同变量数目，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175450.jpg">

</div>
<p>代码为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>)&#123;</div><div class="line">  temp.model &lt;- randomForest(hd ~ .,data=data.imputed, mtry=i,ntree=<span class="number">1000</span>)</div><div class="line">  oob.values[i] &lt;- temp.model$err.rate[nrow(temp.model$err.rate),<span class="number">1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看一下输出结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">oob.values</div><div class="line">[<span class="number">1</span>] <span class="number">0.1650165</span> <span class="number">0.1716172</span> <span class="number">0.1650165</span> <span class="number">0.1815182</span> <span class="number">0.1848185</span> <span class="number">0.1815182</span> <span class="number">0.1848185</span> <span class="number">0.1914191</span></div><div class="line">[<span class="number">9</span>] <span class="number">0.1881188</span> <span class="number">0.1881188</span></div></pre></td></tr></table></figure>
<p>其中第3个数值对应的就是<code>mtry=3</code>，它是构建随机森林的默认数字，从中我们可以发现，这个数字基本上是最小的（0.1716172），也就是说它有最低的OOB错误率，因此，默认数值已经是最好的数值了，不过，如果我们不知道最优的数值，那么就要尝试一下其他的数值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175444.jpg">

</div>
<h3 id="绘制随机森林的mds图">绘制随机森林的MDS图</h3>
<p>最后，我们绘制一下随机森林的MDS图，首先利用<code>dist()</code>函数从<code>1- 相似矩</code>中构建一个距离矩阵，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">distance.matrix &lt;- dist(<span class="number">1</span>-model$proximity)</div></pre></td></tr></table></figure>
<p>然后使用缩放函数<code>cmdscale</code>，再计算距离矩阵的x轴与y轴的占总变异的百分比，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mds.stuff &lt;- cmdscale(distance.matrix,eig=<span class="literal">TRUE</span>,x.ret=<span class="literal">TRUE</span>)</div><div class="line">mds.var.per &lt;- round(mds.stuff$eig/sum(mds.stuff$eig)*<span class="number">100</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>构建ggplot绘图的数据集并绘图，如下所示：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mds.values &lt;- mds.stuff$points</div><div class="line">mds.data &lt;- data.frame(Sample = rownames(mds.values),</div><div class="line">                       X=mds.values[,<span class="number">1</span>],</div><div class="line">                       Y=mds.values[,<span class="number">2</span>],</div><div class="line">                       Status=data.imputed$hd)</div><div class="line"></div><div class="line">ggplot(data=mds.data, aes(x=X, y=Y, label=Sample)) +</div><div class="line">  geom_text(aes(color=Status)) +</div><div class="line">  theme_bw()+</div><div class="line">  xlab(paste(<span class="string">"MDS1 - "</span>, mds.var.per[<span class="number">1</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>)) +</div><div class="line">  ylab(paste(<span class="string">"MDS2 - "</span>, mds.var.per[<span class="number">2</span>], <span class="string">"%"</span>, sep=<span class="string">""</span>)) +</div><div class="line">  ggtitle(<span class="string">"MDS plot using(1 - Random Forest Proximities)"</span>)</div></pre></td></tr></table></figure>
<p>最终绘图结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175438.png">

</div>
<p>从图上我们可以得到如下信息：</p>
<ol style="list-style-type: decimal">
<li>不健康的患者位于左侧，健康的患者位于右侧；</li>
<li>但在左侧，有几个患者被错误归类了（绿色中的红色文字）；</li>
<li>我们再看一下x轴，可以发现，MDS1占了总变异的47.7%，y轴上是MDS2，它占据了总异的14.2%；</li>
<li>整个图形呈一个V型（教程中是倒V型，我不太理解为什么我绘图出来是反的），它的开口是朝上x轴的相反方向的，这表明，在V型的两臂上，两个样本相离得越远，他们之间的差异就越大；</li>
<li>如果我们拿到一个新的患者的数据，在不知道他是否得了心脏病的情况下，如果经计算，他被归类到V型的左臂，那么我们就可以得到一个肯定的结论，他得了心脏病，如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714175434.jpg">

</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/07/01/StatQuest/生物统计-StatQuest学习笔记19-决策树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/StatQuest/生物统计-StatQuest学习笔记19-决策树/" itemprop="url">StatQuest学习笔记19——决策树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T12:10:54+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,307
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>本篇笔记是StatQuet系列视频教程的第50节和第51节，主要内容是决策树（decision tree）。其中第50节的内容是决策木树的基本思想，第51节的内容是在构建决策树中，缺失值的处理。</p>
<h2 id="决策树简单案例1">决策树简单案例1</h2>
<p>先看一下简单的决策树案例，在这个案例中，我们提出一个问题，也就是问某人，“请问，你喜欢StatQuest的主题曲吗”。回答者会回答“Yes”或“No”，根据回答者的这个回答，我们可以把回答者分为两类，如果回答Yes，则就是下面的情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172610.jpg">

</div>
<p>如果回答No，那么就是下面的这种情况：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172615.jpg">

</div>
<p>在一个常规的决策树中，通常会问一个问题，然后根据回答者的回答（就是Yes或No），就把他们进行分类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172619.jpg">

</div>
<p>同样的，我们还可以根据一些数据来构建决策树，例如根据人的静息心率（resting heart rate）是否大于100bpm，那么就可以对他们进行分类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172624.jpg">

</div>
<p>如果一个人的静息心率大于100bpm，那么就是说他的静息心率比较高，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172628.jpg">

</div>
<p>那么他就需要去看医生，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172632.jpg">

</div>
<p>如果一个人的静息心率并不高，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172636.jpg">

</div>
<p>那么这个人就属于比较健康的状态了，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172641.jpg">

</div>
<h2 id="决策树简单案例2">决策树简单案例2</h2>
<p>再来看一个决策树的简单案例。在这个案例中，决策树的构建的依据是一个分级数据（ranked data），其中数据<code>Appetite rank =1</code>表示<code>非常饿</code>，<code>Appetite rank = 2</code>表示<code>一般饿</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172701.jpg">

</div>
<p>如果一个人非常饿（<code>Appetite rank = 1</code>）时，那么他就需要吃东西，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172705.jpg">

</div>
<p>如果这个人只是处于一般饿的状态（<code>Appetite rank = 2</code>），那么他只需要只一点东西即可，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172710.jpg">

</div>
<p>如果这个人不是特别的饿，那么他也可以不吃东西，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172715.jpg">

</div>
<p>需要注意的是，决策树中的分类可以是一些二分类变量，如下图左侧所示，也可以是一些连续型变量（数值型变量），如下图右侧所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172718.jpg">

</div>
<p>例如，上图的右侧，我们使用小鼠的体重来预测小鼠的大小（size），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172722.jpg">

</div>
<h2 id="复杂案例">复杂案例</h2>
<p>我们再看一个比较复杂的决策树案例，在这个决策树中，它混合了连续型变量和二分类变量，下图是决策树中的连续型变量，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172736.jpg">

</div>
<p>接着是二分类变量，它使用的yes/no来进行区分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172740.jpg">

</div>
<p>在这个决策树中，我们需要注意的是，静息心率的阈值并非都是相同的，例如在左侧，它的阈值是100bpm，而在右侧，它的阈值是120bpm，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172744.jpg">

</div>
<p>在决策树中，问题的顺序也可以不一样，例如在左侧，第一个问题是静息心率，然后为是否吃甜甜圈（doughnut），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172748.jpg">

</div>
<p>而在右侧，第一个问题则为是否吃甜甜圈，然后是静息心率，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172754.jpg">

</div>
<p>最后的归类可以是一样的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172758.jpg">

</div>
<p>还有两个相同的分支，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172805.jpg">

</div>
<p>对于大多数的决策树来说，它们都很直观，从顶层开始，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172808.jpg">

</div>
<p>接着进入下一层，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172812.jpg">再下一层，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172816.jpg">

</div>
<p>一直到最底层为止，此时就对一个样本进行了分类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172822.jpg">

</div>
<h2 id="决策树术语">决策树术语</h2>
<p>我们来看一下决策树的相关术语，我们把树最顶层的部分称为<code>根结点（Root Node</code>）或直接称为<code>根（The root）</code>。如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172838.jpg">

</div>
<p>把根节点以下最底层之间的部分称为<code>内部节点（Internal Nodes）</code>或<code>节点（Nodes）</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172843.jpg">

</div>
<p>内部节点通过箭头指向下一级的内部节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172846.jpg">

</div>
<p>或者是指离（point away）下一层的内部节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172850.jpg">

</div>
<p>那些终点（也就是没有下一层的节点）被称为<code>叶子节点（Leaf Nodes）</code>或<code>叶子（Leaves）</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172854.jpg">

</div>
<p>内部节点的箭头指向叶子，但叶子自身已经没有箭头指向其他地方，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172859.jpg">

</div>
<h2 id="构建决策树">构建决策树</h2>
<p>现在我们讲一下，如何利用一批数据构建决策树，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172914.jpg">

</div>
<p>我们会利用这个表中的<code>胸痛（chest pain）</code>、 <code>良好血液循环（good blood circulation）</code>和 <code>动脉阻塞状态（blocked artery status）</code>构建一个决策树来预测一个患者是否患有心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172918.jpg">

</div>
<p>第一步我们需要知道的是，我们使用哪些变量作为根结点，是<code>胸痛（chest pain）</code>、<code>良好血液循环（good blood circulation）</code>，还是<code>动脉阻塞状态（blocked artery status）</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172922.jpg">

</div>
<h3 id="单一变量1构建决策树">单一变量1构建决策树</h3>
<p>此时，我们先看一下，<code>胸痛（chest pain）</code>这一个变量预测心脏病的效果如何，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172926.jpg">

</div>
<p>先用这一个变量（胸痛（chest pain））来构建一个小的决策树，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172929.jpg">

</div>
<p>先看第一行的数据，这个患者没有出现胸痛，也没有心脏病，对应到决策树上就是右侧的<code>False</code>中的<code>No</code>，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172934.jpg">

</div>
<p>再看第2行，也就是第2个患者，他出现了胸痛，也出现了心脏病，就归于左侧的<code>True</code>的<code>Yes</code>这一类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172938.jpg">

</div>
<p>再看第3行，也就是第3个患者，他出现了胸痛，但没有出现心脏病，就归到了左侧<code>True</code>的<code>No</code>这个分类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172941.jpg">

</div>
<p>把所有的患者（303个）都统计后，会得到最终是否得心脏病的统计信息，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172946.jpg">

</div>
<h3 id="单一变量2构建决策树">单一变量2构建决策树</h3>
<p>现在我们使用<code>良好血液循环（good blood circulation）</code>这个变量来构建小的决策树，整个过程与前面的一样，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173001.jpg">

</div>
<p>最终得到的结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173006.jpg">

</div>
<h3 id="单一变量3构建决策树">单一变量3构建决策树</h3>
<p>现在我们使用<code>动脉阻塞状态（blocked artery status）</code>这个变量来构建小的决策树，整个过程与前面的一样，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173011.jpg">

</div>
<p>不过这个变量中有一个不明（也就是说除了Yes或No外，还有一个其他的结果，就是三个问号<code>???</code>，这个我们后面会继讲到如何处理），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173027.jpg">

</div>
<p>最终的结果如下所示：：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173032.jpg">

</div>
<h2 id="根节点设置">根节点设置</h2>
<p>前面我们使用了三个不同的变量，即胸痛（chest pain）、 良好血液循环（good blood circulation）和 动脉阻塞状态（blocked artery status）构来构建小的决策树，我们最终的目标就是要找到使用哪个变量做为根节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173046.jpg">

</div>
<p>此时我们看一下胸痛（chest pain）这个变量对是否患有心脏病的区分效果，虽然能够区分，但是效果并非完美，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173050.jpg">

</div>
<p>因为那多数患有心脏病的患者最终会落到<code>Yes</code>这个叶子节点上来，大多数没有心脏病的患者会落后右侧<code>No</code>这个节点上来，我们看一下患有心脏病患者的节点情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173054.jpg">

</div>
<p>再看一下没有患心脏病的患者情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173058.jpg">

</div>
<p>我们再看一下良好血液循环（good blood circulation）这个变量对心脏病患者的区分情况，它也不是特别的完美，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173101.jpg">

</div>
<p>最终，我们看一下动脉阻塞状态（blocked artery status）这个变量对患者的区分情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173104.jpg">

</div>
<p>我们发现，这三个不同的变量用于区分患者是否患有心脏病的数目是不同的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173109.jpg">

</div>
<h3 id="基尼不纯度gini-impurity">基尼不纯度（Gini impurity）</h3>
<p>从中我们可以发现，没有一个叶子节点能够显示100%的患有心脏病，或者是100%没有患心脏病，因此我们称这些叶子节点不纯（<code>impure</code>），为了找到哪个区分的程度更好，我们计算并比较不纯度（impurity），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173124.jpg">

</div>
<p>计算不纯度（impurity）的方法很多，其中最常用的方法称为基尼（Gini）不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173129.jpg">

</div>
<p>此时，我们计算一下胸痛（Chest pain）这个变量构建的决策树的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173133.jpg">

</div>
<p>对于某个叶子结点来说，它的基尼不纯度公式如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173141.jpg">

</div>
<p>此时，再计算另外一个叶子结点的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173146.jpg">

</div>
<p>由于我们已经计算了这两个叶子节点为的基尼不纯度，那么我们就能计算使用了胸痛（chest pain）这个变量区分患者的总基尼不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173149.jpg">

</div>
<p>左侧的叶子节点一共有144个患者，右侧的叶子节点一共有159个患者，计算胸痛这个变量来区分患者的总的基尼不纯度的就是叶子节点不纯度加权平均数（weighted average of the leaf node impurities），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173154.jpg">

</div>
<p>它的公式是，常规的基尼不纯度乘以某个叶子节点的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173159.jpg">

</div>
<p>另外一部分则是如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173203.jpg">

</div>
<p>总的结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173206.jpg">

</div>
<p>此时，计算出剩余两个变量的总基尼不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173210.jpg">

</div>
<p>从中我们可以发现，良好血液循环（good blood circulation）这个变量的总基尼不纯度的值最低，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173213.jpg">

</div>
<p>那么我们就使用它作为根节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173219.jpg">

</div>
<p>虽然我们采用了良好血液循环（good blood circulation）这个变量作为根节点，但它的叶子节点是“不纯”（impure）的，每个叶子中都含有患心脏病与不患心脏病的患者，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173222.jpg">

</div>
<p>例如，在良好血液循环（good blood circulation）的决策树的叶子节点中，有164个患者，其中37个患有心脏病，127个没有心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173226.jpg">

</div>
<p>在右侧的叶子结点中，有133个患者，其中100个患有心脏病，33个不患心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173231.jpg">

</div>
<p>此时，我们需要计算出胸痛（chest pain）和动脉阻塞状态（blocked artery status）这两个变量用于区分左侧164个患者的情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173234.jpg">

</div>
<p>此时，我们分别计算一下胸痛（chest pain）和动脉阻塞状态（blocked artery status）在良好血液循环（good blood circulation）的决策树的左侧叶子节点下的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173238.jpg">

</div>
<p>由于动脉阻塞状态（blocked artery status）在这个叶子节点的基尼不纯度数值最低，因此，我们使用这个变量来区分这些患者，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173244.jpg">

</div>
<p>此时，我们知道了，我们构建的这个决策树，先是使用了良好血液循环（good blood circulation）作为根节点，然后使用了动脉阻塞状态（blocked artery status）作为内部节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173247.jpg">

</div>
<p>最后，我们使用剩下的变量，即胸痛（chest pain）来区分上一级的内部节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173251.jpg">

</div>
<p>最终我们会发现，胸痛（chest pain）这个变量能够很好地区分最后一个叶子节点中的患者，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173257.jpg">

</div>
<p>我们再看一下胸痛（chest pain）这个变量区分右侧叶子节点的情况，在这个节点中有115名患者，其中不患心脏病的患者是102人，比例为89%，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173302.jpg">

</div>
<p>此时把上面红圈的那个内部节点用胸痛（chest pain）这个变量进行区分，并计算它的基尼不纯度，结果为0.29，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173305.jpg">

</div>
<p>如果我们不使用胸痛（chest pain）这个变量来区分这个叶子结点，我们计算一下它的基尼不纯度，就是0.2，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173309.jpg">

</div>
<p>从中我们可以发现，如果我们使用了胸痛（chest pain）这个变量来区分这个叶子节点，那么它的基尼不纯度就相比没有使用变量之前上升了，因此我们并不需要胸痛这个变量来区分这个叶子节点，只把它当成叶子节点，而不是进一步地区分，当其当成内部节点，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173313.jpg">

</div>
<p>因此在决策树的左侧这些节点中，我们已经计算出了最终的结果，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173318.jpg">

</div>
<p>我们现在转向右侧的决策树，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173321.jpg">

</div>
<p>计算右侧的所有节点跟左侧的一样，流程如下所示：</p>
<p>第一，计算出所有的基尼不纯度；</p>
<p>第二，如果节点自身的基尼不纯度比那些加了变量后进一步区分后的基尼不纯度还要低，那么这个节点就被设置为叶子节点；</p>
<p>第三，如果区分的数据会改善最终的分类结果，那么就选择最低不纯度来进行区分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173326.jpg">

</div>
<p>最终，我们会生成一个完整的决策树，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173330.jpg">

</div>
<h2 id="连续型变量构建决策树">连续型变量构建决策树</h2>
<p>前面我们讲的都是二分类变量（yes或no）构建决策树的过程，如果我们的变量是连续型的，例如患者的体重，如何构建决策树呢，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173343.jpg">

</div>
<p>下面就讲这种变量构建决策树的流程：</p>
<p>第一步：对体重进行排序，顺序从小到大，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173353.jpg">

</div>
<p>第二步：计算所有相邻患者的加权平均数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173357.jpg">

</div>
<p>第三步：计算每个加权平均数的不纯度值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173402.jpg">

</div>
<p>现在看一下计算流程，先看第一个167.5这个平均数的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173406.jpg">

</div>
<p>计算出的结果为0，再计算一下右侧的基尼不纯度，为0.375，那么计算一下总的基尼不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173410.jpg">

</div>
<p>现在计算出所有的变量的基尼不纯度，我们发现205这个体重的基尼不纯度为0.27，它的值最低，因此我们会选择205作为阈值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173414.jpg">

</div>
<h2 id="含有排序数据的决策树构建">含有排序数据的决策树构建</h2>
<p>我们前面讲了含有二分类变量（yes或no）与连续型变量（体重）数据的决策树构建，现在我们再谈一种含有“排序数据”（ranked data）的决策树构建，排序数据就是像这样的数据，例如“把我的笑话按照搞笑程度从1到4排列”。</p>
<p>此外，我们还会涉及一种多个选择数据（multiple choice data）的决策树的构建，多个选择数据就像这样的数据，“你喜欢什么颜色，红色，绿色，还是蓝色？”如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173426.jpg">

</div>
<p>排序数据类似于连续型变量的数据（例如体重），只不过我们计算的是这些可能排序的不纯度，例如，把我的笑话按照搞笑程度进行排序，其中4是最搞笑，1不太搞笑，现在我们计算这些笑话的不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173432.jpg">

</div>
<p>在计算这几个数据的不纯度时，我们并不计算<code>Joke Rank &lt;=4</code>这种情况，因此它基本上包括了所有的情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173436.jpg">

</div>
<p>现在我们看一下含有多个选择的数据，例如你喜欢什么颜色，颜色可以选择蓝色，绿色或红色，此时我们会计算每个组合的不纯度，在这个案例中，我们只有这三个种颜色，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173440.jpg">

</div>
<p>它的计算过程如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173444.jpg">

</div>
<p>在这个案例中，我们并不过计算“蓝色或绿色或红色”这种情况，因此这种情况包含了所有的情况，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173448.jpg">

</div>
<h2 id="决策树的过拟合">决策树的过拟合</h2>
<p>在前面的案例中，我们使用了一组数据来构建决策树，这组数据中有三个变量，分别为胸痛（chest pain）<code>、</code>良好血液循环（good blood circulation）和动脉阻塞状态（blocked artery status），如下图左图所示，下图右图是构建好的决策树，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173459.jpg">

</div>
<p>当我们构建了决策树后，我们就可以寻问患者第一个问题了，你的血液循环是否良好，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173504.jpg">

</div>
<p>接着，询问是否出现了动脉阻塞，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173508.jpg">

</div>
<p>然后再询问，是否胸痛，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173512.jpg">

</div>
<p>如果都回答是，那么这个患者就有很大的可能性患了心脏病，因为17个类似的回答的患者都患有心脏病，仅有3个类似回答的患者没有患心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173515.jpg">

</div>
<p>如果在是否出现胸痛这个问题时，回答是否，那么这个患者就不太可能患有心脏病，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173522.jpg">

</div>
<p>我们再往后退一层，如果一个患者回答说他的血液循环良好，并且没有出现动脉阻塞，此时我们就不需要再问他是否出现胸痛了，因为在这一层中计算所得的不纯度更低，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173524.jpg">

</div>
<p>换句话讲，当我们在这个节点中使用了胸痛这个变量进行区分后，它的不纯度得分为0.29，如下所示：</p>
<p><img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173529.jpg">如果不用胸痛这个变量进行区分，它的不纯度得分只有0.20，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173532.jpg">

</div>
<p>由于我们不用胸痛这个变量进行区分时，它的不纯度得分更低，因此它就是一个叶子节点（也就是说不要进行进一步的区分），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173536.jpg">

</div>
<p>此时，我们试想一下，如果胸痛这个变量从来就不能给出一个更低的不纯度，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173540.jpg">

</div>
<p>在这种情况下，我们就不要用胸痛这个变量来区分患者了，我们就要把这个变量从决策树中除去，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173543.jpg">

</div>
<p>即使我们有胸痛这个变量，也不要添加到决策树上，此时决策树上只剩了血液循环和动脉阻塞这两个变量，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173548.jpg">

</div>
<p>这就是一种自动特征选择，但是，我们还是需要设定一个阈值，从而使不纯度降低到足以能够产生很强区分的程度，最终我们会构建出一个更加简洁的决策树，并且这个决策树不出现“过拟合”，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173552.jpg">

</div>
<p>这个提到了一个术语，“过拟合”（over fit），过拟合指的是我们构建的决策树与原始数据（就是构建决策树的数据）匹配得很好，但是这个决策树却与其他的数据（我们拿到一个新的数据，放到这个决策树中）无法很好的匹配，决策树如果构建不好，很容易出现的毛病就是“过拟合”，如果要解决这个问题，就需要大幅度地降低决策树的不纯度，从而避免决策树过拟合，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173556.jpg">

</div>
<p>因此，简单来说，这就是特征选择要做的内容，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173600.jpg">

</div>
<h2 id="缺失值的处理">缺失值的处理</h2>
<p>在前面的案例中，我们看到了动脉阻塞这个变量中有个缺失值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173626.jpg">

</div>
<p>这个缺失值是在第4行，也就是第4个患者中，当我们统计到第4个患者时，就会遇到，此时我们就会跳过这个患者，因为我们不知道这个缺失值原来是Yes，还是No，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173629.jpg">

</div>
<p>但是，并非只有一种跳过这种处理方式，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173633.jpg">

</div>
<p>我们可以在这个变量中，找到哪个变量（yes或no）出现的频率最高，就选它即可，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173636.jpg">

</div>
<p>如果在动脉阻塞这个变量中，yes出现的频率更高，那么我们就把这个缺失值当作yes，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173640.jpg">

</div>
<p>此外，我们还可以找到另外一列（例如第1列的胸痛）与这一列（动脉阻塞）关系，这种关系可以为我们提供指导，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173644.jpg">

</div>
<p>在这个案例中，我们发现，胸痛与动脉阻塞通常是相似的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173648.jpg">

</div>
<p>例如，第1行，两个变量都是No，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173652.jpg">

</div>
<p>第2行，两个变量都是Yes，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173655.jpg">

</div>
<p>第3行，两个变量都是No，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173659.png">

</div>
<p>因此，我们就可以在这个缺失值上填上Yes，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173703.jpg">

</div>
<p>我们再考虑一种情况，假如我们此时没有动脉阻塞这个变量，这一处的变量用体重进行了替换，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173707.jpg">

</div>
<p>我们此时，可以使用体重这个变量的均值或中位数来替换这个缺失值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173711.jpg">

</div>
<p>此外，我们还可以找到第1列（身高）与第3列（体重）之间的关系，用于确定体重的缺失值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173715.jpg">

</div>
<p>在这个案例中，我们发现身高与体重高度相关，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173718.jpg">

</div>
<p>由于它们都是连续型变量，因此我们可以做一下线性回归，求出这个值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173722.jpg">

</div>
<p>最终的结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714173725.jpg">

</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/30/StatQuest/生物统计-StatQuest学习笔记18-K邻近算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/30/StatQuest/生物统计-StatQuest学习笔记18-K邻近算法/" itemprop="url">StatQuest学习笔记18——K邻近算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-30T12:10:54+08:00">
                2018-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,378
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是StatQuest系列视频教程的第50节，主要内容是讲K邻近算法（K-Nearest neighbors algorithm，缩写为KNN）。K邻近算法是一种对数据进行分类的，非常简单的算法。例如我们已经有了很多对细胞进行分类的数据，那么我们要研究某个细胞属于这些分类中的哪个类别，就需要使用这种算法，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172134.jpg">

</div>
<h2 id="k邻近算法基本思想">K邻近算法基本思想</h2>
<p>先看一个简单的案例。</p>
<p>第一步，我们拥有一批数据，这批数据已经进行了分类，在下图中，来源于小肠肿瘤中的这些细胞拥有不同的分类，我们使用PCA对这些细胞进行聚类，如下图所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172138.jpg">

</div>
<p>第二步，当我们再往这批数据中添加一个新的细胞时，我们此时并不清楚这个新细胞的分类，因为这个细胞是从另外的一个肿瘤中取出来的，不好归类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172143.jpg">

</div>
<p>第三步：我们计算这个新的细胞离它最近的那个分类（也就是最近的领居“nearest neighbors”），这个细胞就属于这个分类。如果“K最近的邻居（K-nearest neighbors）”中的这个K等于1（这个K表示的是邻居的数目），那么我们就能把这个新的细胞归于这个离它最近的分类中，在这个案例中，这个最近的分类是绿色的。如果K等于11，那我们就需要使用11个最近的邻居，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172146.jpg">

</div>
<p>假如这个新的细胞在其它的地方，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172149.jpg">

</div>
<p>如果K=11（这个意思表示，最这个点最近的邻居有11个），那么这个新的细胞就位于两类或更多的类中间，我们就把它归于得到“票数”最多的那个类别，那么在这个案例中，有7个最近的邻居是红色，3个最近的邻居是橘黄色，有1个最近的邻居是绿色，由于红色得到的票数最多，那么这个新的细胞就属于红色这一类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172154.jpg">

</div>
<h2 id="热图案例">热图案例</h2>
<p>K邻近算法同样适用于热图，下面的这个热图是用采用层次聚类算法得到的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172159.jpg">

</div>
<p>此时如果我们有一个新的细胞，它的基因表达模式位于热图中浅蓝色区域的中央，如果K=1，那么我们仅仅需要看一下离它最近的细胞，我们就知道这个新的细胞是属于哪个类型的，这种情况下，它属于浅蓝色区域的分类，如果K=5，我们看一下离个细胞最近的邻居，它还是属于这个浅蓝色区域（仔细数一下，浅蓝色区域中有17列），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172202.jpg">

</div>
<p>假如这个新的细胞的基因表达模式位于浅蓝色区域的偏左侧的话，如果此时K=11，我们就需要进行一个投票，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172205.jpg">

</div>
<p>经过投票发现，在这11个最近的邻居中，有7个位于浅蓝色区域，有4个位于浅绿色区域，因此，我们把这个新细胞类型归于浅蓝色区域，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172209.jpg">

</div>
<p>如果这个新的细胞分类正好位于两个区域中央，这个细胞的归类就有两种解决方法：</p>
<p>第一，如果K值是奇数，那么我们就很容易进行计算；</p>
<p>第二，（如果K值是偶数），那么我们就会得到一个比较很麻烦的投票，此时就要靠投硬币来决定这个细胞属于哪个分类了，或者就是不归类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172213.jpg">

</div>
<h2 id="训练数据">训练数据</h2>
<p>在这里我们讲一些简单的机器学习方面的内容，我们把那些用于最初始聚类的数据（这些数据我们已经知道它们是什么分类了）称为“训练数据”（training data），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172217.jpg">

</div>
<h2 id="如何选择k值">如何选择K值</h2>
<p>K值只是算法意义上的数字，它无关生理学或生物学方面的意义，因此在设置K值之前，你或许会尝试设置多设几个K值。在多设几个K值时，此时假定你不清楚一部分训练数据（实际上是知道的）的分类，那么通过K邻近算法（KNN），你对这些未知的训练数据进行分类，进而查看你的数据（此处是非训练数据）的分类情况。</p>
<p>上面的这一段是完全翻译视频中的文字，我是不太理解，但就我自己的理解而言，就先找一批训练数据，这些数据的分类已经很明确了，把这些数据分成2份，分别定义为A和B，其中A用于聚类（这部分数据通常比较大），另外一份B用KNN进行分类（也就是A中分好的类），此时能找出最佳的K值，然后再使用一批新的数据C进行KNN分类。</p>
<p>如果K值比较低（例如K=1或K=2），那么噪音就会比较大，会受到异常值的影响。如果K值过大，虽然会解决K值过小的问题，但是，你也不会想让K值太大，因为如果你只有几个样本，那么运算时间会过长，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714172221.jpg">

</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/06/29/StatQuest/生物统计-StatQuest学习笔记17-聚类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/29/StatQuest/生物统计-StatQuest学习笔记17-聚类/" itemprop="url">StatQuest学习笔记17——聚类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-29T12:10:54+08:00">
                2018-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/生统之StatQuest/" itemprop="url" rel="index">
                    <span itemprop="name">生统之StatQuest</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,272
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言">前言</h2>
<p>这篇笔记是StatQuest系列教程的第47，48，49节。第47节与第48节有很在一部分内容是重复的，主要讲的是层次聚类，第49节讲提K-means聚类。</p>
<h2 id="热图简单案例">热图简单案例</h2>
<p>平时在读一个测序文章时，我们可能会经常看到热图，就像现在的这种图：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164818.jpg">

</div>
<p>现在我们来解释一下这张图：</p>
<ol style="list-style-type: decimal">
<li>这是一张热图（heatmap），为什么要叫热图呢，因为它用不同的颜色来表示数值的大小，通常来说，用暖色（红色）表示数值大，冷色（蓝色）表示数值小。</li>
<li>这个热图的行（row）是基因名（可能太小看不清楚），列是RNA-seq的样本名。</li>
<li>当原始数据通过热图来展现时，数据经过了两种修饰来展示出来。第一种修饰就是相对丰度（relative abundances），以这种方式展示的数据，它研究的是一个基因在不同样本中的相对表达情况，这种展示方式，需要对同一行（也就是相同的基因在不同样本中的表达水平）的数据进行缩放（scaled），也就是Z转换。从下面的图中，我们就可以看到，样本1的某基因表达量明显高于其它样本（因为样本1的颜色最红，根据图例，它的表达值就最高），如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164825.jpg">

</div>
<p>为了方便理解，我随手用Excel做了一下简陋的热图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164828.png">

</div>
<p>可以看出，基因4在样本1中的表达量很高。不过按照第一种展示数据的方式，无法比较不同基因的表达水平差异，例如，在上图的黑色方框中，基因4显红色，这只能表达，样本1中基因4的表达水平比其它的样本高，不能说明样本1中的其它基因（例如基因3）的水平也比其它样本高，这种数据的展示方式只用于研究同一个基因在不同的样本中的表达水平差异。</p>
<p>第二处修饰后的展示方式就是根据这些基因表达的相似性，把它们放到一块，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164833.png">

</div>
<p>再看下面的图形：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164837.jpg">

</div>
<p>从上到下，我们可以看到这些基因的表达的模式。</p>
<p>在第一个紫红色的方框中，我们可以看到，这些基因在第2个样本中表达水平最高，而在第4个样本中表达水平最低。</p>
<p>在第二个黑色的方框中，我们可以看到，这些基因在第1个样本中表达水平最高，而在第4个样本中表达水平最低。</p>
<p>在第三个橙色方框中中，我们可以看到，这些基因在第2个样本中的表达水平最高，而在第3个栖中的表达水平最低。</p>
<p>根据不同基因表达模式的相似性进行的“聚类”（clustering）并不是偶然的，而是通过一定的算法实现的，这些算法会将那些表达模式类似的基因放到一块，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164845.png">

</div>
<p>如果不进行聚类（clustering），那么用热图展示出来就是下图右边的那个样子，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164852.jpg">

</div>
<p>如果热图中既不进行聚类（clustering），也不进行缩放（scaling），那么热图就变成了如下的这个样子：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164858.jpg">

</div>
<p>从图上我们可以看到，红色部分的这个基因表达水平最高（比其他的基因表达高太多了），可以把它视为一个异常值。</p>
<h2 id="热图复杂案例">热图复杂案例</h2>
<p>现在我们再看一下比较复杂的热图案例，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164914.jpg">

</div>
<p>从这个图的标题上我们可以看出，这个貌似是一个结肠的单细胞测序数据的热图。这个热图的数据经过了缩放（scaled）与聚类（clustered），它的缩放是全局的，因此，这一组数据中并没有异常值，这里的缩放要与前面热图的缩放区分开来，前面的前面是按照某个基因进行缩放的，也就是把同一行的数据当成整体，进行了缩放（也就是z转换），而这个数据是把所有的数据当作整体，进行缩放。</p>
<p>再看聚类。这个热图的聚类是按照列（column，也就是样本）和行（row，也就是基因）同时进行的聚类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714165212.png">

</div>
<p>在上图中，我们可以看到，纵矩形的部分表示基因表达模式相似的样本聚在了一起，横矩形表示的是，表达模式相似的基因聚集在了一起。它们的交集表示，这些样本的基因表达模式相似，以及有哪些基因相似。</p>
<p>如果不进行聚类，也不进行数据缩放（scaling），那么下图的右上表示的就是不聚类的热图，右下表示的就是即不进行聚类，又不进行缩放的热图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714165248.jpg">

</div>
<p>此时我们再回到前面的那个简单热图案例中来，我们试想一个问题，在那张热图中，如果我们对所有的基因进行整体的缩放（global scaling），而非单个基因的缩放，那么这个热图会怎么样，我们看下图：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714164924.jpg">

</div>
<p>经过全局缩放（global scaling）后，得到下面的图形，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171141.jpg">

</div>
<p>此时，我们会发现，这些聚类的结果就会发生了改变，并且新生成的图形中出面了异常高的热图，它是异常值，这个异常值会导致热图整体上出来严重的偏离，并且不容易观察基因的变化，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171147.jpg">

</div>
<p>因此，我们从上面的结果可以知道，缩放（scaling）会影响两个结果，第一，不同表达水平基因的颜色，这会影响你比较不同样本中的相同基因的表达水平，第二，影响聚类（clustering），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171156.jpg">

</div>
<h2 id="如何对数据进行缩放scale">如何对数据进行缩放（scale）</h2>
<p>此时，我们再回到数据的缩放这个话题上，无论你对相同基因在不同样本中进行缩放，还是对全局的基因进行缩放，最常用的方法就是Z值缩放法（Z-Score Scaling），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171208.jpg">

</div>
<p>接着，我们具体看一下这种方法是如何实现数据的缩放的。在下图中，我们看到一个数轴上分布了几个样本的reads数，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171212.jpg">

</div>
<p>第一步：计算其均值（均值为16.5），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171216.jpg">

</div>
<p>第二步：每个样本的数值减去均值，此时，如果这个数值大，就表示此样本的某基因转录水平高；如果数值小，就表示此样本的某基因转录水平低，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171219.jpg">

</div>
<p>第三步：计算标准差（标准差为6.28）；</p>
<p>第四步：将第2步中的数值除以标准差，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171225.jpg">

</div>
<p>经过上述的处理后，无论原始数据的变异程度如何，这些数据的范围最终会缩小，之所以这样处理，就是因为如果原始数据之间差异过大，那么不同基因表达水平就会变化程度（more subtle）更高的色度（shade）来表示，经过这样的处理，用较小程度的色度（shade）就能表示出基因水平的差异，方便观察，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171232.jpg">

</div>
<p>此时，我们可能会遇到这样的一种情况，例如，如果数据中出现异常值时，数据会怎么样，就像下面的这个样子：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171240.jpg">

</div>
<p>此时如果进行Z转换的话，标准差会很大，也就是Z值的分子会很大，最终得到的值会有一部分集中在0附近，只能用很少的色度来进行区分，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171245.jpg">

</div>
<p>例如，我们如果采用全局缩放来处理原始数据中，在第一个案例中，我们就会得到下面这样的图形，其中有一个基因明显表达水平非常高，使得其它的基因差异很难看出来，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171251.jpg">

</div>
<h2 id="如何聚类">如何聚类</h2>
<p>原始数据经过缩放后（scaling），此时就可以进行聚类了，聚类有2种方法，分别是层次聚类（hierarchical clustering）和K-均值（K-means）聚类，我们先讲层次聚类（hierarchical clustering），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171300.jpg">

</div>
<h2 id="层次聚类hierarchical-clustering">层次聚类（hierarchical clustering）</h2>
<p>先看一个简单的案例，在这个案例中，有3个样本，每个样本4个基因，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171317.jpg">

</div>
<p>这种聚类方法的思路是这样的：</p>
<p>第一步，计算出哪些基因与基因1最为接近，基因2明显与基因1表达模式不同，基因3与基因1的表达形式比较类似，基因4与基因1的表达模式也比较类似，但是，在这几个基因中，与基因1表达模式最接近的还是基因3，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171322.jpg">

</div>
<p>第二步，计算出哪些基因的表达模式与基因2最为接近（然后是基因3，基因4），经计算发现，基因4与基因2的表达模式最相似，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171328.jpg">

</div>
<p>第三步，我们在前面找到基因1和基因3的表达模式相似，基因2和基因4的表达模式相似，但是，基因1和基因3的相似程度要比基因2和基因4的相似程度高，我们把前面的组合（基因1和基因3）放到一个簇（cluster）中，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171334.jpg">

</div>
<p>第四步：此时再回到第一步，把基因1和基因3构成的簇（Cluster # 1）当作一个基因，然后再按照第二步，第三步来计算，经计算，此时，基因2和基因4最相似，把它们再放到一个簇中（Cluster #2），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171338.jpg">

</div>
<p>通常情况下，层次聚类（Hierarchical Clustering）通常会用一个树形图（dendrogram）连接起来，用于表明聚类成员之间的相似性和聚类次序，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171346.jpg">

</div>
<p>在右侧的树形中，我们可以发现，<code>Cluster #1</code>是最先形成的聚类，它们的相似性最高，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171353.jpg">

</div>
<p><code>Cluster #2</code>是第二个形成的聚类，它们的相似性次高，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171357.jpg">

</div>
<p>而第三个聚类<code>Cluster #3</code>则包含了所有的基因，它是最后形成的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171403.jpg">

</div>
<h2 id="层次聚类的原理">层次聚类的原理</h2>
<p>前面我们提到过，层次聚类的第一步就是计算两组基因的相似性，此时我们详细介绍一下如何进行计算。</p>
<p>在计算相似性方面并没有一个统计的标准，但有一些常用的手段。第一种计算相似性的方法就是欧氏距离（Euclidian distance），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171417.jpg">

</div>
<p>为了简单地说明欧氏距离（Euclidian distance），我们以最简单的例子来说明，在这个例子中，有2个样本，每个样本有2个基因，然后两个样本的相同基因的差值的平方相加，并开平方，得到的数值就是欧氏距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171423.jpg">

</div>
<p>除了欧氏距离可以计算相似性外，还可以使用曼哈顿距离（Manhattan distance）和坎贝拉距离（Canberra distance）来计算相似性，其中曼哈顿距离只是不同样本之间相同基因差值的绝对值之和，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171430.jpg">

</div>
<p>我们看一下用不同的方法计算相似性的区别，下图的左侧图使用的欧氏距离（Euclidian distance）来得到的热图，右图使用的是曼哈顿距离（Manhattan distance）得到的热图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171434.jpg">

</div>
<p>从图上来看，使用这两种不同的相似性计算方法得到的热图略有差异，具体要使用哪种方法来计算相似性，并没有一个统计的标准，它们也没有什么生物学意义。</p>
<p>此时，我们再回到原来的案例中来，在前面部分中我们提到，基因1和基因3的相似程度最高，把它们都放到一个簇（Cluster #1）中，此时，我们如何计算Cluster #1和基因2，基因4的相似性呢？有几种方法。</p>
<p>其中最简单的一种方法就是求出Cluster #1中的两个基因的平均值，然后进行计算。但还有其它的方法，这些方法同样会影响聚类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171439.jpg">

</div>
<p>为了简单地说明簇（Cluster #1）与其它基因相似性计算的问题，我们假设有一批数据，分布在X-Y轴上，此时，我们已经生成了2个簇，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171443.jpg">

</div>
<p>此时，我们仅需要计算最后一个点属于哪个簇，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171448.jpg">

</div>
<p>此时我们可以采用以下这些方法进行计算：</p>
<p>第一，计算这个点与两个簇平均值的距离（centroid），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171452.jpg">

</div>
<p>第二，计算这个点到两个簇最近的点的距离（single-linkage），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171501.jpg">

</div>
<p>第三，计算这个点到两个簇中最远的点的距离（complete-linkage），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171504.jpg">

</div>
<p>我们用前面的单细胞测序的热图来说明一下这三种方法，从左到右分别是：某点到某簇最远点的距离（在R中默认的就是这个选项），某点到某簇均值的距离，某点到某簇最近的点的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171521.jpg">

</div>
<h2 id="k-means聚类">K-means聚类</h2>
<h3 id="什么是k-means">什么是K-means</h3>
<p>先看一个场景，例如我们手中有这样的一批数据，把它们绘制到一个数轴上，此时你的目的就是把它们分成3个簇（cluster），这三个数据或许是来源于三种不同的细胞或都是三种不同的肿瘤，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171528.jpg">

</div>
<p>我们仅从肉眼观察，就知道这一批数据明显可以分成3个簇，但是，如果我们不用肉眼来观察，用计算机来计算，如何得到这3个簇呢？此时就需要用到一种算法，即K-means聚类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171533.jpg">

</div>
<h3 id="k-means的基本思想">K-means的基本思想</h3>
<p>此时，我们先了解一下K-means聚类的基本思想。</p>
<p>第一步：选择你要聚类的个数，K-means聚类中的这个<code>K</code>就是你要聚类的数目的意思，此时，你们选择<code>K=3</code>，这也就是说，我们想把这些数据取成3个簇（cluster），对这个<code>K</code>值如何选择，我们后文会提到，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171538.jpg">

</div>
<p>第二步，随机选择3个不同的数据点当成3个簇，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171542.jpg">

</div>
<p>第三步：计算第1个点到这三个簇的距离，先计算第1个点到蓝簇的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171542.jpg">

</div>
<p>接着，计算第1个点到绿簇的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171549.jpg">

</div>
<p>最后，计算第1个点到橘黄簇的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171554.jpg">

</div>
<p>第四步：将第1个点归于离它最近的簇，在这个案例中，第1个点就属于蓝簇，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171558.jpg">

</div>
<p>接着，重复前面的步骤，只是这次计算的第2个点，第2个点最终的计算结果它属于绿簇，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171601.jpg">

</div>
<p>再计算第3个点，它属于橘黄簇，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171608.jpg">

</div>
<p>经过最终计算，第3个点到最后的点都属于橘黄簇，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171616.jpg">

</div>
<p>此时，所有的点都进行了聚类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171620.jpg">

</div>
<p>第五步：计算每个簇的均值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171625.jpg">

</div>
<p>此时，我们还按照前面的方法，计算每个点到这三个簇的均值的距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171629.jpg">

</div>
<p>最终计算结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171633.jpg">

</div>
<p>经过最终的计算，我们发现，这些聚类结果并没有发生改变，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171637.jpg">

</div>
<p>也就是说，K-means的聚类结果似乎比我们肉眼进行的聚类的结果还要差，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171643.jpg">

</div>
<p>此时，我们需要对聚类的结果进行评估，其方法就是计算每个簇的变异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171647.jpg">

</div>
<p>由于K-means的聚类过程并不能“看”到最佳的聚类，只能追踪这些簇与这些簇的总变异，然后通过不断更改起始的数据点进行迭代。</p>
<p>此时我们回到起点，再将随机选择3个初始数据点作为初始的簇，按照前面同样的自救，计算剩余的点到这三个簇的距离，计算每个簇的均值，然后基于新的均值进行聚类，直接这些簇不再改变为止，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171652.jpg">

</div>
<p>计算的结果如下所示，此时这些数据已经进行了聚类，再计算这三个簇的变异，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171659.jpg">

</div>
<p>这一轮迭代结束，然后再来一轮，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171703.jpg">

</div>
<p>我们把这三次的聚类结果放一块儿，我们可以发现，第二次的聚类结果最好，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171707.jpg">

</div>
<p>但是我们并不清楚这个结果是不是所有可能的聚类结果中最好的（总变异最小），因此我们需要进行更多次的聚类，然后才能下结论。</p>
<p>此时我们提出一个问题，<code>K</code>值应该如何选？在这个案例中，明显可以知道K值为3，但是，有的时候，这个K值并不像本案例中这么明显，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171713.jpg">

</div>
<p>其中一种确定K值的方法就是不断地使用不同的K值，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171719.jpg">

</div>
<p>我们先使用K=1这个数值，通过计算总的变异程度，明显这个结果不行，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171726.jpg">

</div>
<p>再使用K=2，此时我们计算一下总变异，这个结果比K=1的时候要好一些，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171731.jpg">

</div>
<p>接着，我们使用K=3，通过计算它的总变异，我们发现K=3的结果要比K=2更好，因为它的总变异更低，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171746.jpg">

</div>
<p>再继续，使K=4，我们发现，K=4的总变异比K=3的总变异还要小，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171751.jpg">

</div>
<p>从前面的这些计算结果来看，我们能总结出一个规律，每当我们添加一个新的簇时，总变异就会降低，当簇的数目等于总的数据点的数目时，总变异就是0，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171756.jpg">

</div>
<p>如果我们把K值与变异降低的程度绘制成曲线，那么就能得到下面的这条曲线：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171800.jpg">

</div>
<p>从这个曲线上我们可以看到，当K=3时，它之后的K值每增加1，总变异的降低幅度就没有前面的快，我们把K=3这个点称为拐点（elbow plot）。</p>
<h3 id="k-mean聚类与层次聚类的区别">K-mean聚类与层次聚类的区别</h3>
<p>此时，我们再提出一个问题：K-mean聚类与层次聚类有什么区别？</p>
<p>K-means聚类会把数据聚成你所期望的簇的数目，而层次聚类则中介告诉你，哪两个数据是最相似的，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171803.jpg">

</div>
<h2 id="二维坐标的k-means">二维坐标的K-means</h2>
<p>如果我们的数据无法绘制到一条数轴上时，如何进行K-means聚类呢，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171808.jpg">

</div>
<p>这种情况下，它的聚类原理跟一维数轴的原理一样，第一步就是随机找到三个点（前提是你想聚成3个簇），如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171812.jpg">

</div>
<p>然后，计算不同的点到这三个簇的欧氏距离（Euclidean distance），在二维坐标中，计算这个欧氏距离就是采用勾股定理，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171816.jpg">

</div>
<p>接着，就像前面讲的那样，距离最近的就属于某个簇，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171821.jpg">

</div>
<p>第一次的聚类结果如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171825.jpg">

</div>
<p>再接着，我们会像前面是找到的那样，计算出每个族的中心点（也就是均值），然后再聚类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171832.jpg">

</div>
<p>最后，得到比较满意的聚类图，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171837.jpg">

</div>
<h2 id="热图的k-means">热图的K-means</h2>
<p>如果我们的数据是热图，那么如何进行K-means聚类呢？</p>
<p>为了方便描述，我们就以下面的案例说明一下，两个样本（sample 1和sample 2），分别有4个基因，现在把这两个样本分别命令为X，Y，把它们的基因放到二维坐标轴上，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171855.jpg">

</div>
<p>然后像前面那样进行聚类，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171858.jpg">

</div>
<p>事实上，在实际的计算过程中，我们并不需要把数据投射到二维坐标上，只用计算不同样本之间的距离即可，例如欧氏距离，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171902.jpg">

</div>
<h2 id="r的kmeans函数备注">R的kmeans()函数备注</h2>
<p>在R中，进行K-menas聚类的函数是<code>kmeans()</code>，它有一些注意事项。</p>
<ol style="list-style-type: decimal">
<li>此函数会对每个距离加上权重，因此那些大簇（large clusters）的权重要略高于小簇（small clusters）的权重。</li>
<li>默认情况下，此函数只有一组原始的簇，如果你要使用多个不同的起始数据点，那么你需要设定参数<code>nclust=25</code>或者是25左右的数字，例如（<code>kmans(data, k=3, nclust=25)</code>)。</li>
</ol>
<p>如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190714171906.jpg">

</div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">223</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">109</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>


<div class="BbeiAn-info">
	<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41018102000118" style="color:#909090;text-decoration:none;padding-left:0px;no-repeat left center" rel="nofollow">豫公网安备 41018102000118</a>	  <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
</div>

  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共890.3k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
