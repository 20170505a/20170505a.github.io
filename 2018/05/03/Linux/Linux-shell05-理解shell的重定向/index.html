<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Linux,脚本,Shell,结构化命令," />










<meta name="description" content="理解输入与输出 脚本的两种显示方法就是：第一，在显示器屏幕上显示输出；第二，将输出重定向到文件。这篇笔记主要是理解Linux如何处理输入与输出的。 标准文件描述符 Linux系统将每个对象当作文件处理，这就包括了输入和输出过程，Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，每个进程最多可以有9个文件描述符，">
<meta name="keywords" content="Linux,脚本,Shell,结构化命令">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell学习笔记（5）——理解Shell的重定向">
<meta property="og:url" content="http://rvdsd.top/2018/05/03/Linux/Linux-shell05-理解shell的重定向/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:description" content="理解输入与输出 脚本的两种显示方法就是：第一，在显示器屏幕上显示输出；第二，将输出重定向到文件。这篇笔记主要是理解Linux如何处理输入与输出的。 标准文件描述符 Linux系统将每个对象当作文件处理，这就包括了输入和输出过程，Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，每个进程最多可以有9个文件描述符，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-15T10:21:26.116Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shell学习笔记（5）——理解Shell的重定向">
<meta name="twitter:description" content="理解输入与输出 脚本的两种显示方法就是：第一，在显示器屏幕上显示输出；第二，将输出重定向到文件。这篇笔记主要是理解Linux如何处理输入与输出的。 标准文件描述符 Linux系统将每个对象当作文件处理，这就包括了输入和输出过程，Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，每个进程最多可以有9个文件描述符，">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/2018/05/03/Linux/Linux-shell05-理解shell的重定向/"/>





  <title>Shell学习笔记（5）——理解Shell的重定向 | RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/05/03/Linux/Linux-shell05-理解shell的重定向/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Shell学习笔记（5）——理解Shell的重定向</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T00:00:01+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,079
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="理解输入与输出">理解输入与输出</h2>
<p>脚本的两种显示方法就是：第一，在显示器屏幕上显示输出；第二，将输出重定向到文件。这篇笔记主要是理解Linux如何处理输入与输出的。</p>
<h3 id="标准文件描述符">标准文件描述符</h3>
<p>Linux系统将每个对象当作文件处理，这就包括了输入和输出过程，Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件，每个进程最多可以有9个文件描述符，而bash shell保留了前3个文件描述符，即0、1和2。</p>
<table>
<thead>
<tr class="header">
<th>文件描述符</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr class="even">
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr class="odd">
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
<p>这三个特殊文件描述符会处理脚本中的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</p>
<h3 id="stdin">STDIN</h3>
<p>STDIN文件描述符代表了shell的标准输入，对于终端来说，标准输入就是键盘，shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上的键输入的。许多bash命令能接受STDIN的输入，尤其是在命令行上指定文件的话。下面看一下<code>cat</code>这个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/userdata$ cat</div><div class="line">test cat command</div><div class="line">test cat command</div><div class="line">cat command can input from keyboard</div><div class="line">cat command can input from keyboard</div></pre></td></tr></table></figure>
<p>当在命令行上只输入<code>cat</code>时，它会从<code>STDIN</code>接受僌，输入一行，<code>cat</code>命令就会显示出一行。但也可以通过<code>STDIN</code>重定向符号强制<code>cat</code>命令接受来自另一个非<code>STDIN</code>文件的输入，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat testfile </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div><div class="line">biotest@ubuntu:~/input$ cat &lt; testfile </div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div></pre></td></tr></table></figure>
<p>这个结果显示，cat命令会用testfile文件中的行作为输入。</p>
<h3 id="stdout">STDOUT</h3>
<p><code>STDOUT</code>文件描述符代表shell的标准输出。在终端界面上，标准输出应时终显示器。Shell的所有输出（包括shell文中运行的程序和脚本）会被定向到标准输出中，也就是显示器。默认情况下，大多数bash命令会将输出导向STDOUT文件描述符，也可以使用输出重定向来改变，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -l &gt; test2</div><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div></pre></td></tr></table></figure>
<p>使用<code>&gt;&gt;</code>符号可以向一个文件中追加数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div><div class="line">biotest@ubuntu:~/input$ who</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">biotest@ubuntu:~/input$ who &gt;&gt; test2</div><div class="line">biotest@ubuntu:~/input$ cat test2</div><div class="line">total 4</div><div class="line">-rw-rw-r-- 1 biotest biotest  0 May  5 19:35 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest 73 May  5 19:32 testfile</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div></pre></td></tr></table></figure>
<p>当某个主文件不存在时，无产进行重定向，但会生成要重定向的文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al badfile &gt; test3</div><div class="line">ls: cannot access &apos;badfile&apos;: No such file or directory</div><div class="line">biotest@ubuntu:~/input$ cat test3</div></pre></td></tr></table></figure>
<p>由于不存在badfile文件，因此bash无法获取里面的信息，也无法将其信息重定向到test3，但是test3这个文件会被创建，只是里面是空的。</p>
<h3 id="stderr">STDERR</h3>
<p><code>STDERR</code>文件描述符被设成2，可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al badfile 2&gt; test3</div><div class="line">biotest@ubuntu:~/input$ cat test3</div><div class="line">ls: cannot access 'badfile': No such file or directory</div></pre></td></tr></table></figure>
<p>此时，错误消息不会出现在屏幕上，该命令生怕任何错误消息都会保存在输出文件中，用这种方法，shell只重定向错误消息，而非普通数据。下面的一个案例是将<code>STDOUT</code>和<code>STDERR</code>消息混杂在同一个输出中的例子，如下所示；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test badtest test2 2&gt; test5</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">biotest@ubuntu:~/input$ cat test5</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div></pre></td></tr></table></figure>
<p>ls命令的正常<code>STDOUT</code>输出仍然公改善到默认的<code>STDOUT</code>文件描述符，也就是显示器，由于该命令将文件描述符2的输出（<code>STDERR</code>）重定向到了一个输出文件，shell将生成的所有错误消息直接改善到指定的重定向文件中。</p>
<h4 id="重定向错误和数据">重定向错误和数据</h4>
<p>如果想重定向错误和正常输出，需要用2个重定向符号，需要在符号前放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7</div><div class="line">biotest@ubuntu:~/input$ cat test6</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div><div class="line">biotest@ubuntu:~/input$ cat test7</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest  55 May  5 19:48 test3</div></pre></td></tr></table></figure>
<p>在这个案例中，shell利用<code>1&gt;</code>符号将ls命令的正常输出重定向到了<code>test7</code>文件，而这些输出本该是进入<code>STDOUT</code>的。所有本该输出到<code>STDERR</code>的错误消息通过<code>2&gt;</code>符号被重定向到了<code>test6</code>文件。 这种方法哦可以将脚本的正常输出和脚本的错误消息分离开来。</p>
<p>除此之外，还可以将<code>STDERR</code>和<code>STDOUT</code>的输出重定向到同一个输出文件，可以使用特殊的重定向符号<code>$&gt;</code>，如下所示：：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al test test2 test3 badtest &amp;&gt; test7</div><div class="line">biotest@ubuntu:~/input$ cat test7</div><div class="line">ls: cannot access 'test': No such file or directory</div><div class="line">ls: cannot access 'badtest': No such file or directory</div><div class="line">-rw-rw-r-- 1 biotest biotest 157 May  5 19:38 test2</div><div class="line">-rw-rw-r-- 1 biotest biotest  55 May  5 19:48 test3</div></pre></td></tr></table></figure>
<p>当使用<code>&amp;&gt;</code>符号哩主，命令生成的所有输出都会改善到同一位置，包括数据和错误。bash shell会自动赋予错误消息更高的优先级，在输出文件的最开头部分显示错误消息。</p>
<h2 id="在脚本中重定向输出">在脚本中重定向输出</h2>
<p>有2种方法在脚本中重定向输出，第一，临时重定向行输出；第二，永久重定向脚本中的所有命令。</p>
<h3 id="临时重定向">临时重定向</h3>
<p>如果脚本中意外生成错误消息，可以将单独的一行输出重定向到<code>STDERR</code>，在重定向到文件描述符时，需要在文件描述符前面添加一具<code>&amp;</code>，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing STDERR messages</div><div class="line"></div><div class="line">echo "This is an error" &gt;&amp;2</div><div class="line">echo "This is normal output"</div></pre></td></tr></table></figure>
<p>运行过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test8.sh</div><div class="line">biotest@ubuntu:~/input$ ./test8.sh</div><div class="line">This is an error</div><div class="line">This is normal output</div><div class="line">biotest@ubuntu:~/input$ ./test8.sh 2&gt;test9</div><div class="line">This is normal output</div><div class="line">biotest@ubuntu:~/input$ cat test9</div><div class="line">This is an error</div></pre></td></tr></table></figure>
<p>从结果可以看出，STDOUT显示的文件会出现在屏幕上，而发送给STDERR的echo语句的文本则被重定向到了输出文件。这个方便适合在脚本中生成错误的消息。</p>
<h3 id="永久重定向">永久重定向</h3>
<p>如果脚本中有大量数据需要重定向，则可以使用<code>exec</code>命令告诉shell脚本执行期间重定向某个特定文件的描述符，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting all output to a file</div><div class="line">exec 1&gt; testout</div><div class="line"></div><div class="line">echo "This is a test of redirecting all output"</div><div class="line">echo "from a script to another file."</div><div class="line">echo "without having to redirect every individual line"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test10.sh</div><div class="line">biotest@ubuntu:~/input$ ./test10.sh</div><div class="line">biotest@ubuntu:~/input$ cat testout</div><div class="line">This is a test of redirecting all output</div><div class="line">from a script to another file.</div></pre></td></tr></table></figure>
<p><code>exec</code>命令会启动一个新的shell，并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。可以在脚本执行过程中重定向STDOUT，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting output to different locatons</div><div class="line"></div><div class="line">exec 2&gt; testerror</div><div class="line"></div><div class="line">echo "This is the start of the script"</div><div class="line">echo "now redirecting all output to another location"</div><div class="line"></div><div class="line">exec 1&gt; testout</div><div class="line"></div><div class="line">echo "THis output should go to the testout file"</div><div class="line">echo "but this should go to the testerror file" &gt;&amp;2</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test11.sh</div><div class="line">biotest@ubuntu:~/input$ ./test11.sh</div><div class="line">This is the start of the script</div><div class="line">now redirecting all output to another location</div><div class="line">biotest@ubuntu:~/input$ cat testerror</div><div class="line">but this should go to the testerror file</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将发给STDERR的输出重定向到了文件testerror，接下来，脚本用echo语句向STDOUT显示了几行文本，随后再次使用exec命令来将STDOUT重定向到了testout文件，虽然STDOUT被重定向了，但仍然可以将echo语句的输出发给STDERR，在此案例中，重定向到了testerror文件。</p>
<h2 id="在脚本中重定向输入">在脚本中重定向输入</h2>
<p>在脚本中可以使用与重向STDOUT和STDERR同样的方法来将STDIN从键盘重定向到其他位置。exec命令可以将STDIN重定向到linux系统上的文件中，用法是<code>exec 0&lt; testfile</code>，这个命令会告诉shell应该从文件testfile中获得输入，而不是<code>STDIN</code>，这个重定向只要在脚本需要输入时就会作用，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting fiel input</div><div class="line"></div><div class="line">exec 0&lt; testfile</div><div class="line">count=1</div><div class="line"></div><div class="line">while read line</div><div class="line">do</div><div class="line">    echo "Line #$count: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test12.sh</div><div class="line">biotest@ubuntu:~/input$ ./test12.sh</div><div class="line">Line #1: This is the first line.</div><div class="line">Line #2: This is the second line.</div><div class="line">Line #3: This is the third line.</div></pre></td></tr></table></figure>
<p>将<code>STDIN</code>重定向到文件后，当read命令试图从STDIN读入数据时，它会到文件中去读取数据，而不是键盘。</p>
<h2 id="创建自己的重定向">创建自己的重定向</h2>
<p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符（即0，1和2）。shell中最多可以有9个打开的文件描述符。其他6个从 3 ~ 8 的文件描述符均可用作输入或输出重定向。用户可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>
<h3 id="创建输出文件描述符">创建输出文件描述符</h3>
<p>exec 命令可以给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using an alternative file descriptor</div><div class="line"></div><div class="line">exec 3&gt;test13out</div><div class="line"></div><div class="line">echo "This should display on the monitor"</div><div class="line">echo "and this should be stored in the file" &gt;&amp;3</div><div class="line">echo "Then this shold be back on the monitor"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test13.sh</div><div class="line">biotest@ubuntu:~/input$ ./test13.sh</div><div class="line"></div><div class="line">This should display on the monitor</div><div class="line">Then this shold be back on the monitor</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat test13out</div><div class="line">and this should be stored in the file</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内容会像预想中那样显示在STDOUT 上。但你重定向到文件描述符3 的那行echo语句的输出却进入了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如日志文件）。 也可以不用创建文件，使用exec命令来将输出追加到现有文件早，例如<code>exec 3&gt;&gt; test13out</code>。</p>
<h3 id="重定向文件描述符">重定向文件描述符</h3>
<p>看一个案例，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> storing STDOUT, then coming back to it</div><div class="line"></div><div class="line">exec 3&gt;&amp;1 # 将文件描述符3重定向到文件描述符1的位置，也就是STDOUT，这意味着任何发送给文件描述符3的输出都将会出现在显示器上</div><div class="line"></div><div class="line">exec 1&gt; test14out # 将STDOUT重定向到文件，shell现在会将改善给STDOUT的输出直接重定向到输出文件上，但文件描述符3仍然指向STDOUT原来的位置，也就是显示器，如果此时将输出数据改善给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了</div><div class="line"></div><div class="line">echo "This should store in the output file"</div><div class="line">echo "along with this line."</div><div class="line"></div><div class="line">exec 1&gt;&amp;3</div><div class="line"><span class="meta">#</span> 在向STDOUT发送一些输出后，脚本将STDOUT重定向到文件描述符3的当前位置（显示器），这意味着现在STDOUT又指向了原来的位置，即显示器</div><div class="line"></div><div class="line">echo "Now things should be back to normal"</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test14.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test14.sh </div><div class="line">Now things should be back to normal</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat test14out </div><div class="line">This should store in the output file</div><div class="line">along with this line.</div></pre></td></tr></table></figure>
<h3 id="创建输入文件描述符">创建输入文件描述符</h3>
<p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将 STDIN 文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将 STDIN 恢复到它原来的位置，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> redirecting input file descriptors</div><div class="line"></div><div class="line">exec 6&lt;&amp;0</div><div class="line"></div><div class="line">exec 0&lt; testfile</div><div class="line"></div><div class="line">count=1</div><div class="line">while read line </div><div class="line">do</div><div class="line">    echo "Line #$cont: $line"</div><div class="line">    count=$[ $count+1 ]</div><div class="line">done</div><div class="line">exec 0&lt;&amp;6</div><div class="line">read -p "Are you done now " answer</div><div class="line">case $answer in </div><div class="line">Y|y) echo "Goodbye";;</div><div class="line">N|n) echo "Sorry, this is the end.";;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test15.sh</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test15.sh</div><div class="line">Line #: This is the first line.</div><div class="line">Line #: This is the second line.</div><div class="line">Line #: This is the third line.</div><div class="line">Are you done now Y</div><div class="line">Goodbye</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test15.sh</div><div class="line">Line #: This is the first line.</div><div class="line">Line #: This is the second line.</div><div class="line">Line #: This is the third line.</div><div class="line">Are you done now n</div><div class="line">Sorry, this is the end.</div></pre></td></tr></table></figure>
<p>在这个案例中，文件描述符6用来保存STDIN的位置，然后脚本将STDIN重定向到一个文件，read命令的所有输入都来自重定向后的STDIN（也就是输入文件），在读取了所有行之后，脚本将STDIN重定向到文件描述符6，从而将STDIN恢复到原来的位置，该脚本用了另外一个read命令来测试STDIN是否恢复正常，这将它等待键盘的输入。</p>
<h3 id="创建读写文件描述符">创建读写文件描述符</h3>
<p>在bash shell中，可以打开单个文件描述符来作为输入和输出，可以用一个文件描述符对同一个文件进行读写，不过使用这种方法需要谨慎，由于用户是对一个文件进行数据读写，shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始，如果不够小心，会生成严重的后果，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing input/output file descriptor</div><div class="line"></div><div class="line">exec 3&lt;&gt; testfile</div><div class="line">read line &lt;&amp;3</div><div class="line">echo "Read: $line"</div><div class="line">echo "This is a test line" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ chmod u+x test16.sh </div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is the second line.</div><div class="line">This is the third line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ ./test16.sh</div><div class="line">Read: This is the first line.</div><div class="line"></div><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is a test line</div><div class="line">ine.</div><div class="line">This is the third line.</div></pre></td></tr></table></figure>
<p>在这个案例中，exec命令将文件描述符分配文件testfile以进行文件读写，接下来，通过使用分配好的文件描述符，使read命令读取文件中的第一行，然后将这一行显示在STDOUT上，最后使用echo语句将一行数据写入由同一个文件描述符打开的文件中。在运行结果中，开始运行正常，输出内容表明脚本读取了testfile文件中的第一行，如果脚本运行完毕，查看testfile文件时发现，写入文件中的数据覆盖了已有的数据。原因是，当脚本向中文件中写入数据时，它会从文件指针所处的位置开始，read命令读取了第一行数据，所以它使得文件指针指向了第二行数据的第一个字符，在echo语句将数据输出到文件时，它会将数据放在文件指针的当前位置，覆盖了该位置的已有数据。</p>
<h3 id="关闭文件描述符">关闭文件描述符</h3>
<p>如果用户创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们，有些情况下需要在脚本关闭之前手动关闭文件描述符，要关闭文件描述符，将它重定向到特殊符号<code>&amp;-</code>，在脚本中是这样的<code>exec 3&gt;&amp;-</code>，这条语句会关闭文件描述符3，不再脚本中使用它，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing closing file descriptors</div><div class="line"></div><div class="line">exec 3&gt; tets17file</div><div class="line"></div><div class="line">echo "This is a test line of data " &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">echo "This won't work" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash badtest2.sh </div><div class="line">badtest2.sh: line 9: 3: Bad file descriptor</div></pre></td></tr></table></figure>
<p>一旦关闭了文件描述符，就无法在脚本中写入任何数据，否则shell会生成错误消息。在关闭文件描述符时还需要注意，如果在随后的脚本中打开了同一个输出文件，shell会用一个新文件来替换已有的文件，这就意味着，如果输出数据，它就会覆盖已有鹰爪，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing closing file descriptors</div><div class="line"></div><div class="line">exec 3&gt; test17file</div><div class="line">echo "This is a test line of test" &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">cat test17file</div><div class="line"></div><div class="line">exec 3&gt;test17file</div><div class="line">echo "This will be bad" &gt;&amp;3</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test17.sh</div><div class="line">This is a test line of test</div><div class="line">biotest@ubuntu:~/input$ cat test17file</div><div class="line">This will be bad</div></pre></td></tr></table></figure>
<p>在向test17file文件发送一个数据字符串并关闭该文件描述符之后，脚本用了 cat 命令来显示文件的内容。下一步，脚本重新打开了该输出文件并向它发送了另一个数据字符串。当显示该输出文件的内容时，你所能看到的只有第二个数据字符串。shell覆盖了原来的输出文件。</p>
<h2 id="列出打开的文件描述符">列出打开的文件描述符</h2>
<p>bash shell中有一个<code>lsof</code>命令，这个命令会列出整个Linux系统打开的所有文件描述符，<code>lsof</code>命令位于<code>/usr/sbin</code>目录中，这个命令会产生大量的输出，它会显示Linux系统中打开的每个文件的有产信息，这包括后台运行的所有进程，以及登录到系统的任何用户。<code>lsof</code>有各种命令选项和参数可以使用，最常用的是<code>-p</code>和<code>-d</code>，前者用于指定进程ID（即PID），后者用于指定显示的文件描述符编号，如果要知道进程的当前PID，可以使用特殊的环境变量<code>$$</code>（shell会将它设为当前PID），<code>-a</code>选项用来对其他两个选项的结果执行布尔<code>AND</code>运算，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ lsof -a -p $$ -d 0,1,2</div><div class="line">COMMAND   PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</div><div class="line">bash    10009 biotest    0u   CHR  136,4      0t0    7 /dev/pts/4</div><div class="line">bash    10009 biotest    1u   CHR  136,4      0t0    7 /dev/pts/4</div><div class="line">bash    10009 biotest    2u   CHR  136,4      0t0    7 /dev/pts/4</div></pre></td></tr></table></figure>
<p>结果显示了当前进程的国俯文件描述符（0、1和2），lsof的默认输出有7列信息，如下所示：</p>
<table>
<thead>
<tr class="header">
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COMMAND</td>
<td>正在运行的命令名的前9个字符</td>
</tr>
<tr class="even">
<td>PID</td>
<td>进程的PID</td>
</tr>
<tr class="odd">
<td>USER</td>
<td>进程属主的登录名</td>
</tr>
<tr class="even">
<td>FD</td>
<td>文件描述符号以及访问类型（r代表读，w代表写，u代表读写）</td>
</tr>
<tr class="odd">
<td>TYPE</td>
<td>文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件）</td>
</tr>
<tr class="even">
<td>DEVICE</td>
<td>设备的设备号（主设备号和从设备号）</td>
</tr>
<tr class="odd">
<td>SIZE</td>
<td>如果有的话，表示文件的大小</td>
</tr>
<tr class="even">
<td>NODE</td>
<td>本地文件的节点号</td>
</tr>
<tr class="odd">
<td>NAME</td>
<td>文件名</td>
</tr>
</tbody>
</table>
<p>与 STDIN 、 STDOUT 和 STDERR 关联的文件类型是字符型。因为 STDIN 、 STDOUT 和 STDERR 文 件描述符都指向终端，所以输出文件的名称就是终端的设备名。现在看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> testing lsof with file descriptors</div><div class="line"></div><div class="line">exec 3&gt; test18file1</div><div class="line">exec 6&gt; test18file2</div><div class="line">exec 7&lt; testfile</div><div class="line"></div><div class="line">lsof -a -p $$ -d0,1,2,3,6,7</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test18.sh</div><div class="line">COMMAND   PID    USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</div><div class="line">bash    28264 biotest    0u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    1u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    2u   CHR  136,4      0t0      7 /dev/pts/4</div><div class="line">bash    28264 biotest    3w   REG    8,1        0 928519 /home/biotest/input/test18file1</div><div class="line">bash    28264 biotest    6w   REG    8,1        0 928521 /home/biotest/input/test18file2</div><div class="line">bash    28264 biotest    7r   REG    8,1       73 928491 /home/biotest/input/testfile</div></pre></td></tr></table></figure>
<p>这个脚本创建了3个替代性文件描述符，两个是输出（3和6），一个是输入（7），在脚本运行了<code>lsof</code>命令时，可以在输出中看到新的文件描述符，如果去掉输出中的第一部分，就会看到文件名的结果，文件名显示了文件描述符所使用的文件的完整路径名，它将每个文件都显示成了REG类型，这就说明它们是文件系统中的常规文件。</p>
<h2 id="阻止命令输出">阻止命令输出</h2>
<p>有些情况下，用户不想显示脚本的输出。这在将脚本作为后台进程运行时很常见，如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。要解决这个问题，可以将STDERR重定向到一个叫作null文件的特殊文件。null文件跟它的名字很像，文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ ls -al &gt; /dev/null</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null</div><div class="line">biotest@ubuntu:~/input$ ls -al badfile2 test16.sh 2&gt; /dev/null</div><div class="line">-rwxrw-r-- 1 biotest biotest 135 May  5 23:28 test16.sh</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null</div><div class="line">biotest@ubuntu:~/input$</div></pre></td></tr></table></figure>
<p>也可以在输入重定向中将<code>dev/null</code>作为输入文件，由于<code>dev/null</code>文件不含有任何内容，用户通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ cat testfile</div><div class="line">This is the first line.</div><div class="line">This is a test line</div><div class="line">ine.</div><div class="line">This is the third line.</div><div class="line">biotest@ubuntu:~/input$ cat /dev/null &gt; testfile</div><div class="line">biotest@ubuntu:~/input$ cat testfile</div></pre></td></tr></table></figure>
<p>文件testfile仍然存在于系统上，但现在是空文件，这是清除日志文件的一个常用的方法。</p>
<h2 id="创建临时文件">创建临时文件</h2>
<p>Linux系统有特殊的目录，专供临时文件使用。Linux使用/tmp目录来存放不需要永久保留的文件。系统上的任何用户账户都有权限在读写/tmp目录中的文件。这个特性为用户提供了一种创建临时文件的简单方法，而且还不用操心清理工作。有个特殊命令可以用来创建临时文件。mktemp命令可以在/tmp目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的umask值（参见第7章）。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。一旦创建了文件，你就在脚本中有了完整的读写权限，但其他人没法访问它（当然，root用户除外）。</p>
<h3 id="创建本地临时文件">创建本地临时文件</h3>
<p>默认情况下，<code>mktemp</code>会在本地目录中创建一个文件，要用<code>mktemp</code>在本地目录中创建一个临时文件，只要指定一个文件名模板就行了，模板可以包含任意文本文件名，在文件名末尾加上6个x就行了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.ATlZBX</div><div class="line">biotest@ubuntu:~/input$ ls -al testing*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:32 testing.ATlZBX</div></pre></td></tr></table></figure>
<p><code>mktemp</code>命令会用6个字符码替换这6个x，从而保证文件名在目录中是唯一的。用户可以创建多个临床文件，这种用法可以使每个文件名都是唯一的。如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.EWLscI</div><div class="line">biotest@ubuntu:~/input$ mktemp testing.XXXXXX</div><div class="line">testing.Y6pjo8</div><div class="line">biotest@ubuntu:~/input$ ls -al testing*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:32 testing.ATlZBX</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:37 testing.EWLscI</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:37 testing.Y6pjo8</div></pre></td></tr></table></figure>
<p>在脚本中使用<code>mktemp</code>命令可以将文件名保存到变量中，这样就可以在后面的脚本中引用了，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> creating and using a temp file</div><div class="line"></div><div class="line">tempfile=$(mktemp test19.XXXXXX)</div><div class="line"></div><div class="line">exec 3&gt;$tempfile</div><div class="line">echo "This script writes to temp file $tempfile"</div><div class="line"></div><div class="line">echo "This is the first line" &gt;&amp;3</div><div class="line">echo "This is the second line" &gt;&amp;3</div><div class="line">echo "This is the last line" &gt;&amp;3</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line">echo "Done creating temp file. The contents are: "</div><div class="line">cat $tempfile</div><div class="line">rm -f $tempfile 2&gt; /dev/null</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test19.sh</div><div class="line">This script writes to temp file test19.RyVPfD</div><div class="line">Done creating temp file. The contents are: </div><div class="line">This is the first line</div><div class="line">This is the second line</div><div class="line">This is the last line</div><div class="line">biotest@ubuntu:~/input$ ls -al test19*</div><div class="line">-rw-rw-r-- 1 biotest biotest 354 May  6 00:40 test19.sh</div></pre></td></tr></table></figure>
<p>在这个脚本中，使用mktemp命令创建临时文件，并将文件名赋给<code>$tempfile</code>变量，接着将这个临时文件作为文件描述3的输出重定向文件，在将临时文件名显示在STDOUT之后，向中临时文件中写入了几行文本，然后关闭了文件描述符，最后显示出临时文件的内容，并用<code>rm</code>命令将其删除。</p>
<h3 id="在tmp目录创建临时文件">在<code>/tmp</code>目录创建临时文件</h3>
<p><code>-t</code>选项会强制mktemp命令在系统的临时目录来创建文件，在使用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不是仅有文件名，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ mktemp -t test.XXXXXX</div><div class="line">/tmp/test.oL5jbT</div><div class="line">biotest@ubuntu:~/input$ ls -al /tmp/test*</div><div class="line">-rw------- 1 biotest biotest 0 May  6 00:45 /tmp/test.oL5jbT</div></pre></td></tr></table></figure>
<p>由于mktemp返回了全路径，因此用户可以在Linux系统的任意目录下引用该临时文件，不管目录在哪里，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> creating a temp file in /tmp</div><div class="line"></div><div class="line">tempfile=$(mktemp -t tmp.XXXXXX)</div><div class="line"></div><div class="line">echo "This is a test file." &gt; $tempfile</div><div class="line">echo "This is the second line of the test." &gt;&gt; $tempfile</div><div class="line"></div><div class="line">echo "The temp file is located at: $tempfile"</div><div class="line">cat $tempfile</div><div class="line">rm -f $tempfile</div></pre></td></tr></table></figure>
<p>结果运行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test20.sh</div><div class="line">The temp file is located at: /tmp/tmp.4hLOyR</div><div class="line">This is a test file.</div><div class="line">This is the second line of the test.</div></pre></td></tr></table></figure>
<p>mktemp创建了临时文件时，它会返回全路径给变量，这样就可以在任何命令中使用该值来引用临时变量了。</p>
<h3 id="创建临时目录">创建临时目录</h3>
<p><code>-d</code>选项告诉mktemp命令来创建一个临时目录，而不是临时文件，这样就能用此目录进行任何需要的操作，体积如创建其他的临时文件，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using a temporary directory</div><div class="line"></div><div class="line">tempdir=$(mktemp -d dir.XXXXXX)</div><div class="line">cd $tempdir</div><div class="line">tempfile1=$(mktemp temp.XXXXXX)</div><div class="line">tempfile2=$(mktemp temp.XXXXXX)</div><div class="line">exec 7&gt; $tempfile1</div><div class="line">exec 8&gt; $tempfile2</div><div class="line"></div><div class="line">echo "Sending data to directory $tempdir"</div><div class="line">echo "This is a test line of data for $tempfile1" &gt;&amp;7</div><div class="line">echo "This is a test line of data for $tempfile2" &gt;&amp;8</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input$ bash test21.sh</div><div class="line">Sending data to directory dir.4ZeP0T</div><div class="line">biotest@ubuntu:~/input$ ls -al</div><div class="line">drwx------  2 biotest biotest 4096 May  6 01:02 dir.4ZeP0T</div><div class="line">... ...</div><div class="line">-rw-rw-r--  1 biotest biotest   29 May  5 23:41 tets17file</div><div class="line">biotest@ubuntu:~/input$ cd dir.4ZeP0T</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ ls</div><div class="line">temp.7KoQoD  temp.jj2vb1</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat temp.7KoQoD </div><div class="line">This is a test line of data for temp.7KoQoD</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat temp.jj2vb1 </div><div class="line">This is a test line of data for temp.jj2vb1</div></pre></td></tr></table></figure>
<p>这段脚本在当前目录创建了一个目录，然后它用cd命令进入该目录，并创建了两个临时文件。之后这两个临时文件被分配给文件描述符，用来存储脚本的输出。</p>
<h2 id="记录消息">记录消息</h2>
<p>有时候需要将输出同时发送到显示器和日志文件，此时需要<code>tee</code>命令。tee在英文就是T的意思，在Linux中，这个命令相当于管道一个T接头，它将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是tee命令所指定的文件名<code>tee filename</code>，由于tee会重定向来自STDIN的数据，可以用它配合管道命令来重定向命令输出，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ date | tee testfile2</div><div class="line">Sun May  6 01:12:57 PDT 2018</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">Sun May  6 01:12:57 PDT 2018</div></pre></td></tr></table></figure>
<p>输出出现在了STDOUT中，同时也写入了指定的文件中，默认情况下，tee命令会在每次使用时覆盖输出文件的内容，如下挂满：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ who | tee testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div></pre></td></tr></table></figure>
<p>如果需要追加数据，则要使用<code>-a</code>参数，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ date | tee -a testfile2</div><div class="line">Sun May  6 01:14:55 PDT 2018</div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat testfile2</div><div class="line">biotest  tty7         2018-04-27 22:30 (:0)</div><div class="line">Sun May  6 01:14:55 PDT 2018</div></pre></td></tr></table></figure>
<p>看一个案例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> using the tee command for logging </div><div class="line"></div><div class="line">tempfile=test22file</div><div class="line"></div><div class="line">echo "This is the start of the test" |tee $tempfile</div><div class="line">echo "This is the second line of the test" | tee -a $tempfile</div><div class="line">echo "This is the end of the test" | tee -a $tempfile</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ bash test22.sh</div><div class="line">This is the start of the test</div><div class="line">This is the second line of the test</div><div class="line">This is the end of the test</div><div class="line"></div><div class="line">biotest@ubuntu:~/input/dir.4ZeP0T$ cat test22file</div><div class="line">This is the start of the test</div><div class="line">This is the second line of the test</div><div class="line">This is the end of the test</div></pre></td></tr></table></figure>
<p>从结果可以看出，用户显示输出的同时，还能保存一份输出内容。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" <i class="fa fa-tag"></i> Linux</a>
          
            <a href="/tags/脚本/" <i class="fa fa-tag"></i> 脚本</a>
          
            <a href="/tags/Shell/" <i class="fa fa-tag"></i> Shell</a>
          
            <a href="/tags/结构化命令/" <i class="fa fa-tag"></i> 结构化命令</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/02/Linux/Linux-shell03-break几层循环的理解/" rel="next" title="break n层循环的理解">
                <i class="fa fa-chevron-left"></i> break n层循环的理解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/04/Linux/Linux-shell06-控制脚本/" rel="prev" title="Shell学习笔记（6）——控制脚本">
                Shell学习笔记（6）——控制脚本 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="vcomments"></div>
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">109</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">103</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#理解输入与输出"><span class="nav-number">1.</span> <span class="nav-text">理解输入与输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准文件描述符"><span class="nav-number">1.1.</span> <span class="nav-text">标准文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdin"><span class="nav-number">1.2.</span> <span class="nav-text">STDIN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stdout"><span class="nav-number">1.3.</span> <span class="nav-text">STDOUT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stderr"><span class="nav-number">1.4.</span> <span class="nav-text">STDERR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重定向错误和数据"><span class="nav-number">1.4.1.</span> <span class="nav-text">重定向错误和数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在脚本中重定向输出"><span class="nav-number">2.</span> <span class="nav-text">在脚本中重定向输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#临时重定向"><span class="nav-number">2.1.</span> <span class="nav-text">临时重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#永久重定向"><span class="nav-number">2.2.</span> <span class="nav-text">永久重定向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在脚本中重定向输入"><span class="nav-number">3.</span> <span class="nav-text">在脚本中重定向输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建自己的重定向"><span class="nav-number">4.</span> <span class="nav-text">创建自己的重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建输出文件描述符"><span class="nav-number">4.1.</span> <span class="nav-text">创建输出文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重定向文件描述符"><span class="nav-number">4.2.</span> <span class="nav-text">重定向文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建输入文件描述符"><span class="nav-number">4.3.</span> <span class="nav-text">创建输入文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建读写文件描述符"><span class="nav-number">4.4.</span> <span class="nav-text">创建读写文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭文件描述符"><span class="nav-number">4.5.</span> <span class="nav-text">关闭文件描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列出打开的文件描述符"><span class="nav-number">5.</span> <span class="nav-text">列出打开的文件描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻止命令输出"><span class="nav-number">6.</span> <span class="nav-text">阻止命令输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建临时文件"><span class="nav-number">7.</span> <span class="nav-text">创建临时文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建本地临时文件"><span class="nav-number">7.1.</span> <span class="nav-text">创建本地临时文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在tmp目录创建临时文件"><span class="nav-number">7.2.</span> <span class="nav-text">在/tmp目录创建临时文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建临时目录"><span class="nav-number">7.3.</span> <span class="nav-text">创建临时目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#记录消息"><span class="nav-number">8.</span> <span class="nav-text">记录消息</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共392.2k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  










  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine@1.1.4/dist/Valine.min.js"></script>
  <script type="text/javascript">
    new Valine({
        av: AV,
        el: '#vcomments' ,
        verify: true,
        notify: true,
        app_id: '4ORLDMxXCFDLSHPJ4wSSDkkw-gzGzoHsz',
        app_key: 'HSWpCY7XlN0pGV5DCrKoC0ic',
        placeholder: 'Comment input placeholder'
    });
  </script>



  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
