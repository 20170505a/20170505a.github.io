<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="生物信息学," />










<meta name="description" content="相关术语 面向对象即Object Oriented,OO，这是一种软件开发方法，具体的定义也说不清楚，根据书中的描述，对象大致意味着一系列数据或属性以及一套访问这些数据的方法。 与面向对象有关的一些术语有多态、封装、方法、属性、超类和继承。 多态：可对不同类型的对象执行相同的损伤；； 封装：对外部隐藏有关对象工作原理的细节。 继承：可基于通用类创建出专用类。 在后面的笔记中会详细说明这">
<meta name="keywords" content="生物信息学">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习笔记（11）-面向对象">
<meta property="og:url" content="http://rvdsd.top/2018/04/13/Python/Python学习笔记（11）-面向对象/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:description" content="相关术语 面向对象即Object Oriented,OO，这是一种软件开发方法，具体的定义也说不清楚，根据书中的描述，对象大致意味着一系列数据或属性以及一套访问这些数据的方法。 与面向对象有关的一些术语有多态、封装、方法、属性、超类和继承。 多态：可对不同类型的对象执行相同的损伤；； 封装：对外部隐藏有关对象工作原理的细节。 继承：可基于通用类创建出专用类。 在后面的笔记中会详细说明这">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-13T02:51:15.490Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python学习笔记（11）-面向对象">
<meta name="twitter:description" content="相关术语 面向对象即Object Oriented,OO，这是一种软件开发方法，具体的定义也说不清楚，根据书中的描述，对象大致意味着一系列数据或属性以及一套访问这些数据的方法。 与面向对象有关的一些术语有多态、封装、方法、属性、超类和继承。 多态：可对不同类型的对象执行相同的损伤；； 封装：对外部隐藏有关对象工作原理的细节。 继承：可基于通用类创建出专用类。 在后面的笔记中会详细说明这">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/2018/04/13/Python/Python学习笔记（11）-面向对象/"/>





  <title>Python学习笔记（11）-面向对象 | RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/13/Python/Python学习笔记（11）-面向对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python学习笔记（11）-面向对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-13T12:00:00+08:00">
                2018-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,337
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="相关术语">相关术语</h2>
<p>面向对象即Object Oriented,OO，这是一种软件开发方法，具体的定义也说不清楚，根据书中的描述，对象大致意味着一系列数据或属性以及一套访问这些数据的方法。</p>
<p>与面向对象有关的一些术语有多态、封装、方法、属性、超类和继承。</p>
<p>多态：可对不同类型的对象执行相同的损伤；；</p>
<p>封装：对外部隐藏有关对象工作原理的细节。</p>
<p>继承：可基于通用类创建出专用类。</p>
<p>在后面的笔记中会详细说明这是什么意思。</p>
<h2 id="什么是类">什么是类</h2>
<p>类是一种对象，每个对象都属于特定的类，并被称为该类的实例。例如，如果你在窗外看到一只鸟，这只鸟就是“鸟类”的一个实例，鸟类是一个非常通用（抽象）的类，它有许多个子类：你看到的那只鸟可能属于子类”云雀“。你可以将“鸟类”视为由所有鸟组成的集合，而“云雀”是其一个子集，一个类的对象为另一个类的对象的子集时，前者就是后者的子类。因此“云雀”为“鸟类”的子类，而“鸟类”为“云雀”的超类。并且在面向对象的编程中，是先定义类，然后再由类生成一个实例。</p>
<p>通过上面的比喻，我们大致就理解了类，子类，超类。但在面向对象的编程中，子类可能还要更复些，因为类是由其支持的方法定义的。类的所有实例都有该类的所有方法，因此子类的所有实例都有超类的所有方法。因此，要定义子类，只需要定义多出来的方法（或者是重写某个方法）即可。例如鸟类（我们用Bird替代）可能提供方法fly，而Penguin类（Bird的一个子类）可能新增方法eat_fish。创建Penguin类时，我们还可能要重写超类方法，即方法fly，星Penguin不会飞，我们要在Penguin的实例中，方法fly应什么都不做或引发异常。</p>
<h3 id="创建类">创建类</h3>
<p>在使用面向对象开发之前，应该首先分析一下需要，确定程序中需要包括哪些类。在程度开发中，要设计一个类，通常需要满足以下三个要求：</p>
<ol style="list-style-type: decimal">
<li>类名。类名的命名要以驼峰式命名法进行命名，也就是每个单词的首字母要大写，例如<code>CapWords</code>；</li>
<li>属性。属性赋予事物具有什么样的特性；</li>
<li>方法。方法赋予事物具有什么样的行为。</li>
</ol>
<h3 id="属性和方法的确定">属性和方法的确定</h3>
<p>描述对象特征的内容可以定义为<code>属性</code>。对象具有的某些行为（动词），就可以定义为<code>方法</code>。</p>
<p>例如我们看下面一个案例：</p>
<ul>
<li><strong>小明</strong>今年<strong>18岁</strong>，身高<strong>1.75</strong>，每天早上<strong>跑</strong>完步，会去<strong>吃</strong>东西。</li>
<li><strong>小美</strong>今年<strong>17岁</strong>，身高<strong>1.65</strong>，小美<strong>不跑步</strong>，小美喜<strong>欢</strong>吃东西。</li>
</ul>
<p>从上面的描述我们可以这么思考，我们可以设计一个人类，例如<code>persion</code>，这个类中需要包含3个属性，即名字<code>name</code>，年龄<code>age</code>，和身高<code>height</code>，此外，还要包括2个动作，分别为是跑步<code>run</code>和吃东西<code>eat</code>。</p>
<p>再看一个案例：</p>
<p>我们有以下需求：</p>
<ul>
<li>一只<strong>黄颜色</strong>的狗，叫<strong>大黄</strong></li>
<li>看见生人<strong>叫</strong></li>
<li>看见家人<strong>摇尾巴</strong></li>
</ul>
<p>那么我们就会设计这样一个狗类(<code>Dog</code>)，这个类中含有2个属性，分别是名字(<code>name</code>）用于记录狗的名字，颜色(<code>color</code>)用于记录狗的颜色；含有2个方法，分别是叫(<code>shout</code>)和摇尾巴(<code>shake</code>)。</p>
<p>以上就是类是如何设计的，总之就是一句话，先考虑需求，然后考虑类，描述性的文字是属性，动作性的文字是方法。</p>
<h2 id="面向对象基础语法">面向对象基础语法</h2>
<h2 id="多态polymorphism">多态(Polymorphism)</h2>
<p>书中原文说的多态是指：术语多态（polymorphism）源自希腊语，意思是“有多种形态”。这大致意味着即便你不知道变量指向的是哪种对象，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异。</p>
<p>书中列举了几个案例，例如当你收到一个对象时，却根本不知道它是如何实现的，它就有可能是众多“多态”中的任何一种，例如当设计一个购物系统中，有一项功能是获取某个物品的价格，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>object.get_price()</div><div class="line"><span class="number">2.5</span></div></pre></td></tr></table></figure>
<p>像这样与对象属性相关联的函数称为方法，在常规的Python对象，例如字符串、列表或字典中也会见到这样的方法，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'abc'</span>.count(<span class="string">'a'</span>)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>].count(<span class="string">'a'</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>就像上面的案例，如果有一个变量x，你需要知道它是字符串，还是列表，就能调用方法count，你只需要向这个方法提供一个字符作为参数，它就能正常运行，这就是多态的表现之一。下面再来做一个实验，标准库模块random包含一个名为choice的函数，它会从序列中随机选择一个元素，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> choice</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = choice([<span class="string">'Hello world!'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'e'</span>,<span class="string">'e'</span>,<span class="number">4</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x</div><div class="line"><span class="string">'Hello world!'</span></div></pre></td></tr></table></figure>
<p>x可能包含字符串`Hello, world!‘，也可能包含列表[1,2,‘e’,‘e’,4]，具体是哪一个，我们并不需要关心，我们只关心x包含多个e，而不管x是字符串还是列表，此时我们再调用count方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x.count(<span class="string">'e'</span>)</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>从结果来看，x包括的应该是字符串（其实前面也显示了这个结果），但关键在于你无需执行相关的检查，只要x有一个名为count的方法，它将单个字符作为参数并返回一个整数就行。</p>
<h3 id="多态形式的多样性">多态形式的多样性</h3>
<p>每当无需知道对象是什么样时，就能对其进行操作时，就是多态在起作用。这不仅仅适用于方法，内置运算符和函数都大量使用了多态，可以看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Fish'</span> + <span class="string">'License'</span></div><div class="line"><span class="string">'FishLicense'</span></div></pre></td></tr></table></figure>
<p>上面的案例说明，<code>+</code>运算符即可以用于整数的加法，还可以用于字符串的连接，这就是多态的体现。</p>
<p>再看一个案例，如果要编写一个函数，通过打印一条消息来指出对象的长度，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_message</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">"The length of "</span>,repr(x), <span class="string">"is"</span>, len(x))</div><div class="line"></div><div class="line"></div><div class="line">length_message(<span class="string">'Fonrd'</span>)</div><div class="line">length_message([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>length_message(<span class="string">'Fonrd'</span>)</div><div class="line">The length of  <span class="string">'Fonrd'</span> <span class="keyword">is</span> <span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>length_message([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">The length of  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">is</span></div></pre></td></tr></table></figure>
<p>可以看出来，无论对象是列表，还是字符串，此函数都能运行。当使用多有态的函数和运算符时，多态都将发挥作用，事实上，要破坏多态，唯一的办法就是使用诸如type，issubclass等函数显式地执行类型检查，但你应尽可能避免以这种方式破坏多态。</p>
<h2 id="封装encapsulation">封装(encapsulation)</h2>
<p>封装指的是向外部隐藏不必要的细节。这听起来有点像多态（无需知道对象的内部细节就可使用它）。这两个概念很像，因为它们都是抽象的原则。它们都像函数一样，可帮助你处理程序的组成部分，让你无需关心不必要的细节。</p>
<p>但封闭与多态又有所不同，多态让你无需知道对象所属的类（对象的类型）就能调用其方法，而封闭则是让你需知道对象的构造就能使用它，下面展示一个案例，在这个案例中，使用了多态，但是没有使用封闭，发吭你有一个名为OpenObject的类，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;o = OpenObject()</div><div class="line">&gt;&gt;&gt;o.set_name(<span class="string">'Sir Lancelot'</span>)</div><div class="line">&gt;&gt;&gt;o.get_names()</div><div class="line">&gt;&gt;&gt;<span class="string">'Sir Lancelot'</span></div></pre></td></tr></table></figure>
<p>在上面的案例中，我们像调用函数一样调用了类，创建了一个对象，并将其关联到变量o，然后使用了<code>set_name</code>和<code>get_name</code>这两个方法（假设OpenObject支持这些方法），但是，如果o将其名称储存在全局变量global_name中，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;gloabl_name</div><div class="line"><span class="string">'Sir Lancelot'</span></div></pre></td></tr></table></figure>
<p>这就意味着使用OpenObject类的实例（对象）时，就需要考虑global_name的内容，事实上，必须确保无人能修改它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;global_name = <span class="string">'Sir Gumby'</span></div><div class="line">&gt;&gt;&gt;o.get_name()</div><div class="line"><span class="string">'Sir Gumby'</span></div></pre></td></tr></table></figure>
<p>d如果浓度创建多个OpenObject对象，则会出现问题，因为它们共用同一个变量，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>o1 = OpenObject() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = OpenObject() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>o1.set_name(<span class="string">'Robin Hood'</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>o2.get_name() </div><div class="line"><span class="string">'Robin Hood'</span></div></pre></td></tr></table></figure>
<p>在上面的这个案例中，设置一个对象的名称时，将自动设置另一个对象的名称，这可能不是我们想要的结果。基本上，你希望对象是抽象的：当调用方法时，无需操心其他的事情，如避免干扰全局变量。如何将名称“封装”在对象中呢，将其作为一种<code>属性</code>即可，属性是归属于对象的变量，就像方法一样，实际上，方法差不多就是与函数相关联的属性，如果你使用属性而非全局变量重新编写前面的类，并将其重命名为ClosedObject，就可以像下面这样使用它，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = ClosedObject() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.set_name(<span class="string">'Sir Lancelot'</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.get_name() </div><div class="line"><span class="string">'Sir Lancelot'</span></div></pre></td></tr></table></figure>
<p>到目前为止，一切顺利，但这并不能证明名称不是存储在全局变量中的，现在再来创建一个对象，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = ClosedObject() </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.set_name(<span class="string">'Sir Robin'</span>) </div><div class="line">r.get_name()</div><div class="line"><span class="string">'Sir Robin'</span></div></pre></td></tr></table></figure>
<p>从中可知正确地设置了新对象的名称，此时再来看一下第一个对象，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.get_name() </div><div class="line"><span class="string">'Sir Lancelot'</span></div></pre></td></tr></table></figure>
<p>其名称还在，因为这个对象有自己的状态，对象的状态由其属性（如名称）描述，对象的方法可能修改这些属性，因此对象将一系列函数（方法）组合起来，并赋予它们访问一些变量（属性）的权限，而属性可用于在两次函数调用之间存储值。</p>
<h2 id="继承">继承</h2>
<p>现在我们假设我们已经有了一个类，并且还要创建一个与之很像的类（可能只是新增了几个方法），该如何办呢（不能复制旧类的代码），解决思路如下：</p>
<p>例如我们有了一个名为Shape的类，它知道将自己绘制到屏幕上，现在我们想创建一个名为Rectangle的类，但它不仅知道如何将自己绘制到屏幕上，而且还知道如何计算其面积，我们不想重新编写方法draw，因此Shape已经了这样一个方法，且效果很好，那么我们就可以让Rectange继承Shape的方法，使得对Rectangle对象调用方法draw时，将自动调用Shape类的方法。</p>
<h3 id="创建自定义类">创建自定义类</h3>
<p>先看下面的一个案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hello, wolrd! I'm &#123;&#125;."</span>.format(self.name))</div></pre></td></tr></table></figure>
<p>在上面的这个案例中，一共定义了3种方法，它们类似于函数定义，但都位于class语句语，Person是类的名称。class语句创建独立的命名空间，用于在其中定义方法（其实就是定义函数）。self它指向对象本身，具体是哪个对象呢，我们再来看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo = Person()</div><div class="line">bar = Person()</div><div class="line">foo.set_name(<span class="string">'Luke Skywalker'</span>)</div><div class="line">bar.set_name(<span class="string">'Anakin Skywalker'</span>)</div><div class="line">foo.greet()</div><div class="line">bar.greet()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, wolrd! I<span class="string">'m Luke Skywalker.</span></div><div class="line"><span class="string">Hello, wolrd! I'</span>m Anakin Skywalker.</div></pre></td></tr></table></figure>
<p>这个案例主要是用来说明self是什么，对foo调用set_name和greet时，foo都会做为第一个参数自动传递给它们，也就是命名为self的原因（其实可以任意命名），如果没有self，所有的方法都无法访问对象本身，也就是要损伤的属性所属的对象。此外，也可以从外部访问这些属性，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo.name</div><div class="line">bar.name = <span class="string">'Yoda'</span></div><div class="line">bar.greet()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Hello, wolrd! I<span class="string">'m Luke Skywalker.</span></div><div class="line"><span class="string">Hello, wolrd! I'</span>m Anakin Skywalker.</div><div class="line">Hello, wolrd! I<span class="string">'m Yoda.</span></div></pre></td></tr></table></figure>
<h2 id="属性函数和方法">属性、函数和方法</h2>
<p>方法和函数的区别表现在前面提到的参数self上，方法更准确地说是关联的方法，是将第一个参数关联到它所属的实例中，因此无需提供这个参数。也可以将属性关联到一个普通的函数，但这样就没有特殊的self参数了，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"I have a self"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"I don't..."</span>)</div><div class="line"></div><div class="line">instance = Class()</div><div class="line">instance.method()</div><div class="line">instance.method= function</div><div class="line">instance.method()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I have a self</div><div class="line">I don<span class="string">'t...</span></div></pre></td></tr></table></figure>
<p>从上面可以知道，有没有参数self并不取决于是否以刚才使用的方式（如instance.method）调用方法。实际上，完全可以让另一个变量指向同一个方法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    song = <span class="string">'Squaawk!'</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.song)</div><div class="line"></div><div class="line">bird = Bird()</div><div class="line">bird.sing()</div><div class="line">birdsong = bird.sing</div><div class="line">birdsong()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Squaawk!</div><div class="line">Squaawk!</div></pre></td></tr></table></figure>
<p>最后一个方法调用看起来很像函数调用，但变量birdsong指向的是关联的方法bird.song，这意味着它也能够访问参数self（即使它被关联到类的实例）。</p>
<h2 id="隐藏">隐藏</h2>
<p>默认情况下，我们可以从外部访问对象的属性，看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;c.name</div><div class="line"><span class="string">'Sir Lancelot'</span></div><div class="line">&gt;&gt;&gt;c.name = <span class="string">'Sir Gumby'</span></div><div class="line">&gt;&gt;&gt;c.get_name()</div><div class="line"><span class="string">'Sir Gumby'</span></div></pre></td></tr></table></figure>
<p>如果我们不让其他人从外部访问属性，就可能将属性定义为私有，私有属性不能从对象外部访问，而只能通过存取器（例如get_name和set_name）来访问。</p>
<p>要让方法或属性成为私有的（不能从外部访问），只需要让其名称以两个下划线打头即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secrective</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__inaccessible</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Bet you can't see me..."</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accessible</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"The secret message is: "</span>)</div><div class="line">        self.__inaccessible()</div><div class="line"></div><div class="line">s = Secrective()</div><div class="line">s.accessible()</div><div class="line">s.__inaccessible()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">s.accessible()</div><div class="line">The secret message <span class="keyword">is</span>: </div><div class="line">Bet you can<span class="string">'t see me...</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">s.__inaccessible()</span></div><div class="line"><span class="string">Traceback (most recent call last):</span></div><div class="line"><span class="string">  File "C:/Users/20161111/PycharmProjects/untitled2/test.py", line 11, in &lt;module&gt;</span></div><div class="line"><span class="string">    s.__inaccessible()</span></div><div class="line"><span class="string">AttributeError: '</span>Secrective<span class="string">' object has no attribute '</span>__inaccessible<span class="string">'</span></div></pre></td></tr></table></figure>
<p>从上面的案例我们可以看出来，无法从外部访问<code>__inaccessible</code>，但是在类中，例如<code>accessible</code>中我们仍然可以使用它。虽然以两个下划线打头有点奇怪，但这样的方法类似于其他语言中的标准私有方法。然后背后的处理手法并不标准：在类定义中，对所有以两个下划线打头的名称都进行转换，即在开头加上一个下划线和类名，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Secretive._Secretive__inaccessible </div><div class="line">&lt;unbound method Secretive.__inaccessible&gt;</div></pre></td></tr></table></figure>
<p>上面的代码在我的编辑器中无法运行，可以直接跳过，但知道了这种幕后处理手法，就能从类外部访问私有方法，但是不建议这么做，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s=Secrective()</div><div class="line">s._Secrective__inaccessible()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bet you can<span class="string">'t see me...</span></div></pre></td></tr></table></figure>
<p>总之，你无法禁止别人访问对象的私有方法和属性，但这种名称修改方式发出了强烈的信号，让他们不要这样做。如果你不希望名称被悠，又想发出不要从外部修改属性或方法的信号，可以用一个下划线打头，这虽然只是一种约定，但也有些作用，例如使用<code>from module import *</code>就不会导入以一个下划线打头的名称。</p>
<h2 id="类的命名空间">类的命名空间</h2>
<p>下面的两条语句大致等价：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span><span class="keyword">return</span> x*x</div><div class="line">foo = <span class="keyword">lambda</span> x: x*x</div></pre></td></tr></table></figure>
<p>它们𨝌会创建一个返回参数平方的函数，并将这个函数关联到变量foo，可以在全局（模块）作用域内定义名称foo，也可以在函数或方法内定义。定义类时情况也是如此，在class语句中定义的代码都是在一个特殊的命名空间（类的命名空间）内执行的，而类的所有成员都可以访问这个命名空间。类定义其实就是要执行的代码段。例如，在类定义中，并非只能包括def语句，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></div><div class="line"><span class="meta">... </span>    print(<span class="string">'Class C being defined...'</span>)</div><div class="line">...</div><div class="line">Class C being defined...</div></pre></td></tr></table></figure>
<p>这个案例非常简单，再看下一个案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberCounter</span>:</span></div><div class="line">   members = <span class="number">0</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></div><div class="line">       MemberCounter.members += <span class="number">1</span></div><div class="line"></div><div class="line">m1 = MemberCounter()</div><div class="line">m1.init()</div><div class="line">MemberCounter.members</div><div class="line">m2 = MemberCounter()</div><div class="line">m2.init()</div><div class="line">MemberCounter.members</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>上述代码在类作用域内定义了一个变量，所有的成员（实例）都可以访问它，这里使用它来计算类实例的数量，注意到这里使用了init来初始化所有的实例，也就是将init转换为合适的构造函数，每个实例都可以访问这个类作用域内的变化，就像方法一样，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m1.members</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m2.members</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>如果在一个实例中给属性members赋值，结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m1.members=<span class="string">'two'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m1.members</div><div class="line"><span class="string">'two'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m2.members</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>新值被写入m1的一个属性中，这个属性遮住了类级变量。</p>
<h2 id="指定超类">指定超类</h2>
<p>前面提到过，子类扩展了超类的定义。要指定超类，可以在class语句中的类名后加上超类名，并将其用圆括号括起来，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></div><div class="line">        self.blocked = []</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, sequence)</span>:</span></div><div class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> sequence <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.blocked]</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SPAMFilter</span><span class="params">(Filter)</span>:</span> <span class="comment"># SPAMFilter是Filter的子类</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span> <span class="comment"># 重写超类Filter的方法init</span></div><div class="line">        self.blocked = [<span class="string">'SPAM'</span>]</div><div class="line"></div><div class="line">f = Filter()</div><div class="line">f.init()</div><div class="line">f.filter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = Filter()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.init()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.filter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>Filter是一个过滤序列的通用类。实际上，它不会过滤掉任何东西。 Filter类的用途在于可用作其他类（如将’SPAM’从序列中过滤掉的SPAMFilter类）的基类（超类），如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = SPAMFilter()</div><div class="line">s.init()</div><div class="line">s.filter([<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'eggs'</span>,<span class="string">'bacon'</span>,<span class="string">'SPAM'</span>])</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.filter([<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'SPAM'</span>,<span class="string">'eggs'</span>,<span class="string">'bacon'</span>,<span class="string">'SPAM'</span>])</div><div class="line">[<span class="string">'eggs'</span>, <span class="string">'bacon'</span>]</div></pre></td></tr></table></figure>
<p>需要注意SPAMFilter类的定义中有两个要点：</p>
<p>第一，以提供新定义的方式重写了Filter类中方法init的定义</p>
<p>第二，直接从Filter类继承了方法filter的定义，因此无需要重新编写其定义。第二点说明了继承很有用的原因：可以创建大量不同的过滤器类，它们都从Filter类派生而来，并且都使用已编写好的方法filter。</p>
<h2 id="深入继承">深入继承</h2>
<p>如果要确定一个类是否是另一个类的子类，可以使用<code>issubclass</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(SPAMFilter,Filter)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(Filter,SPAMFilter)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>如果有一个类，想知道它的基类，可以访问其特殊属性<code>__bases__</code>，（需要注意的是，这里是复数，后来会提到），如下所示；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>SPAMFilter.__bases__</div><div class="line">(&lt;class '__main__.Filter'&gt;,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Filter.__bases__</div><div class="line">(&lt;class 'object'&gt;,)</div></pre></td></tr></table></figure>
<p>同样的，如果要确定某个对象是否是特定类的实例，可以使用isinstance，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = SPAMFilter()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, SPAMFilter)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, Filter)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, str)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>从上面的案例我们可以看出，s是SPAMFilter类的直接实例，但它也是Filter类的间接实例，因为SPMAFilter是Filter的子类，换句话讲，所有SPAMFilter对象都是Filter对象，从前面一个案例可以知道，isinstance也可用于类型，如字符串类型str，如果要想知道对象属于哪个类，可以使用属性<code>__class__</code>，或<code>type</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.__class__</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">SPAMFilter</span>'&gt;</span></div><div class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(s)</span></span></div><div class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SPAMFilter</span>'&gt;</span></div></pre></td></tr></table></figure>
<h2 id="多个超类">多个超类</h2>
<p>前面我们说了，<code>__bases__</code>是复数形式，我们可以用它来知道类的基类，而基类可能有多个，为说明如何继承多个类，下面我们来看一下案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculatro</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(selfself, expression)</span>:</span></div><div class="line">        self.value = eval(expression)</div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Talker</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hi, my value is "</span>, self.value)</div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingCalculator</span><span class="params">(Calculator, Talker)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>子类TalkingCalculator本身无所作为，其所有的行为都是从超类那里继承的，关键是通过Calculator那里继承calculate，并从Talker那里继承talk，它能了会说话的计算器，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, expression)</span>:</span></div><div class="line">        self.value = eval(expression)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Talker</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hi, my value is "</span>, self.value)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingCalculator</span><span class="params">(Calculator, Talker)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">tc = TalkingCalculator()</div><div class="line">tc.calculate(<span class="string">'1 + 2 *3'</span>)</div><div class="line">tc.talk()</div></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>tc = TalkingCalculator()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tc.calculate(<span class="string">'1 + 2 *3'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tc.talk()</div><div class="line">Hi, my value <span class="keyword">is</span>  <span class="number">7</span></div></pre></td></tr></table></figure>
<p>这种情况称为多重继承，这是一种功能强大的工具，然而除非万不得已，尽量避免使用这种方法。在使用多重继承时，有一点需要注意：如果多个超类以不同的方式实现了同一个方法（即有多个同名方法），必须在class语句中仔细排列这些超类，因此位于前面的类的方法会覆盖位于后面的类的方法。因此，在前面的救命中，如何Calculator类包含方法talk，那么这个方法将覆盖Talker类的方法talk，导致它不可访问，如果像下面这样反转超类的排列顺序，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingCalculator</span><span class="params">(Talker, Calculator)</span>:</span><span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>这将导致Talker的方法talk是可以访问的，多个超类的超类相同时，查找特定方法或属性时访问超类的顺序称为方法解析顺序（MRO）。</p>
<h2 id="接口和内省">接口和内省</h2>
<h2 id="参考资料">参考资料</h2>
<p>Python基础教程(第3版).Magnus Lie Hetland</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/生物信息学/" <i class="fa fa-tag"></i> 生物信息学</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/12/Python/Python学习笔记（10）-输入输入与文件及目录操作/" rel="next" title="Python学习笔记（10）-文件、目录和输入输出操作">
                <i class="fa fa-chevron-left"></i> Python学习笔记（10）-文件、目录和输入输出操作
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/13/Python/Python学习笔记（12）-黑马教程-面向对象之封装/" rel="prev" title="Python学习笔记（12）-黑马教程-面向对象之封装">
                Python学习笔记（12）-黑马教程-面向对象之封装 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="vcomments"></div>
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">134</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#相关术语"><span class="nav-number">1.</span> <span class="nav-text">相关术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是类"><span class="nav-number">2.</span> <span class="nav-text">什么是类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建类"><span class="nav-number">2.1.</span> <span class="nav-text">创建类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性和方法的确定"><span class="nav-number">2.2.</span> <span class="nav-text">属性和方法的确定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象基础语法"><span class="nav-number">3.</span> <span class="nav-text">面向对象基础语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态polymorphism"><span class="nav-number">4.</span> <span class="nav-text">多态(Polymorphism)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多态形式的多样性"><span class="nav-number">4.1.</span> <span class="nav-text">多态形式的多样性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装encapsulation"><span class="nav-number">5.</span> <span class="nav-text">封装(encapsulation)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">6.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建自定义类"><span class="nav-number">6.1.</span> <span class="nav-text">创建自定义类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性函数和方法"><span class="nav-number">7.</span> <span class="nav-text">属性、函数和方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐藏"><span class="nav-number">8.</span> <span class="nav-text">隐藏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的命名空间"><span class="nav-number">9.</span> <span class="nav-text">类的命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定超类"><span class="nav-number">10.</span> <span class="nav-text">指定超类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入继承"><span class="nav-number">11.</span> <span class="nav-text">深入继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多个超类"><span class="nav-number">12.</span> <span class="nav-text">多个超类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口和内省"><span class="nav-number">13.</span> <span class="nav-text">接口和内省</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">14.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共513.4k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
