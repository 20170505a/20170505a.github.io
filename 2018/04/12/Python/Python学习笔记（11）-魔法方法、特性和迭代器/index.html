<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="目录操作," />










<meta name="description" content="魔法方法 魔法方法(Magic methods)在Python中是一类特殊的方法，它们的形式就是前后有两个下划线，例如__init__这个方法，这个方法是我们最常见的魔法方法之一。 构造函数 构造函数(constructor)是Python中的一个魔法方法，例如我们在创建某个类的时候使用的初始化方法__init__。构造函数不同的于普通方法的地方在于，对象创建后会自动调用魔法方法，例如常规的">
<meta name="keywords" content="目录操作">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习笔记（11）-魔法方法、特性和迭代器">
<meta property="og:url" content="http://rvdsd.top/2018/04/12/Python/Python学习笔记（11）-魔法方法、特性和迭代器/index.html">
<meta property="og:site_name" content="RVDSD的个人笔记本">
<meta property="og:description" content="魔法方法 魔法方法(Magic methods)在Python中是一类特殊的方法，它们的形式就是前后有两个下划线，例如__init__这个方法，这个方法是我们最常见的魔法方法之一。 构造函数 构造函数(constructor)是Python中的一个魔法方法，例如我们在创建某个类的时候使用的初始化方法__init__。构造函数不同的于普通方法的地方在于，对象创建后会自动调用魔法方法，例如常规的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190626144020.png">
<meta property="og:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190626184432.png">
<meta property="og:updated_time" content="2019-06-26T13:09:19.623Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python学习笔记（11）-魔法方法、特性和迭代器">
<meta name="twitter:description" content="魔法方法 魔法方法(Magic methods)在Python中是一类特殊的方法，它们的形式就是前后有两个下划线，例如__init__这个方法，这个方法是我们最常见的魔法方法之一。 构造函数 构造函数(constructor)是Python中的一个魔法方法，例如我们在创建某个类的时候使用的初始化方法__init__。构造函数不同的于普通方法的地方在于，对象创建后会自动调用魔法方法，例如常规的">
<meta name="twitter:image" content="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190626144020.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://rvdsd.top/2018/04/12/Python/Python学习笔记（11）-魔法方法、特性和迭代器/"/>





  <title>Python学习笔记（11）-魔法方法、特性和迭代器 | RVDSD的个人笔记本</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RVDSD的个人笔记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习过程中的输出</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://rvdsd.top/2018/04/12/Python/Python学习笔记（11）-魔法方法、特性和迭代器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RVDSD">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RVDSD的个人笔记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python学习笔记（11）-魔法方法、特性和迭代器</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T12:00:00+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,808
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="魔法方法">魔法方法</h2>
<p>魔法方法(Magic methods)在Python中是一类特殊的方法，它们的形式就是前后有两个下划线，例如<code>__init__</code>这个方法，这个方法是我们最常见的魔法方法之一。</p>
<h2 id="构造函数">构造函数</h2>
<p>构造函数(constructor)是Python中的一个魔法方法，例如我们在创建某个类的时候使用的初始化方法<code>__init__</code>。<code>构造函数</code>不同的于普通方法的地方在于，对象创建后会自动调用魔法方法，例如常规的方法使用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f = FooBar()</div><div class="line">f.init()</div></pre></td></tr></table></figure>
<p>但是构造函数的使用如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f = FooBar()</div></pre></td></tr></table></figure>
<p>从上面可以看出，构造函数不用初始化，只要创建这个对象，它自己就自动初始化了，来看一个简单的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.somevar = <span class="number">42</span></div><div class="line">        </div><div class="line">f = FooBar()</div><div class="line">f.somevar</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.somevar = <span class="number">42</span></div><div class="line">f = FooBar()</div><div class="line">f.somevar</div><div class="line">Out[<span class="number">2</span>]: <span class="number">42</span></div></pre></td></tr></table></figure>
<p>从上面的结果可以看出来，在创建了<code>f</code>这个对象后，我们并没有给<code>f.somevar</code>添加属性，但是在<code>__init__</code>中我们已经初始化了这个属性，因此不用再次定义属性。</p>
<p>再给这个构造函数添加几个参数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value = <span class="number">24</span>)</span>:</span></div><div class="line">        self.somevar = value</div><div class="line"></div><div class="line">f = FooBar(<span class="string">"This is a constructor argument"</span>)</div><div class="line">f.somevar</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span>^M</div><div class="line">   ...:     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value = <span class="number">24</span>)</span>:</span>^M</div><div class="line">   ...:         self.somevar = value^M</div><div class="line">   ...: ^M</div><div class="line">   ...: f = FooBar(<span class="string">"This is a constructor argument"</span>)^M</div><div class="line">   ...: f.somevar</div><div class="line">   ...:</div><div class="line">Out[<span class="number">1</span>]: <span class="string">'This is a constructor argument'</span></div></pre></td></tr></table></figure>
<p>从这个案例中可以知道，如果指定了参数，那么最终属性显示的结果就是添加的指定的参数。</p>
<h3 id="重写普通方法和特殊的构造函数">重写普通方法和特殊的构造函数</h3>
<p>在面向对象的编程中，每个类都有一个或多个超类，并从它们那里继承行为，对<code>类B</code>的实例调用方法或访问其属性时，如果找不到该方法或属性，将在其<code>超类A</code>中查找，可以看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hello, I'm A."</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">a = A()</div><div class="line">b = B()</div><div class="line">a.hello()</div><div class="line">b.hello()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, I<span class="string">'m A.</span></div><div class="line"><span class="string">Hello, I'</span>m A.</div></pre></td></tr></table></figure>
<p>在这个案例中，我们可以看到，由于<code>类B</code>自己没有定义方法<code>hello</code>，因此对其调用方法<code>hello</code>时，打印的消息是<code>Hello, I'm A.</code>。要在子类中添加功能，一种基本方法是添加方法，但是如果你想写超类的某些方法，以定制继承而来的行为。还以上面的案例为例说明一下，<code>类B</code>可以重写方法<code>hello</code>，如下述修改后的<code>类B</code>定义如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hello, I'm A."</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Hello, I'm B"</span>)</div><div class="line"></div><div class="line">a = A()</div><div class="line">b = B()</div><div class="line">a.hello()</div><div class="line">b.hello()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, I<span class="string">'m A.</span></div><div class="line"><span class="string">Hello, I'</span>m B</div></pre></td></tr></table></figure>
<p>重写是继承机制的一个重要方法，对构造函数来说万为重要，构造函数用于初始化新建对象的状态，而对于大多数子类来说，除超类的初始化代码外，还要有自己的初始化值代码。虽然所有方法的重写机制都相同，但与重写普通方法相比，重写构造函数时更有可能遇到一个特别的问题：重写构造函数时，必须调用超类（继承的类）的构建函数，否则无法正确地初始化对象，看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hungry = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hungry:</div><div class="line">            print(<span class="string">"Aaaah ..."</span>)</div><div class="line">            self.hungry = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"No, thanks!"</span>)</div><div class="line"></div><div class="line">b = Bird()</div><div class="line">b.eat()</div><div class="line">b.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Aaaah ...</div><div class="line">No, thanks!</div></pre></td></tr></table></figure>
<p>从这个案例中我们可以知道，初始情况下，<code>鸟b</code>处于饥饿状态(<code>hungry = True</code>)，第一次<code>b.eat()</code>后，输出的是<code>Aaaah ...</code>， 此时并把<code>hungry = True</code>切换为<code>hungry = False</code>，当第二次<code>b.eat()</code>后，就输出了<code>No, thanks !</code>。</p>
<p>再看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hungry = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hungry:</div><div class="line">            print(<span class="string">"Aaaah ..."</span>)</div><div class="line">            self.hungry = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"No, thanks!"</span>)</div><div class="line"></div><div class="line">b = Bird()</div><div class="line">b.eat()</div><div class="line">b.eat()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongBird</span><span class="params">(Bird)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.sound = <span class="string">"Squawk!"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.sound)</div><div class="line"></div><div class="line">singbird = SongBird()</div><div class="line">singbird.sing()</div><div class="line">singbird.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Aaaah ...</div><div class="line">Traceback (most recent call last):</div><div class="line">No, thanks!</div><div class="line">Squawk!</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">24</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    singbird.eat()</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> eat</div><div class="line">    <span class="keyword">if</span> self.hungry:</div><div class="line">AttributeError: <span class="string">'SongBird'</span> object has no attribute <span class="string">'hungry'</span></div></pre></td></tr></table></figure>
<p>在这个案例中，<code>SongBird</code>是<code>Bird</code>的子类，继承了方法<code>est</code>，但如果你要尝试调用它，就出现了问题。</p>
<p>异常提示，<code>SongBird</code>没有属性<code>hungry</code>，这是因为，在<code>SongBird</code>类中重写了构造函数，但新的构造函数中没有包含任何初始化属性<code>hungry</code>的代码。如果要消除这种错误，<code>SongBird</code>的构造函数必须调用其超类<code>Bird</code>的构造函数，以确保基本的初始化得以执行。</p>
<p>为此，有两种方法：</p>
<p>第一，调用未关联的超类构造函数；</p>
<p>第二，使用函数<code>super</code>。</p>
<h3 id="调用未关联的超类构建函数">调用未关联的超类构建函数</h3>
<p>还以上面的案例为例说明一下，如果要调用未关联的超类方法，就要添加一行<code>Bird.__init__(self)</code>，完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hungry = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hungry:</div><div class="line">            print(<span class="string">"Aaaah ..."</span>)</div><div class="line">            self.hungry = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"No, thanks!"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongBird</span><span class="params">(Bird)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        Bird.__init__(self)</div><div class="line">        self.sound = <span class="string">"Squawk!"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.sound)</div><div class="line"></div><div class="line">singbird = SongBird()</div><div class="line">singbird.sing()</div><div class="line">singbird.eat()</div><div class="line">singbird.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Squawk!</div><div class="line">Aaaah ...</div><div class="line">No, thanks!</div></pre></td></tr></table></figure>
<p>在常规的面向对象编程中，对<code>实例调用方法时</code>，方法的参数<code>self</code>将自动关联到实例（称为关联的方法）。</p>
<p>如果通过<code>类调用方法</code>（例如<code>Bird.__init__</code>），就没有实例与其相关联，在这种情况下，可以随便设置参数<code>self</code>，这样的方法称为<code>未关联</code>。参过将这个未关联方法的<code>self</code>参数设置为当前实例，将使用超类的构造函数来初始化<code>singbird</code>对象，这表明将设置其属性<code>hungry</code>。</p>
<h3 id="使用super函数">使用<code>super()</code>函数</h3>
<p>这一种方法只适用Python3。调用<code>super</code>这个函数时，将当前类和当前实例作为参数。对其返回的对象调用方法时，调用的是将是超类（而不是当前类）的方法，因此在<code>singbird</code>的构造函数中，可以不使用<code>Bird</code>而是使用了<code>super(singbird, self)</code>，另外，可以像常规调用方法那样（也就是调用关联的方法那样）调用方法<code>__init__</code>。在Python3中调用函数<code>super</code>，可以不提供任何参数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hungry = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.hungry:</div><div class="line">            print(<span class="string">"Aaaah ..."</span>)</div><div class="line">            self.hungry = <span class="keyword">False</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"No, thanks!"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongBird</span><span class="params">(Bird)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super().__init__()</div><div class="line">        self.sound = <span class="string">"Squawk!"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.sound)</div><div class="line"></div><div class="line">singbird = SongBird()</div><div class="line">singbird.sing()</div><div class="line">singbird.eat()</div><div class="line">singbird.eat()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Squawk!</div><div class="line">Aaaah ...</div><div class="line">No, thanks!</div></pre></td></tr></table></figure>
<h2 id="元素访问">元素访问</h2>
<p>这一部分是其他的魔法方法。</p>
<h3 id="基本的序列和映射协议">基本的序列和映射协议</h3>
<p>序列和映射基本上是<code>元素(item)</code>的集合，要实现它们的基本行为（协议），不可变对象需要实现2个方法，而可变对象要实现4个：</p>
<ul>
<li><code>__len__(self)</code>：这个方法返回集合包含的项数，对序列来说就是元素个数，对映射来说，就是<code>键-值</code>对。如果<code>__len__(self)</code>返回零（且没有实现覆盖这种行为的<code>__nonzero__</code>），对象在布尔上下文中将被视为假（就像空的列表、元组、字符串和字典一样）。</li>
<li><code>__getitem__(self, key)</code>：返回与指定键相关联的值。对序列来说，键应该是<code>0~n-1</code>的整数（也可以是负数），其中<code>n</code>为序列的长度，对映射来说，键可以是任何类型。如果键为负责，应从末尾往前数，也就是说<code>x[-n]</code>应与<code>x[len(x)-n]</code>等效。</li>
<li><code>__setitem__(self, key8, value)</code>：这个方法应以与键相关联的方式存储值，以便以后能够使用<code>__getitem__</code>来获取。</li>
<li><code>__delitem__(self, key)</code>：这个方法在对对象的组成部分使用<code>__del__</code>语句时被调用，应删除与key相关联的值，同样，仅当对象可变（且允许其值被删除）时，才需要实现这个方法。</li>
</ul>
<p>另外，如果键的类型不合适（如对序列使用字符串键），可能引发<code>TypeError</code>异常。对于序列，如果索引的类型是正确的，但不在允许的范围内，会引发<code>IndexError</code>异常。</p>
<p>下面看一个案例，观察一下能否创建一个无穷序列，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=utf8</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_index</span><span class="params">(key)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    指定的键上是否是可接受的索引？</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    键必须是非负整数，才是可接受的；</span></div><div class="line"><span class="string">    如果不是整数，将引发TypeError异常；</span></div><div class="line"><span class="string">    如果是负数，将引发IndexError异常（因为这个序列是无穷的）</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(key, int): <span class="keyword">raise</span> TypeError</div><div class="line">    <span class="keyword">if</span> key &lt; <span class="number">0</span>:<span class="keyword">raise</span> IndexError</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArithmeticSequence</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start = <span class="number">0</span>, step = <span class="number">1</span>)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        初始化这个算术序列</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">        start --- 序列中的第一个值</span></div><div class="line"><span class="string">        step  --- 两个相邻的值的差</span></div><div class="line"><span class="string">        changed - 一个字典，包含用户修改后的值</span></div><div class="line"><span class="string">        """</span></div><div class="line">        self.start = start <span class="comment">#存储起始值</span></div><div class="line">        self.step = step</div><div class="line">        self.changed = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        从算术序列中获取一个元素</span></div><div class="line"><span class="string">        """</span></div><div class="line">        check_index(key)</div><div class="line"></div><div class="line">        <span class="keyword">try</span>: <span class="keyword">return</span> self.changed[key]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">return</span> self.start + key*self.step</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        修改算术序列中的元素</span></div><div class="line"><span class="string">        """</span></div><div class="line">        check_index(key)</div><div class="line">        self.changed[key] = value</div><div class="line"></div><div class="line">s = ArithmeticSequence(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">s[<span class="number">4</span>]</div><div class="line">s[<span class="number">4</span>] = <span class="number">2</span></div><div class="line">s[<span class="number">4</span>]</div><div class="line">s[<span class="number">5</span>]</div><div class="line">print(s[<span class="number">4</span>])</div><div class="line">print(s[<span class="number">5</span>])</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span></div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure>
<p>这些代码实现的是一个<code>算术序列</code>，其中任何两个相邻数字的差都相同，第一值是由构造函数的参数<code>start</code>（默认为0）指定的，而相邻值之间的差是由参数<code>step</code>（默认为1）指定的。允许允许修改某些元素，这是通过将不符合规则的值保存在字典<code>changed</code>中实现的。如果元素未被修改，就用公式<code>self.start + key*self.step</code>来计算它的值。</p>
<p>这段代码中禁止删除元素，因此没有实现<code>__del__</code>，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">del</span> s[<span class="number">4</span>]</div><div class="line">File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">52</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">del</span> s[<span class="number">4</span>]</div><div class="line">AttributeError: __delitem__</div></pre></td></tr></table></figure>
<p>另外这个类中没有方法<code>__len__</code>，因此其长度是无穷的，如果所使用考虑综的类型非法，将引发TypeError异常，如果索引的类型正确，但不在允许的范围内（即为负数），将引发IndexError异常，其中索引的检查是源代码中的<code>check_index</code>这个函数负责的，如果出现索引错误，就是如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">s[<span class="string">"four"</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">49</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    s[<span class="string">"four"</span>]</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">31</span>, <span class="keyword">in</span> __getitem__</div><div class="line">    check_index(key)</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> check_index</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(key, int): <span class="keyword">raise</span> TypeError</div><div class="line">TypeError</div><div class="line">s[<span class="number">-42</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">49</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    s[<span class="number">-42</span>]</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">31</span>, <span class="keyword">in</span> __getitem__</div><div class="line">    check_index(key)</div><div class="line">  File <span class="string">"D:/netdisk/bioinfo.notes/Python/python_bio/PythonBio/test.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> check_index</div><div class="line">    <span class="keyword">if</span> key &lt; <span class="number">0</span>:<span class="keyword">raise</span> IndexError</div><div class="line">IndexError</div></pre></td></tr></table></figure>
<h3 id="从listdict和str派生">从list、dict和str派生</h3>
<p>关于序列/映射的一些方法可以还从已有方法中继承，在标准库<code>collections</code>这个模块中提供了抽象和具体的基类，用户也能继承内置类型。因此如果要实现一种行为类似于内置列表的序列类型，可以直接继承list，在下面这个案例中，来实现一个带访问计数器的列表，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterList</span><span class="params">(list)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        super().__init__(*args)</div><div class="line">        self.counter = <span class="number">0</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></div><div class="line">        self.counter += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> super(CounterList, self).__getitem__(index)</div></pre></td></tr></table></figure>
<p>在上面的这段代码中，<code>CounterList</code>类依赖于其超类<code>List</code>的行为。<code>CounterList</code>没有重写的方法（如<code>append</code>、<code>extend</code>，<code>index</code>等）都可以直接使用。在两个被重写的方法中，使用<code>super</code>来调用超类的相应方法，并添加了必要的行为：初始化属性<code>counter</code>（在<code>__init__</code>中）和更新属性<code>counter</code>（在<code>__getitem__</code>）。需要注意的是，重写<code>__getitem__</code>并不能保证一定会捕捉用户的访问操作，因为还有其他访问列表内容的方法，例如通过方法<code>pop</code>，下面来演示一下<code>CounterList</code>的可能用法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterList</span><span class="params">(list)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        super().__init__(*args)</div><div class="line">        self.counter = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></div><div class="line">        self.counter += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> super(CounterList, self).__getitem__(index)</div><div class="line"></div><div class="line">cl = CounterList(range(<span class="number">10</span>))</div><div class="line">print(cl)</div><div class="line">cl.reverse()</div><div class="line">print(cl)</div><div class="line"><span class="keyword">del</span> cl[<span class="number">3</span>:<span class="number">6</span>]</div><div class="line">print(cl.counter)</div><div class="line">print(cl[<span class="number">4</span>] + cl[<span class="number">2</span>])</div><div class="line">print(cl.counter)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>在上面的案例中，<code>CounterList</code>的行为在大多数方面的都类型于列表，但它有一个<code>counter</code>属性（其初始值为0），每当访问列表元素时，这个属性的值就都加1，执行加法运算<code>cl[4] + cl[2]</code>后，<code>counter</code>的值递增了2次，变成了2。</p>
<h2 id="特性">特性</h2>
<p><code>存取方法</code>是名称类似于<code>getHeight</code>和<code>setHeight</code>的方法，用于获取或设置属性，如果访问给定属性时，必须采取特定的措施，那么像这样的封装状态变量（属性）很重要，例如看下面的案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.width = <span class="number">0</span></div><div class="line">        self.height = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_size</span><span class="params">(self, size)</span>:</span></div><div class="line">        self.width, self.height = size</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.width, self.height</div><div class="line"></div><div class="line">r = Rectangle()</div><div class="line">r.width = <span class="number">10</span></div><div class="line">r.height = <span class="number">5</span></div><div class="line">print(r.get_size())</div><div class="line">r.set_size((<span class="number">150</span>, <span class="number">100</span>))</div><div class="line">print(r.width)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(r.get_size())</div><div class="line">(<span class="number">10</span>, <span class="number">5</span>)</div><div class="line">print(r.width)</div><div class="line"><span class="number">150</span></div></pre></td></tr></table></figure>
<p><code>get_size</code>和<code>set_size</code>是假想属性<code>size</code>的存取方法，这个属性是一个由<code>width</code>和<code>height</code>组成的元组，这些代码并非完全错误，但存在缺陷。使用这个类时，用户无需关心它是如何被封装的。如果用户想要修改实现，让size成为真正的属性，而width和height是动态计算出来的，就需要提供用于访问width和height的存取方法，使用这个类的程序也必须重写。应当客户代码能够以同样的方式对待所有的属性。</p>
<p>那么如何解决这个问题呢？给所有的属性都提供存取方法并不现实。而Python能够隐藏存取方法，让所有的属性看起来都一样，通过存取方法定义的属性通常称为<code>特性(property)</code>。在Python中有两种创建特性的机制，但Python中只用<code>property</code>函数。</p>
<h3 id="property函数"><code>property</code>函数</h3>
<p>以前面的<code>Rectangle</code>类为例说明一下，在使用<code>property</code>函数时，只需要添加一行代码，即<code>size = property(get_size, set_size)</code>即可，完整代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.width = <span class="number">0</span></div><div class="line">        self.height = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_size</span><span class="params">(self, size)</span>:</span></div><div class="line">        self.width, self.height = size</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.width, self.height</div><div class="line">    size = property(get_size, set_size)</div><div class="line"></div><div class="line">r = Rectangle()</div><div class="line">r.width = <span class="number">10</span></div><div class="line">r.height = <span class="number">5</span></div><div class="line">print(r.size)</div><div class="line">r.size = <span class="number">150</span>, <span class="number">100</span></div><div class="line">print(r.width)</div></pre></td></tr></table></figure>
<p>在上面的这段代码中，通过调用<code>property</code>函数，将存取方法作为参数（<code>获取方法</code>在前，<code>设置方法</code>在后）创建了一个特性，然后将名称<code>size</code>关联到这个特性。这样就能以同样的方式对待width、height和size了，而无需关心它们是如何实现的，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(r.size)</div><div class="line">(<span class="number">10</span>, <span class="number">5</span>)</div><div class="line">print(r.width)</div><div class="line"><span class="number">150</span></div></pre></td></tr></table></figure>
<p>从运行结果中可以看到，属性<code>size</code>依然受制于<code>get_size</code>和<code>set_size</code>执行的计算，但是看起来就像普通属性一样。</p>
<p>事实上，调用函数<code>property</code>时，还可以①不指定参数；②指定一个参数；③指定三个参数或四个参数。</p>
<p>如果没有指定任何参数，创建的特性将既不可读，也不可写。如果只指定一个参数（获取方法），创建的特性将是只读的。第三个参数是可选的，指定用于删除属性的方法（这个方法不接受任何参数）。第四个参数也是可选的，指定一个文档字符串，这些参数分别命名为<code>fget</code>、<code>fset</code>、<code>fdel</code>和<code>doc</code>。如果要创建一个只可写且带文档字符串的特性，可使用它们作为关键字参数。</p>
<h3 id="property函数的工作原理"><code>property</code>函数的工作原理</h3>
<p><code>property</code>其实并不一个函数，而是一个类，它的实例包含一些魔法方法，而所有的魔法都是由这些方法完成的。这些魔法方法为<code>__get__</code>，<code>__set__</code>和<code>__delete__</code>，它们一道定义了所谓的描述符协议。只要对象实现了这些方法中的任何一个，它就是一个描述符。描述符的独特之处在于其访问方式。例如，读取属性（具体来说，是在实例中访问类中定义的属性）时，如果它关联的是一个实现了<code>__get__</code>的对象，将不会返回这个对象，而是调用方法<code>__get__</code>并将其结果返回。实际上，这是隐藏在特性、关联的方法、静态方法和类方法。</p>
<h3 id="静态方法和类方法">静态方法和类方法</h3>
<p>静态方法和类方法是这样创建的：将它们分别包装在<code>staticmethod</code>和<code>classmethod</code>类的对象中。静态方法的定义中没有参数<code>self</code>，可直接通过类来调用。类方法的定义中包含类似于self的参数，通常被命令为cls，对于类方法，也可通过对象直接调用，但参数cls将自动关联到类。</p>
<p>看下面的一个简单案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smeth</span><span class="params">()</span>:</span></div><div class="line">        print(<span class="string">"This is a static method"</span>)</div><div class="line">    smeth = staticmethod(smeth)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmeth</span><span class="params">(cls)</span>:</span></div><div class="line">        print(<span class="string">"This is a class method of"</span>,cls)</div><div class="line">    cmeth = classmethod(cmeth)</div></pre></td></tr></table></figure>
<p>像这样手工包装和替换方法有点繁琐。在Python2中，引入了一种名为<code>装饰器</code>的新语法，可用于像这样包装方法（实际上，装饰器可用于包装任何可调用的对象，并且可用于方法和函数）。要指定一个或多个装饰器，为此可在方法（或函数）前面使用运算符<code>@</code>列出这些装饰器（指定了多少装饰器时，应用的顺序与列出的顺序相反），如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smeth</span><span class="params">()</span>:</span></div><div class="line">        print(<span class="string">"This is a static method"</span>)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmeth</span><span class="params">(cls)</span>:</span></div><div class="line">        print(<span class="string">"This is a class methods of "</span>, cls)</div><div class="line"></div><div class="line">MyClass.smeth()</div><div class="line">MyClass.cmeth()</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">This <span class="keyword">is</span> a static method</div><div class="line">This <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">of</span>  &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">MyClass</span>'&gt;</span></div></pre></td></tr></table></figure>
<h3 id="getattr____setattr__等方法"><code>__getattr__</code>、<code>__setattr__</code>等方法</h3>
<p>可以拦截对象属性的所有访问企图、其用途之一是在旧式类中实现特性（在旧类中，函数<code>property</code>的行为可能不符合预期）。要在属性被访问时执行一段代码，必须使用一些魔法方法，以下的4个魔法方法提供了你需要的所有功能：</p>
<ul>
<li><code>__getattribute__(self, name)</code>：在属性被访问时自动调用；</li>
<li><code>__getattr__(self, name)</code>：在属性被访问而对象没有这样的属性时自动调用；</li>
<li><code>__setattr__(self, name, value)</code>：试图给属性赋值时自动调用；</li>
<li><code>__delattr__(self, name)</code>：试图删除属性时自动调用。</li>
</ul>
<p>相比函数<code>property</code>，这些魔法方法使用起来比较麻烦。但它们很有用，因为用户可以在这些方法中编写处理多个特性的代码。然而在可能的情况下，最好还是首选<code>property</code>函数。</p>
<p>还看一下前面的<code>Rectangle</code>的案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.width = <span class="number">0</span></div><div class="line">        self.height = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">"size"</span>:</div><div class="line">            self.width, self.height = value</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.__dict__[name] = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">"size"</span>:</div><div class="line">            <span class="keyword">return</span> self.width, self.height</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError()</div></pre></td></tr></table></figure>
<p>如上面代码所示，这个版本需要处理额外的管理细节，对于这段代码，需要注意以下两点：</p>
<ol style="list-style-type: decimal">
<li>即使涉及的属性不是<code>size</code>，也将调用方法<code>__setattr__</code>。因此这个方法必须考虑如下两种情形：如果涉及的属性为<code>size</code>，就执行与以前一样的操作；否则就使用魔法属性<code>__dict__</code>。<code>__dict__</code>属性是一个字典，其中包含所有的实例属性。使用它们而不是执行常规属性赋值，是因为旨在避免再次调用<code>__setattr__</code>，进而导致无限循环。</li>
<li>仅当没有找到指定的属性时，才会调用方法<code>__getattr__</code>。这意味着如果指定的名称不是<code>size</code>，这个方法将引发<code>AttributeError</code>异常。这在要让类能够正确地支持<code>__hasattr__</code>和<code>__getattr__</code>等内置函数时非常重要。如果指定的名称为<code>size</code>，就使用前一个实现中的表达式。</li>
</ol>
<p>需要注意的是：编写方法<code>__setattr__</code>时需要避开无限循环陷阱，编写<code>__getattribute__</code>时也是如此。由于它拦截对所有属性的访问，因此将拦截对<code>__dict__</code>的访问。在<code>__getattribute__</code>中访问当前实例的属性时，唯一案例的方式是使用父类的方法<code>__getattribute__</code>（使用<code>super</code>）。</p>
<h2 id="迭代器">迭代器</h2>
<p>有关迭代器的魔法方法是<code>__iter__</code>，它是迭代器协议的基础。</p>
<h3 id="迭代器协议">迭代器协议</h3>
<p><code>迭代(iterate)</code>意味着重复多次，就像循环那样。方法<code>__iter__</code>返回一个迭代器，它是包含方法<code>__next__</code>的对象，而调用这个方法时可不提供任何参数，当调用<code>__next__</code>方法时，迭代器应返回其下一个值。如果迭代器没有可供返回的值，应引发<code>StopIteration</code>异常。另外，还可以使用内置的函数<code>next</code>，在这种情况下<code>next(it)</code>与<code>it.__next__()</code>等效。</p>
<p>这有什么意义呢，为什么不使用列表？</p>
<p>因为在很多情况下，使用列表都点大材小用。例如，现在有一个可逐个计算值的函数，你可能只想逐个地获取值，而不是使用列表一次性获取。这是因为如果有很多值，列表可以战用太多的内存。但还有其他原因：使用迭代器更通用与简便。</p>
<p>在下面的案例中就可以看到不能使用列表的案例，因为如果要使用列表，这个列表的长度必须是无穷大的，下面的这个案例是有关斐波那契数列的，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibs</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a = <span class="number">0</span></div><div class="line">        self.b = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a, self.b = self.b, self.a + self.b</div><div class="line">        <span class="keyword">return</span> self.a</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div></pre></td></tr></table></figure>
<p>这个迭代器实现了方法<code>__iter__</code>，而这个方法返回迭代器本身，在很多情况下，都在<code>另一个</code>对象中实现返回迭代器的方法<code>__iter__</code>，并在for循环中使用这个对象。在推荐在迭代器中也实现方法<code>__iter__</code>（并像刚才那样让它返回self），这样迭代器就可直接用于for循环中。</p>
<p>有关<code>迭代</code>更正规的定义是，实现了方法<code>__iter__</code>的对象是<strong>可迭代的</strong>，而实现了方法<code>__next__</code>的对象是<strong>迭代器</strong>。</p>
<p>来看一下迭代器的for循环案例，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibs</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a = <span class="number">0</span></div><div class="line">        self.b = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a, self.b = self.b, self.a + self.b</div><div class="line">        <span class="keyword">return</span> self.a</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line"></div><div class="line">fibs = Fibs()</div><div class="line"><span class="keyword">for</span> f <span class="keyword">in</span> fibs:</div><div class="line">    <span class="keyword">if</span> f &gt; <span class="number">1000</span>:</div><div class="line">        print(f)</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1597</span></div></pre></td></tr></table></figure>
<p>这个循环会停止是因为其中包含break语句，否则这个for循环会一直执行下去。</p>
<p>通过对可迭代对象调用内置函数<code>iter</code>就可以获得一个迭代器，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</div><div class="line"><span class="number">1</span></div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<h3 id="从迭代器创建序列">从迭代器创建序列</h3>
<p>除了对迭代器和可迭代对象进行迭代外，还可以将它们转换为序列。在可以使用序列的情况下，大多数也可以使用迭代器或可迭代对象（索引和切片这种操作除外）。</p>
<p>看下面的一个案例，使用构造函数list显式地将迭代器转换为列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestIterator</span>:</span></div><div class="line">    value = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        self.value += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> self.value &gt; <span class="number">10</span>:<span class="keyword">raise</span> StopIteration</div><div class="line">        <span class="keyword">return</span> self.value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">ti = TestIterator()</div><div class="line">list(ti)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div></pre></td></tr></table></figure>
<h2 id="生成器">生成器</h2>
<p>生成器是一种使用普通函数语法定义的迭代器。</p>
<h3 id="创建生成器">创建生成器</h3>
<p>现在创建一个将嵌套列表展开的函数，这个函数以类似于下面的列表作为参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nested = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>]]</div></pre></td></tr></table></figure>
<p>上面的这个参数其实是一个列表的列表，现在定义这样的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(nested)</span>:</span></div><div class="line">    <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</div><div class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> sublist:</div><div class="line">            <span class="keyword">yield</span> element</div></pre></td></tr></table></figure>
<p>这个函数首选迭代所提供嵌套列表中的所有子列表，然后按顺序迭代每个子列表的元素。</p>
<p>这个函数的最后一行含有<code>yield</code>语句，像含有<code>yield</code>语句的函数都被称为<strong>生成器</strong>。生成器与普通函数的区别在于，生成器不是使用<code>return</code>返回一个值，而是生成多个值，一次一个。每次使用<code>yield</code>生成一个值后，函数都将冻结，即在此停止执行，等待被重新唤醒，被唤醒后，函数将从停止的地方开始继续执行。</p>
<p>为使用所有的值，可对生成器进行迭代，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">nested = [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>]]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(nested)</span>:</span></div><div class="line">    <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</div><div class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> sublist:</div><div class="line">            <span class="keyword">yield</span> element</div><div class="line"></div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> flatten(nested):</div><div class="line">    print(num)</div><div class="line">    </div><div class="line"><span class="comment"># 或者如下所示</span></div><div class="line">list(flatten(nested))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> flatten(nested):</div><div class="line"><span class="meta">... </span>    print(num)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 或者如下所示</span></div><div class="line"><span class="meta">... </span>list(flatten(nested))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>
<h3 id="生成器推导">生成器推导</h3>
<p><strong>生成器推导</strong>也叫<strong>生成器表达式</strong>，这是一个类似于列表推导的概念。其工作原理与列表推导相同，但不是创建一个列表，而是返回一个生成器，让你能够逐步执行计算，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>g = ((i + <span class="number">2</span> **<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">27</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</div><div class="line"><span class="number">7</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>在这段代码中，使用的是圆括号。像在这种简单的情形下，不如使用列表推导；但如果要包装可迭代对象（可能生成大量的值），使用列表推导将立即实例化一个列表，从而丧失迭代的优势。另一个好处是，直接在一对既有的圆括号内（如在函数中调用）使用生成器推导时，无需再添加一对圆括号。也就是可编写下面这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sum(i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</div><div class="line"><span class="number">285</span></div></pre></td></tr></table></figure>
<h3 id="递归生成器">递归生成器</h3>
<p>前面的生成器是使用了2个for循环实现的，如果要处理更多层的嵌套列表，此时就需要使用递归的思路，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(nested)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</div><div class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> flatten(sublist):</div><div class="line">                <span class="keyword">yield</span> element</div><div class="line">    <span class="keyword">except</span> TypeError:</div><div class="line">        <span class="keyword">yield</span> nested</div></pre></td></tr></table></figure>
<p>调用<code>flatten</code>时，有两种可能性：</p>
<p>第一，<strong>基线条件</strong>。在基线条件下，要求这个函数展开单个元素，例如一个数，在这种情况下，for循环将引发TypeError异常（因为用户此时试图迭代一个数），而这个生成器只生成一个元素。</p>
<p>第二，<strong>递归条件</strong>。如果要展开的是一个列表，就需要做这些工作：遍历所有的子列表，并对它们调用<code>flatten</code>，然后使用另一个for循环生成展开后的子列表中的所有元素，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(flatten([[[<span class="number">1</span>],<span class="number">2</span>],<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]],<span class="number">8</span>]))</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
<p>但是这种方案存在一个问题，如果<code>nested</code>是字符串或类似于字符串的对象，它就属于序列，因此不会引发TypeError异常。要处理这种问题，必须要在生成器开头进行检查。要检查对象是否类似于字符串，最简单的方式就是尝试将对象与一个字符串拼接起来，并检查这是否会引发TypeError异常，添加后的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding=utf8</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(nested)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="comment"># 不迭代类似于字符串的对象：</span></div><div class="line">        <span class="keyword">try</span>:nested +<span class="string">""</span></div><div class="line">        <span class="keyword">except</span> TypeError:<span class="keyword">pass</span></div><div class="line">        <span class="keyword">else</span>:<span class="keyword">raise</span> TypeError</div><div class="line">        <span class="keyword">for</span> sublist <span class="keyword">in</span> nested:</div><div class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> flatten(sublist):</div><div class="line">                <span class="keyword">yield</span> element</div><div class="line">    <span class="keyword">except</span> TypeError:</div><div class="line">        <span class="keyword">yield</span> nested</div><div class="line"></div><div class="line">list(flatten([<span class="string">'foo'</span>, [<span class="string">'bar'</span>,[<span class="string">'baz'</span>]]]))</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(flatten([<span class="string">'foo'</span>, [<span class="string">'bar'</span>,[<span class="string">'baz'</span>]]]))</div><div class="line">[<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</div></pre></td></tr></table></figure>
<p>在这个案例中，如查表达式<code>nested + &quot;&quot;</code>引发了TypeError异常，就忽略这种异常；如果没有引发TypeError异常，内部<code>try</code>语句中的else语句就引发TypeError异常，这样将在外部的except中生成类似于字符串的对象。</p>
<p>需要注意的是，这段代码没有进行类型检查，也就是说没有检查<code>nested</code>是否为字符串，而是只检查了它的行为是否类似于字符串，即能否与字符串拼接。对于这种检查，更符合常规思路的方案是使用<code>isinstance</code>以及字符串和类似于字符串的对象的一些抽象父类，但是Python中没这样的标准类。</p>
<h3 id="通用生成器">通用生成器</h3>
<p>这里再描述一下生成器，生成器是含有<code>yield</code>的函数，但被调用时不会执行函数体内的代码，而是返回一个迭代器，每次请求值时，都将执行生成器的代码，直到遇到<code>yield</code>或<code>return</code>，<code>yield</code>意味着应生成一个值，而<code>return</code>意味着生成器应停止执行（即不再生成值，仅当在生成器调用<code>return</code>时，才能不提供任何参数）。</p>
<p>换句话讲就是，生成器由两个单独的部分构成：①<strong>生成器的函数</strong>和②<strong>生成器的迭代器</strong>。生成器的函数是由<code>def</code>语句定义的，其中包含<code>yield</code>。生成器迭代器是这个函数返回的结果。用不太精准的话讲，生成器就是这两个东西的组合，看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_generator</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></div><div class="line">...</div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>simple_generator</div><div class="line">&lt;function simple_generator at <span class="number">0x0000021C0C224840</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>simple_generator()</div><div class="line">&lt;generator object simple_generator at <span class="number">0x0000021C0C203F68</span>&gt;</div></pre></td></tr></table></figure>
<h3 id="生成器的方法">生成器的方法</h3>
<p>在生成器开始运行后，可使用生成器和外部之间的通信渠道向它提供值，这个通信渠道包含如下两个商战：</p>
<ul>
<li><strong>外部世界</strong>：外部世界可访问生成器的方法<code>send</code>，这个方法类似于<code>next</code>，但接受一个参数（要发挥的<code>消息</code>可以是任何对象）。</li>
<li><strong>生成器</strong>：在挂起的生成器内部，<code>yield</code>可能用作<strong>表达式</strong>而不是<strong>语句</strong>。也就是说，在生成器重新运行时，<code>yield</code>返回一个值，也就是通过<code>send</code>从外部世界发达的值。如果使用的是<code>next</code>，<code>yield</code>将返回<code>None</code>。需要注意的是，仅当生成器被挂起（也就是遇到第一个<code>yield</code>）后，使用<code>send</code>（而不是<code>next</code>）才有意义。要在此之前向生成器提供消息，可使用生成器的函数的参数，下面的一个简单的案例就说明了这个机制：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeater</span><span class="params">(value)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        new = (<span class="keyword">yield</span> value)</div><div class="line">        <span class="keyword">if</span> new <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:value = new</div><div class="line">        </div><div class="line">r = repeater(<span class="number">42</span>)</div><div class="line">next(r)</div><div class="line">r.send(<span class="string">"Hello, python"</span>)</div></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = repeater(<span class="number">42</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next(r)</div><div class="line"><span class="number">42</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.send(<span class="string">"Hello, python"</span>)</div><div class="line"><span class="string">'Hello, python'</span></div></pre></td></tr></table></figure>
<p>在上面代码中，使用圆括号将<code>yield</code>表达式圈了起来。</p>
<p>生成器还有另外两种方法，分别是<code>throw</code>与<code>close</code>。其中：</p>
<p><code>throw</code>方法用于在生成器中（yield表达式处）引发异常调用时可提供一个异常类型、一个可选值和一个<code>traceback</code>对象。</p>
<p><code>close</code>方法用于停止生成器，调用时无需提供任何参数。方法<code>close</code>也是基于异常的。在<code>yield</code>处引发<code>GeneratorExit</code>异常。因此如果要在生成器中提供一些清理代码，可将<code>yield</code>放在一条<code>try/finally</code>语句中。如果愿意，也可以捕获<code>GeneratorExit</code>异常，但随后必须重新引发它（可能在清理后）、引发其他 异常或直接返回。对生成器调用<code>close</code>方法后，再试图从它那里获取值将导致<code>RuntimeError</code>异常。</p>
<h2 id="生成器的使用案例八皇后问题">生成器的使用案例——八皇后问题</h2>
<p>现在使用生成器来解决一个经典的编程问题。</p>
<h3 id="问题背景">问题背景</h3>
<p>对于逐步得到结果的复杂递归算法，非常适合使用生成器来实现。要在不使用生成器的情况下实现这些算法，通常必须通过额外的参数来传递部分结果，让递归调用能够接着往下计算。通过使用生成器，所有的递归调用进乞只需要生成其负责部分的结果。在前面的递归函数<code>flatten</code>就是这样做的，可以使用这种策略来遍历<code>图结构</code>和<code>树结构</code>。</p>
<p>然而在有些应用程序中，你不能马上得到答案。你必须尝试多次，且在每个递归层级中都如此。</p>
<p>这里讲一个简单的案例。假设你要去参加一个很重要的会议，你不知道会议在哪里召开，但前面有两扇门，而会议室就在其中一扇门的后面。你选择进入左边的那扇门后，又看到两扇门。你再次选择进入左边的那扇门，但发现走错了。因此你往回走，并进入右边那扇门，但发现也走错了。因此你继续往回走到起始，现在可以尝试进入右边那扇门了。</p>
<p>对于需要尝试所有组合直到找到答案的问题，这种回溯策略对其解决很有帮助。这种问题的解决方案类似于以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> each possibility at level <span class="number">1</span>:</div><div class="line">    <span class="keyword">for</span> each possibility at level <span class="number">2</span>:</div><div class="line">        ...</div><div class="line">            <span class="keyword">for</span> each possibility at level n:</div><div class="line">                is it viable?</div></pre></td></tr></table></figure>
<p>如果要直接使用for循环来实现，就要写许多层，此时就可以使用递归。</p>
<h3 id="问题描述">问题描述</h3>
<p>将8个皇后（这个皇后指的是国际象棋中的皇后）放在棋盘上，条件是任何一个皇后都不能威胁其他皇后，即任何两个皇后都不能吃掉对方。</p>
<p>这里再讲一下国际象棋的部分规则。</p>
<p>第一，国际象棋的棋盘是<code>8 x 8</code>的方格，如下所示：</p>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190626144020.png">

</div>
<p>第二，皇后是国际象棋中的一个柜子，并且是棋局中实力最强的一种棋子，但同时也是最容易被吃掉的棋子。皇后可横着走，可以直着走，可以斜着走，且格数不限。</p>
<p>第三，因此如果不想让8个皇后中的任何1个被其他的皇后吃掉，那么要满足：①任意2个皇后不能处于同一条横线上；②任意2个皇不能处于同一条竖线上；③任意2个皇后不能处于同一条斜线上。</p>
<h3 id="解决思路">解决思路</h3>
<p>八皇后问题是一个典型的回溯问题：</p>
<p>第一，在棋盘的第一行尝试为第一个皇后选择一个位置；</p>
<p>第二，在第二行尝试为第二个皇后选择一个位置，依次类推；</p>
<p>第三，当发现无法为一个皇后选择合适的位置后，回溯到前一个皇后，并尝试为它选择另外一个位置；</p>
<p>第四，最终要么要尝试完所有的可能性，要么找到答案。</p>
<h3 id="代码实现">代码实现</h3>
<p>现在使用Python来解决一下这个问题。</p>
<h4 id="状态表示">状态表示</h4>
<p>可以简单地使用元组或列表来表示可能的解，其中每个元素表示相应行中皇后所在的位置（即列）。因此如果<code>state[0] = 3</code>就说明第1行的皇后放在第4列。在特定的递归层级（特定的行），你只需要知道上面各皇后的位置即可，因此状态元组的长度是小于8（即皇后的总数）。</p>
<h4 id="检测冲突">检测冲突</h4>
<p>先来做些简单的抽象。要找到没有冲突，即任何一个皇后都无法吃掉其他皇后的位置组合，首选必须定义冲突是什么。此时我们就可以使用一个函数<code>conflict</code>来定义一下。</p>
<p>函数<code>conflict</code>接受现有皇后的位置，并确定下一个皇后的位置是否会导致冲突，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conflict</span><span class="params">(state, nextX)</span>:</span></div><div class="line">    nextY = len(state)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nextY):</div><div class="line">        <span class="keyword">if</span> abs(state[i] - nextX) <span class="keyword">in</span> (<span class="number">0</span>, nextY - i):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>参数描述：</p>
<ol style="list-style-type: decimal">
<li><code>nextX</code>表示下一个皇后的水平位置，也就是x坐标；</li>
<li><code>nextY</code>表示下一个皇后的垂直位置，也就是y坐标；</li>
<li>这个函数对现有的每个皇后执行简单的检查：如果下一个皇后与当前皇后的<code>x</code>坐标相同或在同一条对角线上，将发生冲突，因此会返回<code>True</code>，如果没有发生冲突，就返回<code>False</code>；</li>
<li><code>abs(state[i] - nextX) in (0, nextY - i)</code>表示：如果下一个皇后和当前皇后的水平距离为0，就表示他们同一列；或者是他们的垂直距离相等，这表示他们位于同一条对角线上，这个表达式就为真，否则为假。</li>
</ol>
<h4 id="基线条件">基线条件</h4>
<p>基线条件：最后一个皇后，对于这个皇后，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num, state)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(state) == num - <span class="number">1</span>:</div><div class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line">                <span class="keyword">yield</span> pos</div></pre></td></tr></table></figure>
<p>这段代码的意思是：</p>
<ol style="list-style-type: decimal">
<li>如果只剩下最后一个皇后没有放好，就遍历所有可能的位置，并返回那些不会引发冲突的位置；</li>
<li>参数<code>num</code>是皇后总数，而参数<code>state</code>是一个元组，包含已经放好的皇后位置，例如，假设总共有4个皇后，而前3个皇后的位置分别是1、3和0，如下所示：</li>
</ol>
<div class="figure">
<img src="https://pic-1256416512.cos.ap-chengdu.myqcloud.com/img/20190626184432.png">

</div>
<p>从上图可知，每个皇后都占据一行，而皇后的位置是从0开始编号的，<code>queens</code>函数的代码运行如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">conflict</span><span class="params">(state, nextX)</span>:</span></div><div class="line"><span class="meta">... </span>    nextY = len(state)</div><div class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(nextY):</div><div class="line"><span class="meta">... </span>        <span class="keyword">if</span> abs(state[i] - nextX) <span class="keyword">in</span> (<span class="number">0</span>, nextY - i):</div><div class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num, state)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(state) == num - <span class="number">1</span>:</div><div class="line"><span class="meta">... </span>        <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line"><span class="meta">... </span>            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line"><span class="meta">... </span>                <span class="keyword">yield</span> pos</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(queens(<span class="number">4</span>, (<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>)))</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>使用list旨在让生成器生成所有的值，在这个案例中，只有一个位置符合条件，就是上面白色棋子的位置。</p>
<h4 id="递归条件">递归条件</h4>
<p>处理好基线条件后，可在递归条件中假设来自更低层级（编号更大的皇后）的结果都是正确的，因此，只需要在函数queens的前述实现中给if语句添加一个else语句。最终我们想要的返回结果是当前行下面所有皇后的位置，假设位置是以元组的形式返回的，因此需要修改基线条件，使其返回一个（长度为1的）元组。</p>
<p>因此，对于递归调用，向它提供的是当前行上面的皇后位置组成的元组。对于当前皇后的每个合法位置，递归调用返回的是由下面的皇后位置组成的元组。为了让这个过程不断进行下去，只需将当前皇后的位置插入返回结果的开头即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num=<span class="number">8</span>, state=<span class="params">()</span>)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(state) == num - <span class="number">1</span>:</div><div class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line">                <span class="keyword">yield</span> pos</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num, state + (pos, )):</div><div class="line">                    <span class="keyword">yield</span> (pos, ) + result</div></pre></td></tr></table></figure>
<p>这里的<code>for pos</code>和前面的<code>if not conflict</code>部分与前面相同，因此哦可以稍微简化一下代码，另外还可以给参数指定默认值，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num = <span class="number">8</span>, state = <span class="params">()</span>)</span>:</span></div><div class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):</div><div class="line">            <span class="keyword">if</span> len(state) == num - <span class="number">1</span>:</div><div class="line">                <span class="keyword">yield</span> (pos,)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num, state + (pos, )):</div><div class="line">                    <span class="keyword">yield</span> (pos, ) + result</div></pre></td></tr></table></figure>
<h4 id="扫尾工作">扫尾工作</h4>
<p>在代码结束部分，可以让输出更容易理解一些，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prettyprint</span><span class="params">(solution)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(pos, length=len<span class="params">(solution)</span>)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'. '</span>*(pos) + <span class="string">'X '</span> + <span class="string">'. '</span> *(length - pos - <span class="number">1</span>)</div><div class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> solution:</div><div class="line">        print(line(pos))</div></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>MagnusLieHetland. Python基础教程.第3版[M]. 人民邮电出版社, 2018.</li>
</ol>
<h2 id="参考资料-1">参考资料</h2>
<ol style="list-style-type: decimal">
<li><a href="">A Guide to Python’s Magic Methods</a></li>
<li></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/目录操作/" <i class="fa fa-tag"></i> 目录操作</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/12/Python/Python学习笔记（10）-输入输入与文件及目录操作/" rel="next" title="Python学习笔记（10）-文件、目录和输入输出操作">
                <i class="fa fa-chevron-left"></i> Python学习笔记（10）-文件、目录和输入输出操作
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/13/Python/Python学习笔记（12）-面向对象之封装/" rel="prev" title="Python学习笔记（12）-黑马教程-面向对象之封装">
                Python学习笔记（12）-黑马教程-面向对象之封装 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="vcomments"></div>
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">RVDSD</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">159</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#魔法方法"><span class="nav-number">1.</span> <span class="nav-text">魔法方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">2.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重写普通方法和特殊的构造函数"><span class="nav-number">2.1.</span> <span class="nav-text">重写普通方法和特殊的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用未关联的超类构建函数"><span class="nav-number">2.2.</span> <span class="nav-text">调用未关联的超类构建函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用super函数"><span class="nav-number">2.3.</span> <span class="nav-text">使用super()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素访问"><span class="nav-number">3.</span> <span class="nav-text">元素访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的序列和映射协议"><span class="nav-number">3.1.</span> <span class="nav-text">基本的序列和映射协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从listdict和str派生"><span class="nav-number">3.2.</span> <span class="nav-text">从list、dict和str派生</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性"><span class="nav-number">4.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#property函数"><span class="nav-number">4.1.</span> <span class="nav-text">property函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property函数的工作原理"><span class="nav-number">4.2.</span> <span class="nav-text">property函数的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法和类方法"><span class="nav-number">4.3.</span> <span class="nav-text">静态方法和类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getattr____setattr__等方法"><span class="nav-number">4.4.</span> <span class="nav-text">__getattr__、__setattr__等方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">5.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器协议"><span class="nav-number">5.1.</span> <span class="nav-text">迭代器协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从迭代器创建序列"><span class="nav-number">5.2.</span> <span class="nav-text">从迭代器创建序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器"><span class="nav-number">6.</span> <span class="nav-text">生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建生成器"><span class="nav-number">6.1.</span> <span class="nav-text">创建生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器推导"><span class="nav-number">6.2.</span> <span class="nav-text">生成器推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归生成器"><span class="nav-number">6.3.</span> <span class="nav-text">递归生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用生成器"><span class="nav-number">6.4.</span> <span class="nav-text">通用生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器的方法"><span class="nav-number">6.5.</span> <span class="nav-text">生成器的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器的使用案例八皇后问题"><span class="nav-number">7.</span> <span class="nav-text">生成器的使用案例——八皇后问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题背景"><span class="nav-number">7.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题描述"><span class="nav-number">7.2.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决思路"><span class="nav-number">7.3.</span> <span class="nav-text">解决思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现"><span class="nav-number">7.4.</span> <span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#状态表示"><span class="nav-number">7.4.1.</span> <span class="nav-text">状态表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测冲突"><span class="nav-number">7.4.2.</span> <span class="nav-text">检测冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基线条件"><span class="nav-number">7.4.3.</span> <span class="nav-text">基线条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归条件"><span class="nav-number">7.4.4.</span> <span class="nav-text">递归条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扫尾工作"><span class="nav-number">7.4.5.</span> <span class="nav-text">扫尾工作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料-1"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RVDSD</span>

  
</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共597.7k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
